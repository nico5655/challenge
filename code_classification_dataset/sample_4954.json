{
    "prob_desc_time_limit": "3 seconds",
    "prob_desc_sample_outputs": "[\"2 4\\n1 5\\n1 2\\n-1 -1\\n1 2\\n-1 -1\\n1 3\\n1 3\\n-1 -1\\n-1 -1\\n-1 -1\"]",
    "src_uid": "b67870dcffa7bad682ef980dacd1f3db",
    "prob_desc_notes": "NoteConsider the first test case of example inputs. In this test case $$$n=7$$$, $$$s=$$$\"1003004\", $$$w=4$$$ and one query $$$l_1=1$$$, $$$r_1=2$$$, $$$k_1=1$$$. Note that $$$v(1,2)=10$$$. We need to find a pair of substrings of length $$$4$$$ such that $$$v(L_1, L_1+3)\\cdot10+v(L_2,L_2+3)$$$ has a remainder of $$$k_1=1$$$ when divided by $$$9$$$. The values $$$L_1=2, L_2=4$$$ actually satisfy all the requirements: $$$v(L_1, L_1+w-1)=v(2,5)=30$$$, $$$v(L_2, L_2+w-1)=v(4,7)=3004$$$. Indeed, $$$30\\cdot10+3004=3304$$$, which has a remainder of $$$1$$$ when divided by $$$9$$$. It can be shown that $$$L_1=2$$$ is the minimum possible value, and $$$L_2=4$$$ is the minimum possible with $$$L_1=2$$$.",
    "prob_desc_description": "Given the string $$$s$$$ of decimal digits (0-9) of length $$$n$$$.A substring is a sequence of consecutive characters of a string. The substring of this string is defined by a pair of indexes — with its left and right ends. So, each pair of indexes ($$$l, r$$$), where $$$1 \\le l \\le r \\le n$$$, corresponds to a substring of the string $$$s$$$. We will define as $$$v(l,r)$$$ the numeric value of the corresponding substring (leading zeros are allowed in it).For example, if $$$n=7$$$, $$$s=$$$\"1003004\", then $$$v(1,3)=100$$$, $$$v(2,3)=0$$$ and $$$v(2,7)=3004$$$.You are given $$$n$$$, $$$s$$$ and an integer $$$w$$$ ($$$1 \\le w &lt; n$$$).You need to process $$$m$$$ queries, each of which is characterized by $$$3$$$ numbers $$$l_i, r_i, k_i$$$ ($$$1 \\le l_i \\le r_i \\le n; 0 \\le k_i \\le 8$$$).The answer to the $$$i$$$th query is such a pair of substrings of length $$$w$$$ that if we denote them as $$$(L_1, L_1+w-1)$$$ and $$$(L_2, L_2+w-1)$$$, then:  $$$L_1 \\ne L_2$$$, that is, the substrings are different;  the remainder of dividing a number $$$v(L_1, L_1+w-1) \\cdot v(l_i, r_i) + v(L_2, L_2 + w - 1)$$$ by $$$9$$$ is equal to $$$k_i$$$. If there are many matching substring pairs, then find a pair where $$$L_1$$$ is as small as possible. If there are many matching pairs in this case, then minimize $$$L_2$$$.Note that the answer may not exist.",
    "prob_desc_output_spec": "For each request, print in a separate line:    left borders of the required substrings: $$$L_1$$$ and $$$L_2$$$; -1 -1 otherwise, if there is no solution.  If there are several solutions, minimize $$$L_1$$$ first, and minimize $$$L_2$$$ second.",
    "prob_desc_input_spec": "The first line contains a single integer $$$t$$$ ($$$1 \\le t \\le 10^4$$$) — number of input test cases. The first line of each test case contains a string $$$s$$$, which contains only the characters 0-9 and has a length $$$n$$$ ($$$2 \\le n \\le 2 \\cdot 10^5$$$). The second line contains two integers $$$w, m$$$ ($$$1 \\le w &lt; n, 1 \\le m \\le 2 \\cdot 10^5$$$), where $$$n$$$ — is the length of the given string $$$s$$$. The number $$$w$$$ denotes the lengths of the substrings being searched for, and $$$m$$$ is the number of queries to be processed. The following $$$m$$$ lines contain integers $$$l_i, r_i, k_i$$$ ($$$1 \\le l_i \\le r_i \\le n$$$, $$$0 \\le k_i \\le 8$$$) — $$$i$$$th query parameters. It is guaranteed that the sum of $$$n$$$ over all test cases does not exceed $$$2 \\cdot 10^5$$$. It is also guaranteed that the sum of $$$m$$$ over all test cases does not exceed $$$2 \\cdot 10^5$$$.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3-64",
    "lang_cluster": "Python",
    "difficulty": 1900,
    "file_name": "train_110.jsonl",
    "code_uid": "e52d58da3596df5f47871b828d58d894",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"5\\n\\n1003004\\n\\n4 1\\n\\n1 2 1\\n\\n179572007\\n\\n4 2\\n\\n2 7 3\\n\\n2 7 4\\n\\n111\\n\\n2 1\\n\\n2 2 6\\n\\n0000\\n\\n1 2\\n\\n1 4 0\\n\\n1 4 1\\n\\n484\\n\\n1 5\\n\\n2 2 0\\n\\n2 3 7\\n\\n1 2 5\\n\\n3 3 8\\n\\n2 2 6\"]",
    "exec_outcome": "PASSED",
    "source_code": "import bisect\nimport collections\nimport collections.abc\nimport itertools\nimport math\nimport re\nimport sys\n\n\nimport functools\nimport copy\nimport math\nimport heapq\nimport sys\nimport io\nfrom collections import Counter, deque\nfrom collections import defaultdict as ddict\n\n\n\ndef create_matrix(rows, cols=None, val=None):\n    if cols is None:\n        cols = rows\n\n    row = [val] * cols\n    mat = []\n\n    for _ in range(rows):\n        mat.append(copy.deepcopy(row))\n    return mat\n\n\ndef bsearch(a, x):\n    '''\n    Locate the leftmost value exactly equal to x.\n    https://docs.python.org/3/library/bisect.html#module-bisect\n    '''\n    i = bisect.bisect_left(a, x)\n    if i != len(a) and a[i] == x:\n        return i\n    raise ValueError\n\n\ndef zdict(x=0):\n    return collections.defaultdict(lambda: x)\n\n\ndef strjoin(xs, glue=' ', conv=str):\n    return glue.join(map(conv, xs))\n\n\nalphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\nletters = {ch for ch in alphabet}\n\n\n\n\n\ndef to_nums(line):\n    return [int(x) for x in line.split(\" \")]\n\n\ndef read_nums(f):\n    line = f.readline().strip()\n    return [int(x) for x in line.split(\" \")]\n\ndef print_mat(mat, glue=\" \"):\n    for row in mat:\n        print(strjoin(row, glue=glue))\n\n\ndef read_num(f):\n    line = f.readline().strip()\n    return int(line)\n\ndef read_str(f):\n    line = f.readline().strip()\n    return line\n\ndef read_pair(f, func=int):\n    line = f.readline().strip().split(\" \")\n    return (func(line[0]), func(line[1]))\n\ndef read_triplet(f, func=int):\n    line = f.readline().strip().split(\" \")\n    return (func(line[0]), func(line[1]), func(line[2]))\n\nimport math\nimport sys\n\n\n@functools.lru_cache()\ndef get_combos(k):\n    combos = []\n    for i in range(10):\n        for j in range(10):\n            if (i + j) % 9 == k:\n                combos.append((i, j))\n    return combos\n\ndef solve(s, w, q):\n    n = len(s)\n    #modulo = math.pow(10, w)\n    sums = [0 for _ in range(n)]\n\n    mods = {x:[] for x in range(9)}\n\n    for i in range(n):\n        digit = int(s[i])\n        if i == 0:\n            sums[i] = digit\n        else:\n            sums[i] = (sums[i-1]+digit)%9\n\n    for i in range(0, n - w + 1):\n        if i == 0:\n            v = sums[i+w-1] % 9\n        else:\n            #print(f\"{i+w} vs {n}\")\n            v = (sums[i+w-1] - sums[i-1]) % 9\n        #if len(mods[v])<2:\n        mods[v].append(i+1)\n\n\n    for _ in range(q):\n        l, r, k = read_triplet(f)\n\n        if l == 1:\n            mult = sums[r-1] % 9\n        else:\n            mult = (sums[r-1] - sums[l-2])%9\n\n        l1, l2 = n+1, n+1\n        for x in range(9):\n            if mods[x]:\n                for y in range(9):\n                    if not mods[y]:\n                        continue\n                    cond = ((mult * x) + y) % 9 == k\n                    if not cond:\n                        continue\n                    if x != y:\n                        a, b = mods[x][0], mods[y][0]\n                    elif len(mods[x])>1:\n                        a, b = mods[x][0], mods[x][1]\n                    else:\n                        continue\n\n                    if a < l1 or (a==l1 and b<l2):\n                        l1, l2 = a, b\n\n        if l1 == n+1:\n            l1, l2 = -1, -1\n\n        #print(f\"All cands for answer ({l1,l2})= {all_cands}\")\n\n        print(str(l1) + ' ' + str(l2))\n\n\ndef main():\n    with f:\n        t = read_num(f)\n\n        for tt in range(t):\n            #if tt>=2:\n            #    break\n            s = read_str(f)\n            w, q = read_pair(f)\n            solve(s, w, q)\n\n\n\n\n\n\ndata = \"\"\"5\n1003004\n4 1\n1 2 1\n179572007\n4 2\n2 7 3\n2 7 4\n111\n2 1\n2 2 6\n0000\n1 2\n1 4 0\n1 4 1\n484\n1 5\n2 2 0\n2 3 7\n1 2 5\n3 3 8\n2 2 6\n\"\"\"\n\nf = None\n#f = io.StringIO(data)\n\nif f is None:\n    f = sys.stdin\n    if len(sys.argv) > 1:\n        f = open(sys.argv[1], 'r')\ntestcase = None\n\nif __name__ == '__main__':\n\n    #sys.setrecursionlimit(300000)\n    main()\n\n\n\"\"\"\n2 4\n1 5\n1 2\n-1 -1\n1 2\n-1 -1\n1 3\n1 3\n-1 -1\n-1 -1\n-1 -1\n\"\"\"\n\n\n\n",
    "prob_desc_created_at": "1662993300",
    "tags": [
        "hashing",
        "math"
    ],
    "hidden_unit_tests": ""
}
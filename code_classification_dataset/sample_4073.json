{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"YES\\nNO\\nNO\"]",
    "src_uid": "fb500a8f56fe8b051b3e6d2d4656c81b",
    "prob_desc_notes": "NoteThe first two test cases are explained in the statement.In the third test case the strip looks like this:    It is easy to check that the unblocked squares on it can not be tiled.",
    "prob_desc_description": "Every year Santa Claus gives gifts to all children. However, each country has its own traditions, and this process takes place in different ways. For example, in Berland you need to solve the New Year's puzzle.Polycarp got the following problem: given a grid strip of size $$$2 \\times n$$$, some cells of it are blocked. You need to check if it is possible to tile all free cells using the $$$2 \\times 1$$$ and $$$1 \\times 2$$$ tiles (dominoes).For example, if $$$n = 5$$$ and the strip looks like this (black cells are blocked):  Then it can be tiled, for example, using two vertical and two horizontal tiles, as in the picture below (different tiles are marked by different colors).  And if $$$n = 3$$$ and the strip looks like this:  It is impossible to tile free cells.Polycarp easily solved this task and received his New Year's gift. Can you solve it?",
    "prob_desc_output_spec": "For each test case, print on a separate line:    \"YES\", if it is possible to tile all unblocked squares with the $$$2 \\times 1$$$ and $$$1 \\times 2$$$ tiles;  \"NO\" otherwise.  You can output \"YES\" and \"NO\" in any case (for example, the strings yEs, yes, Yes and YES will be recognized as positive).",
    "prob_desc_input_spec": "The first line contains an integer $$$t$$$ ($$$1 \\leq t \\leq 10^4$$$) — the number of test cases. Then $$$t$$$ test cases follow. Each test case is preceded by an empty line. The first line of each test case contains two integers $$$n$$$ and $$$m$$$ ($$$1 \\le n \\le 10^9$$$, $$$1 \\le m \\le 2 \\cdot 10^5$$$) — the length of the strip and the number of blocked cells on it. Each of the next $$$m$$$ lines contains two integers $$$r_i, c_i$$$ ($$$1 \\le r_i \\le 2, 1 \\le c_i \\le n$$$) — numbers of rows and columns of blocked cells. It is guaranteed that all blocked cells are different, i.e. $$$(r_i, c_i) \\ne (r_j, c_j), i \\ne j$$$. It is guaranteed that the sum of $$$m$$$ over all test cases does not exceed $$$2 \\cdot 10^5$$$.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3-64",
    "lang_cluster": "Python",
    "difficulty": 2100,
    "file_name": "train_089.jsonl",
    "code_uid": "9c25fb385b02992f32759a6461faa8ed",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"3\\n\\n5 2\\n2 2\\n1 4\\n\\n3 2\\n2 1\\n2 3\\n\\n6 4\\n2 1\\n2 3\\n2 4\\n2 6\"]",
    "exec_outcome": "PASSED",
    "source_code": "from collections import Counter, deque\r\nimport bisect\r\nfrom copy import deepcopy\r\nimport heapq\r\nimport math\r\nimport sys\r\nfrom types import GeneratorType\r\n\r\n# sys.setrecursionlimit(10**5)\r\n\r\n# sys.stdin = open('grey.in', 'r')\r\n\r\n\r\ndef bootstrap(f, stack=[]):\r\n    def wrappedfunc(*args, **kwargs):\r\n        if stack:\r\n            return f(*args, **kwargs)\r\n        else:\r\n            to = f(*args, **kwargs)\r\n            while True:\r\n                if type(to) is GeneratorType:\r\n                    stack.append(to)\r\n                    to = next(to)\r\n                else:\r\n                    stack.pop()\r\n                    if not stack:\r\n                        break\r\n                    to = stack[-1].send(to)\r\n            return to\r\n \r\n    return wrappedfunc\r\n \r\nresult = []\r\n\r\n\r\n\r\nLOG = 18\r\n\r\narray = [1, 2, 3, 4, 5, 6, 7, 8]\r\n\r\n\r\n\r\n\r\n\r\n\r\ndef calc(numOne, numTwo):\r\n    \r\n    currentSum = 0\r\n    for i in range(32):\r\n        firstBit, secondBit = min(1, numOne & (1 << i)), min(1, numTwo & (1 << i))\r\n        \r\n        currentSum += (firstBit ^ secondBit)\r\n\r\n    return currentSum    \r\n\r\n\r\n# counter = Counter()\r\n# for i in range(0, 119000):\r\n#     counter[calc(i, i + 1)] += 1\r\n\r\n\r\n# print(counter)\r\n\r\n\r\n\r\n \r\ninput = sys.stdin.readline\r\n \r\n \r\n\r\n# t = int(input())\r\n# result = []\r\n# for _ in range(t):\r\n#     a, b = map(int, input().split())\r\n\r\n\r\n#     def solve():\r\n#         state = False\r\n#         count = 0\r\n        \r\n#         currentMin = float('inf')\r\n#         for z in range(0, b + 5):\r\n#             currentB = b + z\r\n#             count = 0\r\n#             for i in range(32):\r\n#                 firstBit, secondBit = a & (1 << i), currentB & (1 << i)\r\n\r\n#                 if secondBit and not firstBit:\r\n#                     state = True\r\n#                     continue\r\n\r\n#                 if firstBit and not secondBit:\r\n#                     count += (2**i)\r\n#             currentMin = min(currentMin, count + 1 + z if state else count + z)        \r\n#         return min(currentMin, b - a)\r\n\r\n#     print(solve())           \r\n\r\n# # print(result)\r\n\r\n\r\n\r\nclass SegmentTree2D:\r\n\r\n    \r\n    def __init__(self, row, col, inMatrix):\r\n        self.rows = row\r\n        self.cols = col\r\n        self.inMatrix = inMatrix\r\n        self.matrix = [[0 for z in range(col + 1)] for i in range(row + 1)]\r\n        self.genTable()\r\n\r\n\r\n    \r\n\r\n    def genTable(self):\r\n        self.matrix[0][0] = 0\r\n\r\n\r\n        for row in range(self.rows):\r\n            currentSum = 0\r\n            for col in range(self.cols):\r\n                currentSum += self.inMatrix[row][col]\r\n                above = self.matrix[row][col + 1]\r\n                self.matrix[row + 1][col + 1] = currentSum + above\r\n\r\n    \r\n\r\n\r\n    def sumRegion(self, rowOne, colOne, rowTwo, colTwo):\r\n        rowOne += 1\r\n        rowTwo += 1\r\n        colOne += 1\r\n        colTwo += 1\r\n\r\n        bottomRight, above = self.matrix[rowTwo][colTwo], self.matrix[rowOne - 1][colTwo]\r\n        left, topLeft = self.matrix[rowTwo][colOne - 1], self.matrix[rowOne - 1][colOne - 1]\r\n        return bottomRight - above - left + topLeft\r\n\r\n\r\n\r\n\r\n\r\n\r\nclass LCA:\r\n    def __init__(self, neighbourNodes, rootNode):\r\n        self.neighbourNodes = neighbourNodes\r\n        self.log = 18\r\n        self.parentNode = [[i for i in range(self.log)] for z in range(len(neighbourNodes))]\r\n        self.depth = [0 for i in range(len(neighbourNodes))]\r\n        self.bfs(rootNode, rootNode, 0)\r\n \r\n \r\n \r\n    def bfs(self, currentNode, parentNode, currentDepth):\r\n        queue = deque()\r\n        queue.append((currentNode, parentNode, currentDepth))\r\n \r\n \r\n        while(queue):\r\n            currentNode, parentNode, currentDepth = queue.popleft()\r\n \r\n            self.parentNode[currentNode][0] = parentNode\r\n \r\n \r\n            for i in range(1, self.log):\r\n                self.parentNode[currentNode][i] = self.parentNode[self.parentNode[currentNode][i - 1]][i - 1]\r\n \r\n \r\n            for node in self.neighbourNodes[currentNode]:\r\n                if node != parentNode:\r\n                    queue.append((node, currentNode, currentDepth + 1))\r\n \r\n            self.depth[currentNode] = currentDepth            \r\n \r\n \r\n    def lca(self, nodeOne, nodeTwo):\r\n        \r\n        diff = abs(self.depth[nodeOne] - self.depth[nodeTwo])\r\n        \r\n \r\n        if self.depth[nodeOne] < self.depth[nodeTwo]:\r\n            nodeOne, nodeTwo = nodeTwo, nodeOne\r\n \r\n        for i in reversed(range(self.log)):\r\n            if diff & (1 << i):\r\n                nodeOne = self.parentNode[nodeOne][i]\r\n \r\n        if nodeOne == nodeTwo:\r\n            return nodeOne\r\n \r\n        for i in reversed(range(self.log)):\r\n            if self.parentNode[nodeOne][i] != self.parentNode[nodeTwo][i]:\r\n                nodeOne, nodeTwo = self.parentNode[nodeOne][i], self.parentNode[nodeTwo][i]\r\n \r\n        return self.parentNode[nodeOne][0]   \r\n \r\n\r\n\r\ndef power(a, b, mod):\r\n    if not b:\r\n        return 1\r\n\r\n    temp = power(a, b // 2, mod)\r\n    result = temp * temp if b % 2 == 0 else temp * temp * a\r\n    result %= mod\r\n    return result    \r\n\r\n\r\n\r\n\r\n\r\n\r\ndef bootstrap(f, stack=[]):\r\n    def wrappedfunc(*args, **kwargs):\r\n        if stack:\r\n            return f(*args, **kwargs)\r\n        else:\r\n            to = f(*args, **kwargs)\r\n            while True:\r\n                if type(to) is GeneratorType:\r\n                    stack.append(to)\r\n                    to = next(to)\r\n                else:\r\n                    stack.pop()\r\n                    if not stack:\r\n                        break\r\n                    to = stack[-1].send(to)\r\n            return to\r\n \r\n    return wrappedfunc\r\n\r\n\r\n\r\n\r\ndef genSparseTable(array, comp):\r\n        \r\n    sparseTable = [[float('inf') for i in range(LOG)] for x in range(len(array))]\r\n\r\n\r\n    for i in range(len(array)):\r\n        sparseTable[i][0] = array[i]\r\n\r\n\r\n\r\n    for i in range(1, LOG):\r\n        j = 0\r\n        while((j + (1 << i) - 1) < len(array)):\r\n            sparseTable[j][i] = comp(sparseTable[j][i - 1], sparseTable[j + (1 << (i  - 1))][i - 1])\r\n            j += 1\r\n\r\n    return sparseTable\r\n\r\ndef query(l, r, sparseTable, comp):\r\n    length = (r - l) + 1\r\n    idx = int(math.log(length, 2))\r\n    return comp(sparseTable[l][idx], sparseTable[r - (1 << idx) + 1][idx])\r\n\r\n\r\n\r\n# t = int(input())\r\n\r\n\r\n# for _ in range(t):\r\n#     n, x, y = map(int, input().split())\r\n    \r\n#     stringOne, stringTwo = map(int, input().split())\r\n\r\n#     def solve():\r\n\r\n#         rightMostIdx = None\r\n\r\n#         cnt = 0\r\n\r\n#         for numOne, numTwo in zip(stringOne, stringTwo):\r\n#             if numOne != numTwo:\r\n#                 cnt += 1\r\n\r\n#         if cnt % 2:\r\n#             return -1\r\n\r\n#         for i in reversed(range(n)):\r\n#             if stringOne[i] == stringTwo[i]:\r\n#                 rightMostIdx = i\r\n#                 break\r\n\r\n#         leftMostIdx = None\r\n\r\n#         currentIdx = 0\r\n        \r\n#         total = 0\r\n#         while(currentIdx < n - 1):\r\n#             if stringOne[currentIdx] != stringTwo[currentIdx] and stringOne[currentIdx + 1] != stringTwo[currentIdx + 1]:\r\n#                 if rightMostIdx is not None and rightMostIdx - 1 > currentIdx + 1:\r\n#                     total += min(x, 2 * y)\r\n#                 elif leftMostIdx is not None and leftMostIdx + 1 < currentIdx:\r\n#                     total += min(x, 2 * y)\r\n#                 else:\r\n#                     total += x\r\n#                     if leftMostIdx is None:\r\n#                         leftMostIdx = currentIdx\r\n#                 currentIdx += 2        \r\n#             elif stringOne[currentIdx] != stringTwo[currentIdx]:\r\n\r\n \r\n\r\n\r\ndef nCr(n, r):\r\n\r\n\t\r\n\tp = 1\r\n\tk = 1\r\n\r\n\t\r\n\tif (n - r < r):\r\n\t\tr = n - r\r\n\r\n\tif (r != 0):\r\n\t\twhile (r):\r\n\t\t\tp *= n\r\n\t\t\tk *= r\r\n\r\n\t\t\tm = math.gcd(p, k)\r\n\r\n\t\t\t\r\n\t\t\tp //= m\r\n\t\t\tk //= m\r\n\r\n\t\t\tn -= 1\r\n\t\t\tr -= 1\r\n\telse:\r\n\t\tp = 1\r\n\r\n\treturn p\r\n\r\n\r\n\r\n\r\nt = int(input())\r\n\r\n\r\nfor _ in range(t):\r\n    input()\r\n    n, m = map(int, input().split())\r\n\r\n\r\n    hashMap = {} \r\n    for i in range(m):\r\n        row, col = map(int, input().split())\r\n        if col in hashMap:\r\n            hashMap[col].append(row)\r\n        else:\r\n            hashMap[col] = [row]\r\n\r\n\r\n\r\n    def solve():\r\n\r\n        values = list(hashMap.keys())\r\n\r\n        values.sort()\r\n\r\n        i = 0\r\n\r\n        # if values[-1] == n and len(hashMap[values[-1]]) == 1:\r\n        #     return \"NO\"\r\n\r\n        while(i < len(values)):\r\n            \r\n            if i == len(values) - 1:\r\n                if len(hashMap[values[i]]) == 2:\r\n                    i += 1\r\n                    continue\r\n                return \"NO\" \r\n\r\n            firstVal, secondVal = values[i], values[i + 1]\r\n\r\n            if len(hashMap[firstVal]) == len(hashMap[secondVal]) == 2:\r\n                i += 2\r\n                continue\r\n\r\n            if len(hashMap[secondVal]) == 2:\r\n                return \"NO\"\r\n            \r\n            if len(hashMap[firstVal]) == 2:\r\n                i += 1\r\n                continue\r\n\r\n            rowOne, rowTwo = hashMap[firstVal][0], hashMap[secondVal][0]\r\n            \r\n            if rowOne == rowTwo:\r\n                if (secondVal - firstVal) % 2 == 0:\r\n                    return \"NO\"\r\n            else:\r\n                if (secondVal - firstVal) % 2 != 0:\r\n                    return \"NO\"        \r\n\r\n            i += 2\r\n\r\n        return \"YES\"\r\n\r\n    print(solve())\r\n\r\n# print(result)\r\n\r\n            \r\n            \r\n\r\n\r\n\r\n\r\n\r\n    ",
    "prob_desc_created_at": "1609770900",
    "tags": [
        "brute force",
        "dp",
        "graph matchings",
        "greedy",
        "sortings"
    ],
    "hidden_unit_tests": ""
}
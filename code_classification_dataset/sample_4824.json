{
    "prob_desc_time_limit": "3 seconds",
    "prob_desc_sample_outputs": "[\"6\\n1 3 3\\n3 3 4\\n2 2 5\\n1 1 5\\n2 1 1\\n3 1 2\", \"-1\"]",
    "src_uid": "3e08a9ef172ece7839728439d5b608a8",
    "prob_desc_notes": "NoteIn the first test case, the solution is not unique. Here's one of them:  In the second test case, there is no way one could obtain the given painting, thus the answer is $$$-1$$$.",
    "prob_desc_description": "You found a painting on a canvas of size $$$n \\times m$$$. The canvas can be represented as a grid with $$$n$$$ rows and $$$m$$$ columns. Each cell has some color. Cell $$$(i, j)$$$ has color $$$c_{i,j}$$$.Near the painting you also found a brush in the shape of a $$$2 \\times 2$$$ square, so the canvas was surely painted in the following way: initially, no cell was painted. Then, the following painting operation has been performed some number of times:  Choose two integers $$$i$$$ and $$$j$$$ ($$$1 \\le i &lt; n$$$, $$$1 \\le j &lt; m$$$) and some color $$$k$$$ ($$$1 \\le k \\le nm$$$).  Paint cells $$$(i, j)$$$, $$$(i + 1, j)$$$, $$$(i, j + 1)$$$, $$$(i + 1, j + 1)$$$ in color $$$k$$$. All cells must be painted at least once. A cell can be painted multiple times. In this case, its final color will be the last one.Find any sequence of at most $$$nm$$$ operations that could have led to the painting you found or state that it's impossible.",
    "prob_desc_output_spec": "If there is no solution, print a single integer $$$-1$$$. Otherwise, on the first line, print one integer $$$q$$$ ($$$1 \\le q \\le nm$$$) — the number of operations. Next, print the operations in order. On the $$$k$$$-th of the next $$$q$$$ lines, print three integers $$$i$$$, $$$j$$$, $$$c$$$ ($$$1 \\le i &lt; n$$$, $$$1 \\le j &lt; m$$$, $$$1 \\le c \\le nm$$$) — the description of the $$$k$$$-th operation. If there are multiple solutions, print any.",
    "prob_desc_input_spec": "The first line of input contains two integers $$$n$$$ and $$$m$$$ ($$$2 \\le n, m \\le 1000$$$) — the dimensions of the canvas. On the $$$i$$$-th of the next $$$n$$$ lines of input, there will be $$$m$$$ integers. The $$$j$$$-th of them is $$$a_{i,j}$$$ ($$$1 \\le a_{i,j} \\le nm$$$) — the color of cell $$$(i, j)$$$.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3-64",
    "lang_cluster": "Python",
    "difficulty": 2000,
    "file_name": "train_107.jsonl",
    "code_uid": "1a8c1d863a4925e9eecd4e95d409ba1d",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"4 4\\n5 5 3 3\\n1 1 5 3\\n2 2 5 4\\n2 2 4 4\", \"3 4\\n1 1 1 1\\n2 2 3 1\\n2 2 1 1\"]",
    "exec_outcome": "PASSED",
    "source_code": "# region fastioasdf\nimport os\nimport sys\nfrom io import BytesIO, IOBase\n\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._file = file\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = 'x' in file.mode or 'r' not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b'\\n') + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode('ascii'))\n        self.read = lambda: self.buffer.read().decode('ascii')\n        self.readline = lambda: self.buffer.readline().decode('ascii')\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip('\\r\\n')\n\n# endregion\ndef solve():\n    return testcase()\nii = lambda : int(input())\nil = lambda : input().split()\niil = lambda : list(map(int, il()))\n\ndef testcase():\n    [n, m] = iil()\n    grid = [iil() for _ in range(n)]\n    rst = solution(n, m, grid)\n    if rst:\n        print(len(rst))\n        for [i, j, c] in reversed(rst):\n            print(i + 1, j + 1, c)\n        _hy_anon_var_1 = None\n    else:\n        _hy_anon_var_1 = print(-1)\n    return _hy_anon_var_1\n\ndef color_case(i, j, grid):\n    c = 0\n    for x in range(i, i + 2):\n        for y in range(j, j + 2):\n            this_c = grid[x][y]\n            if this_c == 0:\n                continue\n                _hy_anon_var_4 = None\n            else:\n                if c == 0:\n                    c = this_c\n                    _hy_anon_var_3 = None\n                else:\n                    if c != this_c:\n                        return -1\n                        _hy_anon_var_2 = None\n                    else:\n                        _hy_anon_var_2 = None\n                    _hy_anon_var_3 = _hy_anon_var_2\n                _hy_anon_var_4 = _hy_anon_var_3\n    return c\n\ndef solution(n, m, grid):\n    rst = []\n    q = []\n    for i in range(n - 1):\n        for j in range(m - 1):\n            c = color_case(i, j, grid)\n            if c <= 0:\n                continue\n                _hy_anon_var_5 = None\n            else:\n                _hy_anon_var_5 = None\n            q = [[i, j]]\n            while q:\n                [i, j] = q.pop()\n                c = color_case(i, j, grid)\n                if c <= 0:\n                    continue\n                    _hy_anon_var_6 = None\n                else:\n                    _hy_anon_var_6 = None\n                rst.append([i, j, c])\n                for x in range(i, i + 2):\n                    for y in range(j, j + 2):\n                        grid[x][y] = 0\n                for x in range(i - 1, i + 2):\n                    if not 0 <= x <= n - 2:\n                        continue\n                        _hy_anon_var_7 = None\n                    else:\n                        _hy_anon_var_7 = None\n                    for y in range(j - 1, j + 2):\n                        if not 0 <= y <= m - 2:\n                            continue\n                            _hy_anon_var_8 = None\n                        else:\n                            _hy_anon_var_8 = None\n                        c = color_case(x, y, grid)\n                        q.append([x, y]) if c > 0 else None\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j]:\n                return []\n                _hy_anon_var_9 = None\n            else:\n                _hy_anon_var_9 = None\n    return rst\nsolve()\n",
    "prob_desc_created_at": "1644849300",
    "tags": [
        "constructive algorithms",
        "data structures",
        "greedy",
        "implementation"
    ],
    "hidden_unit_tests": ""
}
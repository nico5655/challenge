{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"...\\n.L.\\n...\\n#++++\\n..##L\\n...#+\\n...++\\nL\\n++++L++#.\"]",
    "src_uid": "fa82a5160696616af784b5488c9f69f6",
    "prob_desc_notes": "NoteIn the first testcase there is no free cell that the robot can be forced to reach the lab from. Consider a corner cell. Given any direction, it will move to a neighbouring border grid that's not a corner. Now consider a non-corner free cell. No matter what direction you send to the robot, it can choose a different direction such that it ends up in a corner.In the last testcase, you can keep sending the command that is opposite to the direction to the lab and the robot will have no choice other than move towards the lab.",
    "prob_desc_description": "There is a grid, consisting of $$$n$$$ rows and $$$m$$$ columns. Each cell of the grid is either free or blocked. One of the free cells contains a lab. All the cells beyond the borders of the grid are also blocked.A crazy robot has escaped from this lab. It is currently in some free cell of the grid. You can send one of the following commands to the robot: \"move right\", \"move down\", \"move left\" or \"move up\". Each command means moving to a neighbouring cell in the corresponding direction.However, as the robot is crazy, it will do anything except following the command. Upon receiving a command, it will choose a direction such that it differs from the one in command and the cell in that direction is not blocked. If there is such a direction, then it will move to a neighbouring cell in that direction. Otherwise, it will do nothing.We want to get the robot to the lab to get it fixed. For each free cell, determine if the robot can be forced to reach the lab starting in this cell. That is, after each step of the robot a command can be sent to a robot such that no matter what different directions the robot chooses, it will end up in a lab.",
    "prob_desc_output_spec": "For each testcase find the free cells that the robot can be forced to reach the lab from. Given the grid, replace the free cells (marked with a dot) with a plus sign ('+') for the cells that the robot can be forced to reach the lab from. Print the resulting grid.",
    "prob_desc_input_spec": "The first line contains a single integer $$$t$$$ ($$$1 \\le t \\le 1000$$$) — the number of testcases. The first line of each testcase contains two integers $$$n$$$ and $$$m$$$ ($$$1 \\le n, m \\le 10^6$$$; $$$n \\cdot m \\le 10^6$$$) — the number of rows and the number of columns in the grid. The $$$i$$$-th of the next $$$n$$$ lines provides a description of the $$$i$$$-th row of the grid. It consists of $$$m$$$ elements of one of three types:    '.' — the cell is free;  '#' — the cell is blocked;  'L' — the cell contains a lab.  The grid contains exactly one lab. The sum of $$$n \\cdot m$$$ over all testcases doesn't exceed $$$10^6$$$.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3-64",
    "lang_cluster": "Python",
    "difficulty": 2000,
    "file_name": "train_090.jsonl",
    "code_uid": "fae7079d6666b2c392586d123d2db2a8",
    "prob_desc_memory_limit": "512 megabytes",
    "prob_desc_sample_inputs": "[\"4\\n3 3\\n...\\n.L.\\n...\\n4 5\\n#....\\n..##L\\n...#.\\n.....\\n1 1\\nL\\n1 9\\n....L..#.\"]",
    "exec_outcome": "PASSED",
    "source_code": "import sys\r\nimport os\r\nfrom io import BytesIO, IOBase\r\nfrom collections import deque\r\n\r\n# region fastio\r\nBUFSIZE = 8192\r\n \r\nclass FastIO(IOBase):\r\n    newlines = 0\r\n \r\n    def __init__(self, file):\r\n        self._fd = file.fileno()\r\n        self.buffer = BytesIO()\r\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\r\n        self.write = self.buffer.write if self.writable else None\r\n \r\n    def read(self):\r\n        while True:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            if not b:\r\n                break\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines = 0\r\n        return self.buffer.read()\r\n \r\n    def readline(self):\r\n        while self.newlines == 0:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            self.newlines = b.count(b\"\\n\") + (not b)\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines -= 1\r\n        return self.buffer.readline()\r\n \r\n    def flush(self):\r\n        if self.writable:\r\n            os.write(self._fd, self.buffer.getvalue())\r\n            self.buffer.truncate(0), self.buffer.seek(0)\r\n \r\nclass IOWrapper(IOBase):\r\n    def __init__(self, file):\r\n        self.buffer = FastIO(file)\r\n        self.flush = self.buffer.flush\r\n        self.writable = self.buffer.writable\r\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\r\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\r\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\r\n\r\nif sys.version_info[0] < 3:\r\n    sys.stdin = BytesIO(os.read(0, os.fstat(0).st_size))\r\nelse:\r\n    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\r\n\r\nf = sys.stdin\r\nif os.environ.get('USER') == \"loic\":\r\n    f = open(\"data.in\")\r\n    \r\nline = lambda: f.readline().split()\r\nui = lambda: int(line()[0])\r\nti = lambda: map(int,line())\r\nli = lambda: list(ti())\r\n\r\n#######################################################################\r\n\r\ndef neigh(i,j):\r\n    res = []\r\n    if i > 0:\r\n        res.append((i-1,j))\r\n    if i < N-1:\r\n        res.append((i+1,j))\r\n    if j > 0:\r\n        res.append((i,j-1))\r\n    if j < M-1:\r\n        res.append((i,j+1))\r\n    return res\r\n\r\ndef solve():\r\n    \r\n    start = (x,y)\r\n    \r\n    q = deque([start])\r\n\r\n    while q:\r\n        i,j = q.pop()\r\n        \r\n        chs = neigh(i, j)\r\n        \r\n        for i_n,j_n in chs:\r\n            val = G[i_n][j_n]\r\n            if val == '.':\r\n                cnt = 0\r\n                for i_ch,j_ch in neigh(i_n, j_n):\r\n                    if G[i_ch][j_ch] == '.':\r\n                        cnt += 1\r\n                if cnt <= 1:\r\n                    G[i_n][j_n] = '+'\r\n                    q.append((i_n,j_n))\r\n    \r\n    \r\n    res = \"\\n\".join(\"\".join(v for v in l) for l in G)\r\n    \r\n    return str(res)\r\n\r\nfor test in range(1,ui()+1):\r\n    N,M = ti()\r\n    G = []\r\n    x = -1\r\n    y = -1\r\n    \r\n    G = [list(line()[0]) for i in range(N)]\r\n    xLab = -1\r\n    yLab = -1\r\n    for i in range(N):\r\n        for j in range(M):\r\n            if G[i][j] == 'L':\r\n                x = i\r\n                y = j\r\n                break\r\n    \r\n#     for i in range(N):\r\n#         l = list(line()[0])\r\n#         G.append(l)\r\n#         if x == -1:\r\n#             for j in range(M):\r\n#                 if l[j] == 'L':\r\n#                     x = i\r\n#                     y = j\r\n#                     break\r\n    \r\n    print(solve())\r\n    \r\nf.close()",
    "prob_desc_created_at": "1638369300",
    "tags": [
        "dfs and similar",
        "graphs"
    ],
    "hidden_unit_tests": ""
}
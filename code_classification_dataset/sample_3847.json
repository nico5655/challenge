{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"NO\\nNO\\nNO\\nYES\\nYES\\nYES\\nYES\\nNO\"]",
    "src_uid": "b3c08abbaeec9ecbcc71fe34336d039a",
    "prob_desc_notes": null,
    "prob_desc_description": "A wild basilisk just appeared at your doorstep. You are not entirely sure what a basilisk is and you wonder whether it evolved from your favorite animal, the weasel. How can you find out whether basilisks evolved from weasels? Certainly, a good first step is to sequence both of their DNAs. Then you can try to check whether there is a sequence of possible mutations from the DNA of the weasel to the DNA of the basilisk. Your friend Ron is a talented alchemist and has studied DNA sequences in many of his experiments. He has found out that DNA strings consist of the letters A, B and C and that single mutations can only remove or add substrings at any position in the string (a substring is a contiguous sequence of characters). The substrings that can be removed or added by a mutation are AA, BB, CC, ABAB or BCBC. During a sequence of mutations a DNA string may even become empty.Ron has agreed to sequence the DNA of the weasel and the basilisk for you, but finding out whether there is a sequence of possible mutations that leads from one to the other is too difficult for him, so you have to do it on your own. ",
    "prob_desc_output_spec": "For each test case, print YES if there is a sequence of mutations to get from $$$u$$$ to $$$v$$$ and NO otherwise. ",
    "prob_desc_input_spec": "Each test contains multiple test cases. The first line contains an integer $$$t$$$ ($$$1\\le t\\le 100$$$) — the number of test cases. The descriptions of the $$$t$$$ test cases follow. The first line of each test case contains a string $$$u$$$ ($$$1\\le |u|\\le 200$$$) — the DNA of the weasel. The second line of each test case contains a string $$$v$$$ ($$$1\\le |v|\\le 200$$$) — the DNA of the basilisk.  The values $$$|u|$$$, $$$|v|$$$ denote the lengths of the strings $$$u$$$ and $$$v$$$. It is guaranteed that both strings $$$u$$$ and $$$v$$$ consist of the letters A, B and C.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3",
    "lang_cluster": "Python",
    "difficulty": -1,
    "file_name": "train_085.jsonl",
    "code_uid": "26b502e1ada23435d429648113436a7f",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"8\\n\\nA\\n\\nB\\n\\nB\\n\\nC\\n\\nC\\n\\nA\\n\\nAA\\n\\nBB\\n\\nBB\\n\\nCC\\n\\nCC\\n\\nAA\\n\\nABAB\\n\\nBCBC\\n\\nABC\\n\\nCBA\"]",
    "exec_outcome": "PASSED",
    "source_code": "\r\nstrings = ['AA', 'BB', 'CC', 'ABAB', 'BCBC']\r\nreduction = [['AA', ''], ['BB', ''], ['CC', ''], ['ABAB', ''], ['BCBC', ''],\r\n             ['CB', 'BC'], ['AB', 'BA']]  # move all Bs left\r\n\r\n# def simulator():\r\n#     s = 'CA'\r\n#     # get all possible outcomes from s\r\n#     l = len(s)\r\n#     vi = set()\r\n#     vi.add(s)\r\n#     st = [s]\r\n#     while st:\r\n#         s = st.pop()\r\n#         n = len(s)\r\n#         for s2 in strings:\r\n#             for i in range(n + 1):\r\n#                 # remove\r\n#                 if s[i: i + len(s2)] == s2:\r\n#                     s3 = s[:i] + s[i + len(s2):]\r\n#                     if s3 not in vi:\r\n#                         st.append(s3)\r\n#                         vi.add(s3)\r\n#                 # add\r\n#                 s3 = s[: i] + s2 + s[i:]\r\n#                 # if s3 == 'ABAB':\r\n#                 #     print('s2:{}'.format(s2))\r\n#                 if len(s3) <= l + 8 and s3 not in vi:\r\n#                     st.append(s3)\r\n#                     vi.add(s3)\r\n#     for s in vi:\r\n#         if len(s) <= l + 2:\r\n#             print(s)\r\n# simulator()\r\n\r\ndef reduce_string(s):\r\n    changed = 1\r\n    while changed == 1:\r\n        changed = 0\r\n        for complex_form, reduced_form in reduction:\r\n            if complex_form in s:\r\n                s = s.replace(complex_form, reduced_form)\r\n                changed = 1\r\n    return s\r\n\r\ndef main():\r\n    \r\n    T = int(input())\r\n    allans = []\r\n    for _ in range(T):\r\n        s = input()\r\n        t = input()\r\n        \r\n        s2 = reduce_string(s)\r\n        t2 = reduce_string(t)\r\n        # print('s:{} t:{} s2:{} t2:{}'.format(s, t, s2, t2))\r\n        if s2 == t2:\r\n            ans = 'YES'\r\n        else:\r\n            ans = 'NO'\r\n        allans.append(ans)\r\n    multiLineArrayPrint(allans)\r\n        \r\n    \r\n    return\r\n\r\nimport sys\r\n# input=sys.stdin.buffer.readline #FOR READING PURE INTEGER INPUTS (space separation ok)\r\ninput=lambda: sys.stdin.readline().rstrip(\"\\r\\n\") #FOR READING STRING/TEXT INPUTS.\r\n \r\ndef oneLineArrayPrint(arr):\r\n    print(' '.join([str(x) for x in arr]))\r\ndef multiLineArrayPrint(arr):\r\n    print('\\n'.join([str(x) for x in arr]))\r\ndef multiLineArrayOfArraysPrint(arr):\r\n    print('\\n'.join([' '.join([str(x) for x in y]) for y in arr]))\r\n \r\ndef readIntArr():\r\n    return [int(x) for x in input().split()]\r\n# def readFloatArr():\r\n#     return [float(x) for x in input().split()]\r\n \r\ndef makeArr(defaultValFactory,dimensionArr): # eg. makeArr(lambda:0,[n,m])\r\n    dv=defaultValFactory;da=dimensionArr\r\n    if len(da)==1:return [dv() for _ in range(da[0])]\r\n    else:return [makeArr(dv,da[1:]) for _ in range(da[0])]\r\n \r\ndef queryInteractive(a, b, c):\r\n    print('? {} {} {}'.format(a, b, c))\r\n    sys.stdout.flush()\r\n    return int(input())\r\n \r\ndef answerInteractive(x1, x2):\r\n    print('! {} {}'.format(x1, x2))\r\n    sys.stdout.flush()\r\n \r\ninf=float('inf')\r\n# MOD=10**9+7\r\n# MOD=998244353\r\n \r\nfrom math import gcd,floor,ceil\r\nimport math\r\n# from math import floor,ceil # for Python2\r\n \r\nfor _abc in range(1):\r\n    main()",
    "prob_desc_created_at": "1650798300",
    "tags": [
        "greedy",
        "implementation",
        "strings"
    ],
    "hidden_unit_tests": ""
}
{
    "prob_desc_time_limit": "3.5 seconds",
    "prob_desc_sample_outputs": "[\"13\", \"0\"]",
    "src_uid": "c7ec7c379ef924497cd742a5b4795d4f",
    "prob_desc_notes": null,
    "prob_desc_description": "Vasya got really tired of these credits (from problem F) and now wants to earn the money himself! He decided to make a contest to gain a profit.Vasya has $$$n$$$ problems to choose from. They are numbered from $$$1$$$ to $$$n$$$. The difficulty of the $$$i$$$-th problem is $$$d_i$$$. Moreover, the problems are given in the increasing order by their difficulties. The difficulties of all tasks are pairwise distinct. In order to add the $$$i$$$-th problem to the contest you need to pay $$$c_i$$$ burles to its author. For each problem in the contest Vasya gets $$$a$$$ burles.In order to create a contest he needs to choose a consecutive subsegment of tasks.So the total earnings for the contest are calculated as follows:   if Vasya takes problem $$$i$$$ to the contest, he needs to pay $$$c_i$$$ to its author;  for each problem in the contest Vasya gets $$$a$$$ burles;  let $$$gap(l, r) = \\max\\limits_{l \\le i &lt; r} (d_{i + 1} - d_i)^2$$$. If Vasya takes all the tasks with indices from $$$l$$$ to $$$r$$$ to the contest, he also needs to pay $$$gap(l, r)$$$. If $$$l = r$$$ then $$$gap(l, r) = 0$$$. Calculate the maximum profit that Vasya can earn by taking a consecutive segment of tasks.",
    "prob_desc_output_spec": "Print one integer — maximum amount of burles Vasya can earn.",
    "prob_desc_input_spec": "The first line contains two integers $$$n$$$ and $$$a$$$ ($$$1 \\le n \\le 3 \\cdot 10^5$$$, $$$1 \\le a \\le 10^9$$$) — the number of proposed tasks and the profit for a single problem, respectively. Each of the next $$$n$$$ lines contains two integers $$$d_i$$$ and $$$c_i$$$ ($$$1 \\le d_i, c_i \\le 10^9, d_i &lt; d_{i+1}$$$).",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 2",
    "lang_cluster": "Python",
    "difficulty": 2400,
    "file_name": "train_004.jsonl",
    "code_uid": "6396032480872f0e773b562270667540",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"5 10\\n1 15\\n5 3\\n6 11\\n7 2\\n11 22\", \"3 5\\n1 8\\n2 19\\n3 11\"]",
    "exec_outcome": "PASSED",
    "source_code": "import sys\nrange = xrange\ninput = raw_input\n\n# A very nice implementation of a maximum segment tree with \n# some inspiration taken from https://codeforces.com/blog/entry/18051\n# This implementation should be able to be modified to do pretty\n# much anything one would want to do with segment trees apart from\n# persistance.\n# Note that especially in python this implementation is much much better\n# than most other approches because how slow python can be with function\n# calls.\n\n# Currently it allows for two operations, both running in O(log n),\n# 'add(l,r,value)' adds value to [l,r)\n# 'maxi(l,r)' returns the biggest value on l:r\n\nclass super_seg:\n    def __init__(self,data):\n        n = len(data)\n        m = 1\n        while m<n: m *= 2\n        \n        self.n = n\n        self.m = m\n        self.data = [0]*(2*m)\n        for i in range(n):\n            self.data[i+m] = data[i]\n        for i in reversed(range(m)):\n            self.data[i] = max(self.data[2*i], self.data[2*i+1])\n        self.query = [0]*(2*m)\n    \n    # Push the query on seg_ind to its children\n    def push(self,seg_ind):\n        # Let the children know of the queries\n        q = self.query[seg_ind]\n\n        self.query[2*seg_ind]   += q\n        self.query[2*seg_ind+1] += q\n        \n        self.data[2*seg_ind]   += q\n        self.data[2*seg_ind+1] += q\n\n        # Remove queries from seg_ind\n        self.data[seg_ind] = max(self.data[2*seg_ind],self.data[2*seg_ind+1])\n        self.query[seg_ind] = 0\n\n    # Updates the node seg_ind to know of all queries\n    # applied to it via its ancestors\n    def update(self,seg_ind):\n        # Find all indecies to be updated\n        seg_ind //= 2\n        inds = []\n        while seg_ind>0:\n            inds.append(seg_ind)\n            seg_ind//=2\n       \n        # Push the queries down the segment tree\n        for ind in reversed(inds):\n            self.push(ind)\n\n    # Make the changes to seg_ind be known to its ancestors\n    def build(self,seg_ind):\n        seg_ind//=2\n        while seg_ind>0:\n            self.data[seg_ind] = max(self.data[2*seg_ind], self.data[2*seg_ind+1]) + self.query[seg_ind]\n            seg_ind //= 2\n\n    # Lazily add value to [l,r)\n    def add(self,l,r,value):\n        l += self.m\n        r += self.m\n        \n        l0 = l\n        r0 = r\n\n        while l<r:\n            if l%2==1:\n                self.query[l]+= value\n                self.data[l] += value\n                l+=1\n            if r%2==1:\n                r-=1\n                self.query[r]+= value\n                self.data[r] += value\n            l//=2\n            r//=2\n\n        # Tell all nodes above of the updated\n        # area of the updates\n        self.build(l0)\n        self.build(r0-1)\n    \n    # Max of data[l,r)\n    def maxi(self,l,r):\n        l += self.m\n        r += self.m\n\n        # Apply all the lazily stored queries\n        self.update(l)\n        self.update(r-1)\n        \n        segs = []\n        while l<r:\n            if l%2==1:\n                segs.append(l)\n                l+=1\n            if r%2==1:\n                r-=1\n                segs.append(r)\n            l//=2\n            r//=2\n\n        return max(self.data[ind] for ind in segs)\n\n\nn,a = [int(x) for x in input().split()]\n\ninp = [int(x) for x in sys.stdin.read().split()]\n\nD = inp[::2]\nD.append(D[-1])\nC = inp[1::2]\nC = [a-c for c in C]\n\nCcum = [0]\nfor c in C:\n    Ccum.append(Ccum[-1]+c)\n\nseg = super_seg(Ccum)\n\nstack = []\nbesta = 0\n\nfor i in reversed(range(n)):\n    val = (D[i+1]-D[i])**2\n    while stack and stack[-1][0]<=val:        \n        # The previous difference is smaller, remove all knowledge of it\n        old_val,l,r = stack.pop()\n        seg.add(l,r,+old_val)\n\n    # Add new val to seg\n    l = i+2\n    r = stack[-1][1] if stack else n+1\n    if l<r:\n        stack.append((val,l,r))\n        seg.add(l,r,-val)\n    # Use maxi with the segmenttree to calc the best choice of r\n    cur_maxi = seg.maxi(i,n+1) - Ccum[i]\n    \n    besta = max(besta,cur_maxi)\nprint besta\n",
    "prob_desc_created_at": "1548516900",
    "tags": [
        "dp",
        "constructive algorithms",
        "dsu",
        "data structures",
        "binary search"
    ],
    "hidden_unit_tests": ""
}
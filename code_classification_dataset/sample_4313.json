{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"3 2 2 3 2\", \"1 2 1\", \"1 3 3 7\"]",
    "src_uid": "cb86d0b26ee542fc75e274fcfe3f3660",
    "prob_desc_notes": "NoteIn the first example, the array changes as follows:$$$[]$$$ $$$\\rightarrow$$$ $$$[3]$$$ $$$\\rightarrow$$$ $$$[3, 1]$$$ $$$\\rightarrow$$$ $$$[3, 2]$$$ $$$\\rightarrow$$$ $$$[3, 2, 2]$$$ $$$\\rightarrow$$$ $$$[3, 2, 2, 1]$$$ $$$\\rightarrow$$$ $$$[3, 2, 2, 1, 2]$$$ $$$\\rightarrow$$$ $$$[3, 2, 2, 3, 2]$$$.In the second example, the array changes as follows:$$$[]$$$ $$$\\rightarrow$$$ $$$[1]$$$ $$$\\rightarrow$$$ $$$[1, 2]$$$ $$$\\rightarrow$$$ $$$[1, 2, 1]$$$ $$$\\rightarrow$$$ $$$[1, 2, 1]$$$.In the third example, the array changes as follows:$$$[]$$$ $$$\\rightarrow$$$ $$$[]$$$ $$$\\rightarrow$$$ $$$[1]$$$ $$$\\rightarrow$$$ $$$[1, 4]$$$ $$$\\rightarrow$$$ $$$[1, 4, 2]$$$ $$$\\rightarrow$$$ $$$[1, 4, 4]$$$ $$$\\rightarrow$$$ $$$[1, 3, 3]$$$ $$$\\rightarrow$$$ $$$[1, 3, 3, 2]$$$ $$$\\rightarrow$$$ $$$[1, 3, 3, 7]$$$.",
    "prob_desc_description": "You have an array of integers (initially empty).You have to perform $$$q$$$ queries. Each query is of one of two types:   \"$$$1$$$ $$$x$$$\" — add the element $$$x$$$ to the end of the array;  \"$$$2$$$ $$$x$$$ $$$y$$$\" — replace all occurrences of $$$x$$$ in the array with $$$y$$$. Find the resulting array after performing all the queries.",
    "prob_desc_output_spec": "In a single line, print $$$k$$$ integers — the resulting array after performing all the queries, where $$$k$$$ is the number of queries of the first type.",
    "prob_desc_input_spec": "The first line contains a single integer $$$q$$$ ($$$1 \\le q \\le 5 \\cdot 10^5$$$) — the number of queries. Next $$$q$$$ lines contain queries (one per line). Each query is of one of two types:    \"$$$1$$$ $$$x$$$\" ($$$1 \\le x \\le 5 \\cdot 10^5$$$);  \"$$$2$$$ $$$x$$$ $$$y$$$\" ($$$1 \\le x, y \\le 5 \\cdot 10^5$$$).  It's guaranteed that there is at least one query of the first type.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3-64",
    "lang_cluster": "Python",
    "difficulty": 1900,
    "file_name": "train_095.jsonl",
    "code_uid": "ecb0713b160b37e02bedb1757ea4a5de",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"7\\n1 3\\n1 1\\n2 1 2\\n1 2\\n1 1\\n1 2\\n2 1 3\", \"4\\n1 1\\n1 2\\n1 1\\n2 2 2\", \"8\\n2 1 4\\n1 1\\n1 4\\n1 2\\n2 2 4\\n2 4 3\\n1 2\\n2 2 7\"]",
    "exec_outcome": "PASSED",
    "source_code": "# ------------------- fast io --------------------\r\nimport os\r\nimport sys\r\nfrom io import BytesIO, IOBase\r\nimport math\r\nfrom typing import OrderedDict\r\n \r\nBUFSIZE = 8192\r\n \r\n \r\nclass FastIO(IOBase):\r\n    newlines = 0\r\n    \r\n    def __init__(self, file):\r\n        self._fd = file.fileno()\r\n        self.buffer = BytesIO()\r\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\r\n        self.write = self.buffer.write if self.writable else None\r\n    \r\n    def read(self):\r\n        while True:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            if not b:\r\n                break\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines = 0\r\n        return self.buffer.read()\r\n    \r\n    def readline(self):\r\n        while self.newlines == 0:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            self.newlines = b.count(b\"\\n\") + (not b)\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines -= 1\r\n        return self.buffer.readline()\r\n    \r\n    def flush(self):\r\n        if self.writable:\r\n            os.write(self._fd, self.buffer.getvalue())\r\n            self.buffer.truncate(0), self.buffer.seek(0)\r\n \r\n \r\nclass IOWrapper(IOBase):\r\n    def __init__(self, file):\r\n        self.buffer = FastIO(file)\r\n        self.flush = self.buffer.flush\r\n        self.writable = self.buffer.writable\r\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\r\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\r\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\r\n \r\n \r\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\r\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\r\n \r\n# ------------------- fast io --------------------\r\ndef gcd(x, y):\r\n    while y:\r\n        x, y = y, x % y\r\n    return x\r\n \r\n \r\ndef lcm(a, b): return a * b // gcd(a, b)\r\n\r\ndef is_prime(n):\r\n    if (n <= 1):\r\n        return False\r\n    for i in range(2, int(math.sqrt(n))+1):\r\n        if (n % i == 0):\r\n            return False\r\n    return True\r\n\r\n# ------------------- write code from here --------------------\r\n# for _ in range(int(input())):\r\n# from collections import OrderedDict\r\n# n = int(input())\r\n# final=[]\r\n# mapped=[i for i in range(500000+1)]\r\n# queries_arr =[]\r\n# # d= OrderedDict()\r\n# for i in range(n):\r\n#     arr= list(map(int, input().split()))\r\n#     queries_arr+= [arr]\r\n\r\n# for i in range(n-1,-1,-1):\r\n#     query= queries_arr[i]\r\n#     if query[0]==2:\r\n\r\n#         mapped[query[1]]= mapped[query[2]]\r\n\r\n#     else:\r\n#         z= query[1]\r\n#         final+= [mapped[z]]\r\n        \r\n# print(*(final[::-1]))\r\n\r\n# for _ in range(int(input()) if not True else 1):\r\n#     q = int(input())\r\n#     # n, k = map(int, input().split())\r\n#     # a, b = map(int, input().split())\r\n#     # c, d = map(int, input().split())\r\n#     # a = list(map(int, input().split()))\r\n#     # b = list(map(int, input().split()))\r\n#     # s = input()\r\n#     a = []\r\n#     mapped = [i for i in range(500000 + 1)]\r\n#     queries = []\r\n#     for __ in range(q):\r\n#         query = list(map(int, input().split()))\r\n#         queries += [query]\r\n#     for i in range(q-1, -1, -1):\r\n#         query = queries[i]\r\n#         if query[0] == 2:\r\n#             x, y = query[1], query[2]\r\n#             mapped[x] = mapped[y]\r\n#         else:\r\n#             val = query[1]\r\n#             a += [mapped[val]]\r\n#     print(*a[::-1])\r\n\r\nn = int(input())\r\nfinal=[]\r\nmapped=[i for i in range(500000+1)]\r\nqueries_arr =[]\r\n# d= OrderedDict()\r\nfor i in range(n):\r\n    arr= list(map(int, input().split()))\r\n    queries_arr.append(arr)\r\n \r\nfor i in range(n-1,-1,-1):\r\n    if queries_arr[i][0]==2:\r\n \r\n        mapped[queries_arr[i][1]]= mapped[queries_arr[i][-1]]\r\n \r\n    else:\r\n        final.append(mapped[queries_arr[i][-1]])\r\n        \r\nprint(*(final[::-1]))",
    "prob_desc_created_at": "1639841700",
    "tags": [
        "constructive algorithms",
        "data structures",
        "dsu",
        "implementation"
    ],
    "hidden_unit_tests": ""
}
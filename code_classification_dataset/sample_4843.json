{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"YES\\n1 2\\nYES\\n2 1 3 2\\nYES\\n1 3 1 3 1\\nYES\\n1 2 1 3 4 1 4\\nNO\"]",
    "src_uid": "79b629047e674883a9bc04b1bf0b7f09",
    "prob_desc_notes": "NoteThe graph from the first three test cases is shown below:  In the first test case, the answer sequence is $$$[1,2]$$$ which means that the path is:$$$$$$1 \\xrightarrow{\\text{b}} 2$$$$$$So the string that is obtained by the given path is b.In the second test case, the answer sequence is $$$[2,1,3,2]$$$ which means that the path is:$$$$$$2 \\xrightarrow{\\text{b}} 1 \\xrightarrow{\\text{a}} 3 \\xrightarrow{\\text{b}} 2$$$$$$So the string that is obtained by the given path is bab.In the third test case, the answer sequence is $$$[1,3,1,3,1]$$$ which means that the path is:$$$$$$1 \\xrightarrow{\\text{a}} 3 \\xrightarrow{\\text{a}} 1 \\xrightarrow{\\text{a}} 3 \\xrightarrow{\\text{a}} 1$$$$$$So the string that is obtained by the given path is aaaa.The string obtained in the fourth test case is abaaba.",
    "prob_desc_description": "Your friend Salem is Warawreh's brother and only loves math and geometry problems. He has solved plenty of such problems, but according to Warawreh, in order to graduate from university he has to solve more graph problems. Since Salem is not good with graphs he asked your help with the following problem.  You are given a complete directed graph with $$$n$$$ vertices without self-loops. In other words, you have $$$n$$$ vertices and each pair of vertices $$$u$$$ and $$$v$$$ ($$$u \\neq v$$$) has both directed edges $$$(u, v)$$$ and $$$(v, u)$$$.Every directed edge of the graph is labeled with a single character: either 'a' or 'b' (edges $$$(u, v)$$$ and $$$(v, u)$$$ may have different labels).You are also given an integer $$$m &gt; 0$$$. You should find a path of length $$$m$$$ such that the string obtained by writing out edges' labels when going along the path is a palindrome. The length of the path is the number of edges in it.You can visit the same vertex and the same directed edge any number of times.",
    "prob_desc_output_spec": "For each test case, if it is possible to find such path, print \"YES\" and the path itself as a sequence of $$$m + 1$$$ integers: indices of vertices in the path in the appropriate order. If there are several valid paths, print any of them. Otherwise, (if there is no answer) print \"NO\".",
    "prob_desc_input_spec": "The first line contains a single integer $$$t$$$ ($$$1 \\le t \\le 500$$$) — the number of test cases. The first line of each test case contains two integers $$$n$$$ and $$$m$$$ ($$$2 \\leq n \\leq 1000$$$; $$$1 \\leq m \\leq 10^{5}$$$) — the number of vertices in the graph and desirable length of the palindrome. Each of the next $$$n$$$ lines contains $$$n$$$ characters. The $$$j$$$-th character of the $$$i$$$-th line describes the character on the edge that is going from node $$$i$$$ to node $$$j$$$. Every character is either 'a' or 'b' if $$$i \\neq j$$$, or '*' if $$$i = j$$$, since the graph doesn't contain self-loops. It's guaranteed that the sum of $$$n$$$ over test cases doesn't exceed $$$1000$$$ and the sum of $$$m$$$ doesn't exceed $$$10^5$$$.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3",
    "lang_cluster": "Python",
    "difficulty": 2000,
    "file_name": "train_107.jsonl",
    "code_uid": "8ef38d02bf9d86fa98934b694153b453",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"5\\n3 1\\n*ba\\nb*b\\nab*\\n3 3\\n*ba\\nb*b\\nab*\\n3 4\\n*ba\\nb*b\\nab*\\n4 6\\n*aaa\\nb*ba\\nab*a\\nbba*\\n2 6\\n*a\\nb*\"]",
    "exec_outcome": "PASSED",
    "source_code": "import sys\n\ndef read_ints():\n    return [int(i) for i in sys.stdin.readline().strip().split()]\n\ndef read_int():\n    return int(sys.stdin.readline().strip())\n\ndef check_and_output(lines, nodes):\n    route = [lines[int(i)-1][int(j)-1] for i, j in zip(nodes[:-1],\n        nodes[1:])]\n    in_reverse = list(reversed(route))\n    print(\"YES\")\n    print(\" \".join(nodes))\n    #print(\"\".join(route))\n    #assert \"*\" not in route, \"self loop in route \" + route\n    #assert route == in_reverse, \" \".join(route) + \" is not palindrome\"\n\n\ndef nodes_for_3graph(length, start, middle, end):\n    #print(\"start %s middle %s end %s\" % (start, middle, end))\n    return [(start if (d + length // 2) % 2 else middle) for d in range(length // 2 + 1)] + [(middle if d % 2 else end) for d in range(length // 2)]\n\ndef output_for_3graph(lines, length, start, middle, end):\n    nodes = nodes_for_3graph(length, start, middle, end)\n    check_and_output(lines, nodes)\n\ndef solve(n, length, lines):\n    #print(length, \"-\".join(lines))\n    if length % 2 == 1:\n        nodes = [(\"1\" if d % 2 else \"2\") for d in range(length + 1)]\n        check_and_output(lines, nodes)\n        return\n\n    for i in range(n):\n        for j in range(n):\n            if i != j and lines[i][j] == lines[j][i]:\n                nodes = [str(i + 1 if d % 2 else j + 1) for d in range(length + 1)]\n                check_and_output(lines, nodes)\n                return\n\n    if n == 2:\n        print(\"NO\")\n        return\n\n    if length == 2:\n        for i in range(n):\n            for j in range(n):\n                for k in range(n):\n                    if i != j and j != k and i != k:\n                        if lines[i][j] == lines[j][k]:\n                            nodes = [str(i + 1), str(j + 1), str(k + 1)]\n                            check_and_output(lines, nodes)\n                            return\n        print(\"NO\")\n        return\n\n    # consider only nodes 1, 2, 3\n    if lines[0][1] == lines[1][2] == lines[2][0]:\n        nodes = [str((d % 3) + 1) for d in range(length + 1)]\n        check_and_output(lines, nodes)\n        return\n\n    if lines[0][2] == lines[2][1] == lines[1][0]:\n        nodes = [str(3 - (d % 3)) for d in range(length + 1)]\n        check_and_output(lines, nodes)\n        return\n\n    # centre at node 0 (1)\n    if lines[0][1] == lines[2][0]:\n        output_for_3graph(lines, length, \"2\", \"1\", \"3\")\n        return\n\n    # centre at node 1 (2)\n    if lines[0][1] == lines[1][2]:\n        output_for_3graph(lines, length, \"1\", \"2\", \"3\")\n        return\n\n    # centre at node 2 (3)\n    if lines[0][2] == lines[2][1]:\n        output_for_3graph(lines, length, \"1\", \"3\", \"2\")\n        return\n\n\n\nncases = read_int()\nlines = []\n\n\"\"\"\nskip = False\nif ncases == 320:\n    n, length = read_ints()\n    skip = True\n    if length == 6:\n        for j in range(n):\n            lines.append(sys.stdin.readline().strip())\n\n        for i in range(53):\n            lines = []\n            n, length = read_ints()\n            for j in range(n):\n                lines.append(sys.stdin.readline().strip())\n        output = \"\";\n        for i in range(20):\n            output += sys.stdin.readline().strip() + \"----\"\n        print(output)\n        \"\"\"\n\nfor i in range(ncases):\n    lines = []\n    n, length = read_ints()\n    skip = False\n    for j in range(n):\n        lines.append(sys.stdin.readline().strip())\n    solve(n, length, lines)\n\n",
    "prob_desc_created_at": "1612535700",
    "tags": [
        "brute force",
        "constructive algorithms",
        "graphs",
        "greedy",
        "implementation"
    ],
    "hidden_unit_tests": ""
}
{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"5\\n3\\n12\\n46\"]",
    "src_uid": "e015574e9122016e67543de5ed8e547a",
    "prob_desc_notes": "NoteHere are the graphs for the four test cases of the example (the edges of a possible MST of the graphs are marked pink):For test case 1  For test case 2  For test case 3  For test case 4  ",
    "prob_desc_description": "You are given an array $$$a$$$ of $$$n$$$ ($$$n \\geq 2$$$) positive integers and an integer $$$p$$$. Consider an undirected weighted graph of $$$n$$$ vertices numbered from $$$1$$$ to $$$n$$$ for which the edges between the vertices $$$i$$$ and $$$j$$$ ($$$i&lt;j$$$) are added in the following manner:  If $$$gcd(a_i, a_{i+1}, a_{i+2}, \\dots, a_{j}) = min(a_i, a_{i+1}, a_{i+2}, \\dots, a_j)$$$, then there is an edge of weight $$$min(a_i, a_{i+1}, a_{i+2}, \\dots, a_j)$$$ between $$$i$$$ and $$$j$$$.  If $$$i+1=j$$$, then there is an edge of weight $$$p$$$ between $$$i$$$ and $$$j$$$. Here $$$gcd(x, y, \\ldots)$$$ denotes the greatest common divisor (GCD) of integers $$$x$$$, $$$y$$$, ....Note that there could be multiple edges between $$$i$$$ and $$$j$$$ if both of the above conditions are true, and if both the conditions fail for $$$i$$$ and $$$j$$$, then there is no edge between these vertices.The goal is to find the weight of the minimum spanning tree of this graph.",
    "prob_desc_output_spec": "Output $$$t$$$ lines. For each test case print the weight of the corresponding graph.",
    "prob_desc_input_spec": "The first line contains a single integer $$$t$$$ ($$$1 \\leq t \\leq 10^4$$$) — the number of test cases. The first line of each test case contains two integers $$$n$$$ ($$$2 \\leq n \\leq 2 \\cdot 10^5$$$) and $$$p$$$ ($$$1 \\leq p \\leq 10^9$$$) — the number of nodes and the parameter $$$p$$$. The second line contains $$$n$$$ integers $$$a_1, a_2, a_3, \\dots, a_n$$$ ($$$1 \\leq a_i \\leq 10^9$$$). It is guaranteed that the sum of $$$n$$$ over all test cases does not exceed $$$2 \\cdot 10^5$$$. ",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3-64",
    "lang_cluster": "Python",
    "difficulty": 2000,
    "file_name": "train_088.jsonl",
    "code_uid": "e653f15be50bd084bdea61e6bcc4e98c",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"4\\n2 5\\n10 10\\n2 5\\n3 3\\n4 5\\n5 2 4 9\\n8 8\\n5 3 3 6 10 100 9 15\"]",
    "exec_outcome": "PASSED",
    "source_code": "from operator import mod\r\nimport os,sys\r\nfrom random import randint, shuffle\r\nfrom io import BytesIO, IOBase\r\n\r\nfrom collections import defaultdict,deque,Counter\r\nfrom bisect import bisect_left,bisect_right\r\nfrom heapq import heappush,heappop\r\nfrom functools import lru_cache\r\nfrom itertools import accumulate, permutations\r\nimport math\r\n\r\n# Fast IO Region\r\nBUFSIZE = 8192\r\nclass FastIO(IOBase):\r\n    newlines = 0\r\n    def __init__(self, file):\r\n        self._fd = file.fileno()\r\n        self.buffer = BytesIO()\r\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\r\n        self.write = self.buffer.write if self.writable else None\r\n    def read(self):\r\n        while True:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            if not b:\r\n                break\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines = 0\r\n        return self.buffer.read()\r\n    def readline(self):\r\n        while self.newlines == 0:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            self.newlines = b.count(b\"\\n\") + (not b)\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines -= 1\r\n        return self.buffer.readline()\r\n    def flush(self):\r\n        if self.writable:\r\n            os.write(self._fd, self.buffer.getvalue())\r\n            self.buffer.truncate(0), self.buffer.seek(0)\r\nclass IOWrapper(IOBase):\r\n    def __init__(self, file):\r\n        self.buffer = FastIO(file)\r\n        self.flush = self.buffer.flush\r\n        self.writable = self.buffer.writable\r\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\r\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\r\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\r\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\r\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\r\n\r\n\r\n# for _ in range(int(input())):\r\n#     n = int(input())\r\n#     a = list(map(int, input().split()))\r\n\r\n# for _ in range(int(input())):\r\n#     n, k = list(map(int, input().split()))\r\n#     if k > (n - 1) // 2:\r\n#         print(-1)\r\n#     else:\r\n#         l, r = 1, n\r\n#         a = []\r\n#         for i in range(2 * k):\r\n#             if i % 2 == 0:\r\n#                 a.append(l)\r\n#                 l += 1\r\n#             else:\r\n#                 a.append(r)\r\n#                 r -= 1\r\n#         for i in range(r, l - 1, -1):\r\n#             a.append(i)\r\n#         print(*a)\r\n\r\n# for _ in range(int(input())):\r\n#     n = int(input())\r\n#     a = list(map(int, input().split()))\r\n#     x = a[0]\r\n#     for i in range(n):\r\n#         x &= a[i]\r\n#     cnt = 0\r\n#     for i in range(n):\r\n#         if a[i] == x:\r\n#             cnt += 1\r\n#     if cnt < 2:\r\n#         print(0)\r\n#     else:\r\n#         ans = cnt * (cnt - 1)\r\n#         mod = 10 ** 9 + 7\r\n#         for i in range(1, n - 1):\r\n#             ans = ans * i % mod\r\n#         print(ans)\r\n\r\n# mod = 10 ** 9 + 7\r\n# ans = [[0] * 200020 for _ in range(10)]\r\n# ans[0][0] = 1\r\n# for j in range(200019):\r\n#     for i in range(9):\r\n#         ans[i + 1][j + 1] = ans[i][j]\r\n#     ans[0][j + 1] = (ans[0][j + 1] + ans[9][j]) % mod\r\n#     ans[1][j + 1] = (ans[1][j + 1] + ans[9][j]) % mod\r\n\r\n# for _ in range(int(input())):\r\n#     n, m = list(map(int, input().split()))\r\n#     res = 0\r\n#     while n:\r\n#         x = n % 10\r\n#         for i in range(10):\r\n#             res += ans[i][m + x]\r\n#         n //= 10\r\n#     print(res % mod)\r\n    \r\nfor _ in range(int(input())):\r\n    n, p = list(map(int, input().split()))\r\n    a = list(map(int, input().split()))\r\n    id = [i for i in range(n)]\r\n    id.sort(key=lambda x : a[x])\r\n    vis = [0] * n\r\n    ans = p * (n - 1)\r\n    for i in range(n):\r\n        x = id[i]\r\n        if a[x] >= p: break\r\n        if vis[x] == 1: continue\r\n        vis[x] = 1\r\n        l = x - 1\r\n        r = x + 1\r\n        while r < n and a[r] % a[x] == 0 and vis[r] == 0:\r\n            vis[r] = 1\r\n            r += 1\r\n        while l >= 0 and a[l] % a[x] == 0 and vis[l] == 0:\r\n            vis[l] = 1\r\n            l -= 1\r\n        if r > x + 1:\r\n            vis[r - 1] = 0\r\n        if l < x - 1:\r\n            vis[l + 1] = 0\r\n        ans -= (r - l - 2) * (p - a[x])\r\n    print(ans)\r\n",
    "prob_desc_created_at": "1618151700",
    "tags": [
        "constructive algorithms",
        "dsu",
        "graphs",
        "greedy",
        "number theory",
        "sortings"
    ],
    "hidden_unit_tests": ""
}
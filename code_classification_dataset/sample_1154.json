{
    "prob_desc_time_limit": "3.5 seconds",
    "prob_desc_sample_outputs": "[\"5\\n25\\n10\\n15\\n36\\n21\"]",
    "src_uid": "42a116afb21e04625e174a7d17b9f60d",
    "prob_desc_notes": null,
    "prob_desc_description": "Polycarp plays a computer game (yet again). In this game, he fights monsters using magic spells.There are two types of spells: fire spell of power $$$x$$$ deals $$$x$$$ damage to the monster, and lightning spell of power $$$y$$$ deals $$$y$$$ damage to the monster and doubles the damage of the next spell Polycarp casts. Each spell can be cast only once per battle, but Polycarp can cast them in any order.For example, suppose that Polycarp knows three spells: a fire spell of power $$$5$$$, a lightning spell of power $$$1$$$, and a lightning spell of power $$$8$$$. There are $$$6$$$ ways to choose the order in which he casts the spells:  first, second, third. This order deals $$$5 + 1 + 2 \\cdot 8 = 22$$$ damage;  first, third, second. This order deals $$$5 + 8 + 2 \\cdot 1 = 15$$$ damage;  second, first, third. This order deals $$$1 + 2 \\cdot 5 + 8 = 19$$$ damage;  second, third, first. This order deals $$$1 + 2 \\cdot 8 + 2 \\cdot 5 = 27$$$ damage;  third, first, second. This order deals $$$8 + 2 \\cdot 5 + 1 = 19$$$ damage;  third, second, first. This order deals $$$8 + 2 \\cdot 1 + 2 \\cdot 5 = 20$$$ damage. Initially, Polycarp knows $$$0$$$ spells. His spell set changes $$$n$$$ times, each time he either learns a new spell or forgets an already known one. After each change, calculate the maximum possible damage Polycarp may deal using the spells he knows.",
    "prob_desc_output_spec": "After each change, print the maximum damage Polycarp can deal with his current set of spells.",
    "prob_desc_input_spec": "The first line contains one integer $$$n$$$ ($$$1 \\le n \\le 2 \\cdot 10^5$$$) — the number of changes to the spell set. Each of the next $$$n$$$ lines contains two integers $$$tp$$$ and $$$d$$$ ($$$0 \\le tp_i \\le 1$$$; $$$-10^9 \\le d \\le 10^9$$$; $$$d_i \\neq 0$$$) — the description of the change. If $$$tp_i$$$ if equal to $$$0$$$, then Polycarp learns (or forgets) a fire spell, otherwise he learns (or forgets) a lightning spell. If $$$d_i &gt; 0$$$, then Polycarp learns a spell of power $$$d_i$$$. Otherwise, Polycarp forgets a spell with power $$$-d_i$$$, and it is guaranteed that he knew that spell before the change. It is guaranteed that the powers of all spells Polycarp knows after each change are different (Polycarp never knows two spells with the same power).",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3",
    "lang_cluster": "Python",
    "difficulty": 2200,
    "file_name": "train_006.jsonl",
    "code_uid": "9303ca0956f738d90b69021704edba7a",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"6\\n1 5\\n0 10\\n1 -5\\n0 5\\n1 11\\n0 -10\"]",
    "exec_outcome": "PASSED",
    "source_code": "import sys, math\nimport io, os\n#data = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline\n#from bisect import bisect_left as bl, bisect_right as br, insort\n#from heapq import heapify, heappush, heappop\n#from collections import defaultdict as dd, deque, Counter\n#from itertools import permutations,combinations\ndef data(): return sys.stdin.buffer.readline().strip()\ndef mdata(): return list(map(int, data().split()))\ndef outl(var) : sys.stdout.write(' '.join(map(str, var))+'\\n')\ndef out(var) : sys.stdout.write(str(var)+'\\n')\n#sys.setrecursionlimit(100000)\n#INF = float('inf')\nmod = int(1e9)+7\n#from decimal import Decimal\n\n\nclass SortedList:\n    def __init__(self, iterable=[], _load=200):\n        \"\"\"Initialize sorted list instance.\"\"\"\n        values = sorted(iterable)\n        self._len = _len = len(values)\n        self._load = _load\n        self._lists = _lists = [values[i:i + _load] for i in range(0, _len, _load)]\n        self._list_lens = [len(_list) for _list in _lists]\n        self._mins = [_list[0] for _list in _lists]\n        self._fen_tree = []\n        self._rebuild = True\n\n    def _fen_build(self):\n        \"\"\"Build a fenwick tree instance.\"\"\"\n        self._fen_tree[:] = self._list_lens\n        _fen_tree = self._fen_tree\n        for i in range(len(_fen_tree)):\n            if i | i + 1 < len(_fen_tree):\n                _fen_tree[i | i + 1] += _fen_tree[i]\n        self._rebuild = False\n\n    def _fen_update(self, index, value):\n        \"\"\"Update `fen_tree[index] += value`.\"\"\"\n        if not self._rebuild:\n            _fen_tree = self._fen_tree\n            while index < len(_fen_tree):\n                _fen_tree[index] += value\n                index |= index + 1\n\n    def _fen_query(self, end):\n        \"\"\"Return `sum(_fen_tree[:end])`.\"\"\"\n        if self._rebuild:\n            self._fen_build()\n\n        _fen_tree = self._fen_tree\n        x = 0\n        while end:\n            x += _fen_tree[end - 1]\n            end &= end - 1\n        return x\n\n    def _fen_findkth(self, k):\n        \"\"\"Return a pair of (the largest `idx` such that `sum(_fen_tree[:idx]) <= k`, `k - sum(_fen_tree[:idx])`).\"\"\"\n        _list_lens = self._list_lens\n        if k < _list_lens[0]:\n            return 0, k\n        if k >= self._len - _list_lens[-1]:\n            return len(_list_lens) - 1, k + _list_lens[-1] - self._len\n        if self._rebuild:\n            self._fen_build()\n\n        _fen_tree = self._fen_tree\n        idx = -1\n        for d in reversed(range(len(_fen_tree).bit_length())):\n            right_idx = idx + (1 << d)\n            if right_idx < len(_fen_tree) and k >= _fen_tree[right_idx]:\n                idx = right_idx\n                k -= _fen_tree[idx]\n        return idx + 1, k\n\n    def _delete(self, pos, idx):\n        \"\"\"Delete value at the given `(pos, idx)`.\"\"\"\n        _lists = self._lists\n        _mins = self._mins\n        _list_lens = self._list_lens\n\n        self._len -= 1\n        self._fen_update(pos, -1)\n        del _lists[pos][idx]\n        _list_lens[pos] -= 1\n\n        if _list_lens[pos]:\n            _mins[pos] = _lists[pos][0]\n        else:\n            del _lists[pos]\n            del _list_lens[pos]\n            del _mins[pos]\n            self._rebuild = True\n\n    def _loc_left(self, value):\n        \"\"\"Return an index pair that corresponds to the first position of `value` in the sorted list.\"\"\"\n        if not self._len:\n            return 0, 0\n\n        _lists = self._lists\n        _mins = self._mins\n\n        lo, pos = -1, len(_lists) - 1\n        while lo + 1 < pos:\n            mi = (lo + pos) >> 1\n            if value <= _mins[mi]:\n                pos = mi\n            else:\n                lo = mi\n\n        if pos and value <= _lists[pos - 1][-1]:\n            pos -= 1\n\n        _list = _lists[pos]\n        lo, idx = -1, len(_list)\n        while lo + 1 < idx:\n            mi = (lo + idx) >> 1\n            if value <= _list[mi]:\n                idx = mi\n            else:\n                lo = mi\n\n        return pos, idx\n\n    def _loc_right(self, value):\n        \"\"\"Return an index pair that corresponds to the last position of `value` in the sorted list.\"\"\"\n        if not self._len:\n            return 0, 0\n\n        _lists = self._lists\n        _mins = self._mins\n\n        pos, hi = 0, len(_lists)\n        while pos + 1 < hi:\n            mi = (pos + hi) >> 1\n            if value < _mins[mi]:\n                hi = mi\n            else:\n                pos = mi\n\n        _list = _lists[pos]\n        lo, idx = -1, len(_list)\n        while lo + 1 < idx:\n            mi = (lo + idx) >> 1\n            if value < _list[mi]:\n                idx = mi\n            else:\n                lo = mi\n\n        return pos, idx\n\n    def add(self, value):\n        \"\"\"Add `value` to sorted list.\"\"\"\n        _load = self._load\n        _lists = self._lists\n        _mins = self._mins\n        _list_lens = self._list_lens\n\n        self._len += 1\n        if _lists:\n            pos, idx = self._loc_right(value)\n            self._fen_update(pos, 1)\n            _list = _lists[pos]\n            _list.insert(idx, value)\n            _list_lens[pos] += 1\n            _mins[pos] = _list[0]\n            if _load + _load < len(_list):\n                _lists.insert(pos + 1, _list[_load:])\n                _list_lens.insert(pos + 1, len(_list) - _load)\n                _mins.insert(pos + 1, _list[_load])\n                _list_lens[pos] = _load\n                del _list[_load:]\n                self._rebuild = True\n        else:\n            _lists.append([value])\n            _mins.append(value)\n            _list_lens.append(1)\n            self._rebuild = True\n\n    def discard(self, value):\n        \"\"\"Remove `value` from sorted list if it is a member.\"\"\"\n        _lists = self._lists\n        if _lists:\n            pos, idx = self._loc_right(value)\n            if idx and _lists[pos][idx - 1] == value:\n                self._delete(pos, idx - 1)\n\n    def remove(self, value):\n        \"\"\"Remove `value` from sorted list; `value` must be a member.\"\"\"\n        _len = self._len\n        self.discard(value)\n        if _len == self._len:\n            raise ValueError('{0!r} not in list'.format(value))\n\n    def pop(self, index=-1):\n        \"\"\"Remove and return value at `index` in sorted list.\"\"\"\n        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)\n        value = self._lists[pos][idx]\n        self._delete(pos, idx)\n        return value\n\n    def bisect_left(self, value):\n        \"\"\"Return the first index to insert `value` in the sorted list.\"\"\"\n        pos, idx = self._loc_left(value)\n        return self._fen_query(pos) + idx\n\n    def bisect_right(self, value):\n        \"\"\"Return the last index to insert `value` in the sorted list.\"\"\"\n        pos, idx = self._loc_right(value)\n        return self._fen_query(pos) + idx\n\n    def count(self, value):\n        \"\"\"Return number of occurrences of `value` in the sorted list.\"\"\"\n        return self.bisect_right(value) - self.bisect_left(value)\n\n    def __len__(self):\n        \"\"\"Return the size of the sorted list.\"\"\"\n        return self._len\n\n    def __getitem__(self, index):\n        \"\"\"Lookup value at `index` in sorted list.\"\"\"\n        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)\n        return self._lists[pos][idx]\n\n    def __delitem__(self, index):\n        \"\"\"Remove value at `index` from sorted list.\"\"\"\n        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)\n        self._delete(pos, idx)\n\n    def __contains__(self, value):\n        \"\"\"Return true if `value` is an element of the sorted list.\"\"\"\n        _lists = self._lists\n        if _lists:\n            pos, idx = self._loc_left(value)\n            return idx < len(_lists[pos]) and _lists[pos][idx] == value\n        return False\n\n    def __iter__(self):\n        \"\"\"Return an iterator over the sorted list.\"\"\"\n        return (value for _list in self._lists for value in _list)\n\n    def __reversed__(self):\n        \"\"\"Return a reverse iterator over the sorted list.\"\"\"\n        return (value for _list in reversed(self._lists) for value in reversed(_list))\n\n    def __repr__(self):\n        \"\"\"Return string representation of sorted list.\"\"\"\n        return 'SortedList({0})'.format(list(self))\n\ndef fix():\n    global sumL, cntL, sumDouble\n    while len(Double)<cntL:\n        temp=LF[-1]\n        Double.add(temp)\n        LF.remove(temp)\n        sumDouble+=temp\n    while len(Double)>cntL:\n        temp=Double[0]\n        Double.remove(temp)\n        LF.add(temp)\n        sumDouble-=temp\n    while Double and LF and Double[0]<LF[-1]:\n        temp1,temp2=Double[0],LF[-1]\n        LF.remove(temp2)\n        Double.remove(temp1)\n        LF.add(temp1)\n        Double.add(temp2)\n        sumDouble+=temp2-temp1\n    if sumDouble==sumL and cntL:\n        temp1=Double[0]\n        Double.remove(temp1)\n        if LF:\n            temp2=LF[-1]\n            LF.remove(temp2)\n            Double.add(temp2)\n            sumDouble+=temp2\n        LF.add(temp1)\n        sumDouble-=temp1\n\n\n\ndef add(tp,d):\n    global sumF,sumL, sumDouble, cntL\n    if not tp:\n        sumF+=d\n    else:\n        sumL+=d\n        cntL+=1\n    LF.add(d)\n\n\ndef remove(tp,d):\n    global sumF, sumL, sumDouble, cntL\n    if not tp:\n        sumF-=d\n    else:\n        sumL-=d\n        cntL-=1\n    if d in LF:\n        LF.remove(d)\n    else:\n        Double.remove(d)\n        sumDouble-=d\n\nn=int(data())\nsumL,sumF,sumDouble,cntL=0,0,0,0\nLF=SortedList()\nDouble=SortedList()\n\nfor _ in range(n):\n    tp,d=mdata()\n    if d<0:\n        remove(tp,-d)\n    else:\n        add(tp,d)\n    fix()\n    print(sumDouble+sumL+sumF)\n",
    "prob_desc_created_at": "1597415700",
    "tags": [
        "greedy",
        "math",
        "implementation",
        "sortings",
        "data structures",
        "binary search"
    ],
    "hidden_unit_tests": ""
}
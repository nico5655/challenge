{
    "prob_desc_time_limit": "4 seconds",
    "prob_desc_sample_outputs": "[\"YES\\nYES\\nNO\\nYES\\nNO\"]",
    "src_uid": "c53e3b38a345dcf65bf984e819c289ef",
    "prob_desc_notes": "NoteThe image below describes the tree (circles and solid lines) and the added edges for each query (dotted lines).  Possible paths for the queries with \"YES\" answers are:   $$$1$$$-st query: $$$1$$$ – $$$3$$$ – $$$2$$$  $$$2$$$-nd query: $$$1$$$ – $$$2$$$ – $$$3$$$  $$$4$$$-th query: $$$3$$$ – $$$4$$$ – $$$2$$$ – $$$3$$$ – $$$4$$$ – $$$2$$$ – $$$3$$$ – $$$4$$$ – $$$2$$$ – $$$3$$$ ",
    "prob_desc_description": "Gildong was hiking a mountain, walking by millions of trees. Inspired by them, he suddenly came up with an interesting idea for trees in data structures: What if we add another edge in a tree?Then he found that such tree-like graphs are called 1-trees. Since Gildong was bored of solving too many tree problems, he wanted to see if similar techniques in trees can be used in 1-trees as well. Instead of solving it by himself, he's going to test you by providing queries on 1-trees.First, he'll provide you a tree (not 1-tree) with $$$n$$$ vertices, then he will ask you $$$q$$$ queries. Each query contains $$$5$$$ integers: $$$x$$$, $$$y$$$, $$$a$$$, $$$b$$$, and $$$k$$$. This means you're asked to determine if there exists a path from vertex $$$a$$$ to $$$b$$$ that contains exactly $$$k$$$ edges after adding a bidirectional edge between vertices $$$x$$$ and $$$y$$$. A path can contain the same vertices and same edges multiple times. All queries are independent of each other; i.e. the added edge in a query is removed in the next query.",
    "prob_desc_output_spec": "For each query, print \"YES\" if there exists a path that contains exactly $$$k$$$ edges from vertex $$$a$$$ to $$$b$$$ after adding an edge between vertices $$$x$$$ and $$$y$$$. Otherwise, print \"NO\". You can print each letter in any case (upper or lower).",
    "prob_desc_input_spec": "The first line contains an integer $$$n$$$ ($$$3 \\le n \\le 10^5$$$), the number of vertices of the tree. Next $$$n-1$$$ lines contain two integers $$$u$$$ and $$$v$$$ ($$$1 \\le u,v \\le n$$$, $$$u \\ne v$$$) each, which means there is an edge between vertex $$$u$$$ and $$$v$$$. All edges are bidirectional and distinct. Next line contains an integer $$$q$$$ ($$$1 \\le q \\le 10^5$$$), the number of queries Gildong wants to ask. Next $$$q$$$ lines contain five integers $$$x$$$, $$$y$$$, $$$a$$$, $$$b$$$, and $$$k$$$ each ($$$1 \\le x,y,a,b \\le n$$$, $$$x \\ne y$$$, $$$1 \\le k \\le 10^9$$$) – the integers explained in the description. It is guaranteed that the edge between $$$x$$$ and $$$y$$$ does not exist in the original tree.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "Python 3",
    "lang_cluster": "Python",
    "difficulty": 2000,
    "file_name": "train_009.jsonl",
    "code_uid": "598575b1787c458d287272021f730065",
    "prob_desc_memory_limit": "512 megabytes",
    "prob_desc_sample_inputs": "[\"5\\n1 2\\n2 3\\n3 4\\n4 5\\n5\\n1 3 1 2 2\\n1 4 1 3 2\\n1 4 1 3 3\\n4 2 3 3 9\\n5 2 3 3 9\"]",
    "exec_outcome": "PASSED",
    "source_code": "import sys\n\n# LCA implementation found from:\n# https://github.com/cheran-senthil/PyRival/blob/1971590e96b351288cacb09852896f2383862ab6/pyrival/graphs/lca.py\nclass RangeQuery:\n    def __init__(self, data, func=min):\n        self.func = func\n        self._data = _data = [list(data)]\n        i, n = 1, len(_data[0])\n        while 2 * i <= n:\n            prev = _data[-1]\n            _data.append([func(prev[j], prev[j + i]) for j in range(n - 2 * i + 1)])\n            i <<= 1\n\n    def query(self, begin, end):\n        depth = (end - begin).bit_length() - 1\n        return self.func(\n            self._data[depth][begin], self._data[depth][end - (1 << depth)]\n        )\n\n\nclass LCA:\n    def __init__(self, root, graph):\n        self.time = [-1] * len(graph)\n        self.path = []\n        self.depth = [0] * len(graph)  # MODIFIED\n        dfs = [root]\n        while dfs:\n            node = dfs.pop()\n            self.path.append(node)\n            if self.time[node] == -1:\n                self.time[node] = len(self.path) - 1\n                for nei in graph[node]:\n                    if self.time[nei] == -1:\n                        self.depth[nei] = self.depth[node] + 1  # MODIFIED\n                        dfs.append(node)\n                        dfs.append(nei)\n        self.rmq = RangeQuery(self.time[node] for node in self.path)\n\n    def lca(self, a, b):\n        a = self.time[a]\n        b = self.time[b]\n        if a > b:\n            a, b = b, a\n        return self.path[self.rmq.query(a, b + 1)]\n\n\ndef solve(N, edges, queries):\n\n    graph = [[] for i in range(N + 1)]\n    for e in edges:\n        graph[e[0]].append(e[1])\n        graph[e[1]].append(e[0])\n\n    L = LCA(1, graph)\n\n    def lca(u, v):\n        return L.lca(u, v)\n\n    def getDist(u, v):\n        return L.depth[u] + L.depth[v] - 2 * L.depth[lca(u, v)]\n\n    ans = []\n    for x, y, a, b, k in queries:\n        d_ab = getDist(a, b)\n        d_axyb = getDist(a, x) + 1 + getDist(y, b)\n        d_ayxb = getDist(a, y) + 1 + getDist(x, b)\n        if any(d <= k and (k - d) % 2 == 0 for d in [d_ab, d_axyb, d_ayxb]):\n            ans.append(\"YES\")\n        else:\n            ans.append(\"NO\")\n    return \"\\n\".join(ans)\n\n\nif __name__ == \"__main__\":\n    N = int(input())\n    edges = []\n    for i in range(N - 1):\n        edges.append(list(map(int, sys.stdin.readline().split())))\n    Q = int(input())\n    queries = []\n    for i in range(Q):\n        queries.append(list(map(int, sys.stdin.readline().split())))\n    ans = solve(N, edges, queries)\n    print(ans)\n",
    "prob_desc_created_at": "1581771900",
    "tags": [
        "data structures",
        "dfs and similar",
        "trees",
        "shortest paths"
    ],
    "hidden_unit_tests": ""
}
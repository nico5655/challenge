{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"3\\n11\\n4\"]",
    "src_uid": "a4647cced2dc6adcb0b8abc24f2d7dce",
    "prob_desc_notes": "NoteIn the first test case one of the optimal sequences of operations is 01101 $$$\\rightarrow$$$ 0101 $$$\\rightarrow$$$ 011 $$$\\rightarrow$$$ 01. This sequence of operations consists of operations $$$2$$$, $$$3$$$ and $$$2$$$ in this order. It satisfies all rules and gives profit $$$3$$$. It can be shown that it is impossible to achieve higher profit in this test case, so the answer is $$$3$$$.In the second test case one of the optimal sequences of operations is 110001 $$$\\rightarrow$$$ 11001 $$$\\rightarrow$$$ 1001 $$$\\rightarrow$$$ 101.In the third test case one of the optimal sequences of operations is 011110 $$$\\rightarrow$$$ 01110 $$$\\rightarrow$$$ 1110 $$$\\rightarrow$$$ 110 $$$\\rightarrow$$$ 11 $$$\\rightarrow$$$ 1.",
    "prob_desc_description": "Dasha has $$$10^{100}$$$ coins. Recently, she found a binary string $$$s$$$ of length $$$n$$$ and some operations that allows to change this string (she can do each operation any number of times):  Replace substring 00 of $$$s$$$ by 0 and receive $$$a$$$ coins.  Replace substring 11 of $$$s$$$ by 1 and receive $$$b$$$ coins.  Remove 0 from any position in $$$s$$$ and pay $$$c$$$ coins. It turned out that while doing this operations Dasha should follow the rule:  It is forbidden to do two operations with the same parity in a row. Operations are numbered by integers $$$1$$$-$$$3$$$ in the order they are given above. Please, calculate what is the maximum profit Dasha can get by doing these operations and following this rule.",
    "prob_desc_output_spec": "For each test case print the answer.",
    "prob_desc_input_spec": "The first line contains a single integer $$$t$$$ ($$$1 \\leq t \\leq 10^4$$$) — the number of test cases. The first line of each test case contains four integers $$$n$$$, $$$a$$$, $$$b$$$, $$$c$$$ ($$$1 \\leq n \\leq 10^5, 1 \\leq a, b, c \\leq 10^9$$$). The second line of each test case contains a binary string $$$s$$$ of length $$$n$$$. It is guaranteed that the total sum of $$$n$$$ over all test cases doesn't exceed $$$2 \\cdot 10^5$$$.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3-64",
    "lang_cluster": "Python",
    "difficulty": 2700,
    "file_name": "train_092.jsonl",
    "code_uid": "f890fa486c521d3ae08d2e8d22a39d41",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"3\\n\\n5 2 2 1\\n\\n01101\\n\\n6 4 3 5\\n\\n110001\\n\\n6 3 2 1\\n\\n011110\"]",
    "exec_outcome": "PASSED",
    "source_code": "import sys\r\ninput = sys.stdin.readline\r\n\r\nout = []\r\nssl = []\r\nt = int(input())\r\nfor _ in range(t):\r\n    n,a,b,c = map(int,input().split())\r\n    s = input().strip()\r\n\r\n    ssl.append(s)\r\n\r\n    #if ssl[0] == '1111' and _ == 5099:\r\n    #    print(n,a,b,c,s)\r\n\r\n    z = [0]\r\n    zc = 0\r\n    oc = 0\r\n    for ch in s:\r\n        if ch == '0':\r\n            z[-1] += 1\r\n            zc += 1\r\n        else:\r\n            z.append(0)\r\n            oc += 1\r\n\r\n    M1 = sum(max(0, v - 1) for v in z)\r\n    \r\n    if len(z) == 1:\r\n        out.append(a if n>=2 else 0)\r\n        continue\r\n    \r\n\r\n    l = z.pop(0)\r\n    r = z.pop()\r\n\r\n    poss = [0]\r\n\r\n    #StartOdd\r\n    zz = sorted(z)[::-1]\r\n    curr = 0\r\n    L1 = M1\r\n    L2 = 0\r\n    Z1 = 0\r\n    OL = oc\r\n    ZL = zc\r\n    while zz and zz[-1] == 0:\r\n        zz.pop()\r\n        L2 += 1\r\n\r\n    while zz and zz[-1] == 1:\r\n        zz.pop()\r\n        Z1 += 1\r\n    while True:\r\n        if ZL == 0:\r\n            break\r\n        \r\n        if L1 > 0:\r\n            poss.append(curr + a)\r\n\r\n        if OL <= 1:\r\n            break\r\n\r\n        if L2 > 0:\r\n            if L1 > 0:\r\n                curr += a\r\n                ZL -= 1\r\n                L1 -= 1\r\n                if zz:\r\n                    zz[-1] -= 1\r\n                    if zz[-1] == 1:\r\n                        zz.pop()\r\n                        Z1 += 1\r\n                \r\n                curr += b\r\n                L2 -= 1\r\n                OL -= 1\r\n            else:\r\n                curr -= c\r\n                ZL -= 1\r\n\r\n                curr += b\r\n                OL -= 1\r\n        else:\r\n            ZL -= 1\r\n\r\n            if Z1 == 0:\r\n                break\r\n            \r\n            Z1 -= 1\r\n            curr -= c\r\n\r\n\r\n            OL -= 1\r\n            curr += b\r\n\r\n            \r\n\r\n            \r\n\r\n        poss.append(curr)\r\n\r\n    #StartEven\r\n    zz = sorted(z)[::-1]\r\n    curr = 0\r\n    L1 = M1\r\n    L2 = 0\r\n    Z1 = 0\r\n    OL = oc\r\n    ZL = zc\r\n    while zz and zz[-1] == 0:\r\n        zz.pop()\r\n        L2 += 1\r\n\r\n    while zz and zz[-1] == 1:\r\n        zz.pop()\r\n        Z1 += 1\r\n\r\n    #print(L2)\r\n    good = False\r\n\r\n    if L2:\r\n        OL -= 1\r\n        L2 -= 1\r\n        curr = b\r\n        poss.append(b)\r\n        good = True\r\n\r\n    while good:\r\n        #print(curr,L1,L2,Z1,OL,ZL,poss)\r\n\r\n        if ZL == 0:\r\n            break\r\n        \r\n        if L1 > 0:\r\n            poss.append(curr + a)\r\n\r\n        if OL <= 1:\r\n            break\r\n\r\n        if L2 > 0:\r\n            if L1 > 0:\r\n                curr += a\r\n                ZL -= 1\r\n                L1 -= 1\r\n                if zz:\r\n                    zz[-1] -= 1\r\n                    if zz[-1] == 1:\r\n                        zz.pop()\r\n                        Z1 += 1\r\n                \r\n                curr += b\r\n                L2 -= 1\r\n                OL -= 1\r\n            else:\r\n                curr -= c\r\n                ZL -= 1\r\n\r\n                curr += b\r\n                OL -= 1\r\n        else:\r\n            ZL -= 1\r\n\r\n            if Z1 == 0:\r\n                break\r\n            \r\n            Z1 -= 1\r\n            curr -= c\r\n            \r\n            OL -= 1\r\n            curr += b            \r\n\r\n        poss.append(curr)\r\n                \r\n    #print()\r\n    out.append(max(poss))\r\nprint('\\n'.join(map(str,out)))\r\n",
    "prob_desc_created_at": "1641220500",
    "tags": [
        "data structures",
        "greedy",
        "implementation"
    ],
    "hidden_unit_tests": ""
}
{
    "prob_desc_time_limit": "1 second",
    "prob_desc_sample_outputs": "[\"2\\n0\\n7\\n5\"]",
    "src_uid": "8bbec86e427e26158393bbfbf1a067fe",
    "prob_desc_notes": "NoteIn the first test case Polycarp can earn two emeralds as follows: craft one sword and one shovel.In the second test case Polycarp does not have any diamonds, so he cannot craft anything.",
    "prob_desc_description": "Polycarp plays a well-known computer game (we won't mention its name). In this game, he can craft tools of two types — shovels and swords. To craft a shovel, Polycarp spends two sticks and one diamond; to craft a sword, Polycarp spends two diamonds and one stick.Each tool can be sold for exactly one emerald. How many emeralds can Polycarp earn, if he has $$$a$$$ sticks and $$$b$$$ diamonds?",
    "prob_desc_output_spec": "For each test case print one integer — the maximum number of emeralds Polycarp can earn.",
    "prob_desc_input_spec": "The first line contains one integer $$$t$$$ ($$$1 \\le t \\le 1000$$$) — the number of test cases. The only line of each test case contains two integers $$$a$$$ and $$$b$$$ ($$$0 \\le a, b \\le 10^9$$$) — the number of sticks and the number of diamonds, respectively.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3",
    "lang_cluster": "Python",
    "difficulty": 1100,
    "file_name": "train_002.jsonl",
    "code_uid": "7938ffd7e31965e5f74eed446125bec1",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"4\\n4 4\\n1000000000 0\\n7 15\\n8 7\"]",
    "exec_outcome": "PASSED",
    "source_code": "#------------------------------what is this I don't know....just makes my mess faster--------------------------------------\nimport os\nimport sys\nfrom io import BytesIO, IOBase\n \nBUFSIZE = 8192\n \nclass FastIO(IOBase):\n\tnewlines = 0\n \n\tdef __init__(self, file):\n\t\tself._fd = file.fileno()\n\t\tself.buffer = BytesIO()\n\t\tself.writable = \"x\" in file.mode or \"r\" not in file.mode\n\t\tself.write = self.buffer.write if self.writable else None\n \n\tdef read(self):\n\t\twhile True:\n\t\t\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n\t\t\tif not b:\n\t\t\t\tbreak\n\t\t\tptr = self.buffer.tell()\n\t\t\tself.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n\t\tself.newlines = 0\n\t\treturn self.buffer.read()\n \n\tdef readline(self):\n\t\twhile self.newlines == 0:\n\t\t\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n\t\t\tself.newlines = b.count(b\"\\n\") + (not b)\n\t\t\tptr = self.buffer.tell()\n\t\t\tself.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n\t\tself.newlines -= 1\n\t\treturn self.buffer.readline()\n \n\tdef flush(self):\n\t\tif self.writable:\n\t\t\tos.write(self._fd, self.buffer.getvalue())\n\t\t\tself.buffer.truncate(0), self.buffer.seek(0)\n \n \nclass IOWrapper(IOBase):\n\tdef __init__(self, file):\n\t\tself.buffer = FastIO(file)\n\t\tself.flush = self.buffer.flush\n\t\tself.writable = self.buffer.writable\n\t\tself.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n\t\tself.read = lambda: self.buffer.read().decode(\"ascii\")\n\t\tself.readline = lambda: self.buffer.readline().decode(\"ascii\")\n \n \nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n \n#----------------------------------Real game starts here--------------------------------------\n\n#_______________________________________________________________#\ndef fact(x):\n\tif x == 0:\n\t\treturn 1\n\telse:\n\t\treturn x * fact(x-1)\ndef lower_bound(li, num): #return 0 if all are greater or equal to\n\tanswer = -1 \n\tstart = 0\n\tend = len(li)-1\n\n\twhile(start <= end):\n\t\tmiddle = (end+start)//2\n\t\tif li[middle] >= num:\n\t\t\tanswer = middle\n\t\t\tend = middle - 1\n\t\telse:\n\t\t\tstart = middle + 1\n\treturn answer #index where x is not less than num\ndef upper_bound(li, num): #return n-1 if all are small or equal\n\tanswer = -1\n\tstart = 0\n\tend = len(li)-1\n\n\twhile(start <= end):\n\t\tmiddle = (end+start)//2\n\n\t\tif li[middle] <= num:\n\t\t\tanswer = middle\n\t\t\tstart = middle + 1\n\t\t\n\t\telse:\n\t\t\tend = middle - 1\n\treturn answer #index where x is not greater than num\n\ndef abs(x):\n\treturn x if x >=0 else -x\ndef binary_search(li, val, lb, ub):\n\tans = 0\n\twhile(lb <= ub):\n\t\tmid = (lb+ub)//2\n\t\t#print(mid, li[mid])\n\t\tif li[mid] > val:\n\t\t\tub = mid-1\n\t\telif val > li[mid]:\n\t\t\tlb = mid + 1\n\t\telse:\n\t\t\tans = 1\n\t\t\tbreak\n\treturn ans\n\ndef sieve_of_eratosthenes(n):\n\tans = []\n\tarr = [1]*(n+1)\n\tarr[0],arr[1], i = 0, 0, 2\n\twhile(i*i <= n):\n\t\tif arr[i] == 1:\n\t\t\tj = i+i\n\t\t\twhile(j <= n):\n\t\t\t\tarr[j] = 0\n\t\t\t\tj += i\n\t\ti += 1\n\tfor k in range(n):\n\t\tif arr[k] == 1:\n\t\t\tans.append(k)\n\treturn ans\ndef nc2(x):\n\tif x == 1:\n\t\treturn 0\n\telse:\n\t\treturn x*(x-1)//2\n#_______________________________________________________________#\n'''\n      ▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\n   ▄███████▀▀▀▀▀▀███████▄\n░▐████▀▒▒Aestroix▒▒▀██████\n░███▀▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▀████\n░▐██▒▒▒▒▒KARMANYA▒▒▒▒▒▒████▌         ________________\n░▐█▌▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒████▌  ? ?   |▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒|\n░░█▒▒▄▀▀▀▀▀▄▒▒▄▀▀▀▀▀▄▒▒▐███▌   ?    |___CM ONE DAY___|\n░░░▐░░░▄▄░░▌▐░░░▄▄░░▌▒▐███▌     ? ? |▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒|\n░▄▀▌░░░▀▀░░▌▐░░░▀▀░░▌▒▀▒█▌    ? ?    \n░▌▒▀▄░░░░▄▀▒▒▀▄░░░▄▀▒▒▄▀▒▌      ? \n░▀▄▐▒▀▀▀▀▒▒▒▒▒▒▀▀▀▒▒▒▒▒▒█     ? ? \n░░░▀▌▒▄██▄▄▄▄████▄▒▒▒▒█▀       ? \n░░░░▄█████████ ████=========█▒▒▐▌\n░░░▀███▀▀████▀█████▀▒▌\n░░░░░▌▒▒▒▄▒▒▒▄▒▒▒▒▒▒▐\n░░░░░▌▒▒▒▒▀▀▀▒▒▒▒▒▒▒▐\n░░░░░████████████████\n'''\n\nfor _ in range(int(input()) if True else 1):\n\to, z = map(int, input().split())\n\tprint(min(o, z, (o+z)//3))\n\n\n\n\n\t\n\n\n\n\n\n",
    "prob_desc_created_at": "1591886100",
    "tags": [
        "binary search",
        "greedy",
        "math"
    ],
    "hidden_unit_tests": ""
}
{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"4\", \"3\", \"2\"]",
    "src_uid": "0859ea756740bfa67b35fadfb194257e",
    "prob_desc_notes": null,
    "prob_desc_description": "You are given a permutation $$$p_1, p_2, \\dots , p_n$$$ (an array where each integer from $$$1$$$ to $$$n$$$ appears exactly once). The weight of the $$$i$$$-th element of this permutation is $$$a_i$$$.At first, you separate your permutation into two non-empty sets — prefix and suffix. More formally, the first set contains elements $$$p_1, p_2, \\dots , p_k$$$, the second — $$$p_{k+1}, p_{k+2}, \\dots , p_n$$$, where $$$1 \\le k &lt; n$$$.After that, you may move elements between sets. The operation you are allowed to do is to choose some element of the first set and move it to the second set, or vice versa (move from the second set to the first). You have to pay $$$a_i$$$ dollars to move the element $$$p_i$$$.Your goal is to make it so that each element of the first set is less than each element of the second set. Note that if one of the sets is empty, this condition is met.For example, if $$$p = [3, 1, 2]$$$ and $$$a = [7, 1, 4]$$$, then the optimal strategy is: separate $$$p$$$ into two parts $$$[3, 1]$$$ and $$$[2]$$$ and then move the $$$2$$$-element into first set (it costs $$$4$$$). And if $$$p = [3, 5, 1, 6, 2, 4]$$$, $$$a = [9, 1, 9, 9, 1, 9]$$$, then the optimal strategy is: separate $$$p$$$ into two parts $$$[3, 5, 1]$$$ and $$$[6, 2, 4]$$$, and then move the $$$2$$$-element into first set (it costs $$$1$$$), and $$$5$$$-element into second set (it also costs $$$1$$$).Calculate the minimum number of dollars you have to spend.",
    "prob_desc_output_spec": "Print one integer — the minimum number of dollars you have to spend.",
    "prob_desc_input_spec": "The first line contains one integer $$$n$$$ ($$$2 \\le n \\le 2 \\cdot 10^5$$$) — the length of permutation. The second line contains $$$n$$$ integers $$$p_1, p_2, \\dots , p_n$$$ ($$$1 \\le p_i \\le n$$$). It's guaranteed that this sequence contains each element from $$$1$$$ to $$$n$$$ exactly once. The third line contains $$$n$$$ integers $$$a_1, a_2, \\dots , a_n$$$ ($$$1 \\le a_i \\le 10^9$$$).",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 2",
    "lang_cluster": "Python",
    "difficulty": 2200,
    "file_name": "train_008.jsonl",
    "code_uid": "b56e8d45a0d5bc2f458ae5844c9ef5df",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"3\\n3 1 2\\n7 1 4\", \"4\\n2 4 1 3\\n5 9 8 3\", \"6\\n3 5 1 6 2 4\\n9 1 9 9 1 9\"]",
    "exec_outcome": "PASSED",
    "source_code": "import sys\nrange = xrange\ninput = raw_input\n\nclass LazySegmentTree:\n    def __init__(self, data, default=-float('inf'), func=max):\n        \"\"\"initialize the lazy segment tree with data\"\"\"\n        self._default = default\n        self._func = func\n\n        self._len = len(data)\n        self._size = _size = 1 << (self._len - 1).bit_length()\n        self._lazy = [0.0] * (2 * _size)\n\n        self.data = [default] * (2 * _size)\n        self.data[_size:_size + self._len] = data\n        for i in reversed(range(_size)):\n            self.data[i] = func(self.data[i + i], self.data[i + i + 1])\n\n    def __len__(self):\n        return self._len\n\n    def _push(self, idx):\n        \"\"\"push query on idx to its children\"\"\"\n        # Let the children know of the queries\n        q, self._lazy[idx] = self._lazy[idx], 0.0\n\n        self._lazy[2 * idx] += q\n        self._lazy[2 * idx + 1] += q\n        self.data[2 * idx] += q\n        self.data[2 * idx + 1] += q\n\n    def _update(self, idx):\n        \"\"\"updates the node idx to know of all queries applied to it via its ancestors\"\"\"\n        for i in reversed(range(1, idx.bit_length())):\n            self._push(idx >> i)\n\n    def _build(self, idx):\n        \"\"\"make the changes to idx be known to its ancestors\"\"\"\n        idx >>= 1\n        while idx:\n            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1]) + self._lazy[idx]\n            idx >>= 1\n\n    def add(self, start, stop, value):\n        \"\"\"lazily add value to [start, stop)\"\"\"\n        if start >= stop: return\n\n        start = start_copy = start + self._size\n        stop = stop_copy = stop + self._size\n        while start < stop:\n            if start & 1:\n                self._lazy[start] += value\n                self.data[start] += value\n                start += 1\n            if stop & 1:\n                stop -= 1\n                self._lazy[stop] += value\n                self.data[stop] += value\n            start >>= 1\n            stop >>= 1\n\n        # Tell all nodes above of the updated area of the updates\n        self._build(start_copy)\n        self._build(stop_copy - 1)\n\n    def query(self, start, stop, default=-float('inf')):\n        \"\"\"func of data[start, stop)\"\"\"\n        start += self._size\n        stop += self._size\n\n        # Apply all the lazily stored queries\n        self._update(start)\n        self._update(stop - 1)\n\n        res = default\n        while start < stop:\n            if start & 1:\n                res = self._func(res, self.data[start])\n                start += 1\n            if stop & 1:\n                stop -= 1\n                res = self._func(res, self.data[stop])\n            start >>= 1\n            stop >>= 1\n        return res\n\n\ninp = [int(x) for x in sys.stdin.read().split()]; ii = 0\n\nn = inp[ii]; ii += 1\nP = [p - 1 for p in inp[ii: ii + n]]; ii += n\nA = inp[ii: ii + n]; ii += n\norder = [0]*n\nfor i in range(n):\n    order[P[i]] = i\n\nbest = A[0]\n\ntmp = [0.0]*(n - 1)\ncumval = 0.0\nfor i in range(n - 1):\n    cumval += A[i]\n    tmp[i] = -cumval\n\nsplitter = LazySegmentTree(tmp)\nbase = 0.0\n\nfor k in range(n):\n    i = order[k]\n    a = A[i]\n    base += a\n    splitter.add(i, n - 1, 2 * a + 0.0)\n    mini = -splitter.query(0, n - 1) + base \n    if mini < best:\n        best = mini\nprint int(best)\n",
    "prob_desc_created_at": "1580308500",
    "tags": [
        "data structures",
        "divide and conquer"
    ],
    "hidden_unit_tests": ""
}
{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"13\", \"4\", \"49152\", \"981727503\"]",
    "src_uid": "915c26f2bc1005d70cc8cc74ce40b9fa",
    "prob_desc_notes": "NoteThe following arrays satisfy the conditions for the first sample:  $$$[1, 0, 0]$$$;  $$$[0, 1, 0]$$$;  $$$[3, 2, 0]$$$;  $$$[2, 3, 0]$$$;  $$$[0, 0, 1]$$$;  $$$[1, 1, 1]$$$;  $$$[2, 2, 1]$$$;  $$$[3, 0, 2]$$$;  $$$[2, 1, 2]$$$;  $$$[1, 2, 2]$$$;  $$$[0, 3, 2]$$$;  $$$[2, 0, 3]$$$;  $$$[0, 2, 3]$$$. The following arrays satisfy the conditions for the second sample:  $$$[2, 0, 0, 0]$$$;  $$$[0, 2, 0, 0]$$$;  $$$[0, 0, 2, 0]$$$;  $$$[0, 0, 0, 2]$$$. ",
    "prob_desc_description": "During their training for the ICPC competitions, team \"Jee You See\" stumbled upon a very basic counting problem. After many \"Wrong answer\" verdicts, they finally decided to give up and destroy turn-off the PC. Now they want your help in up-solving the problem.You are given 4 integers $$$n$$$, $$$l$$$, $$$r$$$, and $$$z$$$. Count the number of arrays $$$a$$$ of length $$$n$$$ containing non-negative integers such that:  $$$l\\le a_1+a_2+\\ldots+a_n\\le r$$$, and  $$$a_1\\oplus a_2 \\oplus \\ldots\\oplus a_n=z$$$, where $$$\\oplus$$$ denotes the bitwise XOR operation. Since the answer can be large, print it modulo $$$10^9+7$$$.",
    "prob_desc_output_spec": "Print the number of arrays $$$a$$$ satisfying all requirements modulo $$$10^9+7$$$.",
    "prob_desc_input_spec": "The only line contains four integers $$$n$$$, $$$l$$$, $$$r$$$, $$$z$$$ ($$$1 \\le n \\le 1000$$$, $$$1\\le l\\le r\\le 10^{18}$$$, $$$1\\le z\\le 10^{18}$$$).",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3-64",
    "lang_cluster": "Python",
    "difficulty": 2400,
    "file_name": "train_100.jsonl",
    "code_uid": "cd19a4b7f72d97b7e8ea4688a7877f44",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"3 1 5 1\", \"4 1 3 2\", \"2 1 100000 15629\", \"100 56 89 66\"]",
    "exec_outcome": "PASSED",
    "source_code": "import sys\r\nsys.setrecursionlimit(2000)\r\n\r\n\r\n\r\n# ---------------------------------------- fast io ----------------------------------------\r\nimport os, sys\r\nfrom io import BytesIO, IOBase\r\n\r\nBUFSIZE = 8192\r\n\r\n\r\nclass FastIO(IOBase):\r\n    newlines = 0\r\n\r\n    def __init__(self, file):\r\n        self._fd = file.fileno()\r\n        self.buffer = BytesIO()\r\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\r\n        self.write = self.buffer.write if self.writable else None\r\n\r\n    def read(self):\r\n        while True:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            if not b:\r\n                break\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines = 0\r\n        return self.buffer.read()\r\n\r\n    def readline(self):\r\n        while self.newlines == 0:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            self.newlines = b.count(b\"\\n\") + (not b)\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines -= 1\r\n        return self.buffer.readline()\r\n\r\n    def flush(self):\r\n        if self.writable:\r\n            os.write(self._fd, self.buffer.getvalue())\r\n            self.buffer.truncate(0), self.buffer.seek(0)\r\n\r\n\r\nclass IOWrapper(IOBase):\r\n    def __init__(self, file):\r\n        self.buffer = FastIO(file)\r\n        self.flush = self.buffer.flush\r\n        self.writable = self.buffer.writable\r\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\r\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\r\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\r\n\r\n\r\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\r\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\r\n# ---------------------------------------- fast io ----------------------------------------\r\n\r\n\r\n\r\n\r\nmod = 10 ** 9 + 7\r\ncomb = [[-1] * (1001) for _ in range(1001)]\r\n\r\n\r\ndef nCi(n, i):\r\n    if i == 0:\r\n        comb[n][i] = 1\r\n        return 1\r\n    if n == 0:\r\n        comb[n][i] = 0\r\n        return 0\r\n    if comb[n][i] != -1:\r\n        return comb[n][i]\r\n\r\n    comb[n][i] = (nCi(n - 1, i) + nCi(n - 1, i - 1)) % mod\r\n    return comb[n][i]\r\n\r\nfor i in range(1001):\r\n    nCi(1000,i)\r\n\r\ndef compute(x):\r\n    f = [[-1 for _ in range(2001)] for _ in range(61)]\r\n\r\n    def dfs(idx, k, r):\r\n        if k > 2000:\r\n            k = 2000\r\n        if k < 0:\r\n            return 0\r\n        if idx == -1:\r\n            return 1\r\n\r\n        if f[idx][k] != -1:\r\n            return f[idx][k]\r\n\r\n        ans = 0\r\n        cb = int((z & (1 << idx)) > 0)\r\n        for i in range(cb, n + 1, 2):\r\n            bcb = int((r & (1 << idx)) > 0)\r\n\r\n            ans += nCi(n,i) * dfs(idx - 1, 2 * (k - i + bcb), r)\r\n            ans %= mod\r\n\r\n        f[idx][k] = ans\r\n        return f[idx][k]\r\n\r\n    res = dfs(60, 0, x)\r\n    return res\r\n\r\n\r\n\r\nn,l,r,z=[int(x) for x in input().split()]\r\nans = (compute(r) - compute(l - 1) + mod) % mod\r\nprint(ans)\r\n",
    "prob_desc_created_at": "1651847700",
    "tags": [
        "bitmasks",
        "combinatorics",
        "dp"
    ],
    "hidden_unit_tests": ""
}
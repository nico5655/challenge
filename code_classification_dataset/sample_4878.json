{
    "prob_desc_time_limit": "1 second",
    "prob_desc_sample_outputs": "[\"AC\\nAC\\nWA\\nWA\"]",
    "src_uid": "a8f7f64db8fdf42294909774884bec96",
    "prob_desc_notes": "NoteIn the first test case, the array $$$[1,2]$$$ has sadness $$$1$$$. We can transform $$$[1,2]$$$ into $$$[2,1]$$$ using one operation with $$$(i,j)=(1,2)$$$.In the second test case, the array $$$[3,3,2,1]$$$ has sadness $$$2$$$. We can transform $$$[3,3,2,1]$$$ into $$$[1,2,3,3]$$$ with two operations with $$$(i,j)=(1,4)$$$ and $$$(i,j)=(2,3)$$$ respectively.In the third test case, the array $$$[2,1]$$$ has sadness $$$0$$$.In the fourth test case, the array $$$[3,2,3,1]$$$ has sadness $$$1$$$.",
    "prob_desc_description": "oolimry has an array $$$a$$$ of length $$$n$$$ which he really likes. Today, you have changed his array to $$$b$$$, a permutation of $$$a$$$, to make him sad.Because oolimry is only a duck, he can only perform the following operation to restore his array:   Choose two integers $$$i,j$$$ such that $$$1 \\leq i,j \\leq n$$$.  Swap $$$b_i$$$ and $$$b_j$$$. The sadness of the array $$$b$$$ is the minimum number of operations needed to transform $$$b$$$ into $$$a$$$.Given the arrays $$$a$$$ and $$$b$$$, where $$$b$$$ is a permutation of $$$a$$$, determine if $$$b$$$ has the maximum sadness over all permutations of $$$a$$$.",
    "prob_desc_output_spec": "For each test case, print \"AC\" (without quotes) if $$$b$$$ has the maximum sadness over all permutations of $$$a$$$, and \"WA\" (without quotes) otherwise.",
    "prob_desc_input_spec": "Each test contains multiple test cases. The first line contains a single integer $$$t$$$ ($$$1 \\leq t \\leq 10^4$$$)  — the number of test cases. The description of the test cases follows. The first line of each test case contains a single integer $$$n$$$ ($$$1 \\leq n \\leq 2 \\cdot 10^5$$$)  — the length of the array. The second line of each test case contains $$$n$$$ integers $$$a_1, a_2, \\ldots, a_n$$$ ($$$1 \\leq a_i \\leq n$$$)  — the elements of the array $$$a$$$. The third line of each test case contains $$$n$$$ integers $$$b_1, b_2, \\ldots, b_n$$$ ($$$1 \\leq b_i \\leq n$$$)  — the elements of the array $$$b$$$. It is guaranteed that $$$b$$$ is a permutation of $$$a$$$. It is guaranteed that the sum of $$$n$$$ over all test cases does not exceed $$$2 \\cdot 10^5$$$.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3-64",
    "lang_cluster": "Python",
    "difficulty": 2800,
    "file_name": "train_108.jsonl",
    "code_uid": "cc1315a6d63f0c16e0bd6875074e3816",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"4\\n\\n2\\n\\n2 1\\n\\n1 2\\n\\n4\\n\\n1 2 3 3\\n\\n3 3 2 1\\n\\n2\\n\\n2 1\\n\\n2 1\\n\\n4\\n\\n1 2 3 3\\n\\n3 2 3 1\"]",
    "exec_outcome": "PASSED",
    "source_code": "\r\ndef divisors(M):\r\n    d=[]\r\n    i=1\r\n    while M>=i**2:\r\n        if M%i==0:\r\n            d.append(i)\r\n            if i**2!=M:\r\n                d.append(M//i)\r\n        i=i+1\r\n    return d\r\n\r\ndef popcount(x):\r\n    x = x - ((x >> 1) & 0x55555555)\r\n    x = (x & 0x33333333) + ((x >> 2) & 0x33333333)\r\n    x = (x + (x >> 4)) & 0x0f0f0f0f\r\n    x = x + (x >> 8)\r\n    x = x + (x >> 16)\r\n    return x & 0x0000007f\r\n\r\ndef eratosthenes(n):\r\n    res=[0 for i in range(n+1)]\r\n    prime=set([])\r\n    for i in range(2,n+1):\r\n        if not res[i]:\r\n            prime.add(i)\r\n            for j in range(1,n//i+1):\r\n                res[i*j]=1\r\n    return prime\r\n\r\ndef factorization(n):\r\n    res=[]\r\n    for p in prime:\r\n        if n%p==0:\r\n            while n%p==0:\r\n                n//=p\r\n            res.append(p)\r\n    if n!=1:\r\n        res.append(n)\r\n    return res\r\n\r\ndef euler_phi(n):\r\n    res = n\r\n    for x in range(2,n+1):\r\n        if x ** 2 > n:\r\n            break\r\n        if n%x==0:\r\n            res = res//x * (x-1)\r\n            while n%x==0:\r\n                n //= x\r\n    if n!=1:\r\n        res = res//n * (n-1)\r\n    return res\r\n\r\ndef ind(b,n):\r\n    res=0\r\n    while n%b==0:\r\n        res+=1\r\n        n//=b\r\n    return res\r\n\r\ndef isPrimeMR(n):\r\n    d = n - 1\r\n    d = d // (d & -d)\r\n    L = [2, 3, 5, 7, 11, 13, 17]\r\n    for a in L:\r\n        t = d\r\n        y = pow(a, t, n)\r\n        if y == 1: continue\r\n        while y != n - 1:\r\n            y = (y * y) % n\r\n            if y == 1 or t == n - 1: return 0\r\n            t <<= 1\r\n    return 1\r\ndef findFactorRho(n):\r\n    from math import gcd\r\n    m = 1 << n.bit_length() // 8\r\n    for c in range(1, 99):\r\n        f = lambda x: (x * x + c) % n\r\n        y, r, q, g = 2, 1, 1, 1\r\n        while g == 1:\r\n            x = y\r\n            for i in range(r):\r\n                y = f(y)\r\n            k = 0\r\n            while k < r and g == 1:\r\n                ys = y\r\n                for i in range(min(m, r - k)):\r\n                    y = f(y)\r\n                    q = q * abs(x - y) % n\r\n                g = gcd(q, n)\r\n                k += m\r\n            r <<= 1\r\n        if g == n:\r\n            g = 1\r\n            while g == 1:\r\n                ys = f(ys)\r\n                g = gcd(abs(x - ys), n)\r\n        if g < n:\r\n            if isPrimeMR(g): return g\r\n            elif isPrimeMR(n // g): return n // g\r\n            return findFactorRho(g)\r\ndef primeFactor(n):\r\n    i = 2\r\n    ret = {}\r\n    rhoFlg = 0\r\n    while i*i <= n:\r\n        k = 0\r\n        while n % i == 0:\r\n            n //= i\r\n            k += 1\r\n        if k: ret[i] = k\r\n        i += 1 + i % 2\r\n        if i == 101 and n >= 2 ** 20:\r\n            while n > 1:\r\n                if isPrimeMR(n):\r\n                    ret[n], n = 1, 1\r\n                else:\r\n                    rhoFlg = 1\r\n                    j = findFactorRho(n)\r\n                    k = 0\r\n                    while n % j == 0:\r\n                        n //= j\r\n                        k += 1\r\n                    ret[j] = k\r\n\r\n    if n > 1: ret[n] = 1\r\n    if rhoFlg: ret = {x: ret[x] for x in sorted(ret)}\r\n    return ret\r\n\r\ndef divisors(n):\r\n    res = [1]\r\n    prime = primeFactor(n)\r\n    for p in prime:\r\n        newres = []\r\n        for d in res:\r\n            for j in range(prime[p]+1):\r\n                newres.append(d*p**j)\r\n        res = newres\r\n    res.sort()\r\n    return res\r\n\r\ndef xorfactorial(num):\r\n    if num==0:\r\n        return 0\r\n    elif num==1:\r\n        return 1\r\n    elif num==2:\r\n        return 3\r\n    elif num==3:\r\n        return 0\r\n    else:\r\n        x=baseorder(num)\r\n        return (2**x)*((num-2**x+1)%2)+function(num-2**x)\r\n\r\ndef xorconv(n,X,Y):\r\n    if n==0:\r\n        res=[(X[0]*Y[0])%mod]\r\n        return res\r\n    x=[X[i]+X[i+2**(n-1)] for i in range(2**(n-1))]\r\n    y=[Y[i]+Y[i+2**(n-1)] for i in range(2**(n-1))]\r\n    z=[X[i]-X[i+2**(n-1)] for i in range(2**(n-1))]\r\n    w=[Y[i]-Y[i+2**(n-1)] for i in range(2**(n-1))]\r\n    res1=xorconv(n-1,x,y)\r\n    res2=xorconv(n-1,z,w)\r\n    former=[(res1[i]+res2[i])*inv for i in range(2**(n-1))]\r\n    latter=[(res1[i]-res2[i])*inv for i in range(2**(n-1))]\r\n    former=list(map(lambda x:x%mod,former))\r\n    latter=list(map(lambda x:x%mod,latter))\r\n    return former+latter\r\n\r\ndef merge_sort(A,B):\r\n    pos_A,pos_B = 0,0\r\n    n,m = len(A),len(B)\r\n    res = []\r\n    while pos_A < n and pos_B < m:\r\n        a,b = A[pos_A],B[pos_B]\r\n        if a < b:\r\n            res.append(a)\r\n            pos_A += 1\r\n        else:\r\n            res.append(b)\r\n            pos_B += 1\r\n    res += A[pos_A:]\r\n    res += B[pos_B:]\r\n    return res\r\n\r\nclass UnionFindVerSize():\r\n    def __init__(self, N):\r\n        self._parent = [n for n in range(0, N)]\r\n        self._size = [1] * N\r\n        self.group = N\r\n\r\n    def find_root(self, x):\r\n        if self._parent[x] == x: return x\r\n        self._parent[x] = self.find_root(self._parent[x])\r\n        stack = [x]\r\n        while self._parent[stack[-1]]!=stack[-1]:\r\n            stack.append(self._parent[stack[-1]])\r\n        for v in stack:\r\n            self._parent[v] = stack[-1]\r\n        return self._parent[x]\r\n\r\n    def unite(self, x, y):\r\n        gx = self.find_root(x)\r\n        gy = self.find_root(y)\r\n        if gx == gy: return\r\n\r\n        self.group -= 1\r\n\r\n        if self._size[gx] < self._size[gy]:\r\n            self._parent[gx] = gy\r\n            self._size[gy] += self._size[gx]\r\n        else:\r\n            self._parent[gy] = gx\r\n            self._size[gx] += self._size[gy]\r\n\r\n    def get_size(self, x):\r\n        return self._size[self.find_root(x)]\r\n\r\n    def is_same_group(self, x, y):\r\n        return self.find_root(x) == self.find_root(y)\r\n\r\nclass WeightedUnionFind():\r\n    def __init__(self,N):\r\n        self.parent = [i for i in range(N)]\r\n        self.size = [1 for i in range(N)]\r\n        self.val = [0 for i in range(N)]\r\n        self.flag = True\r\n        self.edge = [[] for i in range(N)]\r\n\r\n    def dfs(self,v,pv):\r\n        stack = [(v,pv)]\r\n        new_parent = self.parent[pv]\r\n        while stack:\r\n            v,pv = stack.pop()\r\n            self.parent[v] = new_parent\r\n            for nv,w in self.edge[v]:\r\n                if nv!=pv:\r\n                    self.val[nv] = self.val[v] + w\r\n                    stack.append((nv,v))\r\n\r\n    def unite(self,x,y,w):\r\n        if not self.flag:\r\n            return\r\n        if self.parent[x]==self.parent[y]:\r\n            self.flag = (self.val[x] - self.val[y] == w)\r\n            return\r\n\r\n        if self.size[self.parent[x]]>self.size[self.parent[y]]:\r\n            self.edge[x].append((y,-w))\r\n            self.edge[y].append((x,w))\r\n            self.size[x] += self.size[y]\r\n            self.val[y] = self.val[x] - w\r\n            self.dfs(y,x)\r\n        else:\r\n            self.edge[x].append((y,-w))\r\n            self.edge[y].append((x,w))\r\n            self.size[y] += self.size[x]\r\n            self.val[x] = self.val[y] + w\r\n            self.dfs(x,y)\r\n\r\nclass Dijkstra():\r\n    class Edge():\r\n        def __init__(self, _to, _cost):\r\n            self.to = _to\r\n            self.cost = _cost\r\n\r\n    def __init__(self, V):\r\n        self.G = [[] for i in range(V)]\r\n        self._E = 0\r\n        self._V = V\r\n\r\n    @property\r\n    def E(self):\r\n        return self._E\r\n\r\n    @property\r\n    def V(self):\r\n        return self._V\r\n\r\n    def add_edge(self, _from, _to, _cost):\r\n        self.G[_from].append(self.Edge(_to, _cost))\r\n        self._E += 1\r\n\r\n    def shortest_path(self, s):\r\n        import heapq\r\n        que = []\r\n        d = [10**15] * self.V\r\n        d[s] = 0\r\n        heapq.heappush(que, (0, s))\r\n\r\n        while len(que) != 0:\r\n            cost, v = heapq.heappop(que)\r\n            if d[v] < cost: continue\r\n\r\n            for i in range(len(self.G[v])):\r\n                e = self.G[v][i]\r\n                if d[e.to] > d[v] + e.cost:\r\n                    d[e.to] = d[v] + e.cost\r\n                    heapq.heappush(que, (d[e.to], e.to))\r\n        return d\r\n\r\n#Z[i]:length of the longest list starting from S[i] which is also a prefix of S\r\n#O(|S|)\r\ndef Z_algorithm(s):\r\n    N = len(s)\r\n    Z_alg = [0]*N\r\n\r\n    Z_alg[0] = N\r\n    i = 1\r\n    j = 0\r\n    while i < N:\r\n        while i+j < N and s[j] == s[i+j]:\r\n            j += 1\r\n        Z_alg[i] = j\r\n        if j == 0:\r\n            i += 1\r\n            continue\r\n        k = 1\r\n        while i+k < N and k + Z_alg[k]<j:\r\n            Z_alg[i+k] = Z_alg[k]\r\n            k += 1\r\n        i += k\r\n        j -= k\r\n    return Z_alg\r\n\r\nclass BIT():\r\n    def __init__(self,n,mod=0):\r\n        self.BIT = [0]*(n+1)\r\n        self.num = n\r\n        self.mod = mod\r\n\r\n    def query(self,idx):\r\n        res_sum = 0\r\n        mod = self.mod\r\n        while idx > 0:\r\n            res_sum += self.BIT[idx]\r\n            if mod:\r\n                res_sum %= mod\r\n            idx -= idx&(-idx)\r\n        return res_sum\r\n\r\n    #Ai += x O(logN)\r\n    def update(self,idx,x):\r\n        mod = self.mod\r\n        while idx <= self.num:\r\n            self.BIT[idx] += x\r\n            if mod:\r\n                self.BIT[idx] %= mod\r\n            idx += idx&(-idx)\r\n        return\r\n\r\nclass dancinglink():\r\n    def __init__(self,n,debug=False):\r\n        self.n = n\r\n        self.debug = debug\r\n        self._left = [i-1 for i in range(n)]\r\n        self._right = [i+1 for i in range(n)]\r\n        self.exist = [True for i in range(n)]\r\n\r\n    def pop(self,k):\r\n        if self.debug:\r\n            assert self.exist[k]\r\n        L = self._left[k]\r\n        R = self._right[k]\r\n        if L!=-1:\r\n            if R!=self.n:\r\n                self._right[L],self._left[R] = R,L\r\n            else:\r\n                self._right[L] = self.n\r\n        elif R!=self.n:\r\n            self._left[R] = -1\r\n        self.exist[k] = False\r\n\r\n    def left(self,idx,k=1):\r\n        if self.debug:\r\n            assert self.exist[idx]\r\n        res = idx\r\n        while k:\r\n            res = self._left[res]\r\n            if res==-1:\r\n                break\r\n            k -= 1\r\n        return res\r\n\r\n    def right(self,idx,k=1):\r\n        if self.debug:\r\n            assert self.exist[idx]\r\n        res = idx\r\n        while k:\r\n            res = self._right[res]\r\n            if res==self.n:\r\n                break\r\n            k -= 1\r\n        return res\r\n\r\nclass SparseTable():\r\n    def __init__(self,A,merge_func,ide_ele):\r\n        N = len(A)\r\n \r\n        self.merge_func = merge_func\r\n \r\n        self.lg = [0]*(N + 1)\r\n        for i in range(2, N+1):\r\n            self.lg[i] = self.lg[i >> 1] + 1\r\n        self.pow_2 = [pow(2,i) for i in range(20)]\r\n \r\n        self.table = [None]*(self.lg[N] + 1)\r\n        st0 = self.table[0] = [a for a in A]\r\n        b = 1\r\n        for i in range(self.lg[N]):\r\n            st0 = self.table[i+1] = [self.merge_func(u,v) for u, v in zip(st0, st0[b:])]\r\n            b <<= 1\r\n \r\n    def query(self,s,t):\r\n        b = t-s+1\r\n        m = self.lg[b]\r\n        return self.merge_func(self.table[m][s],self.table[m][t-self.pow_2[m]+1])\r\n \r\n\r\nclass BinaryTrie:\r\n    class node:\r\n        def __init__(self,val):\r\n            self.left = None\r\n            self.right = None\r\n            self.max = val\r\n\r\n    def __init__(self):\r\n        self.root = self.node(-10**15)\r\n\r\n    def append(self,key,val):\r\n        pos = self.root\r\n        for i in range(29,-1,-1):\r\n            pos.max = max(pos.max,val)\r\n            if key>>i & 1:\r\n                if pos.right is None:\r\n                    pos.right = self.node(val)\r\n                    pos = pos.right\r\n                else:\r\n                    pos = pos.right\r\n            else:\r\n                if pos.left is None:\r\n                    pos.left = self.node(val)\r\n                    pos = pos.left\r\n                else:\r\n                    pos = pos.left\r\n        pos.max = max(pos.max,val)\r\n\r\n    def search(self,M,xor):\r\n        res = -10**15\r\n        pos = self.root\r\n        for i in range(29,-1,-1):\r\n            if pos is None:\r\n                break\r\n\r\n            if M>>i & 1:\r\n                if xor>>i & 1:\r\n                    if pos.right:\r\n                        res = max(res,pos.right.max)\r\n                    pos = pos.left\r\n                else:\r\n                    if pos.left:\r\n                        res = max(res,pos.left.max)\r\n                    pos = pos.right\r\n            else:\r\n                if xor>>i & 1:\r\n                    pos = pos.right\r\n                else:\r\n                    pos = pos.left\r\n\r\n        if pos:\r\n            res = max(res,pos.max)\r\n        return res\r\n\r\ndef solveequation(edge,ans,n,m):\r\n    #edge=[[to,dire,id]...]\r\n    def dfs(v):\r\n        used[v]=True\r\n        r=ans[v]\r\n        for to,dire,id in edge[v]:\r\n            if used[to]:\r\n                continue\r\n            y=dfs(to)\r\n            if dire==-1:\r\n                x[id]=y\r\n            else:\r\n                x[id]=-y\r\n            r+=y\r\n        return r\r\n        \r\n    x=[0]*m\r\n    used=[False]*n\r\n    for v in range(n):\r\n        if used[v]:\r\n            continue\r\n        y = dfs(v)\r\n        if y!=0:\r\n            return False\r\n    return x\r\n\r\n    \r\n\r\nclass slope_trick():\r\n    def __init__(self):\r\n        self.L = [10**17]\r\n        self.R = [10**17]\r\n        self.min_f = 0\r\n\r\n        self.x_left = 0\r\n        self.x_right = 0\r\n\r\n    def add_right(self,a):\r\n        a -= self.x_left\r\n        l0 = -self.L[0]\r\n        self.min_f  = self.min_f + max(0,l0-a)\r\n        if l0 <= a:\r\n            a += self.x_left\r\n            a -= self.x_right\r\n            heappush(self.R,a)\r\n        else:\r\n            heappush(self.L,-a)\r\n            a = -heappop(self.L)\r\n            a += self.x_left\r\n            a -= self.x_right\r\n            heappush(self.R,a)\r\n\r\n        #self.min_f  = self.min_f + max(0,l0-a)\r\n\r\n    def add_left(self,a):\r\n        a -= self.x_right\r\n        r0 = self.R[0]\r\n        self.min_f = self.min_f + max(0,a-r0)\r\n\r\n        if a <= r0:\r\n            a += self.x_right\r\n            a -= self.x_left\r\n            heappush(self.L,-a)\r\n        else:\r\n            heappush(self.R,a)\r\n            a = heappop(self.R)\r\n            a += self.x_right\r\n            a -= self.x_left\r\n            heappush(self.L,-a)\r\n\r\n        #self.min_f = self.min_f + max(0,a-r0)\r\n\r\n    def add_abs(self,a):\r\n        self.add_left(a)\r\n        self.add_right(a)\r\n\r\n    def change_min_slide(self,a,b):\r\n        self.x_left += a\r\n        self.x_right += b\r\n    \r\n    def get_val(self,x):\r\n        L = [-l+self.x_left for l in self.L]\r\n        L.sort()\r\n        R = [r+self.x_right for r in self.R]\r\n        R.sort()\r\n\r\n        res = self.min_f\r\n\r\n        if 0 < L[-1]:\r\n            L = L[::-1]\r\n            n = len(L)\r\n            for i in range(n):\r\n                c0 = L[i]\r\n                c1 = L[i+1]\r\n        \r\n                if c1 <= x <= c0:\r\n                    res += (i+1) * (c0-x)\r\n                    break\r\n                else:\r\n                    res += (i+1) * (c0-c1)\r\n            return res\r\n        elif L[-1] <= x <= R[0]:\r\n            return res\r\n        else:\r\n            n = len(R)\r\n            for i in range(n):\r\n                c0 = R[i]\r\n                c1 = R[i+1]\r\n                if c0 <= x <= c1:\r\n                    res += (i+1) * (x-c0)\r\n                    break\r\n                else:\r\n                    res += (i+1) * (c1-c0)\r\n            return res\r\n\r\nclass SegmentTree:\r\n    def __init__(self, init_val, segfunc, ide_ele):\r\n        n = len(init_val)\r\n        self.segfunc = segfunc\r\n        self.ide_ele = ide_ele\r\n        self.num = 1 << (n - 1).bit_length()\r\n        self.tree = [ide_ele] * 2 * self.num\r\n        self.size = n\r\n        for i in range(n):\r\n            self.tree[self.num + i] = init_val[i]\r\n        for i in range(self.num - 1, 0, -1):\r\n            self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])\r\n\r\n    def update(self, k, x):\r\n        k += self.num\r\n        self.tree[k] = x\r\n        while k > 1:\r\n            k >>= 1\r\n            self.tree[k] = self.segfunc(self.tree[2*k], self.tree[2*k+1])\r\n\r\n    def query(self, l, r):\r\n        if r==self.size:\r\n            r = self.num\r\n\r\n        res = self.ide_ele\r\n\r\n        l += self.num\r\n        r += self.num\r\n        right = []\r\n        while l < r:\r\n            if l & 1:\r\n                res = self.segfunc(res, self.tree[l])\r\n                l += 1\r\n            if r & 1:\r\n                right.append(self.tree[r-1])\r\n            l >>= 1\r\n            r >>= 1\r\n\r\n        for e in right[::-1]:\r\n            res = self.segfunc(res,e)\r\n        return res\r\n\r\n    def bisect_l(self,l,r,x):\r\n        l += self.num\r\n        r += self.num\r\n        Lmin = -1\r\n        Rmin = -1\r\n        while l<r:\r\n            if l & 1:\r\n                if self.tree[l] <= x and Lmin==-1:\r\n                    Lmin = l\r\n                l += 1\r\n            if r & 1:\r\n                if self.tree[r-1] <=x:\r\n                    Rmin = r-1\r\n            l >>= 1\r\n            r >>= 1\r\n\r\n        if Lmin != -1:\r\n            pos = Lmin\r\n            while pos<self.num:\r\n                if self.tree[2 * pos] <=x:\r\n                    pos = 2 * pos\r\n                else:\r\n                    pos = 2 * pos +1\r\n            return pos-self.num\r\n        elif Rmin != -1:\r\n            pos = Rmin\r\n            while pos<self.num:\r\n                if self.tree[2 * pos] <=x:\r\n                    pos = 2 * pos\r\n                else:\r\n                    pos = 2 * pos +1\r\n            return pos-self.num\r\n        else:\r\n            return -1\r\n\r\nimport sys,random,bisect\r\nfrom collections import deque,defaultdict\r\nfrom heapq import heapify,heappop,heappush\r\nfrom itertools import permutations\r\nfrom math import gcd,log\r\n\r\ninput = lambda :sys.stdin.buffer.readline()\r\nmi = lambda :map(int,input().split())\r\nli = lambda :list(mi())\r\n\r\nfor _ in range(int(input())):\r\n    n = int(input())\r\n    A = li()\r\n    B = li()\r\n\r\n    A = [a-1 for a in A]\r\n    B = [b-1 for b in B]\r\n    \r\n    cnt = [0] * n\r\n    for a in A:\r\n        cnt[a] += 1\r\n    M = max(cnt)\r\n    bye = cnt.index(M)\r\n\r\n    edge = [[] for v in range(n)]\r\n    deg = [0] * n\r\n    for i in range(n):\r\n        if A[i]!=bye and B[i]!=bye:\r\n            edge[A[i]].append(B[i])\r\n            deg[B[i]] += 1\r\n    \r\n    deq = deque([v for v in range(n) if deg[v]==0])\r\n    while deq:\r\n        v = deq.popleft()\r\n        for nv in edge[v]:\r\n            deg[nv] -= 1\r\n            if deg[nv]==0:\r\n                deq.append(nv)\r\n    \r\n    if sum(deg) > 0:\r\n        print(\"WA\")\r\n    else:\r\n        print(\"AC\")",
    "prob_desc_created_at": "1650722700",
    "tags": [
        "constructive algorithms",
        "dfs and similar",
        "graphs"
    ],
    "hidden_unit_tests": ""
}
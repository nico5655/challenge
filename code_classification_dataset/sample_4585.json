{
    "prob_desc_time_limit": "1 second",
    "prob_desc_sample_outputs": "[\"2 3 4\\n5 3 1\\n2 3\\n4 1\\n3 5\"]",
    "src_uid": "a9021fed22299e90aaef50c4d0d9f5b2",
    "prob_desc_notes": "NoteIn the first case, the sum of tiredness is $$$\\min(2,5) + \\min(3,3) + \\min(4,1) = 6$$$.  In the second case, the sum of tiredness is $$$\\min(2,4,3) + \\min(3,1,5) = 3$$$.",
    "prob_desc_description": "The 2050 volunteers are organizing the \"Run! Chase the Rising Sun\" activity. Starting on Apr 25 at 7:30 am, runners will complete the 6km trail around the Yunqi town.There are $$$n+1$$$ checkpoints on the trail. They are numbered by $$$0$$$, $$$1$$$, ..., $$$n$$$. A runner must start at checkpoint $$$0$$$ and finish at checkpoint $$$n$$$. No checkpoint is skippable — he must run from checkpoint $$$0$$$ to checkpoint $$$1$$$, then from checkpoint $$$1$$$ to checkpoint $$$2$$$ and so on. Look at the picture in notes section for clarification.Between any two adjacent checkpoints, there are $$$m$$$ different paths to choose. For any $$$1\\le i\\le n$$$, to run from checkpoint $$$i-1$$$ to checkpoint $$$i$$$, a runner can choose exactly one from the $$$m$$$ possible paths. The length of the $$$j$$$-th path between checkpoint $$$i-1$$$ and $$$i$$$ is $$$b_{i,j}$$$ for any $$$1\\le j\\le m$$$ and $$$1\\le i\\le n$$$.To test the trail, we have $$$m$$$ runners. Each runner must run from the checkpoint $$$0$$$ to the checkpoint $$$n$$$ once, visiting all the checkpoints. Every path between every pair of adjacent checkpoints needs to be ran by exactly one runner. If a runner chooses the path of length $$$l_i$$$ between checkpoint $$$i-1$$$ and $$$i$$$ ($$$1\\le i\\le n$$$), his tiredness is $$$$$$\\min_{i=1}^n l_i,$$$$$$ i. e. the minimum length of the paths he takes.Please arrange the paths of the $$$m$$$ runners to minimize the sum of tiredness of them.",
    "prob_desc_output_spec": "For each test case, output $$$n$$$ lines. The $$$j$$$-th number in the $$$i$$$-th line should contain the length of the path that runner $$$j$$$ chooses to run from checkpoint $$$i-1$$$ to checkpoint $$$i$$$. There should be exactly $$$m$$$ integers in the $$$i$$$-th line and these integers should form a permuatation of $$$b_{i, 1}$$$, ..., $$$b_{i, m}$$$ for all $$$1\\le i\\le n$$$. If there are multiple answers, print any.",
    "prob_desc_input_spec": "Each test contains multiple test cases. The first line contains the number of test cases $$$t$$$ ($$$1 \\le t \\le 10\\,000$$$). Description of the test cases follows. The first line of each test case contains two integers $$$n$$$ and $$$m$$$ ($$$1 \\leq n,m \\leq 100$$$). The $$$i$$$-th of the next $$$n$$$ lines contains $$$m$$$ integers $$$b_{i,1}$$$, $$$b_{i,2}$$$, ..., $$$b_{i,m}$$$ ($$$1 \\le b_{i,j} \\le 10^9$$$). It is guaranteed that the sum of $$$n\\cdot m$$$ over all test cases does not exceed $$$10^4$$$.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3-64",
    "lang_cluster": "Python",
    "difficulty": 1200,
    "file_name": "train_101.jsonl",
    "code_uid": "45eb7fa21d2d129f39fb23987e96fa9d",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"2\\n2 3\\n2 3 4\\n1 3 5\\n3 2\\n2 3\\n4 1\\n3 5\"]",
    "exec_outcome": "PASSED",
    "source_code": "from math import ceil,gcd,factorial,sqrt,log,log2\r\nimport queue\r\nimport re\r\n# from functools import reduce\r\n#product is used to generater truth tables or multiply list produc([0,1],repeat=n)\r\nfrom itertools import permutations,combinations,accumulate,product\r\nfrom collections import Counter,deque\r\nfrom sys import stdin,stdout\r\nfrom bisect import bisect,insort,bisect_left,insort_left\r\ninput=lambda: stdin.readline()\r\n#bisect=upper_bound,bisect_left=lower_bound\r\ndef sieve(n):\r\n    prime = [True]*(n+1)\r\n    p = 2\r\n    a=[]\r\n    for p in range(2,int(n**0.5)+1):\r\n        if (prime[p] == True):\r\n            a.append(p)\r\n            for l1 in range(p * p, n+1, p):\r\n                prime[l1] = False\r\n    return a\r\ndef simplesieve(n):\r\n    prime=[2]\r\n    mark=[False]*(n+1)\r\n    for p in range(3,n+1,2):\r\n        if(mark[p]==False):\r\n            prime.append(p)\r\n            if(p*p<=n):\r\n                for l1 in range(p*p,n +1,2*p):\r\n                    mark[l1]=True\r\n    return prime\r\ndef segementedsieve(low,high):\r\n    primes=simplesieve(int(high**0.5))\r\n    prime = [True] * (high-low + 1)\r\n    for l1 in primes:\r\n        lower = (low//l1)\r\n        if lower <= 1:\r\n            lower = l1+l1\r\n        elif (low % l1) != 0:\r\n            lower = (lower * l1) + l1\r\n        else:\r\n            lower = lower*l1\r\n        for l2 in range(lower, high+1, l1):\r\n            prime[l2-low] = False\r\n    a=[]\r\n    s=0\r\n    for l in range(low, high + 1):\r\n        if prime[l-low]:\r\n            a.append(l)\r\n    return a\r\ndef isprime(n):\r\n    if(n==2):\r\n        return True\r\n    if(n%2==0 or n==1):\r\n        return False\r\n    for l1 in range(3,int(n**0.5)+1,2):\r\n        if(n%l1==0):\r\n            return False\r\n    return True\r\ndef binpow(a,b,m):\r\n    r2=1\r\n    a=a%m\r\n    while(b>0):\r\n        if(b&1):\r\n            r2=(r2*a)%m\r\n        a=(a*a)%m\r\n        b>>=1\r\n        print(a,b,r2)\r\n    return r2\r\ndef lcm(a,b):\r\n    return (a//gcd(a,b))*b\r\n#gcd(a,b)=ax+by and \r\n\r\ndef gcdExtended(a,b): \r\n    if(b==0):  \r\n        return a,1,0\r\n    g,x1,y1=gcdExtended(b,a%b)  \r\n    x1,y1 = y1,x1-(a//b)*y1 \r\n    return g,x1,y1\r\ndef binsearch(a,l,r,key):\r\n    while(r-l>1):\r\n        m=l+(r-l)//2\r\n        if(a[m]<=key):\r\n            l=m\r\n        else:\r\n            r=m\r\n    if(a[l]==key):\r\n        return l\r\n    if(a[r]==key):\r\n        return r\r\n    return -1\r\nclass Node():\r\n    def __init__(self, data):\r\n        self.data = data\r\n        self.left = None\r\n        self.right = None\r\ndef inorder(root):\r\n    res, stack = [], []\r\n    current = root\r\n    while True:\r\n        while current:\r\n            stack.append(current)\r\n            current = current.left\r\n        if len(stack) == 0:\r\n            return res\r\n        node = stack[-1]\r\n        stack.pop(len(stack)-1)\r\n        if node.data != None:\r\n            res.append(node.data)\r\n        current = node.right\r\n    return res \r\n\r\ndef dfs(graph,s,v):\r\n    v[s]=1\r\n    for i in graph[s]:\r\n        if(v[i]==0):\r\n            dfs(graph,i,v)\r\ndef bfs(graph,n,x,dest):\r\n    v=[0]*(1+n)\r\n    d=[0]*(1+n)\r\n    # d=[-1]*1000\r\n    d[x]=0\r\n    v[x]=1\r\n    q=queue.Queue()\r\n    q.put(x)\r\n    # p=[0]*(1+n)\r\n    # p[x]=-1\r\n    while(not q.empty()):\r\n        z=q.get()\r\n        for s in graph[z]:\r\n            if(v[s]==0):\r\n                v[s]=1\r\n                d[s]=d[z]+1\r\n                q.put(s)\r\n                # p[s]=z\r\n    # path=[]\r\n    # #l1=dest#given\r\n    # while(l1!=-1):\r\n    #    path.append(l1)\r\n    #    l1=p[l1]\r\n    # path.reverse()\r\n    #?print(d)\r\n    return d[dest]\r\n# a=simplesieve(10**6)\r\n# for _ in range(int(input())):    \r\n#     n=int(input())  \r\n    # n,m=map(int,input().split())\r\n    # a=list(map(int,input().split()))\r\nfor _ in range(int(input())):\r\n    # n=int(input())\r\n    n,m=map(int,input().split())\r\n    b=[]\r\n    c=[]\r\n    for i in range(n):\r\n        a=list(map(int,input().split()))\r\n        c.append(a)\r\n        for j in a:\r\n            b.append(j)\r\n    b.sort()\r\n    b=list(b[:m])\r\n    # print(b,\"ji\")\r\n    k=0\r\n    ans=[[0 for i in range(m)] for i in range(n)]\r\n    for i in range(n):\r\n        d=list(c[i])\r\n        for j in range(m):\r\n            if(c[i][j] in b):\r\n                ans[i][k]=c[i][j]\r\n                b.remove(c[i][j])\r\n                d.remove(c[i][j])\r\n                k+=1\r\n        # print(d,ans,b,k)\r\n        l=0\r\n        for j in range(m):\r\n            if(ans[i][j]==0):\r\n                ans[i][j]=d[l]\r\n                l+=1\r\n    for i in ans:\r\n        for j in i:\r\n            print(j,end=\" \")\r\n        print()",
    "prob_desc_created_at": "1619188500",
    "tags": [
        "constructive algorithms",
        "greedy",
        "sortings"
    ],
    "hidden_unit_tests": ""
}
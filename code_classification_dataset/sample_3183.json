{
    "prob_desc_time_limit": "1 second",
    "prob_desc_sample_outputs": "[\"2\", \"1\", \"-1\", \"3\"]",
    "src_uid": "20e13f21610c5614310bcd764662231c",
    "prob_desc_notes": "NoteImagine we have string a = a1a2a3...a|a|, where |a| is the length of string a, and ai is the ith letter of the string. We will call string alal + 1al + 2...ar (1 ≤ l ≤ r ≤ |a|) the substring [l, r] of the string a. The substring [l, r] is unique in a if and only if there is no pair l1, r1 such that l1 ≠ l and the substring [l1, r1] is equal to the substring [l, r] in a.",
    "prob_desc_description": "Police headquarter is monitoring signal on different frequency levels. They have got two suspiciously encoded strings s1 and s2 from two different frequencies as signals. They are suspecting that these two strings are from two different criminals and they are planning to do some evil task.Now they are trying to find a common substring of minimum length between these two strings. The substring must occur only once in the first string, and also it must occur only once in the second string.Given two strings s1 and s2 consist of lowercase Latin letters, find the smallest (by length) common substring p of both s1 and s2, where p is a unique substring in s1 and also in s2. See notes for formal definition of substring and uniqueness.",
    "prob_desc_output_spec": "Print the length of the smallest common unique substring of s1 and s2. If there are no common unique substrings of s1 and s2 print -1.",
    "prob_desc_input_spec": "The first line of input contains s1 and the second line contains s2 (1 ≤ |s1|, |s2| ≤ 5000). Both strings consist of lowercase Latin letters.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "Python 2",
    "lang_cluster": "Python",
    "difficulty": 2200,
    "file_name": "train_045.jsonl",
    "code_uid": "d03cd113f1d50fdebcc833d4e601fe15",
    "prob_desc_memory_limit": "512 megabytes",
    "prob_desc_sample_inputs": "[\"apple\\npepperoni\", \"lover\\ndriver\", \"bidhan\\nroy\", \"testsetses\\nteeptes\"]",
    "exec_outcome": "PASSED",
    "source_code": "import sys\nimport bisect\n\nclass suffixautomaton:\n    def __init__(self, words, symbol = \"#\"):\n        self.words = []\n        self.sequence = \"\"\n        self.terminal = set()\n        self.nCounters = len(words)\n        self.states = [[0, None, {}]]\n        self.counters = [[0] * self.nCounters]\n\n        for w in words:\n            self.sequence += w\n            self.words.append(len(self.sequence))\n            self.sequence += symbol\n            symbol = chr(ord(symbol)+1)\n\n        pushback = []\n\n        sz = 1\n        last = 0\n        \n        for ci in range(len(self.sequence)):\n            c = self.sequence[ci]\n            \n            cur = sz\n            sz += 1\n            \n            self.states.append([self.states[last][0] + 1, None, {}])\n            self.counters.append([0] * self.nCounters)\n            word = bisect.bisect_left(self.words, ci)\n            self.counters[-1][word] = 1\n                \n            pushback.append((self.states[last][0] + 1, cur))\n            \n            p = last\n            while p <> None and c not in self.states[p][2]:\n                self.states[p][2][c] = cur\n                p = self.states[p][1]\n            \n            if p == None:\n                self.states[cur][1] = 0\n            else:\n                q = self.states[p][2][c]\n                if (self.states[p][0] + 1 == self.states[q][0]):\n                    self.states[cur][1] = q\n                else:\n                    clone = sz\n                    sz += 1\n\n                    pushback.append((self.states[p][0] + 1, clone))\n                    self.states.append([self.states[p][0] + 1, self.states[q][1], self.states[q][2].copy()])\n                    \n                    self.counters.append([0] * self.nCounters)\n                    \n                    while p <> None and self.states[p][2][c] == q:\n                        self.states[p][2][c] = clone\n                        p = self.states[p][1]\n                    self.states[cur][1] = clone\n                    self.states[q][1] = clone\n            last = cur\n        \n        pushback.sort(reverse = True)\n        for _, i in pushback:\n            for j in range(self.nCounters):\n                self.counters[self.states[i][1]][j] += self.counters[i][j]\n        \n        while last <> 0:\n            self.terminal.add(last)\n            last = self.states[last][1]\n\n    def __repr__(self):\n        S = \"\"\n        \n        for i, s in enumerate(self.states):\n            S += str(i) + \" - \" + str(self.counters[i]) + \" - \" + str(s) + \"\\n\"\n        \n        return S\n\n\n    def CustomaryFunction1(self):\n        \"\"\" Minimal non-repeating substring among all uploaded string\"\"\"\n        \n        best = sys.maxint\n        for i in range(len(self.states)):\n            if reduce(lambda a, b: a and b, [self.counters[i][j] == 1 for j in range(self.nCounters)]):\n                best = min(best, self.states[self.states[i][1]][0] + 1)\n                \n        if best == sys.maxint:\n            return -1\n        \n        return best          \n\ndef solve():\n    a = sys.stdin.readline().strip(\"\\n\\r\")\n    b = sys.stdin.readline().strip(\"\\n\\r\")\n    \n    A = suffixautomaton([a, b])\n        \n    print A.CustomaryFunction1()\n    \nsolve()\n",
    "prob_desc_created_at": "1399044600",
    "tags": [
        "dp",
        "string suffix structures",
        "strings"
    ],
    "hidden_unit_tests": ""
}
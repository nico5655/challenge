{
    "prob_desc_time_limit": "1 second",
    "prob_desc_sample_outputs": "[\"29\\n23\\n35\\n25\\n35\"]",
    "src_uid": "d70a774248d9137c30f33fb37c6467a7",
    "prob_desc_notes": "NoteAfter the first query $$$a$$$ is equal to $$$[1, 2, 2, 4, 5]$$$, and the answer is $$$29$$$ because we can split each of the subsegments the following way:   $$$[1; 1]$$$: $$$[1]$$$, 1 block;  $$$[1; 2]$$$: $$$[1] + [2]$$$, 2 blocks;  $$$[1; 3]$$$: $$$[1] + [2, 2]$$$, 2 blocks;  $$$[1; 4]$$$: $$$[1] + [2, 2] + [4]$$$, 3 blocks;  $$$[1; 5]$$$: $$$[1] + [2, 2] + [4] + [5]$$$, 4 blocks;  $$$[2; 2]$$$: $$$[2]$$$, 1 block;  $$$[2; 3]$$$: $$$[2, 2]$$$, 1 block;  $$$[2; 4]$$$: $$$[2, 2] + [4]$$$, 2 blocks;  $$$[2; 5]$$$: $$$[2, 2] + [4] + [5]$$$, 3 blocks;  $$$[3; 3]$$$: $$$[2]$$$, 1 block;  $$$[3; 4]$$$: $$$[2] + [4]$$$, 2 blocks;  $$$[3; 5]$$$: $$$[2] + [4] + [5]$$$, 3 blocks;  $$$[4; 4]$$$: $$$[4]$$$, 1 block;  $$$[4; 5]$$$: $$$[4] + [5]$$$, 2 blocks;  $$$[5; 5]$$$: $$$[5]$$$, 1 block;  which is $$$1 + 2 + 2 + 3 + 4 + 1 + 1 + 2 + 3 + 1 + 2 + 3 + 1 + 2 + 1 = 29$$$ in total.",
    "prob_desc_description": "Stanley has decided to buy a new desktop PC made by the company \"Monoblock\", and to solve captcha on their website, he needs to solve the following task.The awesomeness of an array is the minimum number of blocks of consecutive identical numbers in which the array could be split. For example, the awesomeness of an array   $$$[1, 1, 1]$$$ is $$$1$$$;  $$$[5, 7]$$$ is $$$2$$$, as it could be split into blocks $$$[5]$$$ and $$$[7]$$$;  $$$[1, 7, 7, 7, 7, 7, 7, 7, 9, 9, 9, 9, 9, 9, 9, 9, 9]$$$ is 3, as it could be split into blocks $$$[1]$$$, $$$[7, 7, 7, 7, 7, 7, 7]$$$, and $$$[9, 9, 9, 9, 9, 9, 9, 9, 9]$$$. You are given an array $$$a$$$ of length $$$n$$$. There are $$$m$$$ queries of two integers $$$i$$$, $$$x$$$. A query $$$i$$$, $$$x$$$ means that from now on the $$$i$$$-th element of the array $$$a$$$ is equal to $$$x$$$.After each query print the sum of awesomeness values among all subsegments of array $$$a$$$. In other words, after each query you need to calculate $$$$$$\\sum\\limits_{l = 1}^n \\sum\\limits_{r = l}^n g(l, r),$$$$$$ where $$$g(l, r)$$$ is the awesomeness of the array $$$b = [a_l, a_{l + 1}, \\ldots, a_r]$$$.",
    "prob_desc_output_spec": "Print the answer to each query on a new line.",
    "prob_desc_input_spec": "In the first line you are given with two integers $$$n$$$ and $$$m$$$ ($$$1 \\leq n, m \\leq 10^5$$$). The second line contains $$$n$$$ integers $$$a_1, a_2, \\ldots, a_n$$$ ($$$1 \\le a_i \\le 10^9$$$) — the array $$$a$$$. In the next $$$m$$$ lines you are given the descriptions of queries. Each line contains two integers $$$i$$$ and $$$x$$$ ($$$1 \\leq i \\leq n$$$, $$$1 \\leq x \\leq 10^9$$$).",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3-64",
    "lang_cluster": "Python",
    "difficulty": 1700,
    "file_name": "train_082.jsonl",
    "code_uid": "83495944839b5011b7b1c6873e738bce",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"5 5\\n1 2 3 4 5\\n3 2\\n4 2\\n3 1\\n2 1\\n2 2\"]",
    "exec_outcome": "PASSED",
    "source_code": "import sys\r\n\r\na = list(map(int, sys.stdin.readline().split()))\r\nn = a[0]\r\nm = a[1]\r\na = list(map(int, sys.stdin.readline().split()))\r\ncount = 0\r\ns = []\r\nfor i in range(n):\r\n    if i == 0:\r\n        s.append(0)\r\n    elif a[i] == a[i - 1]:\r\n        s.append(0)\r\n    elif a[i] != a[i - 1]:\r\n        s.append(1)\r\ncount = n * (n + 1) // 2\r\nz1 = [0] * n\r\nfor i in range(n):\r\n    if n % 2 == 0:\r\n        if i + 1 <= (n // 2):\r\n            z1[i] = (i + 1) * (n - i) - 1\r\n        else:\r\n            z1[i] = (n - i) * (i + 1) - 1\r\n\r\n    else:\r\n        if i + 1 <= (n // 2 + 1):\r\n            z1[i] = (i + 1) * (n - i) - 1\r\n        else:\r\n            z1[i] = (n - i) * (i + 1) - 1\r\n\r\nfor i in range(n):\r\n    if s[i] == 1:\r\n        count -= (n - 1 - i)\r\n\r\n        count += z1[i]\r\n\r\nfor _ in range(m):\r\n    p = list(map(int, sys.stdin.readline().split()))\r\n    x = p[0] - 1\r\n    y = p[1]\r\n    if n == 1:\r\n        count += 0\r\n    elif x == 0:\r\n        if a[x] == y:\r\n            count += 0\r\n        elif a[x] != a[x + 1] and a[x + 1] != y:\r\n            count += 0\r\n        elif a[x] != a[x + 1] and a[x + 1] == y:\r\n            count += (1 - n)\r\n        elif a[x] == a[x + 1] and a[x + 1] != y:\r\n            count += (n - 1)\r\n    elif x == n - 1:\r\n        if a[x] == y:\r\n            count += 0\r\n        elif a[x] != a[x - 1] and a[x - 1] != y:\r\n            count += 0\r\n        elif a[x] != a[x - 1] and a[x - 1] == y:\r\n            count += (1 - n)\r\n        elif a[x] == a[x - 1] and a[x - 1] != y:\r\n            count += (n - 1)\r\n    else:\r\n        if a[x] == y:\r\n            count += 0\r\n        elif a[x] != a[x - 1] and a[x] != a[x + 1]:\r\n            if a[x - 1] != y and a[x + 1] != y:\r\n                count += 0\r\n            elif a[x - 1] != y and a[x + 1] == y:\r\n                count += (-z1[x] + x)\r\n            elif a[x - 1] == y and a[x + 1] != y:\r\n                count += (-z1[x] + (n - x - 1))\r\n            elif a[x - 1] == y and a[x + 1] == y:\r\n                count += ((n - 1) * (-1) + (z1[x] - n + 1) * (-2))\r\n\r\n        elif a[x] == a[x - 1] and a[x] == a[x + 1]:\r\n            if a[x - 1] != y and a[x + 1] != y:\r\n                count += ((n - 1) * (1) + (z1[x] - n + 1) * (2))\r\n\r\n        elif a[x] != a[x - 1] and a[x] == a[x + 1]:\r\n            if a[x - 1] != y and a[x + 1] != y:\r\n                count += (z1[x] - x)\r\n            elif a[x - 1] == y and a[x + 1] != y:\r\n                count += (n - x - 1 - x)\r\n        elif a[x] == a[x - 1] and a[x] != a[x + 1]:\r\n            if a[x - 1] != y and a[x + 1] != y:\r\n                count += (z1[x] - n + x + 1)\r\n            elif a[x - 1] != y and a[x + 1] == y:\r\n                count += (x - n + x + 1)\r\n    a[x] = y\r\n\r\n    print(count)\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
    "prob_desc_created_at": "1661006100",
    "tags": [
        "combinatorics",
        "data structures",
        "implementation",
        "math"
    ],
    "hidden_unit_tests": ""
}
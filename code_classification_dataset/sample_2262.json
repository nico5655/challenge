{
    "prob_desc_time_limit": "4 seconds",
    "prob_desc_sample_outputs": "[\"5\", \"2\\n42\", \"490902\\n10598759\"]",
    "src_uid": "b88e00d0f549d3ff13c92edd89df187b",
    "prob_desc_notes": "NoteExplanation of the first sample. Each picture specifies the number of ways to arrive at the cell at the appropriate time. (X stands for a cell blocked at this particular moment of time)  Time moment 1.   Time moment 2.  Time moment 3.  Time moment 4.  Time moment 5.  Time moment 6.  Time moment 7.",
    "prob_desc_description": "Gosha's universe is a table consisting of n rows and m columns. Both the rows and columns are numbered with consecutive integers starting with 1. We will use (r, c) to denote a cell located in the row r and column c.Gosha is often invited somewhere. Every time he gets an invitation, he first calculates the number of ways to get to this place, and only then he goes. Gosha's house is located in the cell (1, 1).At any moment of time, Gosha moves from the cell he is currently located in to a cell adjacent to it (two cells are adjacent if they share a common side). Of course, the movement is possible only if such a cell exists, i.e. Gosha will not go beyond the boundaries of the table. Thus, from the cell (r, c) he is able to make a move to one of the cells (r - 1, c), (r, c - 1), (r + 1, c), (r, c + 1). Also, Ghosha can skip a move and stay in the current cell (r, c).Besides the love of strange calculations, Gosha is allergic to cats, so he never goes to the cell that has a cat in it. Gosha knows exactly where and when he will be invited and the schedule of cats travelling along the table. Formally, he has q records, the i-th of them has one of the following forms:   1, xi, yi, ti — Gosha is invited to come to cell (xi, yi) at the moment of time ti. It is guaranteed that there is no cat inside cell (xi, yi) at this moment of time.  2, xi, yi, ti — at the moment ti a cat appears in cell (xi, yi). It is guaranteed that no other cat is located in this cell (xi, yi) at that moment of time.  3, xi, yi, ti — at the moment ti a cat leaves cell (xi, yi). It is guaranteed that there is cat located in the cell (xi, yi). Gosha plans to accept only one invitation, but he has not yet decided, which particular one. In order to make this decision, he asks you to calculate for each of the invitations i the number of ways to get to the cell (xi, yi) at the moment ti. For every invitation, assume that Gosha he starts moving from cell (1, 1) at the moment 1.Moving between two neighboring cells takes Gosha exactly one unit of tim. In particular, this means that Gosha can come into the cell only if a cat sitting in it leaves the moment when Gosha begins his movement from the neighboring cell, and if none of the cats comes to the cell at the time when Gosha is in it.Two ways to go from cell (1, 1) to cell (x, y) at time t are considered distinct if for at least one moment of time from 1 to t Gosha's positions are distinct for the two ways at this moment. Note, that during this travel Gosha is allowed to visit both (1, 1) and (x, y) multiple times. Since the number of ways can be quite large, print it modulo 109 + 7.",
    "prob_desc_output_spec": "For each invitation i (that is, tpi = 1) calculate the number of ways to get to cell (xi, yi) at the moment of time ti. Respond to the invitations chronologically, that is, in the order they appear in the input.",
    "prob_desc_input_spec": "The first line of the input contains three positive integers n, m and q (1 ≤ n·m ≤ 20, 1 ≤ q ≤ 10 000) — the number of rows and columns in the table and the number of events respectively. Next q lines describe the events, each description contains four integers tpi, xi, yi and ti (1 ≤ tp ≤ 3, 1 ≤ x ≤ n, 1 ≤ y ≤ m, 2 ≤ t ≤ 109) — the type of the event (1 if Gosha gets an invitation, 2 if a cat comes to the cell and 3 if a cat leaves the cell), the coordinates of the cell where the action takes place and the moment of time at which the action takes place respectively. It is guaranteed that the queries are given in the chronological order, i.e. ti &lt; ti + 1. ",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "Python 3",
    "lang_cluster": "Python",
    "difficulty": 2400,
    "file_name": "train_019.jsonl",
    "code_uid": "e1d1af7e94e978c0965d2abb1d994d5f",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"1 3 3\\n2 1 2 3\\n3 1 2 5\\n1 1 1 7\", \"3 3 3\\n2 2 2 2\\n1 3 3 5\\n1 3 3 7\", \"4 5 5\\n2 2 5 3\\n2 2 4 6\\n3 2 4 9\\n1 4 4 13\\n1 4 4 15\"]",
    "exec_outcome": "PASSED",
    "source_code": "import sys\nfrom contextlib import contextmanager\nfrom io import StringIO\n\n\nM = 10**9 + 7\n\n\ndef smvmul(d, m, v):\n    return [sum(m[r][k] * v[k] for k in range(d)) % M for r in range(d)]\n\n\ndef smmul(d, m1, m2):\n    return [[sum(m1[r][k] * m2[k][c] for k in range(d)) % M\n            for c in range(d)] for r in range(d)]\n\n\ndef smpow(d, m, p):\n    a = None\n    while p > 1:\n        if p % 2:\n            if a is None:\n                a = m\n            else:\n                a = smmul(d, a, m)\n        m = smmul(d, m, m)\n        p //= 2\n    return m if (a is None) else smmul(d, a, m)\n\n\ndef process(n, m, events):\n    d = n*m\n    v = [0 for _ in range(d)]\n    v[0] = 1\n\n    a = [[0 for _ in range(d)] for _ in range(d)]\n    for r in range(1, n+1):\n        for c in range(1, m+1):\n            i = (r-1)*m + (c-1)\n            a[i][i] = 1\n            if r > 1:\n                a[i][i-m] = 1\n                a[i-m][i] = 1\n            if c > 1:\n                a[i][i-1] = 1\n                a[i-1][i] = 1\n\n    # from pprint import pprint\n    # pprint([[v[r*m+c] for c in range(n)] for r in range(m)],\n    #        stream=sys.stderr)\n\n    t = 1\n    for event in events:\n        ee, er, ec, et = event\n        if t < et:\n            # print(f\"POW {et-t}\", file=sys.stderr)\n            # pprint([[v[r*m+c] for c in range(n)] for r in range(m)],\n            #        stream=sys.stderr)\n            # pprint(a, stream=sys.stderr)\n            ap = smpow(d, a, et-t)\n            v = smvmul(d, ap, v)\n            # pprint(ap, stream=sys.stderr)\n            # pprint([[v[r*m+c] for c in range(n)] for r in range(m)],\n            #        stream=sys.stderr)\n            t = et\n        ei = (er-1)*m + (ec-1)\n        if ee == 1:\n            # print(f\"QRY {er} {ec} {ei} {v[ei]}\", file=sys.stderr)\n            yield v[ei]\n        else:\n            v[ei] = 0\n            b = 0 if (ee == 2) else 1\n            # print(f\"CAT {er} {ec} {ei} {b}\", file=sys.stderr)\n            a[ei][ei] = b\n            if er > 1:\n                a[ei][ei-m] = b\n            if ec > 1:\n                a[ei][ei-1] = b\n            if er < n:\n                a[ei][ei+m] = b\n            if ec < m:\n                a[ei][ei+1] = b\n            # pprint([[v[r*m+c] for c in range(n)] for r in range(m)],\n            #        stream=sys.stderr)\n            # pprint(a, stream=sys.stderr)\n\ndef pl(line):\n    e, r, c, t  = map(int, line.split())\n    return e, r, c, t\n\n\ndef main():\n    n, m, q = map(int, input().split())\n    events = (pl(input()) for _ in range(q))\n    for k in process(n, m, events):\n        print(k)\n\n\n@contextmanager\ndef patchio(i):\n    try:\n        sys.stdin = StringIO(i)\n        sys.stdout = StringIO()\n        yield sys.stdout\n    finally:\n        sys.stdin = sys.__stdin__\n        sys.stdout = sys.__stdout__\n\n\ndef do_test(k, test):\n    print(f\"TEST {k}\", file=sys.stderr)\n    i, o = test\n    with patchio(i) as r:\n        main()\n    if r.getvalue() == o:\n        print(\"OK\\n\", file=sys.stderr)\n    else:\n        print(f\"Expected:\\n{o}Got:\\n{r.getvalue()}\", file=sys.stderr)\n\ndef test(ts):\n    for k in ts or range(len(tests)):\n        do_test(k, tests[k])\n\ntests = [(\"\"\"\\\n1 3 3\n2 1 2 3\n3 1 2 5\n1 1 1 7\n\"\"\", \"\"\"\\\n5\n\"\"\"), (\"\"\"\\\n3 3 3\n2 2 2 2\n1 3 3 5\n1 3 3 7\n\"\"\", \"\"\"\\\n2\n42\n\"\"\"), (\"\"\"\\\n4 5 5\n2 2 5 3\n2 2 4 6\n3 2 4 9\n1 4 4 13\n1 4 4 15\n\"\"\", \"\"\"\\\n490902\n10598759\n\"\"\")]\n\nif __name__ == '__main__':\n    from argparse import ArgumentParser\n    parser = ArgumentParser()\n    parser.add_argument('--test', '-t', type=int, nargs='*')\n    args = parser.parse_args()\n    main() if args.test is None else test(args.test)\n",
    "prob_desc_created_at": "1446655500",
    "tags": [
        "dp",
        "matrices"
    ],
    "hidden_unit_tests": ""
}
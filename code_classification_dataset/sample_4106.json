{
    "prob_desc_time_limit": "3 seconds",
    "prob_desc_sample_outputs": "[\"1\", \"4\", \"1\", \"0\"]",
    "src_uid": "d7a509d6770da5e63028ed560dcf0825",
    "prob_desc_notes": "NoteIn the first example, you can concatenate the strings as follows: \"(\" $$$+$$$ \")\" $$$=$$$ \"()\", the resulting string will have one prefix, that is an RBS: \"()\".In the second example, you can concatenate the strings as follows: \"(\" $$$+$$$ \")\" $$$+$$$ \"()()())\" $$$+$$$ \"(\" $$$=$$$ \"()()()())(\", the resulting string will have four prefixes that are RBS: \"()\", \"()()\", \"()()()\", \"()()()()\".The third and the fourth examples contain only one string each, so the order is fixed.",
    "prob_desc_description": "A bracket sequence is a string containing only characters \"(\" and \")\". A regular bracket sequence (or, shortly, an RBS) is a bracket sequence that can be transformed into a correct arithmetic expression by inserting characters \"1\" and \"+\" between the original characters of the sequence. For example:  bracket sequences \"()()\" and \"(())\" are regular (the resulting expressions are: \"(1)+(1)\" and \"((1+1)+1)\");  bracket sequences \")(\", \"(\" and \")\" are not. Let's denote the concatenation of two strings $$$x$$$ and $$$y$$$ as $$$x+y$$$. For example, \"()()\" $$$+$$$ \")(\" $$$=$$$ \"()())(\".You are given $$$n$$$ bracket sequences $$$s_1, s_2, \\dots, s_n$$$. You can rearrange them in any order (you can rearrange only the strings themselves, but not the characters in them).Your task is to rearrange the strings in such a way that the string $$$s_1 + s_2 + \\dots + s_n$$$ has as many non-empty prefixes that are RBS as possible.",
    "prob_desc_output_spec": "Print one integer — the maximum number of non-empty prefixes that are RBS for the string $$$s_1 + s_2 + \\dots + s_n$$$, if the strings $$$s_1, s_2, \\dots, s_n$$$ can be rearranged arbitrarily.",
    "prob_desc_input_spec": "The first line contains a single integer $$$n$$$ ($$$1 \\le n \\le 20$$$). Then $$$n$$$ lines follow, the $$$i$$$-th of them contains $$$s_i$$$ — a bracket sequence (a string consisting of characters \"(\" and/or \")\". All sequences $$$s_i$$$ are non-empty, their total length does not exceed $$$4 \\cdot 10^5$$$.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3",
    "lang_cluster": "Python",
    "difficulty": 2400,
    "file_name": "train_090.jsonl",
    "code_uid": "5907ce911e9b228ab4bc6852dc1d1d4e",
    "prob_desc_memory_limit": "512 megabytes",
    "prob_desc_sample_inputs": "[\"2\\n(\\n)\", \"4\\n()()())\\n(\\n(\\n)\", \"1\\n(())\", \"1\\n)(()\"]",
    "exec_outcome": "PASSED",
    "source_code": "from sys import stdin, stdout\r\nimport sys\r\nimport heapq\r\nfrom collections import defaultdict\r\nimport math\r\nimport bisect\r\nimport io, os\r\n# from cffi import FFI\r\nimport copy\r\nimport itertools\r\n\r\n# for interactive problem\r\n# n = int(stdin.readline())\r\n# print(x, flush=True)\r\n\r\n#input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline\r\n\r\ndef ncr(n, r, p):\r\n    # initialize numerator\r\n    # and denominator\r\n    num = den = 1\r\n    for i in range(r):\r\n        num = (num * (n - i)) % p\r\n        den = (den * (i + 1)) % p\r\n    return (num * pow(den,\r\n            p - 2, p)) % p\r\n\r\n#input = sys.stdin.buffer.readline\r\n\r\n# ffi = FFI()\r\n# ffi.cdef(\r\n#     \"\"\"\r\n#     typedef struct {\r\n#         long long suf;\r\n#         long long pre;\r\n#         long long maxi;\r\n#         bool is_plus;\r\n#         long long lowest;\r\n#         long long sum;\r\n#         int length;\r\n#     } node_t;\r\n#     \"\"\"\r\n# )\r\n#\r\n# MX = 2 << ((2 * 10 ** 5) - 1).bit_length()\r\n# data = ffi.new(\"node_t[]\", MX + 3)\r\n# data[MX] = (0, 0, 0, True, 0, 0, 0)\r\n# id_node = data[MX]\r\n# res_left = MX + 1\r\n# res_right = MX + 2\r\n#\r\n# def combine(a, b):\r\n#     if a.length == 0:\r\n#         return b\r\n#     if b.length == 0:\r\n#         return a\r\n#\r\n#     length = a.length + b.length\r\n#     if a.is_plus:\r\n#         pre = a.sum + b.pre\r\n#     else:\r\n#         pre = a.pre\r\n#     if b.is_plus:\r\n#         suf = a.suf + b.sum\r\n#     else:\r\n#         suf = b.suf\r\n#     is_plus = a.is_plus and b.is_plus\r\n#     sum = a.sum + b.sum\r\n#     maxi = max(a.maxi, b.maxi, a.suf + b.pre)\r\n#     lowest = min(a.lowest, a.sum + b.lowest)\r\n#     return (suf, pre, maxi, is_plus, lowest, sum, length)\r\n#\r\n# def mapValue(x):\r\n#     return (max(x, 0), max(x, 0), max(x, 0), (x >= 0), x, x, 1)\r\n#\r\n# class SegmentTree:\r\n#     def __init__(self, N, A):\r\n#         self._len = N\r\n#         self._size = _size = 1 << (self._len - 1).bit_length()\r\n#         for i in range(2 * _size):\r\n#             data[i] = id_node\r\n#         for i, x in enumerate(A):\r\n#             data[_size + i] = mapValue(x)\r\n#         for i in reversed(range(_size)):\r\n#             data[i] = combine(data[i + i], data[i + i + 1])\r\n#\r\n#     def __delitem__(self, idx):\r\n#         self[idx] = id_node\r\n#\r\n#     def __getitem__(self, idx):\r\n#         return data[idx + self._size]\r\n#\r\n#     def __setitem__(self, idx, value):\r\n#         idx += self._size\r\n#         data[idx] = value\r\n#         idx >>= 1\r\n#         while idx:\r\n#             data[idx] = combine(data[2 * idx], data[2 * idx + 1])\r\n#             idx >>= 1\r\n#\r\n#     def __len__(self):\r\n#         return self._len\r\n#\r\n#     def query(self, start, stop):\r\n#         \"\"\"func of data[start, stop)\"\"\"\r\n#         start += self._size\r\n#         stop += self._size\r\n#         data[res_left] = id_node\r\n#         data[res_right] = id_node\r\n#         while start < stop:\r\n#             if start & 1:\r\n#                 data[res_left] = combine(data[res_left], data[start])\r\n#                 start += 1\r\n#             if stop & 1:\r\n#                 stop -= 1\r\n#                 data[res_right] = combine(data[stop], data[res_right])\r\n#             start >>= 1\r\n#             stop >>= 1\r\n#         data[res_left] = combine(data[res_left], data[res_right])\r\n#         return data[res_left]\r\n\r\n# def main():\r\n#     n, q = map(int, stdin.readline().split())\r\n#     segtree = SegmentTree(n, map(int, stdin.readline().split()))\r\n#     ans = []\r\n#     for _ in range(q):\r\n#         t, l, r = map(int, stdin.readline().split())\r\n#         l -= 1\r\n#         if t == 1:\r\n#             segtree[l] = mapValue(r)\r\n#         else:\r\n#             ans.append(int(segtree.query(l, r).ans))\r\n#     print(\"\\n\".join(map(str, ans)))\r\n\r\ndef kbits(n, k):\r\n    result = []\r\n    for bits in itertools.combinations(range(n), k):\r\n        s = ['0'] * n\r\n        for bit in bits:\r\n            s[bit] = '1'\r\n        result.append(''.join(s))\r\n    return result\r\n\r\n\r\ndef main():\r\n    n = int(stdin.readline())\r\n    cnt = [[] for _ in range(n)]\r\n    L = []\r\n    R = []\r\n    for i in range(n):\r\n        l, r = 0, 0\r\n        st = stdin.readline().strip()\r\n        for _ in range(len(st)+1):\r\n            cnt[i].append(0)\r\n        for x in st:\r\n            if x == ')':\r\n                if r > 0:\r\n                    r -= 1\r\n                    if r == 0:\r\n                        cnt[i][l] += 1\r\n                else:\r\n                    l += 1\r\n            else:\r\n                 r += 1\r\n        L.append(l)\r\n        R.append(r)\r\n    dp = [-1] * pow(2,n)\r\n    dp[0] = 0\r\n    dp_mx = [0] * pow(2,n)\r\n    ans = 0\r\n    for c in range(n):\r\n        if c == 0:\r\n            perm = ['0' * n]\r\n        else:\r\n            perm = kbits(n, c)\r\n        for p in perm:\r\n            num = int(p, 2)\r\n            if dp[num] == -1:\r\n                continue\r\n            k = 1\r\n            for i, s in enumerate(reversed(p)):\r\n                if s == '0':\r\n                    bal = dp[num]\r\n                    sm = dp_mx[num]\r\n                    if bal - L[i] > 0:\r\n                        bal -= (L[i] - R[i])\r\n                        dp[num + k] = bal\r\n                        dp_mx[num + k] = max(sm, dp_mx[num + k])\r\n                        ans = max(dp_mx[num + k], ans)\r\n                    elif bal - L[i] == 0:\r\n                        if bal > 0:\r\n                            sm += 1\r\n                        sm += cnt[i][L[i]]\r\n                        dp[num + k] = R[i]\r\n                        dp_mx[num + k] = max(sm, dp_mx[num + k])\r\n                        ans = max(dp_mx[num + k], ans)\r\n                    else:\r\n                        sm += cnt[i][bal]\r\n                        if bal > 0:\r\n                            sm += 1\r\n                        ans = max(sm, ans)\r\n\r\n                k *= 2\r\n\r\n    if ans == 3 and n == 5:\r\n        print(L)\r\n        print(R)\r\n        print(dp_mx)\r\n    stdout.write(str(ans)+\"\\n\")\r\n\r\n\r\nmain()",
    "prob_desc_created_at": "1633856700",
    "tags": [
        "binary search",
        "bitmasks",
        "brute force",
        "data structures",
        "dp"
    ],
    "hidden_unit_tests": ""
}
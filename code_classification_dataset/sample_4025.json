{
    "prob_desc_time_limit": "1 second",
    "prob_desc_sample_outputs": "[\"2 1 1\\n2 1 1\\n2 2 2\\n3 1 1 2\\n3 1 2 1\\n3 3 3 3\\n2 3 2 1\"]",
    "src_uid": "a40de6335e9ecc3f27055398fad9110f",
    "prob_desc_notes": "NoteNote that in every picture below the matrix is transformed in such a way that the blue rows are swapped with the green columns.In the first test case, we can perform $$$1$$$ operation for $$$k = 3$$$. The matrix will be transformed as below:    In the second test case, we can perform $$$2$$$ operations for $$$k = 1$$$ and $$$k = 3$$$:      ",
    "prob_desc_description": "You are given a square matrix $$$A$$$ of size $$$n \\times n$$$ whose elements are integers. We will denote the element on the intersection of the $$$i$$$-th row and the $$$j$$$-th column as $$$A_{i,j}$$$.You can perform operations on the matrix. In each operation, you can choose an integer $$$k$$$, then for each index $$$i$$$ ($$$1 \\leq i \\leq n$$$), swap $$$A_{i, k}$$$ with $$$A_{k, i}$$$. Note that cell $$$A_{k, k}$$$ remains unchanged.For example, for $$$n = 4$$$ and $$$k = 3$$$, this matrix will be transformed like this:    The operation $$$k = 3$$$ swaps the blue row with the green column. You can perform this operation any number of times. Find the lexicographically smallest matrix$$$^\\dagger$$$ you can obtain after performing arbitrary number of operations.$$${}^\\dagger$$$ For two matrices $$$A$$$ and $$$B$$$ of size $$$n \\times n$$$, let $$$a_{(i-1) \\cdot n + j} = A_{i,j}$$$ and $$$b_{(i-1) \\cdot n + j} = B_{i,j}$$$. Then, the matrix $$$A$$$ is lexicographically smaller than the matrix $$$B$$$ when there exists an index $$$i$$$ ($$$1 \\leq i \\leq n^2$$$) such that $$$a_i &lt; b_i$$$ and for all indices $$$j$$$ such that $$$1 \\leq j &lt; i$$$, $$$a_j = b_j$$$.",
    "prob_desc_output_spec": "For each test case, print $$$n$$$ lines with $$$n$$$ integers each — the lexicographically smallest matrix.",
    "prob_desc_input_spec": "The first line contains a single integer $$$t$$$ ($$$1 \\leq t \\leq 10^5$$$) — the number of test cases. The first line of each test case contains a single integer $$$n$$$ ($$$1 \\leq n \\leq 1000$$$) — the size of the matrix. The $$$i$$$-th line of the next $$$n$$$ lines contains $$$n$$$ integers $$$A_{i, 1}, A_{i, 2}, \\dots, A_{i, n}$$$ ($$$1 \\le A_{i, j} \\le 10^9$$$) — description of the matrix $$$A$$$. It is guaranteed that the sum of $$$n^2$$$ over all test cases does not exceed $$$10^6$$$.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3-64",
    "lang_cluster": "Python",
    "difficulty": 2400,
    "file_name": "train_088.jsonl",
    "code_uid": "797243eb8c16996d289ffa259c05497f",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"2\\n\\n3\\n\\n2 1 2\\n\\n2 1 2\\n\\n1 1 2\\n\\n4\\n\\n3 3 1 2\\n\\n1 1 3 1\\n\\n3 2 3 2\\n\\n2 3 3 1\"]",
    "exec_outcome": "PASSED",
    "source_code": "#!/usr/bin/env PyPy3\r\n\r\nfrom collections import Counter, defaultdict, deque\r\nimport itertools\r\nimport re\r\nimport math\r\nfrom functools import reduce\r\nimport operator\r\nimport bisect\r\nfrom heapq import *\r\nimport functools\r\n\r\nmod=998244353\r\n\r\nimport sys\r\nimport os\r\nfrom io import BytesIO, IOBase\r\nBUFSIZE = 8192\r\nclass FastIO(IOBase):\r\n    newlines = 0\r\n    def __init__(self, file):\r\n        self._fd = file.fileno()\r\n        self.buffer = BytesIO()\r\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\r\n        self.write = self.buffer.write if self.writable else None\r\n    def read(self):\r\n        while True:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            if not b:\r\n                break\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines = 0\r\n        return self.buffer.read()\r\n    def readline(self):\r\n        while self.newlines == 0:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            self.newlines = b.count(b\"\\n\") + (not b)\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines -= 1\r\n        return self.buffer.readline()\r\n    def flush(self):\r\n        if self.writable:\r\n            os.write(self._fd, self.buffer.getvalue())\r\n            self.buffer.truncate(0), self.buffer.seek(0)\r\nclass IOWrapper(IOBase):\r\n    def __init__(self, file):\r\n        self.buffer = FastIO(file)\r\n        self.flush = self.buffer.flush\r\n        self.writable = self.buffer.writable\r\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\r\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\r\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\r\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\r\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\r\n\r\nclass UnionFind():\r\n    def __init__(self, n):\r\n        self.n = n\r\n        self.parents = [-1] * n\r\n\r\n    def find(self, x):\r\n        now = x\r\n        tmpl = []\r\n        while self.parents[now] >= 0:\r\n            tmpl.append(now)\r\n            now = self.parents[now]\r\n        for xx in tmpl:\r\n            self.parents[xx] = now\r\n        return now\r\n\r\n    def merge(self, x, y):\r\n        x = self.find(x)\r\n        y = self.find(y)\r\n\r\n        if x == y:\r\n            return x\r\n\r\n        if self.parents[x] > self.parents[y]:\r\n            x, y = y, x\r\n\r\n        self.parents[x] += self.parents[y]\r\n        self.parents[y] = x\r\n        return x\r\n\r\n    def size(self, x):\r\n        return -self.parents[self.find(x)]\r\n\r\n    def same(self, x, y):\r\n        return self.find(x) == self.find(y)\r\n\r\n    def members(self, x):#O(n)かかる。全部求めたい場合は、all_group_membersを使う。\r\n        root = self.find(x)\r\n        return [i for i in range(self.n) if self.find(i) == root]\r\n\r\n    def roots(self):\r\n        return [i for i, x in enumerate(self.parents) if x < 0]\r\n\r\n    def group_count(self):\r\n        return len(self.roots())\r\n\r\n    def all_group_members(self):\r\n        group_members = defaultdict(list)\r\n        for member in range(self.n):\r\n            group_members[self.find(member)].append(member)\r\n        return group_members\r\n\r\n    def __str__(self):\r\n        return '\\n'.join(f'{r}: {m}' for r, m in self.all_group_members().items())\r\n\r\nt = int(input())\r\nfor _ in range(t):\r\n    n = int(input())\r\n    a = [list(map(int,input().split())) for _ in range(n)]\r\n    uf = UnionFind(2 * n)\r\n    for i in range(n):\r\n        for j in range(i+1,n):\r\n            if a[i][j] < a[j][i]:\r\n                if uf.same(i,j+n) or uf.same(i+n,j):continue\r\n                uf.merge(i,j)\r\n                uf.merge(i+n,j+n)\r\n            elif a[i][j] > a[j][i]:\r\n                if uf.same(i,j) or uf.same(i+n,j+n):continue\r\n                uf.merge(i,j+n)\r\n                uf.merge(j,i+n)\r\n    for i in range(n):\r\n        for j in range(i+1,n):\r\n            if not(uf.same(i,j) or uf.same(i+n,j+n)):\r\n                a[i][j],a[j][i] = a[j][i],a[i][j]\r\n    for i in range(n):\r\n        print(*a[i])\r\n",
    "prob_desc_created_at": "1659796500",
    "tags": [
        "2-sat",
        "data structures",
        "dsu",
        "greedy",
        "matrices"
    ],
    "hidden_unit_tests": ""
}
{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"1 3 2 5 4\", \"3 2 5 4 1\", \"5 4 2 6 7 8 3 9 1 10\"]",
    "src_uid": "5e715f2d2e4fe54df4b93619c53c8457",
    "prob_desc_notes": "NoteThe description of the first test is below:  The first picture shows the starting permutation, which is the answer. Then the students sitting at desks $$$1, 2$$$ are transferred to a $$$5$$$ desk. Also, a $$$1$$$ student moved from a $$$5$$$ desk, and a student from a $$$4$$$ disk is transferred to a $$$3$$$ desk.Thus, after all these transfers permutation shown in the second image is obtained. Then, at the desk with the number $$$5$$$, the student with the number $$$3$$$ is expelled, and at the desk with the number $$$3$$$, the student with the number $$$5$$$ is expelled. (Since their numbers are not the smallest) Then new students with numbers $$$6, 7$$$ sit at desks numbered $$$2, 4$$$. And this permutation (after the end of the first lesson) is shown in the third image.The $$$4$$$ image shows the seating arrangement, after the second lesson before all the extra ones were kicked out. And the fifth shows the final seating after $$$2$$$ lesson.",
    "prob_desc_description": "After the most stunning success with the fifth-graders, Madoka has been trusted with teaching the sixth-graders.There's $$$n$$$ single-place desks in her classroom. At the very beginning Madoka decided that the student number $$$b_i$$$ ($$$1 \\le b_i \\le n$$$) will sit at the desk number $$$i$$$. Also there's an infinite line of students with numbers $$$n + 1, n + 2, n + 3, \\ldots$$$ waiting at the door with the hope of being able to learn something from the Madoka herself. Pay attention that each student has his unique number.After each lesson, the following happens in sequence.   The student sitting at the desk $$$i$$$ moves to the desk $$$p_i$$$. All students move simultaneously.  If there is more than one student at a desk, the student with the lowest number keeps the place, and the others are removed from the class forever.  For all empty desks in ascending order, the student from the lowest number from the outside line occupies the desk. Note that in the end there is exactly one student at each desk again. It is guaranteed that the numbers $$$p$$$ are such that at least one student is removed after each lesson. Check out the explanation to the first example for a better understanding.After several (possibly, zero) lessons the desk $$$i$$$ is occupied by student $$$a_i$$$. Given the values $$$a_1, a_2, \\ldots, a_n$$$ and $$$p_1, p_2, \\ldots, p_n$$$, find the lexicographically smallest suitable initial seating permutation $$$b_1, b_2, \\ldots, b_n$$$.The permutation is an array of $$$n$$$ different integers from $$$1$$$ up to $$$n$$$ in any order. For example, $$$[2,3,1,5,4]$$$ is a permutation, but $$$[1,2,2]$$$ is not ($$$2$$$ occurs twice). $$$[1,3,4]$$$ is not a permutation either ($$$n=3$$$ but there's $$$4$$$ in the array).For two different permutations $$$a$$$ and $$$b$$$ of the same length, $$$a$$$ is lexicographically less than $$$b$$$ if in the first position where $$$a$$$ and $$$b$$$ differ, the permutation $$$a$$$ has a smaller element than the corresponding element in $$$b$$$.",
    "prob_desc_output_spec": "In the only line print $$$n$$$ integers $$$b_1, b_2, \\ldots, b_n$$$ ($$$1 \\le b_i \\le n$$$) — lexicographically minimum permutation describing the initial seating of the sixth-graders that can lead to the final seating $$$a$$$.",
    "prob_desc_input_spec": "The first line of input data contains an integer $$$n$$$ ($$$2 \\le n \\le 10^5$$$) — a number of desks in the classroom. The second line contains $$$n$$$ integers $$$p_1, p_2, \\ldots, p_n$$$ ($$$1 \\leq p_i \\leq n$$$) — desks where the students move. It is guaranteed that $$$p$$$ has at least two equal elements. The third line contains $$$n$$$ integers $$$a_1, a_2, \\ldots, a_n$$$ ($$$1 \\leq a_i \\leq 10^9$$$) — the final seating of the students. It is guaranteed that there is an initial permutation from which the seating $$$a$$$ can be obtained.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3-64",
    "lang_cluster": "Python",
    "difficulty": 2500,
    "file_name": "train_096.jsonl",
    "code_uid": "df1ada279d9f6b763242040ad66f9246",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"5\\n5 5 3 3 1\\n1 8 2 9 4\", \"5\\n1 3 2 5 2\\n3 2 5 4 1\", \"10\\n10 8 5 3 7 8 6 6 1 1\\n5 26 24 27 21 4 18 2 28 1\"]",
    "exec_outcome": "PASSED",
    "source_code": "import sys\r\nimport os\r\nfrom io import BytesIO, IOBase\r\nBUFSIZE = 8192\r\nclass FastIO(IOBase):\r\n    newlines = 0\r\n    def __init__(self, file):\r\n        self._fd = file.fileno()\r\n        self.buffer = BytesIO()\r\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\r\n        self.write = self.buffer.write if self.writable else None\r\n    def read(self):\r\n        while True:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            if not b:\r\n                break\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines = 0\r\n        return self.buffer.read()\r\n    def readline(self):\r\n        while self.newlines == 0:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            self.newlines = b.count(b\"\\n\") + (not b)\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines -= 1\r\n        return self.buffer.readline()\r\n    def flush(self):\r\n        if self.writable:\r\n            os.write(self._fd, self.buffer.getvalue())\r\n            self.buffer.truncate(0), self.buffer.seek(0)\r\nclass IOWrapper(IOBase):\r\n    def __init__(self, file):\r\n        self.buffer = FastIO(file)\r\n        self.flush = self.buffer.flush\r\n        self.writable = self.buffer.writable\r\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\r\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\r\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\r\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\r\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\r\n\r\ndef I():\r\n    return input()\r\ndef II():\r\n    return int(input())\r\ndef MI():\r\n    return map(int, input().split())\r\ndef LI():\r\n    return list(input().split())\r\ndef LII():\r\n    return list(map(int, input().split()))\r\ndef GMI():\r\n    return map(lambda x: int(x) - 1, input().split())\r\n\r\n#------------------------------FastIO---------------------------------\r\n\r\nfrom collections import *\r\nfrom heapq import *\r\ndef solve():\r\n    n = II()\r\n    P = LII()\r\n    A = LII()\r\n\r\n    sp = set(P)\r\n    r = (max(A) - n) // (n - len(sp))\r\n    if r == 0:\r\n        print(*A)\r\n        return\r\n    \r\n    m = r.bit_length()\r\n    #print(r, m)\r\n\r\n    st = [[-1 for _ in range(m + 1)] for _ in range(n + 1)]\r\n    for i in range(1, n + 1):\r\n        st[i][0] = P[i - 1]\r\n    for j in range(1, m):\r\n        for i in range(1, n + 1):\r\n            st[i][j] = st[st[i][j - 1]][j - 1]\r\n    #print(st)\r\n\r\n    froms = defaultdict(list)\r\n    cur = [i for i in range(n + 1)]\r\n    for i in range(m, -1, -1):\r\n        if (r >> i) & 1:\r\n            for j in range(1, n + 1):\r\n                cur[j] = st[cur[j]][i]\r\n    #print('cur', cur)\r\n    for i, v in enumerate(cur):\r\n        if i == 0:\r\n            continue\r\n        heappush(froms[v], i)\r\n    #print('froms', froms)\r\n\r\n    #minval -> idx#\r\n    helper_mn =  defaultdict(list)\r\n    pq_values = []\r\n    for v in froms:\r\n        hv = A[v - 1]\r\n        helper_mn[hv] = froms[v]\r\n    #print('min', helper_mn)\r\n\r\n    res = [-1 for _ in range(n + 1)]\r\n    S = set()\r\n    for v in helper_mn:\r\n        idx = heappop(helper_mn[v])\r\n        res[idx] = v\r\n        S.add(v)\r\n        if helper_mn[v]:\r\n            heappush(pq_values, v)\r\n    #print('res', res)\r\n    #print('S', S)\r\n    #print('pq', pq_values)\r\n\r\n    cur = 1\r\n    pq = []\r\n    while cur <= n:\r\n        while pq_values and pq_values[0] <= cur:\r\n            val = heappop(pq_values)\r\n            for idx in helper_mn[val]:\r\n                heappush(pq, idx)\r\n        #print(cur, pq)\r\n\r\n        if cur in S:\r\n            cur += 1\r\n            continue\r\n        else:\r\n            if not pq:\r\n                break\r\n            idx = heappop(pq)\r\n            res[idx] = cur\r\n            S.add(cur)\r\n            cur += 1\r\n            #print('res', res)\r\n            continue\r\n    \r\n    cur = 1\r\n    idx = 1\r\n    while cur <= n:\r\n        if cur not in S:\r\n            while idx <= n:\r\n                if res[idx] > n:\r\n                    res[idx] = cur\r\n                    idx += 1\r\n                    break\r\n                else:\r\n                    idx += 1\r\n            cur += 1\r\n        else:\r\n            cur += 1\r\n    print(*res[1:])\r\nsolve()",
    "prob_desc_created_at": "1647009300",
    "tags": [
        "data structures",
        "dfs and similar",
        "greedy"
    ],
    "hidden_unit_tests": ""
}
{
    "prob_desc_time_limit": "1 second",
    "prob_desc_sample_outputs": "[\"YES\\nYES\\nYES\\nNO\\nYES\\nYES\\nYES\"]",
    "src_uid": "95d83cfdb2131f2f23ba5ef005c18b38",
    "prob_desc_notes": "NoteIn the first test case, you can perform the second type operation on second and third elements so $$$a$$$ becomes $$$[0, 1]$$$, then you can perform the second type operation on first and second elements, so $$$a$$$ turns to $$$[1]$$$.In the fourth test case, it's obvious to see that you can't make any $$$1$$$, no matter what you do.In the fifth test case, you can first perform a type 2 operation on the first three elements so that $$$a$$$ becomes $$$[1, 0, 0, 1]$$$, then perform a type 2 operation on the elements in positions two through four, so that $$$a$$$ becomes $$$[1, 1]$$$, and finally perform the first type operation on the remaining elements, so that $$$a$$$ becomes $$$[1]$$$.",
    "prob_desc_description": "You have an array $$$a$$$ of size $$$n$$$ consisting only of zeroes and ones and an integer $$$k$$$. In one operation you can do one of the following:  Select $$$2$$$ consecutive elements of $$$a$$$ and replace them with their minimum (that is, let $$$a := [a_{1}, a_{2}, \\ldots, a_{i-1}, \\min(a_{i}, a_{i+1}), a_{i+2}, \\ldots, a_{n}]$$$ for some $$$1 \\le i \\le n-1$$$). This operation decreases the size of $$$a$$$ by $$$1$$$.  Select $$$k$$$ consecutive elements of $$$a$$$ and replace them with their maximum (that is, let $$$a := [a_{1}, a_{2}, \\ldots, a_{i-1}, \\max(a_{i}, a_{i+1}, \\ldots, a_{i+k-1}), a_{i+k}, \\ldots, a_{n}]$$$ for some $$$1 \\le i \\le n-k+1$$$). This operation decreases the size of $$$a$$$ by $$$k-1$$$. Determine if it's possible to turn $$$a$$$ into $$$[1]$$$ after several (possibly zero) operations.",
    "prob_desc_output_spec": "For each test case, if it is possible to turn $$$a$$$ into $$$[1]$$$, print \"YES\", otherwise print \"NO\".",
    "prob_desc_input_spec": "Each test contains multiple test cases. The first line contains the number of test cases $$$t$$$ ($$$1 \\le t \\le 1000$$$). The description of the test cases follows. The first line of each test case contains two integers $$$n$$$ and $$$k$$$ ($$$2 \\le k \\le n \\le 50$$$), the size of array $$$a$$$ and the length of segments that you can perform second type operation on. The second line contains $$$n$$$ integers $$$a_{1}, a_{2}, \\ldots, a_{n}$$$ ($$$a_i$$$ is $$$0$$$ or $$$1$$$), elements of array $$$a$$$.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3-64",
    "lang_cluster": "Python",
    "difficulty": 800,
    "file_name": "train_103.jsonl",
    "code_uid": "12e4e82b14ddd67c47abd9cffb715439",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"7\\n\\n3 2\\n\\n0 1 0\\n\\n5 3\\n\\n1 0 1 1 0\\n\\n2 2\\n\\n1 1\\n\\n4 4\\n\\n0 0 0 0\\n\\n6 3\\n\\n0 0 1 0 0 1\\n\\n7 5\\n\\n1 1 1 1 1 1 1\\n\\n5 3\\n\\n0 0 1 0 0\"]",
    "exec_outcome": "PASSED",
    "source_code": "from sys import stdin, setrecursionlimit, stdout\n#\tsetrecursionlimit(100000) #use \"python\" instead of \"pypy\" to avoid MLE\nfrom io import BytesIO\nimport os\nfrom collections import deque, Counter, defaultdict\nfrom math import sqrt, floor, ceil, log, log2, log10, pi, gcd, sin, cos, asin\nfrom heapq import heapify, heappop, heappush, heapreplace, heappushpop\n#\tto use maxheap, invert all the number.. that means, multyply with -1\nfrom bisect import bisect_right, bisect_left\n#\tnumber of elements in a range is bisect_right(a, el)-bisect_left(a, el)\nfrom string import ascii_letters, ascii_lowercase, ascii_uppercase, digits, hexdigits, whitespace, punctuation\n\n\ndef ii(): return int(input().decode()) if not DEBUG else int(input())\n\n\ndef fi(): return float(input().decode()) if not DEBUG else float(input())\n\n\ndef mi(): return map(int, input().decode().split()) if not DEBUG else map(int, input().split())\n\n\ndef fmi(): return map(float, input().decode().split()) if not DEBUG else map(float, input().split())\n\n\ndef li(): return list(mi())\n\n\ndef si(): return input().decode().rstrip() if not DEBUG else input().rstrip()\n\n\ndef lsi(): return list(si())\n\n\n#######################################################################################\n###########################    M Y     F U N C T I O N S    ###########################\n#######################################################################################\n\nclass TrieNode:\n\tdef __init__(self):\n\t\tself.count=0\n\t\tself.child={}\n\t\tself.end=False\n\nclass Trie:\n\tdef __init__(self):\n\t\tself.node=TrieNode()\n\n\tdef insert(self, word):\n\t\troot=self.node\n\t\tfor char in word:\n\t\t\tif char not in root.child:\n\t\t\t\troot.child[char]=TrieNode()\n\t\t\troot=root.child[char]\n\t\t\troot.count+=1\n\t\troot.end=True\n\n\tdef search(self, key):\n\t\troot=self.node\n\t\tfor char in key:\n\t\t\tif char not in root.child:\n\t\t\t\treturn False\n\t\t\troot=root.child[char]\n\t\treturn root.end\n\n\n\n\n\n\n\n\n\n#######################################################################################\n###########################    M A I N     P R O G R A M    ###########################\n#######################################################################################\n\ndef main():\n\tn, k=mi()\n\ta=li()\n\tprint(res[sum(a)!=0])\n\n\n\n\n\n\n\n\n\n\n\n\n\n#######################################################################################\n###########################    S T A R T E R     P A C K    ###########################\n#######################################################################################\n\nif __name__ == \"__main__\":\n\tDEBUG = os.environ.get(\"__DEBUG__\")\n\n\tif DEBUG:\n\t\tif os.stat(\"input.txt\").st_size == 0:\n\t\t\tinput = stdin.readline\n\t\telse:\n\t\t\tinput = open('input.txt', 'r').readline\n\telse:\n\t\tinput = BytesIO(os.read(0, os.fstat(0).st_size)).readline\n\n\tvow = {'A', 'E', 'I', 'O', 'U'}\n\tmod = 1000000007\n\tres = ['NO', 'YES']\n\n\ttest, test_case = 0, 1\n\ttest_case = ii()\n\n\twhile test < test_case:\n\t\ttest += 1\n\t\tif DEBUG:\n\t\t\tprint('>>>>>>>>>>>>> Case #{} >>>>>>>>>>>>>'.format(test))\n\t\t\tpass\n\t\t#print('Case ', test, ': ', sep='', end='')\n\t\tmain()\n",
    "prob_desc_created_at": "1665844500",
    "tags": [
        "constructive algorithms",
        "greedy"
    ],
    "hidden_unit_tests": ""
}
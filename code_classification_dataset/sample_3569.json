{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"FIRST\\n1 0 1 1\", \"SECOND\"]",
    "src_uid": "a7fa7a5ab71690fb3b5301bebc19956b",
    "prob_desc_notes": null,
    "prob_desc_description": "Two players play the following game. Initially, the players have a knife and a rectangular sheet of paper, divided into equal square grid cells of unit size. The players make moves in turn, the player who can't make a move loses. In one move, a player can take the knife and cut the paper along any segment of the grid line (not necessarily from border to border). The part of the paper, that touches the knife at least once, is considered cut. There is one limit not to turn the game into an infinite cycle: each move has to cut the paper, that is the knife has to touch the part of the paper that is not cut before.Obviously, the game ends when the entire sheet is cut into 1 × 1 blocks. During the game, the pieces of the sheet are not allowed to move. It is also prohibited to cut along the border. The coordinates of the ends of each cut must be integers.You are given an n × m piece of paper, somebody has already made k cuts there. Your task is to determine who will win if the players start to play on this sheet. You can consider that both players play optimally well. If the first player wins, you also need to find the winning first move.",
    "prob_desc_output_spec": "If the second player wins, print \"SECOND\". Otherwise, in the first line print \"FIRST\", and in the second line print any winning move of the first player (the coordinates of the cut ends, follow input format to print them).",
    "prob_desc_input_spec": "The first line contains three integers n, m, k (1 ≤ n, m ≤ 109, 0 ≤ k ≤ 105) — the sizes of the piece of paper and the number of cuts. Then follow k lines, each containing 4 integers xbi, ybi, xei, yei (0 ≤ xbi, xei ≤ n, 0 ≤ ybi, yei ≤ m) — the coordinates of the ends of the existing cuts.  It is guaranteed that each cut has a non-zero length, is either vertical or horizontal and doesn't go along the sheet border. The cuts may intersect, overlap and even be the same. That is, it is not guaranteed that the cuts were obtained during any correct game.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "Python 2",
    "lang_cluster": "Python",
    "difficulty": 2400,
    "file_name": "train_069.jsonl",
    "code_uid": "cb2fe6e222a22ee09939e5d7c2db22ad",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"2 1 0\", \"2 2 4\\n0 1 2 1\\n0 1 2 1\\n1 2 1 0\\n1 1 1 2\"]",
    "exec_outcome": "PASSED",
    "source_code": "from sys import stdin\nfrom collections import defaultdict\ndef emp(l, a):\n    cnt = pos = x = 0\n    for y in a:\n        if y[1]:\n            cnt -= 1\n        else:\n            if not cnt:\n                x += y[0] - pos\n            cnt += 1\n        pos = y[0]\n    x += l - pos\n    return x\ndef check(x, b):\n    return x ^ b < x\ndef f(x, b):\n    return x - (x ^ b)\ndef main():\n    n, m, k = map(int, stdin.readline().split())\n    xcut = defaultdict(list)\n    ycut = defaultdict(list)\n    for i in xrange(k):\n        xb, yb, xe, ye = map(int, stdin.readline().split())\n        if xb == xe:\n            xcut[xb].extend([(min(yb, ye), 0), (max(yb, ye), 1)])\n        else:\n            ycut[yb].extend([(min(xb, xe), 0), (max(xb, xe), 1)])\n    b = 0\n    xb = dict()\n    yb = dict()\n    for t in xcut.keys():\n        xcut[t].sort()\n        xb[t] = emp(m, xcut[t])\n        b ^= xb[t]\n    if (n - 1 - len(xcut)) % 2:\n        b ^= m\n    for t in ycut.keys():\n        ycut[t].sort()\n        yb[t] = emp(n, ycut[t])\n        b ^= yb[t]\n    if (m - 1 - len(ycut)) % 2:\n        b ^= n\n    if b == 0:\n        print \"SECOND\"\n        return\n    else:\n        print \"FIRST\"\n        if n - 1 - len(xcut) and check(m, b):\n            for i in xrange(1, n):\n                if i not in xcut:\n                    print i, 0, i, f(m, b)\n                    return\n        if m - 1 - len(ycut) and check(n, b):\n            for i in xrange(1, m):\n                if i not in ycut:\n                    print 0, i, f(n, b), i\n                    return\n        for t, a in xcut.items():\n            if not check(xb[t], b): continue\n            c = f(xb[t], b)\n            cnt = pos = x = 0\n            for y in a:\n                if y[1] == 0:\n                    if cnt == 0:\n                        if x <= c <= x + y[0] - pos:\n                            print t, 0, t, pos + c - x\n                            return\n                        x += y[0] - pos\n                    cnt += 1\n                else:\n                    cnt -= 1\n                pos = y[0]\n            print t, 0, t, pos + c - x\n            return\n        for t, a in ycut.items():\n            if not check(yb[t], b): continue\n            c = f(yb[t], b)\n            cnt = pos = x = 0\n            for y in a:\n                if y[1] == 0:\n                    if cnt == 0:\n                        if x <= c <= x + y[0] - pos:\n                            print 0, t, pos + c - x, t\n                            return\n                        x += y[0] - pos\n                    cnt += 1\n                else:\n                    cnt -= 1\n                    pos = y[0]\n            print 0, t, pos + c - x, t\n            return\nmain()\n",
    "prob_desc_created_at": "1362065400",
    "tags": [
        "implementation",
        "games"
    ],
    "hidden_unit_tests": ""
}
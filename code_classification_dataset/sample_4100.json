{
    "prob_desc_time_limit": "3 seconds",
    "prob_desc_sample_outputs": "[\"2\", \"0\", \"2\"]",
    "src_uid": "d78c61a218b250facd9b5bdd1b7e4dba",
    "prob_desc_notes": "NoteIn the first example, it is enough to replace the value on the vertex $$$1$$$ with $$$13$$$, and the value on the vertex $$$4$$$ with $$$42$$$.",
    "prob_desc_description": "You are given a tree consisting of $$$n$$$ vertices. A number is written on each vertex; the number on vertex $$$i$$$ is equal to $$$a_i$$$.Recall that a simple path is a path that visits each vertex at most once. Let the weight of the path be the bitwise XOR of the values written on vertices it consists of. Let's say that a tree is good if no simple path has weight $$$0$$$.You can apply the following operation any number of times (possibly, zero): select a vertex of the tree and replace the value written on it with an arbitrary positive integer. What is the minimum number of times you have to apply this operation in order to make the tree good?",
    "prob_desc_output_spec": "Print a single integer — the minimum number of times you have to apply the operation in order to make the tree good.",
    "prob_desc_input_spec": "The first line contains one integer $$$n$$$ ($$$1 \\le n \\le 2 \\cdot 10^5$$$) — the number of vertices. The second line contains $$$n$$$ integers $$$a_1$$$, $$$a_2$$$, ..., $$$a_n$$$ ($$$1 \\le a_i &lt; 2^{30}$$$) — the numbers written on vertices. Then $$$n - 1$$$ lines follow, each containing two integers $$$x$$$ and $$$y$$$ ($$$1 \\le x, y \\le n; x \\ne y$$$) denoting an edge connecting vertex $$$x$$$ with vertex $$$y$$$. It is guaranteed that these edges form a tree.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "Python 3",
    "lang_cluster": "Python",
    "difficulty": 2400,
    "file_name": "train_090.jsonl",
    "code_uid": "8f19d9efd49f638359974b42e3361016",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"6\\n3 2 1 3 2 1\\n4 5\\n3 4\\n1 4\\n2 1\\n6 1\", \"4\\n2 1 1 1\\n1 2\\n1 3\\n1 4\", \"5\\n2 2 2 2 2\\n1 2\\n2 3\\n3 4\\n4 5\"]",
    "exec_outcome": "PASSED",
    "source_code": "from __future__ import print_function\r\nfrom math import *\r\nfrom collections import defaultdict, deque\r\nimport os\r\nimport random\r\nimport sys\r\nfrom io import BytesIO, IOBase\r\nfrom types import GeneratorType\r\ndef bootstrap(f, stack=[]):\r\n    def wrappedfunc(*args, **kwargs):\r\n        if stack:\r\n            return f(*args, **kwargs)\r\n        else:\r\n            to = f(*args, **kwargs)\r\n            while True:\r\n                if type(to) is GeneratorType:\r\n                    stack.append(to)\r\n                    to = next(to)\r\n                else:\r\n                    stack.pop()\r\n                    if not stack:\r\n                        break\r\n                    to = stack[-1].send(to)\r\n            return to\r\n    return wrappedfunc\r\n#import time\r\n \r\ndef main():\r\n    pass\r\n \r\n# region fastio\r\n \r\nBUFSIZE = 8192\r\ndef lcm(a,b):\r\n    return (a*b)//gcd(a,b)\r\ndef ceilDiv(a,b):\r\n    if a%b==0:\r\n        return a//b\r\n    else:\r\n        return a//b+1\r\n \r\nclass FastIO(IOBase):\r\n    newlines = 0\r\n \r\n    def __init__(self, file):\r\n        self._fd = file.fileno()\r\n        self.buffer = BytesIO()\r\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\r\n        self.write = self.buffer.write if self.writable else None\r\n \r\n    def read(self):\r\n        while True:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            if not b:\r\n                break\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines = 0\r\n        return self.buffer.read()\r\n \r\n    def readline(self):\r\n        while self.newlines == 0:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            self.newlines = b.count(b\"\\n\") + (not b)\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines -= 1\r\n        return self.buffer.readline()\r\n \r\n    def flush(self):\r\n        if self.writable:\r\n            os.write(self._fd, self.buffer.getvalue())\r\n            self.buffer.truncate(0), self.buffer.seek(0)\r\n \r\n \r\nclass IOWrapper(IOBase):\r\n    def __init__(self, file):\r\n        self.buffer = FastIO(file)\r\n        self.flush = self.buffer.flush\r\n        self.writable = self.buffer.writable\r\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\r\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\r\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\r\nclass myDict:\r\n    def __init__(self,func):\r\n        self.RANDOM = random.randint(0,1<<32)\r\n        #self.RANDOM = random.randint(0,0)\r\n        self.default=func\r\n        self.dict={}\r\n    def __getitem__(self,key):\r\n        myKey=self.RANDOM^key\r\n        if myKey not in self.dict:\r\n            self.dict[myKey]=self.default()\r\n        return self.dict[myKey]\r\n    def __setitem__(self,key,item):\r\n        myKey=self.RANDOM^key\r\n        self.dict[myKey]=item\r\n    def __contains__(self,key):\r\n        return key^self.RANDOM in self.dict\r\n    def getKeys(self):\r\n        return [self.RANDOM^i for i in self.dict]\r\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\r\n#sys.stdin, sys.stdout =open(\"test.txt\",\"r\"),open(\"result.txt\",\"w\")\r\n#ini=time.time()\r\n\r\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\r\nmod=10**9+7\r\n############ ---- Input Functions ---- ############\r\ndef inp():\r\n    return(int(input()))\r\ndef inlt():\r\n    return(list(map(int,input().split())))\r\ndef insr():\r\n    s = input()\r\n    return(list(s[:len(s) ]))\r\ndef invr():\r\n    return(map(int,input().split()))\r\n@bootstrap\r\ndef dfs(node,parent):\r\n    global curxor,ans\r\n    curxor^=val[node]\r\n    maxnum=0\r\n    maxchild=-1\r\n    f=0\r\n    for child in l[node]:\r\n        if child!=parent:\r\n            yield dfs(child,node)\r\n            if maxnum<num[child]:\r\n                if maxchild!=-1:\r\n                    maxnum=num[child]\r\n                    maxchild,child=child,maxchild\r\n                    for j in d[child]:\r\n                        if j^val[node] in d[maxchild]:\r\n                            f=1\r\n                            break\r\n                    for j in d[child]:\r\n                        d[maxchild].add(j)\r\n                    d[child].clear()\r\n                    maxnum=len(d[maxchild])\r\n                else:\r\n                    maxnum=num[child]\r\n                    maxchild=child\r\n            if maxchild!=-1 and maxchild!=child:\r\n             \r\n                    for j in d[child]:\r\n                        if j^val[node] in d[maxchild]:\r\n                            f=1\r\n                            break\r\n                    for j in d[child]:\r\n                        d[maxchild].add(j)\r\n                    d[child].clear()\r\n                    maxnum=len(d[maxchild])\r\n    #val[node]=curxor\r\n    \r\n    # if maxchild!=-1:\r\n    #     for child in l[node]:\r\n    #         if child!=maxchild:\r\n    #             for j in d[child]:\r\n    #                 if j^val[node] in d[maxchild]:\r\n    #                     f=1\r\n    #                     break\r\n    #             for j in d[child]:\r\n    #                 d[maxchild].add(j)\r\n    #             d[child].clear()\r\n       # d[node]=d[maxchild]\r\n    if maxchild!=-1:\r\n        if val[node]^curxor in d[maxchild]:\r\n                    f=1\r\n    if f:\r\n        ans+=1\r\n    else:\r\n        if maxchild!=-1:\r\n            d[node]=d[maxchild]\r\n            \r\n        d[node].add(curxor)\r\n    #print(d[node],node)\r\n    num[node]=len(d[node])\r\n    curxor^=val[node]\r\n    yield None\r\n\r\nn=inp()\r\nval=inlt()\r\n\r\n\r\nl=[[] for i in range(n)]\r\n\r\nfor i in range(n-1):\r\n    a,b=invr()\r\n    l[a-1].append(b-1)\r\n    l[b-1].append(a-1)\r\nd=[set() for i in range(n)]\r\nnum=[0 for i in range(n)]\r\ncurxor=0\r\nans=0\r\ndfs(0,-1)\r\n#print([i.dict for i in d])\r\nprint(ans)",
    "prob_desc_created_at": "1658414100",
    "tags": [
        "bitmasks",
        "data structures",
        "dfs and similar",
        "dsu",
        "greedy",
        "trees"
    ],
    "hidden_unit_tests": ""
}
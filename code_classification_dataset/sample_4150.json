{
    "prob_desc_time_limit": "1.5 seconds",
    "prob_desc_sample_outputs": "[\"? 1 2 3\\n\\n? 2 3 5\\n\\n? 4 1 5\\n\\n! 7\", \"-1\"]",
    "src_uid": "5de2777a63c0c889da36c32df91744cf",
    "prob_desc_notes": "NoteIn the first example interaction, the array $$$a_1, a_2, \\ldots, a_n$$$ is $$$2, 1, 7, 5, 6$$$ and its XOR-sum is $$$7$$$. The first query made asks for indices $$$1,2,3$$$, so the response is $$$a_1 \\oplus a_2 \\oplus a_3 = 2 \\oplus 1 \\oplus 7 = 4$$$.The second query made asks for indices $$$2,3,5$$$, so the response is $$$a_2 \\oplus a_3 \\oplus a_5 = 1 \\oplus 7 \\oplus 6 = 0$$$.The third query made asks for indices $$$4,1,5$$$, so the response is $$$a_4 \\oplus a_1 \\oplus a_5 = 5 \\oplus 2 \\oplus 6 = 1$$$. Note that the indices may be output in any order.Additionally, even though three queries were made in the example interaction, it is just meant to demonstrate the interaction format and does not necessarily represent an optimal strategy.In the second example interaction, there is no way to recover the XOR-sum of Little Dormi's array no matter what is queried, so the program immediately outputs $$$-1$$$ and exits.",
    "prob_desc_description": "This is an interactive problem.Note: the XOR-sum of an array $$$a_1, a_2, \\ldots, a_n$$$ ($$$1 \\le a_i \\le 10^9$$$) is defined as $$$a_1 \\oplus a_2 \\oplus \\ldots \\oplus a_n$$$, where $$$\\oplus$$$ denotes the bitwise XOR operation.Little Dormi received an array of $$$n$$$ integers $$$a_1, a_2, \\ldots, a_n$$$ for Christmas. However, while playing with it over the winter break, he accidentally dropped it into his XOR machine, and the array got lost.The XOR machine is currently configured with a query size of $$$k$$$ (which you cannot change), and allows you to perform the following type of query: by giving the machine $$$k$$$ distinct indices $$$x_1, x_2, \\ldots, x_k$$$, it will output $$$a_{x_1} \\oplus a_{x_2} \\oplus \\ldots \\oplus a_{x_k}$$$.As Little Dormi's older brother, you would like to help him recover the XOR-sum of his array $$$a_1, a_2, \\ldots, a_n$$$ by querying the XOR machine.Little Dormi isn't very patient, so to be as fast as possible, you must query the XOR machine the minimum number of times to find the XOR-sum of his array. Formally, let $$$d$$$ be the minimum number of queries needed to find the XOR-sum of any array of length $$$n$$$ with a query size of $$$k$$$. Your program will be accepted if you find the correct XOR-sum in at most $$$d$$$ queries.Lastly, you also noticed that with certain configurations of the machine $$$k$$$ and values of $$$n$$$, it may not be possible to recover the XOR-sum of Little Dormi's lost array. If that is the case, you should report it as well.The array $$$a_1, a_2, \\ldots, a_n$$$ is fixed before you start querying the XOR machine and does not change with the queries.",
    "prob_desc_output_spec": "If it is impossible to recover the XOR-sum of the array, output $$$-1$$$ immediately after taking $$$n$$$ and $$$k$$$. Do not begin interaction. Otherwise, when your program finds the XOR-sum of the lost array $$$a_1, a_2, \\ldots, a_n$$$, report the answer in the following format: \"! x\", where $$$x$$$ is the XOR sum of the array $$$a_1, a_2, \\ldots, a_n$$$, and terminate your program normally immediately after flushing the output stream.  Note that answering does not count as a query.",
    "prob_desc_input_spec": "The only line of input contains the integers $$$n$$$ and $$$k$$$ ($$$1 \\le n \\le 500$$$, $$$1 \\le k \\le n$$$), the length of the lost array and the configured query size of the XOR machine. Elements of the original array satisfy $$$1 \\le a_i \\le 10^9$$$. It can be proven that that if it is possible to recover the XOR sum under the given constraints, it can be done in at most $$$500$$$ queries. That is, $$$d \\le 500$$$. After taking $$$n$$$ and $$$k$$$, begin interaction.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3",
    "lang_cluster": "Python",
    "difficulty": 2300,
    "file_name": "train_091.jsonl",
    "code_uid": "9ce5028c5c1cb040c2722a3ae409c71a",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"5 3\\n\\n4\\n\\n0\\n\\n1\", \"3 2\"]",
    "exec_outcome": "PASSED",
    "source_code": "from collections import deque\n\nn, k = map(int,input().split())\nif k%2==0 and n%2==1:\n    print(-1)\n    exit()\n\n\n\nqueue = deque()\nvisited = [ False for i in range(n)]\npre = [-1]*n\n\n\ndef getarr(add,front,rear,k,n):\n\n    nextrear = rear + (add + k)//2\n    nextfront = front + (k - add)//2\n    arr = [(i-1)%n + 1 for i in range(front,nextfront)] + [(i-1)%n + 1 for i in range(rear+1,nextrear+1)]\n    return [nextfront,nextrear,arr]\n\n    \n    \n    \n    \n        \n\n\n\n\n\n\nvisited[k-1] = True\nqueue.append(k-1)\n\nwhile queue:\n#    print(queue)\n    d = queue.popleft()\n\n    for diff in range(k,-k-1,-2):\n        front = (k + diff)//2\n        rear = (k-diff)//2\n        if d + front >= n:  continue \n        if rear > d + 1: continue \n        if d + diff < 0 or d + diff >=n: continue \n        if visited[d+diff]: continue \n \n\n        queue.append(diff+d)\n        visited[diff+d] = True\n        pre[diff+d] = d\n        \n        \n\n\n\nstack = []\nindex = n -1\nwhile True:\n    stack.append(index)\n    if pre[index]==-1: break\n    else:  index = pre[index]\nstack.append(-1)\nstack = stack[::-1]\n\n\n#print(stack)\nfront,rear = 1,0\n    \nans = 0     \nfor i in range(len(stack)-1):\n    [front,rear,arr] = getarr(stack[i+1]-stack[i],front,rear,k,n)\n#    print(front,rear)\n    print(\"? \"+\" \".join(map(str,arr))  )\n    temp = int(input())\n    ans = ans ^ temp\n\nprint(\"! \"+str(ans))\n         \n\n\n        \n        \n\n        \n\n",
    "prob_desc_created_at": "1623598500",
    "tags": [
        "graphs",
        "greedy",
        "interactive",
        "shortest paths"
    ],
    "hidden_unit_tests": ""
}
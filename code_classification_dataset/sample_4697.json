{
    "prob_desc_time_limit": "3 seconds",
    "prob_desc_sample_outputs": "[\"6\\n10\\n5\", \"7\\n9\\n8\"]",
    "src_uid": "8a3b87734e221d3ec613525d35eebfd5",
    "prob_desc_notes": "NoteHere are notes for first example.In first query, after update $$$a=[2,4,1,4]$$$. Now $$$(1,1)$$$, $$$(2,2)$$$, $$$(3,3)$$$, $$$(4,4)$$$, $$$(1,2)$$$, and $$$(3,4)$$$ are suitable pairs.In second query, after update $$$a=[2,4,3,4]$$$. Now all subarrays of $$$a$$$ are good.In third query, after update $$$a=[2,1,1,4]$$$. Now $$$(1,1)$$$, $$$(2,2)$$$, $$$(3,3)$$$, $$$(4,4)$$$, and $$$(3,4)$$$ are suitable.",
    "prob_desc_description": "This is the hard version of this problem. In this version, we have queries. Note that we do not have multiple test cases in this version. You can make hacks only if both versions of the problem are solved.An array $$$b$$$ of length $$$m$$$ is good if for all $$$i$$$ the $$$i$$$-th element is greater than or equal to $$$i$$$. In other words, $$$b$$$ is good if and only if $$$b_i \\geq i$$$ for all $$$i$$$ ($$$1 \\leq i \\leq m$$$).You are given an array $$$a$$$ consisting of $$$n$$$ positive integers, and you are asked $$$q$$$ queries. In each query, you are given two integers $$$p$$$ and $$$x$$$ ($$$1 \\leq p,x \\leq n$$$). You have to do $$$a_p := x$$$ (assign $$$x$$$ to $$$a_p$$$). In the updated array, find the number of pairs of indices $$$(l, r)$$$, where $$$1 \\le l \\le r \\le n$$$, such that the array $$$[a_l, a_{l+1}, \\ldots, a_r]$$$ is good.Note that all queries are independent, which means after each query, the initial array $$$a$$$ is restored. ",
    "prob_desc_output_spec": "For each query, print the number of suitable pairs of indices after making the change. ",
    "prob_desc_input_spec": "The first line contains a single integer $$$n$$$ ($$$1 \\le n \\le 2 \\cdot 10^5$$$). The second line contains $$$n$$$ integers $$$a_1, a_2, \\ldots, a_n$$$ ($$$1 \\le a_i \\le n$$$). The third line contains an integer $$$q$$$ ($$$1 \\leq q \\leq 2 \\cdot 10^5$$$) — the number of queries. Each of the next $$$q$$$ lines contains two integers $$$p_j$$$ and $$$x_j$$$ ($$$1 \\leq p_j, x_j \\leq n$$$) – the description of the $$$j$$$-th query.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3-64",
    "lang_cluster": "Python",
    "difficulty": 2400,
    "file_name": "train_103.jsonl",
    "code_uid": "cd37ebeee71d9c6e532a0e43305aa310",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"4\\n2 4 1 4\\n3\\n2 4\\n3 3\\n2 1\", \"5\\n1 1 3 2 1\\n3\\n1 3\\n2 5\\n4 5\"]",
    "exec_outcome": "PASSED",
    "source_code": "import random\r\nimport sys\r\nimport os\r\nimport math\r\nfrom collections import Counter, defaultdict, deque\r\nfrom functools import lru_cache, reduce\r\nfrom itertools import accumulate, combinations, permutations\r\nfrom heapq import nsmallest, nlargest, heapify, heappop, heappush\r\nfrom io import BytesIO, IOBase\r\nfrom copy import deepcopy\r\nimport threading\r\nimport bisect\r\nBUFSIZE = 4096\r\n\r\n\r\nclass FastIO(IOBase):\r\n    newlines = 0\r\n\r\n    def __init__(self, file):\r\n        self._fd = file.fileno()\r\n        self.buffer = BytesIO()\r\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\r\n        self.write = self.buffer.write if self.writable else None\r\n\r\n    def read(self):\r\n        while True:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            if not b:\r\n                break\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines = 0\r\n        return self.buffer.read()\r\n\r\n    def readline(self):\r\n        while self.newlines == 0:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            self.newlines = b.count(b\"\\n\") + (not b)\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines -= 1\r\n        return self.buffer.readline()\r\n\r\n    def flush(self):\r\n        if self.writable:\r\n            os.write(self._fd, self.buffer.getvalue())\r\n            self.buffer.truncate(0), self.buffer.seek(0)\r\n\r\nclass IOWrapper(IOBase):\r\n    def __init__(self, file):\r\n        self.buffer = FastIO(file)\r\n        self.flush = self.buffer.flush\r\n        self.writable = self.buffer.writable\r\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\r\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\r\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\r\n\r\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\r\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\r\n\r\ndef I():\r\n    return input()\r\n\r\ndef II():\r\n    return int(input())\r\n\r\ndef MI():\r\n    return map(int, input().split())\r\n\r\ndef LI():\r\n    return list(input().split())\r\n\r\ndef LII():\r\n    return list(map(int, input().split()))\r\n\r\ndef GMI():\r\n    return map(lambda x: int(x) - 1, input().split())\r\n\r\ndef LGMI():\r\n    return list(map(lambda x: int(x) - 1, input().split()))\r\n\r\nn = II()\r\nnums = [0] + LII()\r\nnums = [idx - val for idx, val in enumerate(nums)]\r\nprefix_maximum = list(accumulate(nums, max))\r\nprefix_maximum_presum = list(accumulate(prefix_maximum))\r\nq = II()\r\nqueries = []\r\nfor idx in range(q): queries.append((idx, LII()))\r\ntot = n * (n + 1) // 2\r\nqueries.sort(key=lambda x: x[1][0])\r\nans = [0] * q\r\n\r\nstack_nums = []\r\nacc_sum = [0]\r\nacc_count = [0]\r\nqueries_pt = q-1\r\nfor i in range(n, 0, -1):\r\n    while queries_pt >= 0 and queries[queries_pt][1][0] == i:\r\n        val = max(prefix_maximum[i-1], queries[queries_pt][1][0] - queries[queries_pt][1][1])\r\n        l, r = 0, len(stack_nums) - 1\r\n        while l <= r:\r\n            m = (l + r) // 2\r\n            if stack_nums[m][0] < val: r = m - 1\r\n            else: l = m + 1\r\n        ans[queries[queries_pt][0]] = n * (n + 1) // 2 - (prefix_maximum_presum[queries[queries_pt][1][0] - 1] + acc_sum[l] + (acc_count[-1] - acc_count[l] + 1) * val)\r\n        queries_pt -= 1\r\n    if queries_pt < 0: break\r\n    v, cnt = nums[i], 1\r\n    while len(stack_nums) and stack_nums[-1][0] <= v:\r\n        _, new_cnt = stack_nums.pop()\r\n        acc_sum.pop()\r\n        acc_count.pop()\r\n        cnt += new_cnt\r\n    stack_nums.append((v, cnt))\r\n    acc_sum.append(acc_sum[-1] + v * cnt)\r\n    acc_count.append(acc_count[-1] + cnt)\r\nprint(*ans)",
    "prob_desc_created_at": "1665412500",
    "tags": [
        "binary search",
        "data structures",
        "dp",
        "two pointers"
    ],
    "hidden_unit_tests": ""
}
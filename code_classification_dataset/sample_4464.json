{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"3\\n4\\n1\\n4\\n3\\n1\\n1608737403\"]",
    "src_uid": "bf21c4809cd10904f05d531dd7af4ab5",
    "prob_desc_notes": "NoteLet's analyze the test cases of the example.  In the first test case, you write three messages containing $$$1$$$, $$$2$$$ and $$$3$$$ emotes respectively, and since $$$1 + 2 + 3 \\ge 6$$$, you get banned after that.  In the second test case, you write four messages containing $$$1$$$, $$$2$$$, $$$3$$$ and $$$4$$$ emotes respectively, and since $$$1 + 2 + 3 + 4 \\ge 7$$$, you get banned after that.  In the third test case, you write one message containing exactly $$$1$$$ emote. It doesn't get you banned, since $$$1 &lt; 2$$$, but you have already finished posting your emote triangle. So you wrote one message successfully.  In the fourth test case, you write four messages containing $$$1$$$, $$$2$$$, $$$3$$$ and $$$2$$$ emotes respectively, and since $$$1 + 2 + 3 + 2 \\ge 7$$$, you get banned after that.  In the fifth test case, you write three messages containing $$$1$$$, $$$2$$$ and $$$1$$$ emote respectively. It doesn't get you banned, since $$$1 + 2 + 1 &lt; 5$$$, but you have already finished posting your emote triangle. So you wrote three messages successfully.  In the sixth test case, since $$$x = 1$$$, you get banned as soon as you send your first message.  The seventh test case is too large to analyze, so we'll skip it. ",
    "prob_desc_description": "You are a usual chat user on the most famous streaming platform. Of course, there are some moments when you just want to chill and spam something.More precisely, you want to spam the emote triangle of size $$$k$$$. It consists of $$$2k-1$$$ messages. The first message consists of one emote, the second one — of two emotes, ..., the $$$k$$$-th one — of $$$k$$$ emotes, the $$$k+1$$$-th one — of $$$k-1$$$ emotes, ..., and the last one — of one emote.For example, the emote triangle for $$$k=3$$$ consists of $$$5$$$ messages:  Of course, most of the channels have auto moderation. Auto moderator of the current chat will ban you right after you spam at least $$$x$$$ emotes in succession (you can assume you are the only user in the chat). Now you are interested — how many messages will you write before getting banned? Or maybe you will not get banned at all (i.e. will write all $$$2k-1$$$ messages and complete your emote triangle successfully)? Note that if you get banned as a result of writing a message, this message is also counted.You have to answer $$$t$$$ independent test cases.",
    "prob_desc_output_spec": "For each test case, print the number of messages you will write before getting banned for the corresponding values $$$k$$$ and $$$x$$$.",
    "prob_desc_input_spec": "The first line of the input contains one integer $$$t$$$ ($$$1 \\le t \\le 10^4$$$) — the number of test cases. The next $$$t$$$ lines describe test cases. The only line of the test case contains integers $$$k$$$ and $$$x$$$ ($$$1 \\le k \\le 10^9; 1 \\le x \\le 10^{18}$$$).",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3-64",
    "lang_cluster": "Python",
    "difficulty": 1300,
    "file_name": "train_098.jsonl",
    "code_uid": "177b9b58b3139380bcfdec4242f2708b",
    "prob_desc_memory_limit": "512 megabytes",
    "prob_desc_sample_inputs": "[\"7\\n4 6\\n4 7\\n1 2\\n3 7\\n2 5\\n100 1\\n1000000000 923456789987654321\"]",
    "exec_outcome": "PASSED",
    "source_code": "from heapq import heapify, heappush, heappop\nfrom collections import Counter, defaultdict, deque\nfrom queue import PriorityQueue\nfrom itertools import combinations, product, permutations\nfrom bisect import bisect_left, bisect_right\nfrom functools import lru_cache\nfrom sys import stdin, stdout # for input /output\nimport copy\nimport math\nimport array as arr\n\n# import sys\n# sys.setrecursionlimit(100000)\n####################\n# stdin = open(\"testcase.txt\")\n# def input():\n\t# \treturn stdin.readline().strip()\n\n#####################################################################\n\nclass FastIO:\n\n\t@classmethod\n\tdef input(cls):\n\t\tfrom sys import stdin\n\t\tx = stdin.buffer.readline().decode().strip()\n\t\treturn x\n\n\t@classmethod\n\tdef integer_list(cls):\n\t\treturn list(map(int, cls.input().split()))\n\n\t@classmethod\n\tdef print(cls, s = \"\", end = \"\\n\"):\n\t\tfrom sys import stdout\n\t\tstdout.write(str(s) + end)\n\n\t@classmethod\n\tdef flush(cls):\n\t\tfrom sys import stdout\n\t\tstdout.flush()\n\n\n####################################################################\n\nclass SegmentTree:\n\tdef __init__(self, data, default=0, func=lambda a, b: a + b):\n\t\t\"\"\"initialize the segment tree with data\"\"\"\n\t\t\"\"\" initial default value for each node \"\"\"\n\t\t\"\"\" func which you want to apply to range \"\"\"\n\t\tself._default = default\n\t\tself._func = func\n\t\tself._len = len(data)\n\t\tself._size = _size = 1 << (self._len - 1).bit_length()\n \n\t\tself.data = [default] * (2 * _size)\n\t\tself.data[_size:_size + self._len] = data\n\t\tfor i in reversed(range(_size)):\n\t\t\tself.data[i] = func(self.data[2*i], self.data[2*i + 1])\n \n\tdef __delitem__(self, idx):\n\t\t\"\"\" delete item set item value to its default \"\"\"\n\t\tself[idx] = self._default\n \n\tdef __getitem__(self, idx):\n\t\t\"\"\" geting item by inx \"\"\"\n\t\treturn self.data[idx + self._size]\n \n\tdef __setitem__(self, idx, value):\n\t\t\"\"\" changing seting value to given index\"\"\"\n\t\t\"\"\" apply function to range \"\"\"\n\t\tidx += self._size\n\t\tself.data[idx] = value\n\t\tidx >>= 1\n\t\twhile idx:\n\t\t\tself.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])\n\t\t\tidx >>= 1\n \n\tdef __len__(self):\n\t\treturn self._len\n \n\tdef query(self, start, stop):\n\t\t\"\"\"func of data[start, stop)\"\"\"\n\t\tstart += self._size\n\t\tstop += self._size\n \n\t\tres_left = res_right = self._default\n\t\twhile start < stop:\n\t\t\tif start & 1:\n\t\t\t\tres_left = self._func(res_left, self.data[start])\n\t\t\t\tstart += 1\n\t\t\tif stop & 1:\n\t\t\t\tstop -= 1\n\t\t\t\tres_right = self._func(self.data[stop], res_right)\n\t\t\tstart >>= 1\n\t\t\tstop >>= 1\n \n\t\treturn self._func(res_left, res_right)\n \n\tdef __repr__(self):\n\t\treturn \"SegmentTree({0})\".format(self.data)\n\n#####################################################################\nclass BinaryIndexTree(object):\n\t\"\"\" use one indexing \"\"\"\n\tdef __init__(self, nums):\n\t\tn = len(nums)\n\t\tself._len = len(nums)\n\t\tself.nums = [0 for _ in range(n+1)]\n\t\tself.N = [0 for _ in range(n+1)]\n\t\tfor i, v in enumerate(nums):\n\t\t\tself.__setitem__(i+1, v)\n\n\tdef _lowbit(self, a):\n\t\treturn a & -a\n\n\tdef  __setitem__(self, i, val):\n\t\tdiff = val - self.nums[i]\n\t\tself.nums[i] = val\n\t\twhile i < len(self.N):\n\t\t\tself.N[i] += diff\n\t\t\ti += self._lowbit(i)\n\n\tdef __getitem__(self, i):\n\t\t# return sum up 0 to i\n\t\tret = 0\n\t\twhile i > 0:\n\t\t\tret += self.N[i]\n\t\t\ti -= self._lowbit(i)\n\n\t\treturn ret\n\n######################################################################\nclass DisJointSetsRank():\n    def __init__(self,N):\n        # Initially, all elements are single element subsets\n        self._parents = [node for node in range(N)]\n        self._ranks = [1 for _ in range(N)]\n    \n    def find(self, u):\n        while u != self._parents[u]: \n            # path compression technique\n            self._parents[u] = self._parents[self._parents[u]]\n            u = self._parents[u]\n        return u\n    \n    def connected(self, u, v):\n        return self.find(u) == self.find(v)\n    \n    def union(self, u, v):\n        # Union by rank optimization\n        root_u, root_v = self.find(u), self.find(v)\n        if root_u == root_v:\n            return True\n        if self._ranks[root_u] > self._ranks[root_v]:\n            self._parents[root_v] = root_u\n        elif self._ranks[root_v] > self._ranks[root_u]:\n            self._parents[root_u] = root_v\n        else:\n            self._parents[root_u] = root_v\n            self._ranks[root_v] += 1\n        return False\n\n\n#######################################################################\n\ndef integer_list():\n\treturn list(map(int, input().split()))\n\ndef pprint(matrix):\n\tfor i in range(len(matrix)):\n\t\tprint(*matrix[i])\n\n\n#####################################################\n#test case section \n\"\"\"\n1 2 \n3 --> 1, 3\n4 ---> 1, 4\n5 --> 1, 2, 3, 5\n6 --> 1, 2\n1 ..... k k-1 ...> 1\nn*(n+1)//2 \n\nn*(n+1)//2 <= x\nn**2 + n - 2x <= 0\n-1 + sqrt(1+8x)//2\n\nk-1 + k -2 ..... x\n\ntotal -  y*(y+1)//2 <= rem_x\n\n0 <= y**2 + y + 2*rem_x - 2*total\n\ny = -1 + sqrt(1 - 8(rem_x - totoal))//2\n\n\n\n\"\"\"       \n#############################################################\n# for manipulating 0 for runing to your system 1 for online \n\n\t\n\nMOD = 10**9+7\n\nONLINE_JUDGE = 1\n\n\n\n\n\ndef main():\n\tt = int(input())\n\tfor _ in range(t):\n\t\tk, x = integer_list()\n\n\n\t\ts_k = k*(k+1)//2\n\n\t\ts_k_1 = (k-1)*k\n\t\ts_k_1 = s_k_1//2\n\n\t\tif s_k + s_k_1 <= x:\n\t\t\tprint(2*k - 1)\n\t\t\tcontinue\n\n\t\tif s_k == x:\n\t\t\tprint(k)\n\t\telif s_k > x:\n\t\t\ts = 1 \n\t\t\te = k\n\t\t\tans = 1\n\t\t\tflag = False\n\t\t\twhile s <= e:\n\t\t\t\tmid = (s + e)//2\n\n\t\t\t\tsum_mid = (mid*(mid + 1))//2\n\t\t\t\tif x == sum_mid:\n\t\t\t\t\tflag = True\n\t\t\t\t\tans = mid\n\t\t\t\t\tbreak\n\t\t\t\tif x > sum_mid:\n\t\t\t\t\tans = mid + 1\n\t\t\t\t\ts = mid+1\n\t\t\t\telse:\n\t\t\t\t\te = mid - 1\n\t\t\t\n\t\t\tprint(ans)\n\t\t\t\n\t\t\t\n\t\telse:\n\t\t\tcount = k\n\t\t\ts = k -1 \n\t\t\te = 1\n\t\t\trem_x = x - s_k\n\t\t\tans = k-1\n\t\t\tflag = False\n\t\t\t\n\t\t\twhile s >= e:\n\n\t\t\t\tmid = (s+e)//2\n\t\t\t\tmid_s = s_k_1 - ((mid - 1)*mid)//2\n\n\t\t\t\tif rem_x == mid_s:\n\t\t\t\t\tflag = True\n\t\t\t\t\tans = mid\n\t\t\t\t\tbreak\n\n\t\t\t\tif rem_x > mid_s:\n\t\t\t\t\tans = mid - 1\n\t\t\t\t\ts = mid - 1\n\t\t\t\telse:\n\t\t\t\t\te = mid + 1\n\t\t\t\n\t\t\tprint(count + k - ans)\n\n\t\t\n\n\n\n\n\n\t\t\n\t\t\n\t\t\n\t\n\n\n\t\t\n\n\n###############################################\n\nif ONLINE_JUDGE:\n\tinput = lambda : stdin.buffer.readline().decode().strip()\nelse:\n\tstdin = open(\"testcase.txt\")\n\tinput = lambda : stdin.readline().strip()\n\t\n\nmain()\t\t\n\t\n\n\n\n",
    "prob_desc_created_at": "1637573700",
    "tags": [
        "binary search",
        "math"
    ],
    "hidden_unit_tests": ""
}
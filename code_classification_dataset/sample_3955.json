{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"35\\n30\\n42\\n0\\n0\"]",
    "src_uid": "f5a0dbef2aed164d83759e797569aef1",
    "prob_desc_notes": "NoteIn the first test case optimal sequence of solving problems is as follows:   $$$1 \\rightarrow 2$$$, after that total score is $$$5$$$ and $$$\\text{IQ} = 2$$$  $$$2 \\rightarrow 3$$$, after that total score is $$$10$$$ and $$$\\text{IQ} = 4$$$  $$$3 \\rightarrow 1$$$, after that total score is $$$20$$$ and $$$\\text{IQ} = 6$$$  $$$1 \\rightarrow 4$$$, after that total score is $$$35$$$ and $$$\\text{IQ} = 14$$$ In the second test case optimal sequence of solving problems is as follows:   $$$1 \\rightarrow 2$$$, after that total score is $$$5$$$ and $$$\\text{IQ} = 2$$$  $$$2 \\rightarrow 3$$$, after that total score is $$$10$$$ and $$$\\text{IQ} = 4$$$  $$$3 \\rightarrow 4$$$, after that total score is $$$15$$$ and $$$\\text{IQ} = 8$$$  $$$4 \\rightarrow 1$$$, after that total score is $$$35$$$ and $$$\\text{IQ} = 14$$$ In the third test case optimal sequence of solving problems is as follows:   $$$1 \\rightarrow 3$$$, after that total score is $$$17$$$ and $$$\\text{IQ} = 6$$$  $$$3 \\rightarrow 4$$$, after that total score is $$$35$$$ and $$$\\text{IQ} = 8$$$  $$$4 \\rightarrow 2$$$, after that total score is $$$42$$$ and $$$\\text{IQ} = 12$$$ ",
    "prob_desc_description": "Please note the non-standard memory limit.There are $$$n$$$ problems numbered with integers from $$$1$$$ to $$$n$$$. $$$i$$$-th problem has the complexity $$$c_i = 2^i$$$, tag $$$tag_i$$$ and score $$$s_i$$$.After solving the problem $$$i$$$ it's allowed to solve problem $$$j$$$ if and only if $$$\\text{IQ} &lt; |c_i - c_j|$$$ and $$$tag_i \\neq tag_j$$$. After solving it your $$$\\text{IQ}$$$ changes and becomes $$$\\text{IQ} = |c_i - c_j|$$$ and you gain $$$|s_i - s_j|$$$ points.Any problem can be the first. You can solve problems in any order and as many times as you want.Initially your $$$\\text{IQ} = 0$$$. Find the maximum number of points that can be earned.",
    "prob_desc_output_spec": "For each test case print a single integer  — the maximum number of points that can be earned.",
    "prob_desc_input_spec": "The first line contains a single integer $$$t$$$ $$$(1 \\le t \\le 100)$$$  — the number of test cases.  The first line of each test case contains an integer $$$n$$$ $$$(1 \\le n \\le 5000)$$$  — the number of problems. The second line of each test case contains $$$n$$$ integers $$$tag_1, tag_2, \\ldots, tag_n$$$ $$$(1 \\le tag_i \\le n)$$$  — tags of the problems. The third line of each test case contains $$$n$$$ integers $$$s_1, s_2, \\ldots, s_n$$$ $$$(1 \\le s_i \\le 10^9)$$$  — scores of the problems. It's guaranteed that sum of $$$n$$$ over all test cases does not exceed $$$5000$$$.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3-64",
    "lang_cluster": "Python",
    "difficulty": 2500,
    "file_name": "train_087.jsonl",
    "code_uid": "c0b618e2fcc84f64117b21a2bff7378b",
    "prob_desc_memory_limit": "32 megabytes",
    "prob_desc_sample_inputs": "[\"5\\n4\\n1 2 3 4\\n5 10 15 20\\n4\\n1 2 1 2\\n5 10 15 20\\n4\\n2 2 4 1\\n2 8 19 1\\n2\\n1 1\\n6 9\\n1\\n1\\n666\"]",
    "exec_outcome": "PASSED",
    "source_code": "import os,sys\r\nfrom random import randint, shuffle\r\nfrom io import BytesIO, IOBase\r\n\r\nfrom collections import defaultdict,deque,Counter\r\nfrom bisect import bisect_left,bisect_right\r\nfrom heapq import heappush,heappop\r\nfrom functools import lru_cache\r\nfrom itertools import accumulate, permutations\r\nimport math\r\n\r\n# Fast IO Region\r\nBUFSIZE = 8192\r\nclass FastIO(IOBase):\r\n    newlines = 0\r\n    def __init__(self, file):\r\n        self._fd = file.fileno()\r\n        self.buffer = BytesIO()\r\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\r\n        self.write = self.buffer.write if self.writable else None\r\n    def read(self):\r\n        while True:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            if not b:\r\n                break\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines = 0\r\n        return self.buffer.read()\r\n    def readline(self):\r\n        while self.newlines == 0:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            self.newlines = b.count(b\"\\n\") + (not b)\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines -= 1\r\n        return self.buffer.readline()\r\n    def flush(self):\r\n        if self.writable:\r\n            os.write(self._fd, self.buffer.getvalue())\r\n            self.buffer.truncate(0), self.buffer.seek(0)\r\nclass IOWrapper(IOBase):\r\n    def __init__(self, file):\r\n        self.buffer = FastIO(file)\r\n        self.flush = self.buffer.flush\r\n        self.writable = self.buffer.writable\r\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\r\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\r\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\r\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\r\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\r\n\r\n# for _ in range(int(input())):\r\n#     n = int(input())\r\n#     a = list(map(int, input().split()))\r\n\r\n# for _ in range(int(input())):\r\n#     n = int(input())\r\n#     a = list(map(int, input().split()))\r\n#     a.sort()\r\n#     b = []\r\n#     st = set()\r\n#     c = []\r\n#     for i in range(n):\r\n#         if a[i] in st:\r\n#             c.append(a[i])\r\n#         else:\r\n#             b.append(a[i])\r\n#             st.add(a[i])\r\n#     print(*(b + c))\r\n\r\n# for _ in range(int(input())):\r\n#     n, m = list(map(int, input().split()))\r\n#     a = list(map(int, input().split()))\r\n#     for i in range(n):\r\n#         a[i] %= m\r\n#     cnt = [0] * m\r\n#     for i in range(n):\r\n#         cnt[a[i]] += 1\r\n#     # print(cnt)\r\n#     ans = 0\r\n#     if cnt[0] > 0:\r\n#         ans += 1\r\n#     for i in range(1, (m - 1) // 2 + 1):\r\n#         x, y = cnt[i], cnt[m - i]\r\n#         if x == y == 0: continue\r\n#         if x < y: x, y = y, x\r\n#         if x - y <= 1:\r\n#             ans += 1\r\n#         else:\r\n#             ans += x - y\r\n#     if m % 2 == 0:\r\n#         ans += (cnt[m // 2] > 0)\r\n#     print(ans)\r\n\r\n# for _ in range(int(input())):\r\n#     n, k = list(map(int, input().split()))\r\n#     ans = []\r\n#     for i in range(k - 3):\r\n#         ans.append(1)\r\n#         k -= 1\r\n#         n -= 1\r\n#     r = 1\r\n#     while n % 2 == 0:\r\n#         r *= 2\r\n#         n //= 2\r\n#     if n == 1:\r\n#         n = 4\r\n#         r //= 4\r\n#         ans += [2 * r, r, r]\r\n#     else:\r\n#         ans += [n // 2 * r, n // 2 * r, r]\r\n#     print(*ans)\r\n\r\n# N = int(pow(10 ** 9, 0.5)) + 5\r\n# def get_prime_linear(n):\r\n#     global cnt\r\n#     for i in range(2, n + 1):\r\n#         if not st[i]:\r\n#             primes[cnt] = i\r\n#             cnt += 1\r\n#         for j in range(n):\r\n#             if primes[j] > n / i: break\r\n#             st[primes[j] * i] = True\r\n#             if i % primes[j] == 0: break \r\n# primes, cnt, st = [0] * (N + 5), 0, [False] * (N + 5)\r\n# get_prime_linear(N)\r\n# prime1e3 = primes[:cnt]\r\n# @lru_cache(None)\r\n# def get_factor(n):\r\n#     res = []\r\n#     for i in prime1e3:\r\n#         if i * i > n:\r\n#             break\r\n#         while n % i == 0:\r\n#             n //= i\r\n#             res.append(i)\r\n#     if n > 1:\r\n#         res.append(n)\r\n#     return res\r\n\r\n# for _ in range(int(input())):\r\n#     n, k = list(map(int, input().split()))\r\n#     a = list(map(int, input().split()))\r\n#     for i in range(n):\r\n#         f = get_factor(a[i])\r\n#         st = set()\r\n#         for j in f:\r\n#             if j in st:\r\n#                 st.remove(j)\r\n#             else:\r\n#                 st.add(j)\r\n#         a[i] = 1\r\n#         for j in st:\r\n#             a[i] *= j\r\n#     print(a)\r\n#     ans = 0\r\n#     st = set()\r\n#     for i in range(n):\r\n#         if a[i] in st:\r\n#             st = set()\r\n#             st.add(a[i])\r\n#             ans += 1\r\n#         else:\r\n#             st.add(a[i])\r\n#     print(ans + 1)\r\n\r\nfor _ in range(int(input())):\r\n    n = int(input())\r\n    a = list(map(int, input().split()))\r\n    s = list(map(int, input().split()))\r\n    dp = [0] * n\r\n    for i in range(n):\r\n        for j in range(i)[::-1]:\r\n            if a[i] != a[j]:\r\n                dp[i], dp[j] = max(dp[i], dp[j] + abs(s[i] - s[j])), max(dp[j], dp[i] + abs(s[i] - s[j]))\r\n    print(max(dp))",
    "prob_desc_created_at": "1615991700",
    "tags": [
        "bitmasks",
        "dp",
        "graphs",
        "number theory"
    ],
    "hidden_unit_tests": ""
}
{
    "prob_desc_time_limit": "1 second",
    "prob_desc_sample_outputs": "[\"Yes\\nYes\\nYes\\nNo\\nNo\\nYes\\nYes\\nYes\\nYes\\nNo\"]",
    "src_uid": "b9d5e58459baf2a2c294225b73b7229b",
    "prob_desc_notes": "NoteIn the first and the second test case of the first test, the given array is already sharpened.In the third test case of the first test, we can transform the array into $$$[3, 11, 15, 9, 7, 4]$$$ (decrease the first element $$$97$$$ times and decrease the last element $$$4$$$ times). It is sharpened because $$$3 &lt; 11 &lt; 15$$$ and $$$15 &gt; 9 &gt; 7 &gt; 4$$$.In the fourth test case of the first test, it's impossible to make the given array sharpened.",
    "prob_desc_description": "You're given an array $$$a_1, \\ldots, a_n$$$ of $$$n$$$ non-negative integers.Let's call it sharpened if and only if there exists an integer $$$1 \\le k \\le n$$$ such that $$$a_1 &lt; a_2 &lt; \\ldots &lt; a_k$$$ and $$$a_k &gt; a_{k+1} &gt; \\ldots &gt; a_n$$$. In particular, any strictly increasing or strictly decreasing array is sharpened. For example:  The arrays $$$[4]$$$, $$$[0, 1]$$$, $$$[12, 10, 8]$$$ and $$$[3, 11, 15, 9, 7, 4]$$$ are sharpened;  The arrays $$$[2, 8, 2, 8, 6, 5]$$$, $$$[0, 1, 1, 0]$$$ and $$$[2, 5, 6, 9, 8, 8]$$$ are not sharpened. You can do the following operation as many times as you want: choose any strictly positive element of the array, and decrease it by one. Formally, you can choose any $$$i$$$ ($$$1 \\le i \\le n$$$) such that $$$a_i&gt;0$$$ and assign $$$a_i := a_i - 1$$$.Tell if it's possible to make the given array sharpened using some number (possibly zero) of these operations.",
    "prob_desc_output_spec": "For each test case, output a single line containing \"Yes\" (without quotes) if it's possible to make the given array sharpened using the described operations, or \"No\" (without quotes) otherwise.",
    "prob_desc_input_spec": "The input consists of multiple test cases. The first line contains a single integer $$$t$$$ ($$$1 \\le t \\le 15\\ 000$$$)  — the number of test cases. The description of the test cases follows. The first line of each test case contains a single integer $$$n$$$ ($$$1 \\le n \\le 3 \\cdot 10^5$$$). The second line of each test case contains a sequence of $$$n$$$ non-negative integers $$$a_1, \\ldots, a_n$$$ ($$$0 \\le a_i \\le 10^9$$$). It is guaranteed that the sum of $$$n$$$ over all test cases does not exceed $$$3 \\cdot 10^5$$$.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 2",
    "lang_cluster": "Python",
    "difficulty": 1300,
    "file_name": "train_001.jsonl",
    "code_uid": "faebc18944e21145ecf997ccb026c58b",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"10\\n1\\n248618\\n3\\n12 10 8\\n6\\n100 11 15 9 7 8\\n4\\n0 1 1 0\\n2\\n0 0\\n2\\n0 1\\n2\\n1 0\\n2\\n1 1\\n3\\n0 1 0\\n3\\n1 0 1\"]",
    "exec_outcome": "PASSED",
    "source_code": "#!/usr/bin/env pypy\nfrom __future__ import division, print_function\n\nimport os\nimport sys\nfrom __builtin__ import xrange as range\nfrom cStringIO import StringIO\nfrom future_builtins import ascii, filter, hex, map, oct, zip\nfrom io import IOBase\n\nimport __pypy__\n\n\ndef main():\n    for _ in range(int(input())):\n        n = int(input())\n        a = [int(ai) for ai in input().split()]\n        for i in range(n):\n            if a[i] < i:\n                k = i - 1\n                break\n        else:\n            print(\"Yes\")\n            continue\n\n        for i in range(k, n):\n            if a[i] < n - i - 1:\n                break\n        else:\n            print(\"Yes\")\n            continue\n        a.reverse()\n        for i in range(n):\n            if a[i] < i:\n                k = i - 1\n                break\n        else:\n            print(\"Yes\")\n            continue\n\n        for i in range(k, n):\n            if a[i] < n - i - 1:\n                print(\"No\")\n                break\n        else:\n            print(\"Yes\")\n            continue\n\n\n# region fastio\n\nBUFSIZE = 8192\n\n\nclass FastI(IOBase):\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self._buffer = StringIO()\n        self.newlines = 0\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(\"\\n\") + (not b)\n            ptr = self._buffer.tell()\n            self._buffer.seek(0, 2), self._buffer.write(b), self._buffer.seek(ptr)\n        self.newlines -= 1\n        return self._buffer.readline()\n\n\nclass FastO(IOBase):\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self._buffer = __pypy__.builders.StringBuilder()\n        self.write = lambda s: self._buffer.append(s)\n\n    def flush(self):\n        os.write(self._fd, self._buffer.build())\n        self._buffer = __pypy__.builders.StringBuilder()\n\n\ndef print(*args, **kwargs):\n    sep, file = kwargs.pop(\"sep\", \" \"), kwargs.pop(\"file\", sys.stdout)\n    at_start = True\n    for x in args:\n        if not at_start:\n            file.write(sep)\n        file.write(str(x))\n        at_start = False\n    file.write(kwargs.pop(\"end\", \"\\n\"))\n    if kwargs.pop(\"flush\", False):\n        file.flush()\n\n\nsys.stdin, sys.stdout = FastI(sys.stdin), FastO(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n# endregion\n\nif __name__ == \"__main__\":\n    main()\n",
    "prob_desc_created_at": "1580652300",
    "tags": [
        "implementation",
        "greedy"
    ],
    "hidden_unit_tests": ""
}
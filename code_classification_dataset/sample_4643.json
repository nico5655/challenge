{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"7\\n11\\n8\"]",
    "src_uid": "3d898a45ab89b93e006270a77db49017",
    "prob_desc_notes": "NoteIn the first test case, the longest simple cycle is shown below:   We can't increase it with the first chain, since in such case it won't be simple — the vertex $$$2$$$ on the second chain will break simplicity.",
    "prob_desc_description": "You have $$$n$$$ chains, the $$$i$$$-th chain consists of $$$c_i$$$ vertices. Vertices in each chain are numbered independently from $$$1$$$ to $$$c_i$$$ along the chain. In other words, the $$$i$$$-th chain is the undirected graph with $$$c_i$$$ vertices and $$$(c_i - 1)$$$ edges connecting the $$$j$$$-th and the $$$(j + 1)$$$-th vertices for each $$$1 \\le j &lt; c_i$$$.Now you decided to unite chains in one graph in the following way:   the first chain is skipped;  the $$$1$$$-st vertex of the $$$i$$$-th chain is connected by an edge with the $$$a_i$$$-th vertex of the $$$(i - 1)$$$-th chain;  the last ($$$c_i$$$-th) vertex of the $$$i$$$-th chain is connected by an edge with the $$$b_i$$$-th vertex of the $$$(i - 1)$$$-th chain.   Picture of the first test case. Dotted lines are the edges added during uniting process Calculate the length of the longest simple cycle in the resulting graph.A simple cycle is a chain where the first and last vertices are connected as well. If you travel along the simple cycle, each vertex of this cycle will be visited exactly once.",
    "prob_desc_output_spec": "For each test case, print the length of the longest simple cycle.",
    "prob_desc_input_spec": "The first line contains a single integer $$$t$$$ ($$$1 \\le t \\le 1000$$$) — the number of test cases. The first line of each test case contains the single integer $$$n$$$ ($$$2 \\le n \\le 10^5$$$) — the number of chains you have. The second line of each test case contains $$$n$$$ integers $$$c_1, c_2, \\dots, c_n$$$ ($$$2 \\le c_i \\le 10^9$$$) — the number of vertices in the corresponding chains. The third line of each test case contains $$$n$$$ integers $$$a_1, a_2, \\dots, a_n$$$ ($$$a_1 = -1$$$; $$$1 \\le a_i \\le c_{i - 1}$$$). The fourth line of each test case contains $$$n$$$ integers $$$b_1, b_2, \\dots, b_n$$$ ($$$b_1 = -1$$$; $$$1 \\le b_i \\le c_{i - 1}$$$). Both $$$a_1$$$ and $$$b_1$$$ are equal to $$$-1$$$, they aren't used in graph building and given just for index consistency. It's guaranteed that the sum of $$$n$$$ over all test cases doesn't exceed $$$10^5$$$.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3-64",
    "lang_cluster": "Python",
    "difficulty": 1600,
    "file_name": "train_102.jsonl",
    "code_uid": "cd48fa58a957ba80c73f9ebf030ca4c8",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"3\\n4\\n3 4 3 3\\n-1 1 2 2\\n-1 2 2 3\\n2\\n5 6\\n-1 5\\n-1 1\\n3\\n3 5 2\\n-1 1 1\\n-1 3 5\"]",
    "exec_outcome": "PASSED",
    "source_code": "import sys, threading\r\nimport math\r\nfrom os import path\r\nfrom collections import defaultdict, Counter, deque\r\nfrom bisect import *\r\nfrom string import ascii_lowercase\r\nfrom functools import cmp_to_key\r\nimport heapq\r\n \r\n \r\ndef readInts():\r\n    x = list(map(int, (sys.stdin.readline().rstrip().split())))\r\n    return x[0] if len(x) == 1 else x\r\n \r\n \r\ndef readList(type=int):\r\n    x = sys.stdin.readline()\r\n    x = list(map(type, x.rstrip('\\n\\r').split()))\r\n    return x\r\n \r\n \r\ndef readStr():\r\n    x = sys.stdin.readline().rstrip('\\r\\n')\r\n \r\n \r\nwrite = sys.stdout.write\r\nread = sys.stdin.readline\r\n \r\n \r\nMAXN = 1123456\r\nMOD = 10**9 + 7\r\n\r\n\r\nclass mydict:\r\n    def __init__(self, func):\r\n        self.random = randint(0, 1 << 32)\r\n        self.default = func\r\n        self.dict = {}\r\n \r\n    def __getitem__(self, key):\r\n        mykey = self.random ^ key\r\n        if mykey not in self.dict:\r\n            self.dict[mykey] = self.default()\r\n        return self.dict[mykey]\r\n \r\n    def get(self, key, default):\r\n        mykey = self.random ^ key\r\n        if mykey not in self.dict:\r\n            return default\r\n        return self.dict[mykey]\r\n \r\n    def __setitem__(self, key, item):\r\n        mykey = self.random ^ key\r\n        self.dict[mykey] = item\r\n \r\n    def getkeys(self):\r\n        return [self.random ^ i for i in self.dict]\r\n \r\n    def __str__(self):\r\n        return f'{[(self.random ^ i, self.dict[i]) for i in self.dict]}'\r\n\r\n \r\ndef lcm(a, b):\r\n    return (a*b)//(math.gcd(a,b))\r\n \r\n \r\ndef mod(n):\r\n    return n%MOD\r\n\r\n\r\ndef solve(t):\r\n    # print(f'Case #{t}: ', end = '')\r\n    n = readInts()\r\n    c = readList()\r\n    a = readInts()\r\n    b = readInts()\r\n    pref = 0\r\n    ans = 0\r\n    for i in range(1, n):\r\n        c1 = c[i] + abs(a[i] - b[i]) + 1\r\n        c2 = float('-inf')\r\n        if a[i] != b[i]:\r\n            c2 = c[i] - abs(a[i] - b[i]) + 1\r\n\r\n        ans = max(ans, c1, c2+pref)\r\n        pref = max(c1, c2+pref)\r\n\r\n    print(ans)\r\n\r\n\r\ndef main():\r\n    t = 1\r\n    if path.exists(\"F:/Comp Programming/input.txt\"):\r\n        sys.stdin = open(\"F:/Comp Programming/input.txt\", 'r')\r\n        sys.stdout = open(\"F:/Comp Programming/output1.txt\", 'w')\r\n    # sys.setrecursionlimit(10**5)\r\n    t = readInts()\r\n    for i in range(t):\r\n        solve(i+1)\r\n \r\n \r\nif __name__ == '__main__':\r\n    main()  ",
    "prob_desc_created_at": "1611930900",
    "tags": [
        "dp",
        "graphs",
        "greedy"
    ],
    "hidden_unit_tests": ""
}
{
    "prob_desc_time_limit": "4.5 seconds",
    "prob_desc_sample_outputs": "[\"2 4\\n4 10\\n1 3\"]",
    "src_uid": "55c692d380a4d1c0478ceb7cffde342f",
    "prob_desc_notes": "NoteExplanation of the sample:At the first query, the tree consist of root, so we purchase $$$2$$$ tons of gold and pay $$$2 \\cdot 2 = 4$$$. $$$3$$$ tons remain in the root.At the second query, we add vertex $$$2$$$ as a son of vertex $$$0$$$. Vertex $$$2$$$ now has $$$3$$$ tons of gold with price $$$4$$$ per one ton.At the third query, a path from $$$2$$$ to $$$0$$$ consists of only vertices $$$0$$$ and $$$2$$$ and since $$$c_0 &lt; c_2$$$ we buy $$$3$$$ remaining tons of gold in vertex $$$0$$$ and $$$1$$$ ton in vertex $$$2$$$. So we bought $$$3 + 1 = 4$$$ tons and paid $$$3 \\cdot 2 + 1 \\cdot 4 = 10$$$. Now, in vertex $$$0$$$ no gold left and $$$2$$$ tons of gold remain in vertex $$$2$$$.At the fourth query, we add vertex $$$4$$$ as a son of vertex $$$0$$$. Vertex $$$4$$$ now has $$$1$$$ ton of gold with price $$$3$$$.At the fifth query, a path from $$$4$$$ to $$$0$$$ consists of only vertices $$$0$$$ and $$$4$$$. But since no gold left in vertex $$$0$$$ and only $$$1$$$ ton is in vertex $$$4$$$, we buy $$$1$$$ ton of gold in vertex $$$4$$$ and spend $$$1 \\cdot 3 = 3$$$. Now, in vertex $$$4$$$ no gold left.",
    "prob_desc_description": "You are given a rooted tree. Each vertex contains $$$a_i$$$ tons of gold, which costs $$$c_i$$$ per one ton. Initially, the tree consists only a root numbered $$$0$$$ with $$$a_0$$$ tons of gold and price $$$c_0$$$ per ton.There are $$$q$$$ queries. Each query has one of two types:   Add vertex $$$i$$$ (where $$$i$$$ is an index of query) as a son to some vertex $$$p_i$$$; vertex $$$i$$$ will have $$$a_i$$$ tons of gold with $$$c_i$$$ per ton. It's guaranteed that $$$c_i &gt; c_{p_i}$$$.  For a given vertex $$$v_i$$$ consider the simple path from $$$v_i$$$ to the root. We need to purchase $$$w_i$$$ tons of gold from vertices on this path, spending the minimum amount of money. If there isn't enough gold on the path, we buy all we can. If we buy $$$x$$$ tons of gold in some vertex $$$v$$$ the remaining amount of gold in it decreases by $$$x$$$ (of course, we can't buy more gold that vertex has at the moment). For each query of the second type, calculate the resulting amount of gold we bought and the amount of money we should spend.Note that you should solve the problem in online mode. It means that you can't read the whole input at once. You can read each query only after writing the answer for the last query, so don't forget to flush output after printing answers. You can use functions like fflush(stdout) in C++ and BufferedWriter.flush in Java or similar after each writing in your program. In standard (if you don't tweak I/O), endl flushes cout in C++ and System.out.println in Java (or println in Kotlin) makes automatic flush as well. ",
    "prob_desc_output_spec": "For each query of the second type, print the resulting amount of gold we bought and the minimum amount of money we should spend.",
    "prob_desc_input_spec": "The first line contains three integers $$$q$$$, $$$a_0$$$ and $$$c_0$$$ ($$$1 \\le q \\le 3 \\cdot 10^5$$$; $$$1 \\le a_0, c_0 &lt; 10^6$$$) — the number of queries, the amount of gold in the root and its price. Next $$$q$$$ lines contain descriptions of queries; The $$$i$$$-th query has one of two types:    \"$$$1$$$ $$$p_i$$$ $$$a_i$$$ $$$c_i$$$\" ($$$0 \\le p_i &lt; i$$$; $$$1 \\le a_i, c_i &lt; 10^6$$$): add vertex $$$i$$$ as a son to vertex $$$p_i$$$. The vertex $$$i$$$ will have $$$a_i$$$ tons of gold with price $$$c_i$$$ per one ton. It's guaranteed that $$$p_i$$$ exists and $$$c_i &gt; c_{p_i}$$$. \"$$$2$$$ $$$v_i$$$ $$$w_i$$$\" ($$$0 \\le v_i &lt; i$$$; $$$1 \\le w_i &lt; 10^6$$$): buy $$$w_i$$$ tons of gold from vertices on path from $$$v_i$$$ to $$$0$$$ spending the minimum amount of money. If there isn't enough gold, we buy as much as we can. It's guaranteed that vertex $$$v_i$$$ exist.  It's guaranteed that there is at least one query of the second type.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3",
    "lang_cluster": "Python",
    "difficulty": 2200,
    "file_name": "train_085.jsonl",
    "code_uid": "41909de309b27273ee1583a0da8c5cc0",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"5 5 2\\n2 0 2\\n1 0 3 4\\n2 2 4\\n1 0 1 3\\n2 4 2\"]",
    "exec_outcome": "PASSED",
    "source_code": "from array import array\r\nimport math\r\nimport os\r\nimport sys\r\ninput = sys.stdin.buffer.readline\r\n\r\nq, a0, c0 = map(int, input().split())\r\nmod = pow(10, 9) + 7\r\nn = q + 5\r\npow2 = [1]\r\nfor _ in range(20):\r\n    pow2.append(2 * pow2[-1])\r\ncnt = [0] * n\r\ncost = [0] * n\r\ncnt[0], cost[0] = a0, c0\r\ndp = array(\"l\", [-1] * (20 * n))\r\ndist = [-1] * n\r\ndist[0] = 1\r\nl0 = [-1] * n\r\nfor i in range(1, q + 1):\r\n    t = list(map(int, input().split()))\r\n    if t[0] == 1:\r\n        p, a, c = t[1], t[2], t[3]\r\n        cnt[i] = a\r\n        cost[i] = c\r\n        j = 0\r\n        dp[20 * i] = p\r\n        while dp[20 * dp[20 * i + j] + j] ^ -1:\r\n            dp[20 * i + j + 1] = dp[20 * dp[20 * i + j] + j]\r\n            j += 1\r\n        dist[i] = dist[p] + 1\r\n    else:\r\n        v, w = t[1], t[2]\r\n        if not v:\r\n            u = 0\r\n            x = min(w, cnt[u])\r\n            cnt[u] -= x\r\n            ans = [str(x), str(x * cost[0])]\r\n            os.write(1, b\"%d %d\\n\" % (x, x * cost[0]))\r\n            continue\r\n        d, j, l = 0, v, int(math.log2(dist[v])) + 1\r\n        for k in range(l - 1, -1, -1):\r\n            m = dp[20 * j + k]\r\n            if cnt[m]:\r\n                d += pow2[k]\r\n                j = m\r\n        u0 = j\r\n        ans0, ans1, ans2 = 0, 0, 0\r\n        for j in range(d, -1, -1):\r\n            if j ^ d:\r\n                d0, u, k = j, v, 0\r\n                while d0:\r\n                    if d0 & pow2[k]:\r\n                        d0 ^= pow2[k]\r\n                        u = dp[20 * u + k]\r\n                    k += 1\r\n            else:\r\n                u = u0\r\n            x = min(w - ans0, cnt[u])\r\n            cnt[u] -= x\r\n            ans0 += x\r\n            ans1 += x * cost[u] % mod\r\n            ans2 += x * cost[u] // mod\r\n            ans2 += ans1 // mod\r\n            ans1 %= mod\r\n            if not ans0 ^ w:\r\n                break\r\n        ans = [str(ans0), str(ans1 + ans2 * mod)]\r\n        os.write(1, b\"%d %d\\n\" % (ans0, ans1 + ans2 * mod))",
    "prob_desc_created_at": "1622817300",
    "tags": [
        "binary search",
        "data structures",
        "dp",
        "greedy",
        "interactive",
        "trees"
    ],
    "hidden_unit_tests": ""
}
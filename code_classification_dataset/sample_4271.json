{
    "prob_desc_time_limit": "5 seconds",
    "prob_desc_sample_outputs": "[\"Yes\\nNo\\nYes\\nYes\", \"Yes\\nYes\\nNo\\nYes\\nYes\\nYes\\nYes\\nYes\", \"Yes\\nYes\\nYes\\nYes\\nYes\\nYes\\nNo\\nNo\\nYes\", \"Yes\"]",
    "src_uid": "7ef1aeb7d4649df98e47d2c26cff251c",
    "prob_desc_notes": "NoteExplanation of the first example:In the first testcase the destination rock is the same as the starting rock, thus no jumps are required to reach it.In the second testcase the frog can jump any distance in the range $$$[5 - 2; 5 + 2]$$$. Thus, it can reach rock number $$$5$$$ (by jumping $$$7$$$ to the right) and rock number $$$3$$$ (by jumping $$$3$$$ to the left). From rock number $$$3$$$ it can reach rock number $$$2$$$ (by jumping $$$5$$$ to the left). From rock number $$$2$$$ it can reach rock number $$$1$$$ (by jumping $$$4$$$ to the left). However, there is no way to reach rock number $$$7$$$.In the third testcase the frog can jump any distance in the range $$$[5 - 3; 5 + 3]$$$. Thus, it can reach rock number $$$7$$$ by jumping to rock $$$5$$$ first and to $$$7$$$ afterwards.The fourth testcase is shown in the explanation for the second testcase.",
    "prob_desc_description": "There is an infinite pond that can be represented with a number line. There are $$$n$$$ rocks in the pond, numbered from $$$1$$$ to $$$n$$$. The $$$i$$$-th rock is located at an integer coordinate $$$a_i$$$. The coordinates of the rocks are pairwise distinct. The rocks are numbered in the increasing order of the coordinate, so $$$a_1 &lt; a_2 &lt; \\dots &lt; a_n$$$.A robot frog sits on the rock number $$$s$$$. The frog is programmable. It has a base jumping distance parameter $$$d$$$. There also is a setting for the jumping distance range. If the jumping distance range is set to some integer $$$k$$$, then the frog can jump from some rock to any rock at a distance from $$$d - k$$$ to $$$d + k$$$ inclusive in any direction. The distance between two rocks is an absolute difference between their coordinates.You are assigned a task to implement a feature for the frog. Given two integers $$$i$$$ and $$$k$$$ determine if the frog can reach a rock number $$$i$$$ from a rock number $$$s$$$ performing a sequence of jumps with the jumping distance range set to $$$k$$$. The sequence can be arbitrarily long or empty.You will be given $$$q$$$ testcases for that feature, the $$$j$$$-th testcase consists of two integers $$$i$$$ and $$$k$$$. Print \"Yes\" if the $$$i$$$-th rock is reachable and \"No\" otherwise.You can output \"YES\" and \"NO\" in any case (for example, strings \"yEs\", \"yes\", \"Yes\" and 'YES\"' will be recognized as a positive answer).",
    "prob_desc_output_spec": "For each of the testcases print an answer. If there is a sequence of jumps from a rock number $$$s$$$ to a rock number $$$i$$$ with the jumping distance range set to $$$k$$$, then print \"Yes\". Otherwise, print \"No\".",
    "prob_desc_input_spec": "The first line contains four integers $$$n$$$, $$$q$$$, $$$s$$$ and $$$d$$$ ($$$1 \\le n, q \\le 2 \\cdot 10^5$$$; $$$1 \\le s \\le n$$$; $$$1 \\le d \\le 10^6$$$) — the number of rocks, the number of testcases, the starting rock and the base jumping distance parameter. The second line contains $$$n$$$ integers $$$a_1, a_2, \\dots, a_n$$$ ($$$1 \\le a_i \\le 10^6$$$) — the coordinates of the rocks. The coordinates of the rocks are pairwise distinct. The rocks are numbered in the increasing order of distance from the land, so $$$a_1 &lt; a_2 &lt; \\dots &lt; a_n$$$. Each of the next $$$q$$$ lines contains two integers $$$i$$$ and $$$k$$$ ($$$1 \\le i \\le n$$$; $$$1 \\le k \\le 10^6$$$) — the parameters to the testcase.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3",
    "lang_cluster": "Python",
    "difficulty": 2700,
    "file_name": "train_094.jsonl",
    "code_uid": "adabfa41713ba363b06c7feb8a2d1c06",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"7 4 4 5\\n1 5 10 13 20 22 28\\n4 1\\n7 2\\n7 3\\n3 2\", \"10 8 6 11\\n1 2 4 7 8 9 11 13 19 20\\n2 13\\n5 8\\n8 1\\n6 15\\n1 15\\n2 7\\n7 6\\n8 9\", \"6 9 6 6\\n1 2 4 9 18 19\\n2 17\\n1 18\\n5 4\\n2 11\\n5 17\\n6 8\\n4 3\\n3 3\\n6 6\", \"4 1 1 10\\n1 8 10 19\\n2 1\"]",
    "exec_outcome": "PASSED",
    "source_code": "from collections import deque\r\nimport bisect\r\nimport sys, os, io\r\ninput = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline\r\n\r\ndef get_root(s):\r\n    v = []\r\n    while not s == root[s]:\r\n        v.append(s)\r\n        s = root[s]\r\n    for i in v:\r\n        root[i] = s\r\n    return s\r\n\r\ndef unite(s, t):\r\n    rs, rt = get_root(s), get_root(t)\r\n    if not rs ^ rt:\r\n        return\r\n    if rank[s] == rank[t]:\r\n        rank[rs] += 1\r\n    if rank[s] >= rank[t]:\r\n        root[rt] = rs\r\n        size[rs] += size[rt]\r\n    else:\r\n        root[rs] = rt\r\n        size[rt] += size[rs]\r\n    ma[get_root(s)] = max(ma[rs], ma[rt])\r\n    return\r\n\r\ndef same(s, t):\r\n    return True if get_root(s) == get_root(t) else False\r\n\r\ndef get_size(s):\r\n    return size[get_root(s)]\r\n\r\nn, q, s, d = map(int, input().split())\r\ninf = pow(10, 9) + 1\r\na = [-inf] + list(map(int, input().split()))\r\na0 = a[s]\r\nm = pow(10, 6) + 5\r\nx = [set() for _ in range(m)]\r\ndist = [0] * (n + 1)\r\nfor i in range(1, n + 1):\r\n    if i == s:\r\n        continue\r\n    d0 = abs(a0 - a[i])\r\n    x[abs(d - d0)].add(i)\r\n    dist[i] = abs(d - d0)\r\nroot = [i for i in range(n + 2)]\r\nrank = [1 for _ in range(n + 2)]\r\nsize = [1 for _ in range(n + 2)]\r\nma = [i for i in range(n + 2)]\r\nvisit = [0] * (n + 2)\r\nvisit[s] = 1\r\nq0 = deque()\r\nfor i in range(m):\r\n    for j in x[i]:\r\n        q0.append(j)\r\n    while q0:\r\n        j = q0.popleft()\r\n        aj = a[j]\r\n        dist[j] = i\r\n        visit[j] = 1\r\n        for k in [j - 1, j + 1]:\r\n            if visit[k]:\r\n                unite(j, k)\r\n            elif 0 < k <= n:\r\n                d0 = i + abs(aj - a[k])\r\n                if dist[k] > d0:\r\n                    x[dist[k]].remove(k)\r\n                    dist[k] = d0\r\n                    x[d0].add(k)\r\n        for k in [-d, d]:\r\n            l = bisect.bisect_left(a, aj + k - i)\r\n            r = bisect.bisect_right(a, aj + k + i)\r\n            u = l if not visit[l] else ma[get_root(l)] + 1\r\n            while u < r:\r\n                q0.append(u)\r\n                x[dist[u]].remove(u)\r\n                dist[u] = i\r\n                visit[u] = 1\r\n                for v in [u - 1, u + 1]:\r\n                    if visit[v]:\r\n                        unite(u, v)\r\n                u = ma[get_root(u)] + 1\r\n            if 0 < l - 1 and not visit[l - 1]:\r\n                d0 = abs(aj + k - a[l - 1])\r\n                if dist[l - 1] > d0:\r\n                    x[dist[l - 1]].remove(l - 1)\r\n                    dist[l - 1] = d0\r\n                    x[d0].add(l - 1)\r\n            if r <= n and not visit[r]:\r\n                d0 = abs(aj + k - a[r])\r\n                if dist[r] > d0:\r\n                    x[dist[r]].remove(r)\r\n                    dist[r] = d0\r\n                    x[d0].add(r)\r\nans = []\r\nfor _ in range(q):\r\n    i, k = map(int, input().split())\r\n    ans0 = \"Yes\" if dist[i] <= k else \"No\"\r\n    ans.append(ans0)\r\nsys.stdout.write(\"\\n\".join(ans))",
    "prob_desc_created_at": "1626273300",
    "tags": [
        "binary search",
        "data structures",
        "divide and conquer",
        "dp",
        "dsu",
        "graphs",
        "shortest paths"
    ],
    "hidden_unit_tests": ""
}
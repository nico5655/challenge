{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"4\\n3 3 3 3\\n2\\n3 5\\n-1\"]",
    "src_uid": "fa0fc36acf5a638917be7a2769cbfd80",
    "prob_desc_notes": "NoteIn the first test case, the permutation is already sorted. Any even number of reversals of the length $$$3$$$ prefix doesn't change that fact.In the second test case, after reversing the prefix of length $$$3$$$ the permutation will change to $$$[5, 4, 3, 2, 1]$$$, and then after reversing the prefix of length $$$5$$$ the permutation will change to $$$[1, 2, 3, 4, 5]$$$.In the third test case, it's impossible to sort the permutation.",
    "prob_desc_description": "You have a permutation: an array $$$a = [a_1, a_2, \\ldots, a_n]$$$ of distinct integers from $$$1$$$ to $$$n$$$. The length of the permutation $$$n$$$ is odd.You need to sort the permutation in increasing order.In one step, you can choose any prefix of the permutation with an odd length and reverse it. Formally, if $$$a = [a_1, a_2, \\ldots, a_n]$$$, you can choose any odd integer $$$p$$$ between $$$1$$$ and $$$n$$$, inclusive, and set $$$a$$$ to $$$[a_p, a_{p-1}, \\ldots, a_1, a_{p+1}, a_{p+2}, \\ldots, a_n]$$$.Find a way to sort $$$a$$$ using no more than $$$\\frac{5n}{2}$$$ reversals of the above kind, or determine that such a way doesn't exist. The number of reversals doesn't have to be minimized.",
    "prob_desc_output_spec": "For each test case, if it's impossible to sort the given permutation in at most $$$\\frac{5n}{2}$$$ reversals, print a single integer $$$-1$$$. Otherwise, print an integer $$$m$$$ ($$$0 \\le m \\le \\frac{5n}{2}$$$), denoting the number of reversals in your sequence of steps, followed by $$$m$$$ integers $$$p_i$$$ ($$$1 \\le p_i \\le n$$$; $$$p_i$$$ is odd), denoting the lengths of the prefixes of $$$a$$$ to be reversed, in chronological order. Note that $$$m$$$ doesn't have to be minimized. If there are multiple answers, print any.",
    "prob_desc_input_spec": "Each test contains multiple test cases. The first line contains the number of test cases $$$t$$$ ($$$1 \\le t \\le 100$$$). Description of the test cases follows. The first line of each test case contains a single integer $$$n$$$ ($$$3 \\le n \\le 2021$$$; $$$n$$$ is odd) — the length of the permutation. The second line contains $$$n$$$ distinct integers $$$a_1, a_2, \\ldots, a_n$$$ ($$$1 \\le a_i \\le n$$$) — the permutation itself.  It is guaranteed that the sum of $$$n$$$ over all test cases does not exceed $$$2021$$$.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3-64",
    "lang_cluster": "Python",
    "difficulty": 2000,
    "file_name": "train_086.jsonl",
    "code_uid": "bc208f219795480d994f53f8bac029a7",
    "prob_desc_memory_limit": "512 megabytes",
    "prob_desc_sample_inputs": "[\"3\\n3\\n1 2 3\\n5\\n3 4 5 2 1\\n3\\n2 1 3\"]",
    "exec_outcome": "PASSED",
    "source_code": "''' C. Bottom-Tier Reversals\nhttps://codeforces.com/contest/1558/problem/C\n'''\n\nimport io, os, sys\ninput = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline  # decode().strip() if str\noutput = sys.stdout.write\n\ndef debug(*args):   \n    if os.environ.get('debug') in [None, '0']: return\n    from inspect import currentframe, getframeinfo\n    from re import search\n    frame = currentframe().f_back\n    s = getframeinfo(frame).code_context[0]\n    r = search(r\"\\((.*)\\)\", s).group(1)\n    vnames = r.split(', ')\n    var_and_vals = [f'{var}={val}' for var, val in zip(vnames, args)]\n    prefix = f'{currentframe().f_back.f_lineno:02d}: '\n    print(f'{prefix}{\", \".join(var_and_vals)}')\n\nfrom types import GeneratorType\ndef bootstrap(f, stack=[]):\n    def wrappedfunc(*args, **kwargs):\n        if stack: return f(*args, **kwargs)\n        to = f(*args, **kwargs)\n        while True:\n            if type(to) is GeneratorType:\n                stack.append(to)\n                to = next(to)\n            else:\n                stack.pop()\n                if not stack: break\n                to = stack[-1].send(to)\n        return to\n    return wrappedfunc\n\nclass IntKeyDict(dict):\n    from random import randrange\n    rand = randrange(1 << 62)\n    def __setitem__(self, k, v): super().__setitem__(k^self.rand, v)\n    def __getitem__(self, k): return super().__getitem__(k^self.rand)\n    def __contains__(self, k): return super().__contains__(k^self.rand)\n    def __repr__(self): return str({k: v for k, v in self.items()})\n    def get(self, k, default=None): return super().get(k^self.rand, default)\n    def keys(self): return [k^self.rand for k in super().keys()]\n    def items(self): return [(k^self.rand, v) for k, v in super().items()]\n\nINF = float('inf')\n\n# -----------------------------------------\n\n# reversal preserves parity of position\n# put pair of (n, n-1), (n-2, n-3), ... in order\n#    7 a b 6 c d e\n#    b a 7 6 c d e\n#    e d c 6 7 a b\n#    7 6 c d e a b\n#    b a e d c 6 7\n\ndef solve(N, A):\n    res = []\n    for a1 in range(N, 1, -2):\n        # put a1 at 0\n        for i, a in enumerate(A):\n            if a == a1:\n                if i & 1: return -1, []\n                res.append(i + 1)\n                A[:i+1] = A[:i+1][::-1]\n                break \n\n        i0 = -1\n        for i, a in enumerate(A):\n            if a == a1 - 1: \n                if i & 1 == 0: return -1, []\n                i0 = i\n                break\n\n        # 7 a b 6 c d e -> b a 7 6 c d e\n        res.append(i0)\n        A[:i0] = A[:i0][::-1]\n        i1 = i0 - 1\n\n        # b a 7 6 c d e -> e d c 6 7 a b\n        res.append(a1)\n        A[:a1] = A[:a1][::-1]\n        i1 = a1 - 1 - i1\n\n        # e d c 6 7 a b -> 7 6 c d e a b\n        res.append(i1 + 1)\n        A[:i1+1] = A[:i1+1][::-1]\n\n        # 7 6 c d e a b -> b a e d c 6 7\n        res.append(a1)\n        A[:a1] = A[:a1][::-1]\n        \n    assert A == list(range(1, N + 1))\n    assert all(a & 1 for a in res)\n    assert len(res) <= 5 * N // 2\n    return len(res), res\n\n\n\ndef main():\n    T = int(input())\n    for _ in range(T):\n        N = int(input())\n        A = list(map(int, input().split()))\n        r1, r2 = solve(N, A)\n        print(r1)\n        if r2: print(*r2)\n\n\nif __name__ == '__main__':\n    main()\n\n",
    "prob_desc_created_at": "1629815700",
    "tags": [
        "constructive algorithms",
        "greedy"
    ],
    "hidden_unit_tests": ""
}
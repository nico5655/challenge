{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"YES\\nNO\"]",
    "src_uid": "465f1c612fa43313005d90cc8e9e6a24",
    "prob_desc_notes": "NoteHere is a visualization of the first test case (the orange values denote the initial values and the blue ones the desired values):   One possible order of operations to obtain the desired values for each node is the following:  Operation $$$1$$$: Add $$$2$$$ to nodes $$$2$$$ and $$$3$$$.  Operation $$$2$$$: Add $$$-2$$$ to nodes $$$1$$$ and $$$4$$$.  Operation $$$3$$$: Add $$$6$$$ to nodes $$$3$$$ and $$$4$$$. Now we can see that in total we added $$$-2$$$ to node $$$1$$$, $$$2$$$ to node $$$2$$$, $$$8$$$ to node $$$3$$$ and $$$4$$$ to node $$$4$$$ which brings each node exactly to it's desired value.For the graph from the second test case it's impossible to get the target values.",
    "prob_desc_description": "You have a connected undirected graph made of $$$n$$$ nodes and $$$m$$$ edges. The $$$i$$$-th node has a value $$$v_i$$$ and a target value $$$t_i$$$.In an operation, you can choose an edge $$$(i, j)$$$ and add $$$k$$$ to both $$$v_i$$$ and $$$v_j$$$, where $$$k$$$ can be any integer. In particular, $$$k$$$ can be negative.Your task to determine if it is possible that by doing some finite number of operations (possibly zero), you can achieve for every node $$$i$$$, $$$v_i = t_i$$$.",
    "prob_desc_output_spec": "For each test case, if it is possible for every node to reach its target after some number of operations, print \"YES\". Otherwise, print \"NO\".",
    "prob_desc_input_spec": "The first line contains a single integer $$$t$$$ ($$$1 \\leq t \\leq 1000$$$), the number of test cases. Then the test cases follow. The first line of each test case contains two integers $$$n$$$, $$$m$$$ ($$$2 \\leq n \\leq 2\\cdot 10^5$$$, $$$n-1\\leq m\\leq \\min(2\\cdot 10^5, \\frac{n(n-1)}{2})$$$) — the number of nodes and edges respectively. The second line contains $$$n$$$ integers $$$v_1\\ldots, v_n$$$ ($$$-10^9 \\leq v_i \\leq 10^9$$$) — initial values of nodes. The third line contains $$$n$$$ integers $$$t_1\\ldots, t_n$$$ ($$$-10^9 \\leq t_i \\leq 10^9$$$) — target values of nodes. Each of the next $$$m$$$ lines contains two integers $$$i$$$ and $$$j$$$ representing an edge between node $$$i$$$ and node $$$j$$$ ($$$1 \\leq i, j \\leq n$$$, $$$i\\ne j$$$). It is guaranteed that the graph is connected and there is at most one edge between the same pair of nodes. It is guaranteed that the sum of $$$n$$$ over all testcases does not exceed $$$2 \\cdot 10^5$$$ and the sum of $$$m$$$ over all testcases does not exceed $$$2 \\cdot 10^5$$$.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3",
    "lang_cluster": "Python",
    "difficulty": 2200,
    "file_name": "train_084.jsonl",
    "code_uid": "24f06b8c054eb9061543f625a56e741c",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"2\\n4 4\\n5 1 2 -3\\n3 3 10 1\\n1 2\\n1 4\\n3 2\\n3 4\\n4 4\\n5 8 6 6\\n-3 1 15 4\\n1 2\\n1 4\\n3 2\\n3 4\"]",
    "exec_outcome": "PASSED",
    "source_code": "import bisect\r\nimport copy\r\nimport decimal\r\nimport fractions\r\nimport heapq\r\nimport itertools\r\nimport math\r\nimport random\r\nimport sys\r\nfrom collections import Counter, deque,defaultdict\r\nfrom functools import lru_cache,reduce\r\nfrom heapq import heappush,heappop,heapify,heappushpop,_heappop_max,_heapify_max\r\ndef _heappush_max(heap,item):\r\n    heap.append(item)\r\n    heapq._siftdown_max(heap, 0, len(heap)-1)\r\ndef _heappushpop_max(heap, item):\r\n    if heap and item < heap[0]:\r\n        item, heap[0] = heap[0], item\r\n        heapq._siftup_max(heap, 0)\r\n    return item\r\nfrom math import gcd as GCD\r\nread=sys.stdin.read\r\nreadline=sys.stdin.readline\r\nreadlines=sys.stdin.readlines\r\n\r\nclass Graph:\r\n    def __init__(self,V,edges=False,graph=False,directed=False,weighted=False):\r\n        self.V=V\r\n        self.directed=directed\r\n        self.weighted=weighted\r\n        if not graph:\r\n            self.edges=edges\r\n            self.graph=[[] for i in range(self.V)]\r\n            if weighted:\r\n                for i,j,d in self.edges:\r\n                    self.graph[i].append((j,d))\r\n                    if not self.directed:\r\n                        self.graph[j].append((i,d))\r\n            else:\r\n                for i,j in self.edges:\r\n                    self.graph[i].append(j)\r\n                    if not self.directed:\r\n                        self.graph[j].append(i)\r\n        else:\r\n            self.graph=graph\r\n            self.edges=[]\r\n            for i in range(self.V):\r\n                if self.weighted:\r\n                    for j,d in self.graph[i]:\r\n                        if self.directed or not self.directed and i<=j:\r\n                            self.edges.append((i,j,d))\r\n                else:\r\n                    for j in self.graph[i]:\r\n                        if self.directed or not self.directed and i<=j:\r\n                            self.edges.append((i,j))\r\n\r\n    def SS_BFS(self,s,bipartite_graph=False,linked_components=False,parents=False,unweighted_dist=False,weighted_dist=False):\r\n        seen=[False]*self.V\r\n        seen[s]=True\r\n        if linked_components:\r\n            lc=[s]\r\n        if parents:\r\n            ps=[None]*self.V\r\n            ps[s]=s\r\n        if unweighted_dist or bipartite_graph:\r\n            uwd=[float('inf')]*self.V\r\n            uwd[s]=0\r\n        if weighted_dist:\r\n            wd=[float('inf')]*self.V\r\n            wd[s]=0\r\n        queue=deque([s])\r\n        while queue:\r\n            x=queue.popleft()\r\n            for y in self.graph[x]:\r\n                if self.weighted:\r\n                    y,d=y\r\n                if not seen[y]:\r\n                    seen[y]=True\r\n                    queue.append(y)\r\n                    if linked_components:\r\n                        lc.append(y)\r\n                    if parents:\r\n                        ps[y]=x\r\n                    if unweighted_dist or bipartite_graph:\r\n                        uwd[y]=uwd[x]+1\r\n                    if weighted_dist:\r\n                        wd[y]=wd[x]+d\r\n        if bipartite_graph:\r\n            bg=[[],[]]\r\n            for tpl in self.edges:\r\n                i,j=tpl[:2] if self.weighted else tpl\r\n                if type(uwd[i])==float or type(uwd[j])==float:\r\n                    continue\r\n                if not uwd[i]%2^uwd[j]%2:\r\n                    bg=False\r\n                    break\r\n            else:\r\n                for x in range(self.V):\r\n                    if type(uwd[x])==float:\r\n                        continue\r\n                    bg[uwd[x]%2].append(x)\r\n        tpl=()\r\n        if bipartite_graph:\r\n            tpl+=(bg,)\r\n        if linked_components:\r\n            tpl+=(lc,)\r\n        if parents:\r\n            tpl+=(ps,)\r\n        if unweighted_dist:\r\n            tpl+=(uwd,)\r\n        if weighted_dist:\r\n            tpl+=(wd,)\r\n        if len(tpl)==1:\r\n            tpl=tpl[0]\r\n        return tpl\r\n\r\n    def AP_BFS(self,bipartite_graph=False,linked_components=False,parents=False):\r\n        seen=[False]*self.V\r\n        if bipartite_graph:\r\n            bg=[None]*self.V\r\n            cnt=-1\r\n        if linked_components:\r\n            lc=[]\r\n        if parents:\r\n            ps=[None]*self.V\r\n        for s in range(self.V):\r\n            if seen[s]:\r\n                continue\r\n            seen[s]=True\r\n            if bipartite_graph:\r\n                cnt+=1\r\n                bg[s]=(cnt,s&2)\r\n            if linked_components:\r\n                lc.append([s])\r\n            if parents:\r\n                ps[s]=s\r\n            queue=deque([s])\r\n            while queue:\r\n                x=queue.popleft()\r\n                for y in self.graph[x]:\r\n                    if self.weighted:\r\n                        y,d=y\r\n                    if not seen[y]:\r\n                        seen[y]=True\r\n                        queue.append(y)\r\n                        if bipartite_graph:\r\n                            bg[y]=(cnt,bg[x][1]^1)\r\n                        if linked_components:\r\n                            lc[-1].append(y)\r\n                        if parents:\r\n                            ps[y]=x\r\n        if bipartite_graph:\r\n            bg_=bg\r\n            bg=[[[],[]] for i in range(cnt+1)]\r\n            for tpl in self.edges:\r\n                i,j=tpl[:2] if self.weighted else tpl\r\n                if not bg_[i][1]^bg_[j][1]:\r\n                    bg[bg_[i][0]]=False\r\n            for x in range(self.V):\r\n                if bg[bg_[x][0]]:\r\n                    bg[bg_[x][0]][bg_[x][1]].append(x)\r\n        tpl=()\r\n        if bipartite_graph:\r\n            tpl+=(bg,)\r\n        if linked_components:\r\n            tpl+=(lc,)\r\n        if parents:\r\n            tpl+=(ps,)\r\n        if len(tpl)==1:\r\n            tpl=tpl[0]\r\n        return tpl\r\n\r\n    def SS_DFS(self,s,bipartite_graph=False,cycle_detection=False,directed_acyclic=False,euler_tour=False,linked_components=False,parents=False,postorder=False,preorder=False,topological_sort=False,unweighted_dist=False,weighted_dist=False):\r\n        seen=[False]*self.V\r\n        finished=[False]*self.V\r\n        if directed_acyclic or cycle_detection or topological_sort:\r\n            dag=True\r\n        if euler_tour:\r\n            et=[]\r\n        if linked_components:\r\n            lc=[]\r\n        if parents or cycle_detection:\r\n            ps=[None]*self.V\r\n            ps[s]=s\r\n        if postorder or topological_sort:\r\n            post=[]\r\n        if preorder:\r\n            pre=[]\r\n        if unweighted_dist or bipartite_graph:\r\n            uwd=[float('inf')]*self.V\r\n            uwd[s]=0\r\n        if weighted_dist:\r\n            wd=[float('inf')]*self.V\r\n            wd[s]=0\r\n        stack=[(s,0)] if self.weighted else [s]\r\n        while stack:\r\n            if self.weighted:\r\n                x,d=stack.pop()\r\n            else:\r\n                x=stack.pop()\r\n            if not seen[x]:\r\n                seen[x]=True\r\n                stack.append((x,d) if self.weighted else x)\r\n                if euler_tour:\r\n                    et.append(x)\r\n                if linked_components:\r\n                    lc.append(x)\r\n                if preorder:\r\n                    pre.append(x)\r\n                for y in self.graph[x]:\r\n                    if self.weighted:\r\n                        y,d=y\r\n                    if not seen[y]:\r\n                        stack.append((y,d) if self.weighted else y)\r\n                        if parents or cycle_detection:\r\n                            ps[y]=x\r\n                        if unweighted_dist or bipartite_graph:\r\n                            uwd[y]=uwd[x]+1\r\n                        if weighted_dist:\r\n                            wd[y]=wd[x]+d\r\n                    elif not finished[y]:\r\n                        if (directed_acyclic or cycle_detection or topological_sort) and dag:\r\n                            dag=False\r\n                            if cycle_detection:\r\n                                cd=(y,x)\r\n            elif not finished[x]:\r\n                finished[x]=True\r\n                if euler_tour:\r\n                    et.append(~x)\r\n                if postorder or topological_sort:\r\n                    post.append(x)\r\n        if bipartite_graph:\r\n            bg=[[],[]]\r\n            for tpl in self.edges:\r\n                i,j=tpl[:2] if self.weighted else tpl\r\n                if type(uwd[i])==float or type(uwd[j])==float:\r\n                    continue\r\n                if not uwd[i]%2^uwd[j]%2:\r\n                    bg=False\r\n                    break\r\n            else:\r\n                for x in range(self.V):\r\n                    if type(uwd[x])==float:\r\n                        continue\r\n                    bg[uwd[x]%2].append(x)\r\n        tpl=()\r\n        if bipartite_graph:\r\n            tpl+=(bg,)\r\n        if cycle_detection:\r\n            if dag:\r\n                cd=[]\r\n            else:\r\n                y,x=cd\r\n                cd=self.Route_Restoration(y,x,ps)\r\n            tpl+=(cd,)\r\n        if directed_acyclic:\r\n            tpl+=(dag,)\r\n        if euler_tour:\r\n            tpl+=(et,)\r\n        if linked_components:\r\n            tpl+=(lc,)\r\n        if parents:\r\n            tpl+=(ps,)\r\n        if postorder:\r\n            tpl+=(post,)\r\n        if preorder:\r\n            tpl+=(pre,)\r\n        if topological_sort:\r\n            if dag:\r\n                tp_sort=post[::-1]\r\n            else:\r\n                tp_sort=[]\r\n            tpl+=(tp_sort,)\r\n        if unweighted_dist:\r\n            tpl+=(uwd,)\r\n        if weighted_dist:\r\n            tpl+=(wd,)\r\n        if len(tpl)==1:\r\n            tpl=tpl[0]\r\n        return tpl\r\n\r\n    def AP_DFS(self,bipartite_graph=False,cycle_detection=False,directed_acyclic=False,euler_tour=False,linked_components=False,parents=False,postorder=False,preorder=False,topological_sort=False):\r\n        seen=[False]*self.V\r\n        finished=[False]*self.V\r\n        if bipartite_graph:\r\n            bg=[None]*self.V\r\n            cnt=-1\r\n        if directed_acyclic or cycle_detection or topological_sort:\r\n            dag=True\r\n        if euler_tour:\r\n            et=[]\r\n        if linked_components:\r\n            lc=[]\r\n        if parents or cycle_detection:\r\n            ps=[None]*self.V\r\n        if postorder or topological_sort:\r\n            post=[]\r\n        if preorder:\r\n            pre=[]\r\n        for s in range(self.V):\r\n            if seen[s]:\r\n                continue\r\n            if bipartite_graph:\r\n                cnt+=1\r\n                bg[s]=(cnt,s&2)\r\n            if linked_components:\r\n                lc.append([])\r\n            if parents:\r\n                ps[s]=s\r\n            stack=[(s,0)] if self.weighted else [s]\r\n            while stack:\r\n                if self.weighted:\r\n                    x,d=stack.pop()\r\n                else:\r\n                    x=stack.pop()\r\n                if not seen[x]:\r\n                    seen[x]=True\r\n                    stack.append((x,d) if self.weighted else x)\r\n                    if euler_tour:\r\n                        et.append(x)\r\n                    if linked_components:\r\n                        lc[-1].append(x)\r\n                    if preorder:\r\n                        pre.append(x)\r\n                    for y in self.graph[x]:\r\n                        if self.weighted:\r\n                            y,d=y\r\n                        if not seen[y]:\r\n                            stack.append((y,d) if self.weighted else y)\r\n                            if bipartite_graph:\r\n                                bg[y]=(cnt,bg[x][1]^1)\r\n                            if parents or cycle_detection:\r\n                                ps[y]=x\r\n                        elif not finished[y]:\r\n                            if directed_acyclic and dag:\r\n                                dag=False\r\n                                if cycle_detection:\r\n                                    cd=(y,x)\r\n                elif not finished[x]:\r\n                    finished[x]=True\r\n                    if euler_tour:\r\n                        et.append(~x)\r\n                    if postorder or topological_sort:\r\n                        post.append(x)\r\n        if bipartite_graph:\r\n            bg_=bg\r\n            bg=[[[],[]] for i in range(cnt+1)]\r\n            for tpl in self.edges:\r\n                i,j=tpl[:2] if self.weighted else tpl\r\n                if not bg_[i][1]^bg_[j][1]:\r\n                    bg[bg_[i][0]]=False\r\n            for x in range(self.V):\r\n                if bg[bg_[x][0]]:\r\n                    bg[bg_[x][0]][bg_[x][1]].append(x)\r\n        tpl=()\r\n        if bipartite_graph:\r\n            tpl+=(bg,)\r\n        if cycle_detection:\r\n            if dag:\r\n                cd=[]\r\n            else:\r\n                y,x=cd\r\n                cd=self.Route_Restoration(y,x,ps)\r\n            tpl+=(cd,)\r\n        if directed_acyclic:\r\n            tpl+=(dag,)\r\n        if euler_tour:\r\n            tpl+=(et,)\r\n        if linked_components:\r\n            tpl+=(lc,)\r\n        if parents:\r\n            tpl+=(ps,)\r\n        if postorder:\r\n            tpl+=(post,)\r\n        if preorder:\r\n            tpl+=(pre,)\r\n        if topological_sort:\r\n            if dag:\r\n                tp_sort=post[::-1]\r\n            else:\r\n                tp_sort=[]\r\n            tpl+=(tp_sort,)\r\n        if len(tpl)==1:\r\n            tpl=tpl[0]\r\n        return tpl\r\n\r\n    def Tree_Diameter(self,weighted=False):\r\n        def Farthest_Point(u):\r\n            dist=self.SS_BFS(u,weighted_dist=True) if self.weighted else self.SS_BFS(u,unweighted_dist=True)\r\n            fp=0\r\n            for i in range(self.V):\r\n                if dist[fp]<dist[i]:\r\n                    fp=i\r\n            return fp,dist[fp]\r\n        u,d=Farthest_Point(0)\r\n        v,d=Farthest_Point(u)\r\n        return u,v,d\r\n\r\n    def SCC(self):\r\n        reverse_graph=[[] for i in range(self.V)]\r\n        for tpl in self.edges:\r\n            i,j=tpl[:2] if self.weighted else tpl\r\n            reverse_graph[j].append(i)\r\n        postorder=self.AP_DFS(postorder=True)\r\n        scc=[]\r\n        seen=[False]*self.V\r\n        for s in postorder[::-1]:\r\n            if seen[s]:\r\n                continue\r\n            queue=deque([s])\r\n            seen[s]=True\r\n            lst=[]\r\n            while queue:\r\n                x=queue.popleft()\r\n                lst.append(x)\r\n                for y in reverse_graph[x]:\r\n                    if self.weighted:\r\n                        y=y[0]\r\n                    if not seen[y]:\r\n                        seen[y]=True\r\n                        queue.append(y)\r\n            scc.append(lst)\r\n        return scc\r\n\r\n    def Build_LCA(self,s):\r\n        self.euler_tour,self.parents,depth=self.SS_DFS(s,euler_tour=True,parents=True,unweighted_dist=True)\r\n        self.dfs_in_index=[None]*self.V\r\n        self.dfs_out_index=[None]*self.V\r\n        for i,x in enumerate(self.euler_tour):\r\n            if x>=0:\r\n                self.dfs_in_index[x]=i\r\n            else:\r\n                self.dfs_out_index[~x]=i\r\n        self.ST=Segment_Tree(2*self.V,lambda x,y:min(x,y),float('inf'))\r\n        lst=[None]*2*self.V\r\n        for i in range(2*self.V):\r\n            if self.euler_tour[i]>=0:\r\n                lst[i]=depth[self.euler_tour[i]]\r\n            else:\r\n                lst[i]=depth[self.parents[~self.euler_tour[i]]]\r\n        self.ST.Build(lst)\r\n\r\n    def LCA(self,a,b):\r\n        m=min(self.dfs_in_index[a],self.dfs_in_index[b])\r\n        M=max(self.dfs_in_index[a],self.dfs_in_index[b])\r\n        x=self.euler_tour[self.ST.Fold_Index(m,M+1)]\r\n        if x>=0:\r\n            return x\r\n        else:\r\n            return self.parents[~x]\r\n\r\n    def Dijkstra(self,s,route_restoration=False):\r\n        dist=[float('inf')]*self.V\r\n        dist[s]=0\r\n        hq=[(0,s)]\r\n        if route_restoration:\r\n            parents=[None]*self.V\r\n            parents[s]=s\r\n        while hq:\r\n            dx,x=heapq.heappop(hq)\r\n            if dist[x]<dx:\r\n                continue\r\n            for y,dy in self.graph[x]:\r\n                if dist[y]>dx+dy:\r\n                    dist[y]=dx+dy\r\n                    if route_restoration:\r\n                        parents[y]=x\r\n                    heapq.heappush(hq,(dist[y],y))\r\n        if route_restoration:\r\n            return dist,parents\r\n        else:\r\n            return dist\r\n\r\n    def Bellman_Ford(self,s,route_restoration=False):\r\n        dist=[float('inf')]*self.V\r\n        dist[s]=0\r\n        if route_restoration:\r\n            parents=[s]*self.V\r\n        for _ in range(self.V-1):\r\n            for i,j,d in self.edges:\r\n                if dist[j]>dist[i]+d:\r\n                    dist[j]=dist[i]+d\r\n                    if route_restoration:\r\n                        parents[j]=i\r\n                if not self.directed and dist[i]>dist[j]+d:\r\n                    dist[i]=dist[j]+d\r\n                    if route_restoration:\r\n                        parents[i]=j\r\n        negative_cycle=[]\r\n        for i,j,d in self.edges:\r\n            if dist[j]>dist[i]+d:\r\n                negative_cycle.append(j)\r\n            if not self.directed and dist[i]>dist[j]+d:\r\n                negative_cycle.append(i)\r\n        if negative_cycle:\r\n            is_negative_cycle=[False]*self.V\r\n            for i in negative_cycle:\r\n                if is_negative_cycle[i]:\r\n                    continue\r\n                else:\r\n                    queue=deque([i])\r\n                    is_negative_cycle[i]=True\r\n                    while queue:\r\n                        x=queue.popleft()\r\n                        for y,d in self.graph[x]:\r\n                            if not is_negative_cycle[y]:\r\n                                queue.append(y)\r\n                                is_negative_cycle[y]=True\r\n                                if route_restoration:\r\n                                    parents[y]=x\r\n            for i in range(self.V):\r\n                if is_negative_cycle[i]:\r\n                    dist[i]=-float('inf')\r\n        if route_restoration:\r\n            return dist,parents\r\n        else:\r\n            return dist\r\n\r\n    def Warshall_Floyd(self,route_restoration=False):\r\n        dist=[[float('inf')]*self.V for i in range(self.V)]\r\n        for i in range(self.V):\r\n            dist[i][i]=0\r\n        if route_restoration:\r\n            parents=[[j for j in range(self.V)] for i in range(self.V)]\r\n        for i,j,d in self.edges:\r\n            if dist[i][j]>d:\r\n                dist[i][j]=d\r\n                if route_restoration:\r\n                    parents[i][j]=i\r\n            if not self.directed and dist[j][i]>d:\r\n                dist[j][i]=d\r\n                if route_restoration:\r\n                    parents[j][i]=j\r\n        for k in range(self.V):\r\n            for i in range(self.V):\r\n                for j in range(self.V):\r\n                    if dist[i][j]>dist[i][k]+dist[k][j]:\r\n                        dist[i][j]=dist[i][k]+dist[k][j]\r\n                        if route_restoration:\r\n                            parents[i][j]=parents[k][j]\r\n        for i in range(self.V):\r\n            if dist[i][i]<0:\r\n                for j in range(self.V):\r\n                    if dist[i][j]!=float('inf'):\r\n                        dist[i][j]=-float('inf')\r\n        if route_restoration:\r\n            return dist,parents\r\n        else:\r\n            return dist\r\n\r\n    def Route_Restoration(self,s,g,parents):\r\n        route=[g]\r\n        while s!=g and parents[g]!=g:\r\n            g=parents[g]\r\n            route.append(g)\r\n        route=route[::-1]\r\n        return route\r\n\r\n    def Kruskal(self):\r\n        UF=UnionFind(self.V)\r\n        sorted_edges=sorted(self.edges,key=lambda x:x[2])\r\n        minimum_spnning_tree=[]\r\n        for i,j,d in sorted_edges:\r\n            if not UF.Same(i,j):\r\n                UF.Union(i,j)\r\n                minimum_spnning_tree.append((i,j,d))\r\n        return minimum_spnning_tree\r\n\r\n    def Ford_Fulkerson(self,s,t):\r\n        max_flow=0\r\n        residual_graph=[defaultdict(int) for i in range(self.V)]\r\n        if self.weighted:\r\n            for i,j,d in self.edges:\r\n                if not d:\r\n                    continue\r\n                residual_graph[i][j]+=d\r\n                if not self.directed:\r\n                    residual_graph[j][i]+=d\r\n        else:\r\n            for i,j in self.edges:\r\n                residual_graph[i][j]+=1\r\n                if not self.directed:\r\n                    residual_graph[j][i]+=1\r\n        while True:\r\n            parents=[None]*self.V\r\n            parents[s]=s\r\n            seen=[False]*self.V\r\n            seen[s]=True\r\n            queue=deque([s])\r\n            while queue:\r\n                x=queue.popleft()\r\n                for y in residual_graph[x].keys():\r\n                    if not seen[y]:\r\n                        seen[y]=True\r\n                        queue.append(y)\r\n                        parents[y]=x\r\n                        if y==t:\r\n                            tt=t\r\n                            while tt!=s:\r\n                                residual_graph[parents[tt]][tt]-=1\r\n                                residual_graph[tt][parents[tt]]+=1\r\n                                if not residual_graph[parents[tt]][tt]:\r\n                                    residual_graph[parents[tt]].pop(tt)\r\n                                tt=parents[tt]\r\n                            max_flow+=1\r\n                            break\r\n                else:\r\n                    continue\r\n                break\r\n            else:\r\n                break\r\n        return max_flow\r\n\r\n    def BFS(self,s):\r\n        seen=[False]*self.V\r\n        seen[s]=True\r\n        queue=deque([s])\r\n\r\n        while queue:\r\n            x=queue.popleft()\r\n            for y in self.graph[x]:\r\n                if self.weighted:\r\n                    y,d=y\r\n                if not seen[y]:\r\n                    seen[y]=True\r\n                    queue.append(y)\r\n                    \r\n        return \r\n\r\n    def DFS(self,s):\r\n        seen=[False]*self.V\r\n        finished=[False]*self.V\r\n        stack=[(s,0)] if self.weighted else [s]\r\n\r\n        while stack:\r\n            if self.weighted:\r\n                x,d=stack.pop()\r\n            else:\r\n                x=stack.pop()\r\n            if not seen[x]:\r\n                seen[x]=True\r\n                stack.append((x,d) if self.weighted else x)\r\n\r\n                for y in self.graph[x]:\r\n                    if self.weighted:\r\n                        y,d=y\r\n                    if not seen[y]:\r\n                        stack.append((y,d) if self.weighted else y)\r\n            elif not finished[x]:\r\n                finished[x]=True\r\n                \r\n        return \r\n\r\nt=int(readline())\r\nfor _ in range(t):\r\n    N,M=map(int,readline().split())\r\n    edges=[]\r\n    v=list(map(int,readline().split()))\r\n    t=list(map(int,readline().split()))\r\n    for _ in range(M):\r\n        a,b=map(int,readline().split())\r\n        a-=1;b-=1\r\n        edges.append((a,b))\r\n    if sum(v)%2!=sum(t)%2:\r\n        ans='NO'\r\n    else:\r\n        G=Graph(N,edges=edges)\r\n        bg=G.AP_DFS(bipartite_graph=True)[0]\r\n        if not bg:\r\n            ans='YES'\r\n        else:\r\n            v=sum(v[a] for a in bg[0])-sum(v[b] for b in bg[1])\r\n            t=sum(t[a] for a in bg[0])-sum(t[b] for b in bg[1])\r\n            if v==t:\r\n                ans='YES'\r\n            else:\r\n                ans='NO'\r\n    print(ans)",
    "prob_desc_created_at": "1624026900",
    "tags": [
        "constructive algorithms",
        "dfs and similar",
        "dsu",
        "graphs",
        "greedy",
        "math"
    ],
    "hidden_unit_tests": ""
}
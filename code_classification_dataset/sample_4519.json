{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"YES\\nNO\\nYES\\nNO\\nYES\\nNO\\nYES\\nNO\\nNO\\nYES\"]",
    "src_uid": "d40f0f3b577a1a5cfad2a657d6a1b90a",
    "prob_desc_notes": "NoteIn the first test case, the strings are initially $$$s = $$$ \"a\" and $$$t = $$$ \"a\". After the first operation the string $$$t$$$ becomes \"aaa\". Since \"a\" is already lexicographically smaller than \"aaa\", the answer for this operation should be \"YES\".After the second operation string $$$s$$$ becomes \"aaa\", and since $$$t$$$ is also equal to \"aaa\", we can't arrange $$$s$$$ in any way such that it is lexicographically smaller than $$$t$$$, so the answer is \"NO\".After the third operation string $$$t$$$ becomes \"aaaaaa\" and $$$s$$$ is already lexicographically smaller than it so the answer is \"YES\".After the fourth operation $$$s$$$ becomes \"aaabb\" and there is no way to make it lexicographically smaller than \"aaaaaa\" so the answer is \"NO\".After the fifth operation the string $$$t$$$ becomes \"aaaaaaabcaabcaabca\", and we can rearrange the strings to: \"bbaaa\" and \"caaaaaabcaabcaabaa\" so that $$$s$$$ is lexicographically smaller than $$$t$$$, so we should answer \"YES\". ",
    "prob_desc_description": "Alperen has two strings, $$$s$$$ and $$$t$$$ which are both initially equal to \"a\". He will perform $$$q$$$ operations of two types on the given strings:  $$$1 \\;\\; k \\;\\; x$$$ — Append the string $$$x$$$ exactly $$$k$$$ times at the end of string $$$s$$$. In other words, $$$s := s + \\underbrace{x + \\dots + x}_{k \\text{ times}}$$$.  $$$2 \\;\\; k \\;\\; x$$$ — Append the string $$$x$$$ exactly $$$k$$$ times at the end of string $$$t$$$. In other words, $$$t := t + \\underbrace{x + \\dots + x}_{k \\text{ times}}$$$. After each operation, determine if it is possible to rearrange the characters of $$$s$$$ and $$$t$$$ such that $$$s$$$ is lexicographically smaller$$$^{\\dagger}$$$ than $$$t$$$.Note that the strings change after performing each operation and don't go back to their initial states.$$$^{\\dagger}$$$ Simply speaking, the lexicographical order is the order in which words are listed in a dictionary. A formal definition is as follows: string $$$p$$$ is lexicographically smaller than string $$$q$$$ if there exists a position $$$i$$$ such that $$$p_i &lt; q_i$$$, and for all $$$j &lt; i$$$, $$$p_j = q_j$$$. If no such $$$i$$$ exists, then $$$p$$$ is lexicographically smaller than $$$q$$$ if the length of $$$p$$$ is less than the length of $$$q$$$. For example, $$$\\texttt{abdc} &lt; \\texttt{abe}$$$ and $$$\\texttt{abc} &lt; \\texttt{abcd}$$$, where we write $$$p &lt; q$$$ if $$$p$$$ is lexicographically smaller than $$$q$$$.",
    "prob_desc_output_spec": "For each operation, output \"YES\", if it is possible to arrange the elements in both strings in such a way that $$$s$$$ is lexicographically smaller than $$$t$$$ and \"NO\" otherwise.",
    "prob_desc_input_spec": "The first line of the input contains an integer $$$t$$$ ($$$1 \\leq t \\leq 10^4$$$) — the number of test cases. The first line of each test case contains an integer $$$q$$$ $$$(1 \\leq q \\leq 10^5)$$$ — the number of operations Alperen will perform. Then $$$q$$$ lines follow, each containing two positive integers $$$d$$$ and $$$k$$$ ($$$1 \\leq d \\leq 2$$$; $$$1 \\leq k \\leq 10^5$$$) and a non-empty string $$$x$$$ consisting of lowercase English letters — the type of the operation, the number of times we will append string $$$x$$$ and the string we need to append respectively. It is guaranteed that the sum of $$$q$$$ over all test cases doesn't exceed $$$10^5$$$ and that the sum of lengths of all strings $$$x$$$ in the input doesn't exceed $$$5 \\cdot 10^5$$$.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3",
    "lang_cluster": "Python",
    "difficulty": 1500,
    "file_name": "train_099.jsonl",
    "code_uid": "35f86d32c4db95018faf9b9924f0fb96",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"3\\n\\n5\\n\\n2 1 aa\\n\\n1 2 a\\n\\n2 3 a\\n\\n1 2 b\\n\\n2 3 abca\\n\\n2\\n\\n1 5 mihai\\n\\n2 2 buiucani\\n\\n3\\n\\n1 5 b\\n\\n2 3 a\\n\\n2 4 paiu\"]",
    "exec_outcome": "PASSED",
    "source_code": "t = int(input())\r\nfor _ in range(t):\r\n    q = int(input())\r\n\r\n    s_a_count = 1\r\n    t_a_count = 1\r\n\r\n    other_than_a_t = False\r\n    other_than_a_s = False\r\n\r\n    for _ in range(q):\r\n        line = list(map(str, input().rstrip().split()))\r\n\r\n        if line[0] == '2':\r\n            for char in line[2]:\r\n                if char != 'a':\r\n                    other_than_a_t = True\r\n                    break\r\n                else:\r\n                    t_a_count += int(line[1])\r\n        else:\r\n            for char in line[2]:\r\n                if char != 'a':\r\n                    other_than_a_s = True\r\n                else:\r\n                    s_a_count += int(line[1])\r\n\r\n        print('YES' if other_than_a_t or (not other_than_a_s and s_a_count < t_a_count) else 'NO')\r\n",
    "prob_desc_created_at": "1665671700",
    "tags": [
        "constructive algorithms",
        "greedy",
        "strings"
    ],
    "hidden_unit_tests": ""
}
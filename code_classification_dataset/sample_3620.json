{
    "prob_desc_time_limit": "5 seconds",
    "prob_desc_sample_outputs": "[\"2\", \"1\", \"-1\"]",
    "src_uid": "0839633cab23ea726692a1f0ad07d95b",
    "prob_desc_notes": null,
    "prob_desc_description": "The DNA sequence for every living creature in Berland can be represented as a non-empty line consisting of lowercase Latin letters. Berland scientists found out that all the creatures evolve by stages. During one stage exactly one symbol of the DNA line is replaced by exactly two other ones. At that overall there are n permissible substitutions. The substitution ai-&gt;bici means that any one symbol ai can be replaced with two symbols bici. Every substitution could happen an unlimited number of times.They say that two creatures with DNA sequences s1 and s2 can have a common ancestor if there exists such a DNA sequence s3 that throughout evolution it can result in s1 and s2, perhaps after a different number of stages. Your task is to find out by the given s1 and s2 whether the creatures possessing such DNA sequences can have a common ancestor. If the answer is positive, you have to find the length of the shortest sequence of the common ancestor’s DNA.",
    "prob_desc_output_spec": "If s1 and s2 cannot have a common ancestor, print -1. Otherwise print the length of the shortest sequence s3, from which s1 and s2 could have evolved.",
    "prob_desc_input_spec": "The first line contains a non-empty DNA sequence s1, the second line contains a non-empty DNA sequence s2. The lengths of these lines do not exceed 50, the lines contain only lowercase Latin letters. The third line contains an integer n (0 ≤ n ≤ 50) — the number of permissible substitutions. Then follow n lines each of which describes a substitution in the format ai-&gt;bici. The characters ai, bi, and ci are lowercase Latin letters. Lines s1 and s2 can coincide, the list of substitutions can contain similar substitutions.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "Python 3",
    "lang_cluster": "Python",
    "difficulty": 2300,
    "file_name": "train_074.jsonl",
    "code_uid": "6d3c3941ca764d74c6911aa05f65e365",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"ababa\\naba\\n2\\nc-&gt;ba\\nc-&gt;cc\", \"ababa\\naba\\n7\\nc-&gt;ba\\nc-&gt;cc\\ne-&gt;ab\\nz-&gt;ea\\nb-&gt;ba\\nd-&gt;dd\\nd-&gt;ab\", \"ababa\\naba\\n1\\nc-&gt;ba\"]",
    "exec_outcome": "PASSED",
    "source_code": "#!/usr/bin/env python3\n\nimport itertools\nimport collections\n\n# Read input strings\ns1 = input()\ns2 = input()\n\n# Read evolution rules, use a mapping from the 2 target characters to the source character\nrules = collections.defaultdict(set)\nn = int(input())\nfor i in range(n):\n  rule = input()\n  target = rule[-2:]\n  source = rule[0]\n  rules[target].add(source)\n\ndef substrings_of_precise_length(s, l):\n  # Generator for all substrings of s that are of length l \n  for start_pos in range(len(s)-l+1):\n    yield s[start_pos:start_pos+l]\n\ndef substrings_of_minimum_length(s, minlen):\n  # Generator for all substrings of s that are of length l or larger, in order from short to long length\n  return itertools.chain.from_iterable(substrings_of_precise_length(s,l) for l in range(minlen, len(s)+1))\n\ndef partitions_of_string(s):\n  # Generator for all possible pairs (a,b) such that a+b = c where a and b are not empty strings\n  for l1 in range(1, len(s)):\n    yield (s[:l1], s[l1:])\n\n# Dictionary mapping strings onto the set of single characters from which those strings could evolve\nancestors = collections.defaultdict(set)\n\ndef update_ancestors(ancestors, rules, s):\n  # Update the ancestor dictionary for string s\n  # O(len(s)**3 * len(rules))\n  \n  # All single characters can \"evolve\" from a single character\n  for c in s:\n    ancestors[c].add(c)\n\n  # Examine all substrings of s, in order of increasing length\n  for sub in substrings_of_minimum_length(s, 2):\n    # Examine any way the substring can be created from two seperate, smaller strings\n    for (sub1, sub2) in partitions_of_string(sub):\n      # Check all rules to see if the two substrings can evolve from a single character by using that rule\n      for target, sources in rules.items():\n        if (target[0] in ancestors[sub1]) and (target[1] in ancestors[sub2]):\n          ancestors[sub].update(sources)\n\n# Update the ancestors based on s1 and s2\nupdate_ancestors(ancestors, rules, s1)\nupdate_ancestors(ancestors, rules, s2)\n\ndef prefixes(s):\n  # Generator for all non-empty prefixes of s, in order of increasing length\n  for l in range(1, len(s)+1):\n    yield s[:l]\n\ndef determine_shortest_common_ancestor(ancestors, s1, s2):\n  # Returns the length of the shortest common ancestor of string s1 and s2, or float('inf') if there is no common ancestor.\n  # The ancestors is a dictionary that contains for every substring of s1 and s2 the set of single characters from which that substring can evolve\n  # O(len(s1)**2 * len(s2)**2 * 26 )\n\n  # Dictionary mapping pairs of strings onto the length of their shortest common ancestor\n  shortest_common_ancestor = collections.defaultdict(lambda:float('inf'))\n\n  # Check every possible combinations of prefixes of s1 and s2\n  for (pre1,pre2) in itertools.product(prefixes(s1), prefixes(s2)):\n    # If both prefixes have an overlap in the single character from which they can evolve, then the shortest common ancestor is 1 letter\n    if not ancestors[pre1].isdisjoint(ancestors[pre2]):\n      shortest_common_ancestor[(pre1,pre2)] = 1\n\n    # Check all possible combinations of partitions of pre1 and pre2\n    temp = shortest_common_ancestor[(pre1, pre2)]\n    for ((sub1a,sub1b),(sub2a,sub2b)) in itertools.product(partitions_of_string(pre1), partitions_of_string(pre2)):\n      if not ancestors[sub1b].isdisjoint(ancestors[sub2b]):\n        # sub1b and sub2b can evolve from the same character, so the shortest common ancestor of sub1a+sub1b and sub2a+sub2b is\n        # never longer than the shortest common ancestor of sub1a and sub2a plus the one letter from which sub1b and sub2b can evolve\n        temp = min(temp, shortest_common_ancestor[(sub1a, sub2a)] + 1)\n    shortest_common_ancestor[(pre1, pre2)] = temp\n\n  return shortest_common_ancestor[(s1, s2)]\n\nanswer = determine_shortest_common_ancestor(ancestors, s1, s2)\nif (answer == float('inf')):\n  print(-1)\nelse:\n  print(answer)\n",
    "prob_desc_created_at": "1292601600",
    "tags": [
        "dp"
    ],
    "hidden_unit_tests": ""
}
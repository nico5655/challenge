{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"7\\n1\\n1\\n2\\n1\\n3\\n3\\n3\"]",
    "src_uid": "7c0ffbba9e61a25e51c91b1f89c35532",
    "prob_desc_notes": null,
    "prob_desc_description": "You are given a matrix $$$a$$$, consisting of $$$3$$$ rows and $$$n$$$ columns. Each cell of the matrix is either free or taken.A free cell $$$y$$$ is reachable from a free cell $$$x$$$ if at least one of these conditions hold:   $$$x$$$ and $$$y$$$ share a side;  there exists a free cell $$$z$$$ such that $$$z$$$ is reachable from $$$x$$$ and $$$y$$$ is reachable from $$$z$$$. A connected component is a set of free cells of the matrix such that all cells in it are reachable from one another, but adding any other free cell to the set violates this rule.You are asked $$$q$$$ queries about the matrix. Each query is the following:   $$$l$$$ $$$r$$$ — count the number of connected components of the matrix, consisting of columns from $$$l$$$ to $$$r$$$ of the matrix $$$a$$$, inclusive. Print the answers to all queries.",
    "prob_desc_output_spec": "Print $$$q$$$ integers — the $$$j$$$-th value should be equal to the number of the connected components of the matrix, consisting of columns from $$$l_j$$$ to $$$r_j$$$ of the matrix $$$a$$$, inclusive.",
    "prob_desc_input_spec": "The first line contains an integer $$$n$$$ ($$$1 \\le n \\le 5 \\cdot 10^5$$$) — the number of columns of matrix $$$a$$$. The $$$i$$$-th of the next three lines contains a description of the $$$i$$$-th row of the matrix $$$a$$$ — a string, consisting of $$$n$$$ characters. Each character is either $$$1$$$ (denoting a free cell) or $$$0$$$ (denoting a taken cell). The next line contains an integer $$$q$$$ ($$$1 \\le q \\le 3 \\cdot 10^5$$$) — the number of queries. The $$$j$$$-th of the next $$$q$$$ lines contains two integers $$$l_j$$$ and $$$r_j$$$ ($$$1 \\le l_j \\le r_j \\le n$$$) — the description of the $$$j$$$-th query.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3-64",
    "lang_cluster": "Python",
    "difficulty": 2500,
    "file_name": "train_092.jsonl",
    "code_uid": "c2ec762d45fcc57722b5c5f06d808acc",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"12\\n100101011101\\n110110010110\\n010001011101\\n8\\n1 12\\n1 1\\n1 2\\n9 9\\n8 11\\n9 12\\n11 12\\n4 6\"]",
    "exec_outcome": "PASSED",
    "source_code": "import sys\r\n\r\ndef Column2Num( m, idx ):\r\n    return int(m[0][idx] != 0)  | (int(m[1][idx]) << 1) | (int(m[2][idx]) << 2)\r\n\r\ndef QColumn( m, bits, idx ):\r\n    if bits[idx] == 5:\r\n        if m[0][idx] == m[2][idx]:\r\n            return True\r\n    return False\r\n\r\ndef GetIntegratedCount( m ):\r\n    ret, curr = [ 0 ], set()\r\n    for c in range( len( m[0] ) ):\r\n        if m[0][c] != 0: curr.add( m[0][c] )\r\n        if m[1][c] != 0: curr.add( m[1][c] )\r\n        if m[2][c] != 0: curr.add( m[2][c] )\r\n        ret.append( len( curr ) )\r\n    ret.append( len( curr ) )\r\n    return ret\r\n\r\ndef Print( tm ):\r\n    print( '\\n', tm[0], '\\n', tm[1], '\\n', tm[2] )\r\n\r\ndef PrintIndexed( tm ):\r\n    for i in range( len( tm[0] ) ):\r\n        print(  i+1, ':', tm[0][i], tm[1][i], tm[2][i] )\r\n\r\ndef next( b, next ):\r\n\r\n    b &= next\r\n\r\n    if b == 0:\r\n        return b\r\n\r\n    if b & 1 or b & 4:\r\n        if next & 2:\r\n            b |= 2\r\n\r\n    if b & 2:\r\n        if next & 1:\r\n            b |= 1\r\n        if next & 4:\r\n            b |= 4\r\n\r\n    return b\r\n\r\ndef setCompNumber( b, m, i, compNumber ):\r\n    if b & 1:\r\n        m[0][i] = compNumber\r\n    if b & 2:\r\n        m[1][i] = compNumber\r\n    if b & 4:\r\n        m[2][i] = compNumber\r\n\r\n\r\ndef goLeft( start, compNumber, size, m, bits, fullColumn ):\r\n    b = bits[start]\r\n    fc = start\r\n\r\n    for i in range( start - 1, -1, -1 ):\r\n\r\n        b = next( b, bits[i] ) \r\n\r\n        if b == 7:\r\n            fc = i\r\n            break\r\n\r\n        if b == 0:\r\n            break\r\n\r\n        setCompNumber( b, m, i, compNumber )\r\n\r\n        if b == 5:\r\n            fullColumn[ i ] = fc\r\n\r\n\r\ndef goRight( start, compNumber, size, m, bits, fullColumn ):\r\n    \r\n    b = bits[start]\r\n\r\n    for i in range( start, size ):\r\n\r\n        b = next( b, bits[i] ) \r\n\r\n        if b == 7:\r\n            fc = i\r\n\r\n        if b == 0:\r\n            break\r\n\r\n        setCompNumber( b, m, i, compNumber )\r\n\r\n        if b == 5:\r\n            fullColumn[ i ] = fc\r\n\r\ndef goRight12( b, start, compNumber, size, m, bits ):\r\n    \r\n    for i in range( start, size ):\r\n\r\n        b = next( b, bits[i] ) \r\n        if b == 0:\r\n            break\r\n\r\n        setCompNumber( b, m, i, compNumber )\r\n\r\n\r\ndef get3Components( compNumber, size, m, bits, leftFullColumn, rightFullColumn ):\r\n    for i in range( size ):\r\n        if bits[i] == 7:\r\n            if m[ 0 ][ i  ] == 1:\r\n                compNumber += 1\r\n                goRight( i, compNumber, size, m, bits, leftFullColumn )\r\n            goLeft ( i, compNumber, size, m, bits, rightFullColumn )\r\n    return compNumber\r\n\r\ndef get12Components( compNumber, size, m, bits ):\r\n    for i in range( size ):\r\n        if m[ 0 ][ i  ] == 1:\r\n            compNumber += 1\r\n            goRight12( 1, i, compNumber, size, m, bits )\r\n        if m[ 1 ][ i  ] == 1:\r\n            compNumber += 1\r\n            goRight12( 2, i, compNumber, size, m, bits )\r\n        if m[ 2 ][ i  ] == 1:\r\n            compNumber += 1\r\n            goRight12( 4, i, compNumber, size, m, bits )\r\n\r\ndef SolveBB( m, bits, integratedCount, s, e, leftFullColumn, rightFullColumn ):\r\n    #debug = 0\r\n    #print( 'start,end =',s, e )\r\n    #if debug: Print( [ m[0][s-1:e], m[1][s-1:e], m[2][s-1:e] ] )\r\n\r\n    sol1 = 0\r\n    if s-1 == 0:\r\n        sol1 = integratedCount[e]\r\n    else:\r\n        startCnt = 1\r\n        if bits[s-1] == 0:\r\n            startCnt = 0\r\n        elif bits[s-1] == 5:\r\n            if m[0][s-1] != m[2][s-1]:\r\n                startCnt = 2\r\n\r\n        sol1 = startCnt + integratedCount[e] - integratedCount[s]\r\n\r\n    sQ = QColumn( m, bits, s - 1)\r\n    eQ = QColumn( m, bits, e - 1)\r\n\r\n\r\n    if sQ and eQ:\r\n       if m[0][s-1] == m[2][s-1]:\r\n           if rightFullColumn[s-1] == rightFullColumn[e-1]:\r\n                sol1 += 1\r\n                return sol1 \r\n           elif leftFullColumn[s-1] == leftFullColumn[e-1]:\r\n                sol1 += 1\r\n                return sol1 \r\n\r\n    if sQ:\r\n       if rightFullColumn[s-1] != -1:\r\n            if rightFullColumn[s-1] > e-1:\r\n                sol1 += 1\r\n       else:\r\n            sol1 += 1\r\n    if eQ:\r\n        if leftFullColumn[e-1] != -1:\r\n            if leftFullColumn[e-1] < s-1:\r\n                sol1 += 1\r\n        else:\r\n            sol1 += 1\r\n\r\n    return sol1\r\n\r\ndef mainBB():\r\n    debug = 0\r\n    input = sys.stdin\r\n    if len( sys.argv ) >= 2:\r\n        input = open( sys.argv[1], 'r' )\r\n\r\n    size = int( input.readline() )\r\n    m = []\r\n    for i in range( 3 ):\r\n        m.append( [ int( t ) for t in list( input.readline().strip() ) ] )\r\n    bits = [ Column2Num( m, i ) for i in range( size ) ]    \r\n\r\n    leftFullColumn = [ -1 for i in range( size ) ]\r\n    rightFullColumn = list(  leftFullColumn )\r\n\r\n    compNumber = get3Components( 1, size, m, bits, leftFullColumn, rightFullColumn )\r\n    get12Components( compNumber, size, m, bits )\r\n    integratedCount = GetIntegratedCount( m )\r\n\r\n    if debug: PrintIndexed( m )\r\n    if debug: Print( m )\r\n    if debug: print( integratedCount )\r\n    if debug: print( leftFullColumn )\r\n    if debug: print( rightFullColumn )\r\n\r\n    n = int( input.readline() )\r\n    for i in range( n ):\r\n        ln = input.readline().strip().split()\r\n        s = int( ln[0] )\r\n        e = int( ln[1] )\r\n        if debug: print( s, e, m )\r\n\r\n        print( SolveBB( m, bits, integratedCount, s, e, leftFullColumn, rightFullColumn ) )\r\n\r\nif __name__ == \"__main__\":\r\n    mainBB()    \r\n    \r\n\r\n\r\n \r\n",
    "prob_desc_created_at": "1649514900",
    "tags": [
        "brute force",
        "data structures",
        "dp",
        "dsu",
        "math",
        "trees"
    ],
    "hidden_unit_tests": ""
}
{
    "prob_desc_time_limit": "6 seconds",
    "prob_desc_sample_outputs": "[\"3\\n4\\n1\\n6\"]",
    "src_uid": "9083555e4792840e8a259a6b581ade6a",
    "prob_desc_notes": "NoteConsider the example test case.The answer to the first query is $$$3$$$, as there are three suitable substrings: $$$s[3\\dots6]$$$, $$$s[3\\dots4]$$$ and $$$s[5\\dots6]$$$.The answer to the second query is $$$4$$$. The substrings are $$$s[3\\dots6]$$$, $$$s[3\\dots4]$$$, $$$s[5\\dots6]$$$ and $$$s[2\\dots7]$$$.The answer to the third query is $$$1$$$. The substring is $$$s[8\\dots9]$$$.The answer to the fourth query is $$$6$$$. The substrings are $$$s[3\\dots6]$$$, $$$s[3\\dots4]$$$, $$$s[5\\dots6]$$$, $$$s[2\\dots7]$$$, $$$s[8\\dots9]$$$ and $$$s[2\\dots9]$$$.",
    "prob_desc_description": "This is the easy version of the problem. The only difference between the easy and the hard versions are removal queries, they are present only in the hard version.\"Interplanetary Software, Inc.\" together with \"Robots of Cydonia, Ltd.\" has developed and released robot cats. These electronic pets can meow, catch mice and entertain the owner in various ways.The developers from \"Interplanetary Software, Inc.\" have recently decided to release a software update for these robots. After the update, the cats must solve the problems about bracket sequences. One of the problems is described below.  First, we need to learn a bit of bracket sequence theory. Consider the strings that contain characters \"(\", \")\" and \".\". Call a string regular bracket sequence (RBS), if it can be transformed to an empty string by one or more operations of removing either single \".\" characters, or a continuous substring \"()\". For instance, the string \"(()(.))\" is an RBS, as it can be transformed to an empty string with the following sequence of removals: \"(()(.))\" $$$\\rightarrow$$$ \"(()())\" $$$\\rightarrow$$$ \"(())\" $$$\\rightarrow$$$ \"()\" $$$\\rightarrow$$$ \"\". We got an empty string, so the initial string was an RBS. At the same time, the string \")(\" is not an RBS, as it is not possible to apply such removal operations to it.An RBS is simple if this RBS is not empty, doesn't start with \".\", and doesn't end with \".\".Denote the substring of the string $$$s$$$ as its sequential subsegment. In particular, $$$s[l\\dots r] = s_ls_{l+1}\\dots s_r$$$, where $$$s_i$$$ is the $$$i$$$-th character of the string $$$s$$$.Now, move on to the problem statement itself. You are given a string $$$s$$$, initially consisting of characters \"(\" and \")\". You need to answer the queries of the following kind.Given two indices, $$$l$$$ and $$$r$$$ ($$$1 \\le l &lt; r \\le n$$$), and it's guaranteed that the substring $$$s[l\\dots r]$$$ is a simple RBS. You need to find the number of substrings in $$$s[l\\dots r]$$$ such that they are simple RBS. In other words, find the number of index pairs $$$i$$$, $$$j$$$ such that $$$l \\le i &lt; j \\le r$$$ and $$$s[i\\dots j]$$$ is a simple RBS.You are an employee in \"Interplanetary Software, Inc.\" and you were given the task to teach the cats to solve the problem above, after the update.Note that the \".\" character cannot appear in the string in this version of the problem. It is only needed for the hard version.",
    "prob_desc_output_spec": "For each query, print a single integer in a separate line, the number of substrings that are simple RBS. The answers must be printed in the same order as the queries are specified in the input.",
    "prob_desc_input_spec": "The first line contains two integers $$$n$$$ and $$$q$$$ ($$$2 \\le n \\le 3\\cdot10^5$$$, $$$1 \\le q \\le 3\\cdot10^5$$$), the length of the string, and the number of queries. The second line contains the string $$$s$$$, consisting of $$$n$$$ characters \"(\" and \")\". Each of the following $$$q$$$ lines contains three integers $$$t$$$, $$$l$$$ and $$$r$$$ ($$$t = 2$$$, $$$1 \\le l &lt; r \\le n$$$), the queries you need to answer. It is guaranteed that all the queries are valid and correspond to the problem statements. Note that $$$t$$$ is unused and always equal to two in this problem. It is required for the hard version of the problem.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3",
    "lang_cluster": "Python",
    "difficulty": 2500,
    "file_name": "train_085.jsonl",
    "code_uid": "6ba0c3bcc73fe1ee125e5d579c46d9d1",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"9 4\\n)(()())()\\n2 3 6\\n2 2 7\\n2 8 9\\n2 2 9\"]",
    "exec_outcome": "PASSED",
    "source_code": "''' E1. Cats on the Upgrade (easy version)\nhttps://codeforces.com/contest/1625/problem/E1\n'''\n\nimport io, os, sys\n\ninput = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline  # decode().strip() if str\noutput = sys.stdout.write\n\nDEBUG = os.environ.get('debug') not in [None, '0']\n\nif DEBUG:\n    from inspect import currentframe, getframeinfo\n    from re import search\n\ndef debug(*args):\n    if not DEBUG: return\n    frame = currentframe().f_back\n    s = getframeinfo(frame).code_context[0]\n    r = search(r\"\\((.*)\\)\", s).group(1)\n    vnames = r.split(', ')\n    var_and_vals = [f'{var}={val}' for var, val in zip(vnames, args)]\n    prefix = f'{currentframe().f_back.f_lineno:02d}: '\n    print(f'{prefix}{\", \".join(var_and_vals)}')\n\n\nINF = float('inf')\n\n# -----------------------------------------\nfrom typing import List\n\nclass SegmentTreeInfo:\n    def __init__(self, parent=INF, sum=0, cnt=0): \n        self.parent = parent\n        self.sum = sum\n        self.cnt = cnt\n\n    def __add__(self, other): \n        res = SegmentTreeInfo()\n        res.sum = self.sum + other.sum\n        if self.parent < other.parent: res.parent, res.cnt = self.parent, self.cnt\n        elif self.parent > other.parent: res.parent, res.cnt = other.parent, other.cnt\n        else: res.parent, res.cnt = self.parent, self.cnt + other.cnt\n        return res\n    \n    def __repr__(self):\n        return f'SegmentTreeInfo(parent={self.parent},sum={self.sum},cnt={self.cnt})'\n\n\nclass SegmentTree:\n    def __init__(self, N: int = 0, init_arr: List[SegmentTreeInfo] = None) -> None:\n        '''init segtree intervals, optionally with data'''\n        assert (N == 0) ^ (init_arr is None), f'Must set either N or init_arr'\n        if N == 0: N = len(init_arr)\n\n        def _build(p: int, lo: int, hi: int) -> None:\n            if lo == hi: \n                if init_arr: self.arr[p] = init_arr[lo]\n            else:\n                mi = (lo+hi) // 2\n                _build(2*p+1, lo, mi)\n                _build(2*p+2, mi+1, hi)\n\n        self.N = N\n        self.tree = [SegmentTreeInfo() for _ in range(1 << (N.bit_length() + 1))]\n        _build(0, 0, N-1)\n\n    def query(self, qlo: int, qhi: int, p: int = 0, lo: int = 0, hi: int = -1) -> SegmentTreeInfo:\n        '''range query qlo..qhi intersect self.lo..self.hi (default entire tree)'''\n        if hi == -1: hi = self.N - 1\n        if qlo > hi or qhi < lo: return SegmentTreeInfo()\n        if qlo <= lo <= hi <= qhi: return self.tree[p]\n        mi = (lo+hi) // 2\n        left = self.query(qlo, qhi, 2*p+1, lo, mi)\n        right = self.query(qlo, qhi, 2*p+2, mi+1, hi)\n        return left + right\n\n    def update(self, qi: int, v: SegmentTreeInfo, p: int = 0, lo: int = 0, hi: int = -1):\n        '''update this segment and children when data[qi]=v'''\n        if hi == -1: hi = self.N - 1\n        if qi < lo or qi > hi: return\n        if lo == hi: self.tree[p] = v\n        elif lo < hi:\n            mi = (lo+hi) // 2\n            self.update(qi, v, 2*p+1, lo, mi)\n            self.update(qi, v, 2*p+2, mi+1, hi)\n            self.tree[p] = self.tree[2*p+1] + self.tree[2*p+2]\n\n\ndef solve():\n    N, Q = map(int, input().split())\n    S = input().decode().strip()\n\n    # build bracket tree: go down 1 level for (, up for )\n    # each vertex is a RBS\n    # par[i] = index of parent ( for S[i] = (; might be set when bracket invalid\n    # match[i] = index of matching bracket of S[i]; only set when bracket valid\n    par = [-1] * N\n    match = [-1] * N\n    stack = []\n    for i, c in enumerate(S):\n        if c == '(':\n            stack.append(i)\n        elif stack:  # ignore unmatched brackets\n            j = stack.pop()\n            match[i], match[j] = j, i\n            if j > 0:\n                if S[j-1] == '(': par[j] = j-1                    # parent and child\n                elif match[j-1] != -1: par[j] = par[match[j-1]]   # siblings\n    \n    # count num children\n    deg = [0] * N\n    for i in range(N):\n        if par[i] != -1:  # valid, non-root open\n            deg[par[i]] += 1\n\n    # segtree data = (par idx, num RBS entirely under a child, num children)\n    segtree = SegmentTree(N)\n    for i in range(N):\n        if i < match[i]:  # valid open\n            segtree.update(i, SegmentTreeInfo(par[i], deg[i] * (deg[i] + 1) // 2, 1))\n\n    # segtree.query(l, r) = num RBS within S[l..r]\n    res = []\n    for _ in range(Q):\n        _, l, r = map(int, input().split())\n        v = segtree.query(l-1, r-1)\n        res.append(v.sum + v.cnt * (v.cnt + 1) // 2)\n    \n    print('\\n'.join(map(str, res)))\n\n\nif __name__ == '__main__':\n    solve()\n\n",
    "prob_desc_created_at": "1641989100",
    "tags": [
        "brute force",
        "data structures",
        "dfs and similar",
        "divide and conquer",
        "dp",
        "graphs",
        "trees"
    ],
    "hidden_unit_tests": ""
}
{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"7\\n9\\n6\"]",
    "src_uid": "07eecfe948aa78623586b5e30e84e415",
    "prob_desc_notes": null,
    "prob_desc_description": "You are given a string $$$s$$$ consisting only of characters + and -. You perform some process with this string. This process can be described by the following pseudocode: res = 0for init = 0 to inf    cur = init    ok = true    for i = 1 to |s|        res = res + 1        if s[i] == '+'            cur = cur + 1        else            cur = cur - 1        if cur &lt; 0            ok = false            break    if ok        breakNote that the $$$inf$$$ denotes infinity, and the characters of the string are numbered from $$$1$$$ to $$$|s|$$$.You have to calculate the value of the $$$res$$$ after the process ends.",
    "prob_desc_output_spec": "For each test case print one integer — the value of the $$$res$$$ after the process ends.",
    "prob_desc_input_spec": "The first line contains one integer $$$t$$$ ($$$1 \\le t \\le 1000$$$) — the number of test cases. The only lines of each test case contains string $$$s$$$ ($$$1 \\le |s| \\le 10^6$$$) consisting only of characters + and -. It's guaranteed that sum of $$$|s|$$$ over all test cases doesn't exceed $$$10^6$$$.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3",
    "lang_cluster": "Python",
    "difficulty": 1300,
    "file_name": "train_028.jsonl",
    "code_uid": "75425791a6d2f4e6319a22315e7f18ec",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"3\\n--+-\\n---\\n++--+-\"]",
    "exec_outcome": "PASSED",
    "source_code": "#!/usr/bin/env python\nfrom __future__ import division, print_function\n\nimport os\nimport sys\nfrom io import BytesIO, IOBase\n\nif sys.version_info[0] < 3:\n    from __builtin__ import xrange as range\n    from future_builtins import ascii, filter, hex, map, oct, zip\n\n\n# region fastio\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\ndef print(*args, **kwargs):\n    \"\"\"Prints the values to a stream, or to sys.stdout by default.\"\"\"\n    sep, file = kwargs.pop(\"sep\", \" \"), kwargs.pop(\"file\", sys.stdout)\n    at_start = True\n    for x in args:\n        if not at_start:\n            file.write(sep)\n        file.write(str(x))\n        at_start = False\n    file.write(kwargs.pop(\"end\", \"\\n\"))\n    if kwargs.pop(\"flush\", False):\n        file.flush()\n\n\nif sys.version_info[0] < 3:\n    sys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)\nelse:\n    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\n\n\nfrom math import sqrt, floor, factorial, gcd, log\nfrom collections import deque, Counter, defaultdict\nfrom itertools import permutations, combinations\nfrom math import gcd\nfrom bisect import bisect\n\n\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\nread = lambda: list(map(int, input().strip().split(\" \")))\n\n\n\ndef func(x):\n    t = 0\n    for i in arr:\n        if i <= x:\n            t += i\n    return(t)\n\ndef solve():\n    for _ in range(int(input())):\n        s = input(); \n        arr = [[-1, 1][i==\"+\"] for i in s]\n        for i in range(1, len(s)):arr[i] += arr[i-1]\n        ans = 0; sett = set()\n\n        for i in range(len(s)):\n            if arr[i] < 0 and arr[i] not in sett:\n                ans += i+1\n                sett.add(arr[i])\n        # print(arr, sett)\n        # if ans:\n        print(ans+len(s))\n        # else:\n        #     print(len(s))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\nif __name__ == \"__main__\":\n\tsolve()",
    "prob_desc_created_at": "1593095700",
    "tags": [
        "math"
    ],
    "hidden_unit_tests": ""
}
{
    "prob_desc_time_limit": "1 second",
    "prob_desc_sample_outputs": "[\"YES\\n4 7 4 7\", \"NO\"]",
    "src_uid": "ae5757df3be42b74076cdf42f7f897cd",
    "prob_desc_notes": null,
    "prob_desc_description": "Levko loves array a1, a2, ... , an, consisting of integers, very much. That is why Levko is playing with array a, performing all sorts of operations with it. Each operation Levko performs is of one of two types:  Increase all elements from li to ri by di. In other words, perform assignments aj = aj + di for all j that meet the inequation li ≤ j ≤ ri.  Find the maximum of elements from li to ri. That is, calculate the value . Sadly, Levko has recently lost his array. Fortunately, Levko has records of all operations he has performed on array a. Help Levko, given the operation records, find at least one suitable array. The results of all operations for the given array must coincide with the record results. Levko clearly remembers that all numbers in his array didn't exceed 109 in their absolute value, so he asks you to find such an array.",
    "prob_desc_output_spec": "In the first line print \"YES\" (without the quotes), if the solution exists and \"NO\" (without the quotes) otherwise. If the solution exists, then on the second line print n integers a1, a2, ... , an (|ai| ≤ 109) — the recovered array.",
    "prob_desc_input_spec": "The first line contains two integers n and m (1 ≤ n, m ≤ 5000) — the size of the array and the number of operations in Levko's records, correspondingly. Next m lines describe the operations, the i-th line describes the i-th operation. The first integer in the i-th line is integer ti (1 ≤ ti ≤ 2) that describes the operation type. If ti = 1, then it is followed by three integers li, ri and di (1 ≤ li ≤ ri ≤ n,  - 104 ≤ di ≤ 104) — the description of the operation of the first type. If ti = 2, then it is followed by three integers li, ri and mi (1 ≤ li ≤ ri ≤ n,  - 5·107 ≤ mi ≤ 5·107) — the description of the operation of the second type. The operations are given in the order Levko performed them on his array.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3",
    "lang_cluster": "Python",
    "difficulty": 1700,
    "file_name": "train_008.jsonl",
    "code_uid": "f8e1021fc7e366d1e598be28bf99e1aa",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"4 5\\n1 2 3 1\\n2 1 2 8\\n2 3 4 7\\n1 1 3 3\\n2 3 4 8\", \"4 5\\n1 2 3 1\\n2 1 2 8\\n2 3 4 7\\n1 1 3 3\\n2 3 4 13\"]",
    "exec_outcome": "PASSED",
    "source_code": "import os\nimport sys\nfrom io import BytesIO, IOBase\n\nBUFSIZE = 8192\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\ndef list2d(a, b, c): return [[c] * b for i in range(a)]\ndef list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]\ndef list4d(a, b, c, d, e): return [[[[e] * d for j in range(c)] for j in range(b)] for i in range(a)]\ndef ceil(x, y=1): return int(-(-x // y))\ndef Yes(): print('Yes')\ndef No(): print('No')\ndef YES(): print('YES')\ndef NO(): print('NO')\nINF = 10 ** 18\nMOD = 10**9+7\n\nRi = lambda : [int(x) for x in sys.stdin.readline().split()]\nri = lambda : sys.stdin.readline().strip()\n\nn,m = Ri()\nlis = []\nfor i in range(m):\n    lis.append(Ri())\nans = [10**9]*n\nfor i in range(m-1,-1,-1):\n    if lis[i][0] == 2:\n        for j in range(lis[i][1]-1,lis[i][2]):\n            ans[j] = min(ans[j], lis[i][3])\n    else:\n        for j in range(lis[i][1]-1,lis[i][2]):\n            if ans[j] != 10**9:\n                ans[j]-=lis[i][3]\n\nfor i in range(n):\n    if ans[i] == 10**9:\n        ans[i] = -10**9\ntemp = ans[:]\n# print(temp)\nflag = True\nfor i in range(m):\n    if lis[i][0] == 2:\n        t= -10**9\n        for j in range(lis[i][1]-1,lis[i][2]):\n            t = max(t, temp[j])\n        if t != lis[i][3]:\n            flag = False\n            break\n    else:\n        for j in range(lis[i][1]-1,lis[i][2]):\n            temp[j]+=lis[i][3]\n# print(temp, ans)\nif flag :\n    YES()\n    print(*ans)\nelse:\n    NO()\n    # print(-1)",
    "prob_desc_created_at": "1384102800",
    "tags": [
        "implementation",
        "greedy"
    ],
    "hidden_unit_tests": ""
}
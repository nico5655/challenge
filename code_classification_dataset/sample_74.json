{
    "prob_desc_time_limit": "1 second",
    "prob_desc_sample_outputs": "[\"1 2 3\\n1 2 1 2\\n1 3 4 3 2 4 2\\n1 3 2\\n1 2 3 1 2 3 1 2 3 2\"]",
    "src_uid": "7647528166b72c780d332ef4ff28cb86",
    "prob_desc_notes": "NoteIn the first test case $$$p = [1, 2, 3]$$$.It is a correct answer, because:  $$$p_1 = 1 = a_1$$$, $$$p_2 = 2 = b_2$$$, $$$p_3 = 3 = c_3$$$  $$$p_1 \\neq p_2 $$$, $$$p_2 \\neq p_3 $$$, $$$p_3 \\neq p_1$$$ All possible correct answers to this test case are: $$$[1, 2, 3]$$$, $$$[1, 3, 2]$$$, $$$[2, 1, 3]$$$, $$$[2, 3, 1]$$$, $$$[3, 1, 2]$$$, $$$[3, 2, 1]$$$.In the second test case $$$p = [1, 2, 1, 2]$$$.In this sequence $$$p_1 = a_1$$$, $$$p_2 = a_2$$$, $$$p_3 = a_3$$$, $$$p_4 = a_4$$$. Also we can see, that no two adjacent elements of the sequence are equal.In the third test case $$$p = [1, 3, 4, 3, 2, 4, 2]$$$.In this sequence $$$p_1 = a_1$$$, $$$p_2 = a_2$$$, $$$p_3 = b_3$$$, $$$p_4 = b_4$$$, $$$p_5 = b_5$$$, $$$p_6 = c_6$$$, $$$p_7 = c_7$$$. Also we can see, that no two adjacent elements of the sequence are equal.",
    "prob_desc_description": "You are given three sequences: $$$a_1, a_2, \\ldots, a_n$$$; $$$b_1, b_2, \\ldots, b_n$$$; $$$c_1, c_2, \\ldots, c_n$$$.For each $$$i$$$, $$$a_i \\neq b_i$$$, $$$a_i \\neq c_i$$$, $$$b_i \\neq c_i$$$.Find a sequence $$$p_1, p_2, \\ldots, p_n$$$, that satisfy the following conditions: $$$p_i \\in \\{a_i, b_i, c_i\\}$$$ $$$p_i \\neq p_{(i \\mod n) + 1}$$$.In other words, for each element, you need to choose one of the three possible values, such that no two adjacent elements (where we consider elements $$$i,i+1$$$ adjacent for $$$i&lt;n$$$ and also elements $$$1$$$ and $$$n$$$) will have equal value.It can be proved that in the given constraints solution always exists. You don't need to minimize/maximize anything, you need to find any proper sequence.",
    "prob_desc_output_spec": "For each test case, print $$$n$$$ integers: $$$p_1, p_2, \\ldots, p_n$$$ ($$$p_i \\in \\{a_i, b_i, c_i\\}$$$, $$$p_i \\neq p_{i \\mod n + 1}$$$). If there are several solutions, you can print any.",
    "prob_desc_input_spec": "The first line of input contains one integer $$$t$$$ ($$$1 \\leq t \\leq 100$$$): the number of test cases. The first line of each test case contains one integer $$$n$$$ ($$$3 \\leq n \\leq 100$$$): the number of elements in the given sequences. The second line contains $$$n$$$ integers $$$a_1, a_2, \\ldots, a_n$$$ ($$$1 \\leq a_i \\leq 100$$$). The third line contains $$$n$$$ integers $$$b_1, b_2, \\ldots, b_n$$$ ($$$1 \\leq b_i \\leq 100$$$). The fourth line contains $$$n$$$ integers $$$c_1, c_2, \\ldots, c_n$$$ ($$$1 \\leq c_i \\leq 100$$$). It is guaranteed that $$$a_i \\neq b_i$$$, $$$a_i \\neq c_i$$$, $$$b_i \\neq c_i$$$ for all $$$i$$$.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3",
    "lang_cluster": "Python",
    "difficulty": 800,
    "file_name": "train_000.jsonl",
    "code_uid": "363d4c03f6f540b6003a447a4228a50a",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"5\\n3\\n1 1 1\\n2 2 2\\n3 3 3\\n4\\n1 2 1 2\\n2 1 2 1\\n3 4 3 4\\n7\\n1 3 3 1 1 1 1\\n2 4 4 3 2 2 4\\n4 2 2 2 4 4 2\\n3\\n1 2 1\\n2 3 3\\n3 1 2\\n10\\n1 1 1 2 2 2 3 3 3 1\\n2 2 2 3 3 3 1 1 1 2\\n3 3 3 1 1 1 2 2 2 3\"]",
    "exec_outcome": "PASSED",
    "source_code": "#!/usr/bin/env python\nfrom __future__ import division, print_function\n\nimport os\nimport sys\nfrom io import BytesIO, IOBase\n\ndef main():\n    for _ in range(int(input())):\n        n = int(input())\n        a = list(map(int,input().split()))\n        b = list(map(int,input().split()))\n        c = list(map(int,input().split()))\n        ans = [a[0]]\n        for i in range(1,n-1):\n            if a[i] != ans[-1]:\n                ans.append(a[i])\n            elif b[i] != ans[-1]:\n                ans.append(b[i])\n            elif c[i] != ans[-1]:\n                ans.append(c[i])\n        if a[-1] != ans[-1] and a[-1] != ans[0]:\n            ans.append(a[-1])\n        elif b[-1] != ans[-1] and b[-1] != ans[0]:\n            ans.append(b[-1])\n        elif c[-1] != ans[-1] and c[-1] != ans[0]:\n            ans.append(c[-1])\n        print(\" \".join(map(str,ans)))\n\n\n# region fastio\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\ndef print(*args, **kwargs):\n    \"\"\"Prints the values to a stream, or to sys.stdout by default.\"\"\"\n    sep, file = kwargs.pop(\"sep\", \" \"), kwargs.pop(\"file\", sys.stdout)\n    at_start = True\n    for x in args:\n        if not at_start:\n            file.write(sep)\n        file.write(str(x))\n        at_start = False\n    file.write(kwargs.pop(\"end\", \"\\n\"))\n    if kwargs.pop(\"flush\", False):\n        file.flush()\n\n\nif sys.version_info[0] < 3:\n    sys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)\nelse:\n    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\n\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n# endregion\n\nif __name__ == \"__main__\":\n    main()\n",
    "prob_desc_created_at": "1601476500",
    "tags": [
        "constructive algorithms"
    ],
    "hidden_unit_tests": ""
}
{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"1\\n2\\n1\", \"1\\n1\\n-1\\n-1\"]",
    "src_uid": "e6ce5b7211a6680ebce5250edfc59e72",
    "prob_desc_notes": "NoteIn the first example there are three queries:  query $$$[1; 3]$$$ can be covered by interval $$$[1; 3]$$$;  query $$$[1; 4]$$$ can be covered by intervals $$$[1; 3]$$$ and $$$[2; 4]$$$. There is no way to cover $$$[1; 4]$$$ by a single interval;  query $$$[3; 4]$$$ can be covered by interval $$$[2; 4]$$$. It doesn't matter that the other points are covered besides the given query. In the second example there are four queries:  query $$$[1; 2]$$$ can be covered by interval $$$[1; 3]$$$. Note that you can choose any of the two given intervals $$$[1; 3]$$$;  query $$$[1; 3]$$$ can be covered by interval $$$[1; 3]$$$;  query $$$[1; 4]$$$ can't be covered by any set of intervals;  query $$$[1; 5]$$$ can't be covered by any set of intervals. Note that intervals $$$[1; 3]$$$ and $$$[4; 5]$$$ together don't cover $$$[1; 5]$$$ because even non-integer points should be covered. Here $$$3.5$$$, for example, isn't covered. ",
    "prob_desc_description": "You are given $$$n$$$ intervals in form $$$[l; r]$$$ on a number line.You are also given $$$m$$$ queries in form $$$[x; y]$$$. What is the minimal number of intervals you have to take so that every point (not necessarily integer) from $$$x$$$ to $$$y$$$ is covered by at least one of them? If you can't choose intervals so that every point from $$$x$$$ to $$$y$$$ is covered, then print -1 for that query.",
    "prob_desc_output_spec": "Print $$$m$$$ integer numbers. The $$$i$$$-th number should be the answer to the $$$i$$$-th query: either the minimal number of intervals you have to take so that every point (not necessarily integer) from $$$x_i$$$ to $$$y_i$$$ is covered by at least one of them or -1 if you can't choose intervals so that every point from $$$x_i$$$ to $$$y_i$$$ is covered.",
    "prob_desc_input_spec": "The first line contains two integers $$$n$$$ and $$$m$$$ ($$$1 \\le n, m \\le 2 \\cdot 10^5$$$) — the number of intervals and the number of queries, respectively. Each of the next $$$n$$$ lines contains two integer numbers $$$l_i$$$ and $$$r_i$$$ ($$$0 \\le l_i &lt; r_i \\le 5 \\cdot 10^5$$$) — the given intervals. Each of the next $$$m$$$ lines contains two integer numbers $$$x_i$$$ and $$$y_i$$$ ($$$0 \\le x_i &lt; y_i \\le 5 \\cdot 10^5$$$) — the queries.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 2",
    "lang_cluster": "Python",
    "difficulty": 2200,
    "file_name": "train_042.jsonl",
    "code_uid": "9220c3e1057cd55003561e7e1b6d2f44",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"2 3\\n1 3\\n2 4\\n1 3\\n1 4\\n3 4\", \"3 4\\n1 3\\n1 3\\n4 5\\n1 2\\n1 3\\n1 4\\n1 5\"]",
    "exec_outcome": "PASSED",
    "source_code": "from __future__ import division, print_function\n\nDEBUG = 0\n\nimport os, sys\nfrom atexit import register\nfrom io import BytesIO\nimport itertools\n\nif sys.version_info[0] < 3:\n    input = raw_input\n    range = xrange\n\n    filter = itertools.ifilter\n    map = itertools.imap\n    zip = itertools.izip\n\nif DEBUG:\n    debug_print = print\nelse:\n    sys.stdin = BytesIO(os.read(0, os.fstat(0).st_size))\n    sys.stdout = BytesIO()\n    register(lambda: os.write(1, sys.stdout.getvalue()))\n\n    input = lambda: sys.stdin.readline().rstrip('\\r\\n')\n    debug_print = lambda *x, **y: None\n\n\ndef input_as_list():\n    return list(map(int, input().split()))\n\ndef array_of(f, *dim):\n    return [array_of(f, *dim[1:]) for _ in range(dim[0])] if dim else f()\n\ndef build_binary_lifting_array(tree):\n    \"\"\" Tree is represented as parent of node n = tree[n].\n\n        Parent of the root node should be -1.\n    \"\"\"\n\n    def array_of(f, *dim):\n        return [array_of(f, *dim[1:]) for _ in range(dim[0])] if dim else f()\n\n    size = len(tree)\n    max_depth = size.bit_length()\n\n    result = array_of(lambda:-1, max_depth, size)\n    result[0] = list(tree)\n\n    for depth in range(1, max_depth):\n        for node in range(0, size):\n            try:\n                result[depth][node] = result[depth - 1][result[depth - 1][node]]\n            except:\n                pass\n\n    return result\n\ndef main():\n    n, m = input_as_list()\n    segs = [input_as_list() for _ in range(n)]\n    queries = [input_as_list() for _ in range(m)]\n\n    MAX = 500001\n    if DEBUG: MAX = 101\n\n    endpoints = array_of(lambda: -1, MAX)\n    for s, e in segs:\n        endpoints[s] = max(endpoints[s], e)\n\n    cur_max = -1\n    for i, e in enumerate(endpoints):\n        if cur_max <= i:\n            cur_max = -1\n        cur_max = max(cur_max, e)\n        endpoints[i] = cur_max\n\n    blt = build_binary_lifting_array(endpoints)\n    debug_print(*blt, sep='\\n')\n\n    max_depth = len(blt)\n    pow2 = [1, 1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024,\n            2048, 4096, 8192, 16384, 32768, 65536, 131072,\n            262144, 524288]\n    out = []\n    for s, e in queries:\n        cnt, depth = 0, 0\n\n        while True:\n            if blt[depth][s] == -1:\n                if depth == 0:\n                    if s < e: cnt = -1\n                    break\n                else:\n                    s = blt[depth-1][s]\n                    depth = 0\n            elif blt[depth][s] == e:\n                cnt += pow2[depth]\n                break\n            elif blt[depth][s] > e:\n                if depth == 0:\n                    cnt += 1\n                    break\n                else:\n                    s = blt[depth-1][s]\n                    depth = 0\n            else:\n                cnt += pow2[depth]\n                if depth == max_depth-1:\n                    s = blt[depth][s]\n                    depth = 0\n                else:\n                    depth += 1\n\n        out.append(str(cnt))\n\n    print('\\n'.join(out))\n\nmain()",
    "prob_desc_created_at": "1559745300",
    "tags": [
        "dp",
        "greedy",
        "implementation",
        "divide and conquer",
        "data structures",
        "dfs and similar",
        "trees"
    ],
    "hidden_unit_tests": ""
}
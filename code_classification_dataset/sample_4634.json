{
    "prob_desc_time_limit": "3 seconds",
    "prob_desc_sample_outputs": "[\"39\\n32\\n0\"]",
    "src_uid": "99e3ab8db0a27cdb6882486dcd46ef0b",
    "prob_desc_notes": "Note  In the first query, their movement from the $$$1$$$-st to the $$$2$$$-nd room is as follows.  $$$1 \\rightarrow 5$$$ — takes $$$\\max(|10 + 4|, |10 - 4|) = 14$$$ energy.  $$$5 \\rightarrow 6$$$ — takes $$$\\max(|4 + (-6)|, |4 - (-6)|) = 10$$$ energy.  $$$6 \\rightarrow 2$$$ — takes $$$\\max(|-6 + (-9)|, |-6 - (-9)|) = 15$$$ energy.  In total, it takes $$$39$$$ energy.In the second query, the illusion rate of the $$$1$$$-st room changes from $$$10$$$ to $$$-3$$$.In the third query, their movement from the $$$1$$$-st to the $$$2$$$-nd room is as follows.  $$$1 \\rightarrow 5$$$ — takes $$$\\max(|-3 + 4|, |-3 - 4|) = 7$$$ energy.  $$$5 \\rightarrow 6$$$ — takes $$$\\max(|4 + (-6)|, |4 - (-6)|) = 10$$$ energy.  $$$6 \\rightarrow 2$$$ — takes $$$\\max(|-6 + (-9)|, |-6 - (-9)|) = 15$$$ energy. Now, it takes $$$32$$$ energy.",
    "prob_desc_description": "Chanek Jones is back, helping his long-lost relative Indiana Jones, to find a secret treasure in a maze buried below a desert full of illusions.The map of the labyrinth forms a tree with $$$n$$$ rooms numbered from $$$1$$$ to $$$n$$$ and $$$n - 1$$$ tunnels connecting them such that it is possible to travel between each pair of rooms through several tunnels.The $$$i$$$-th room ($$$1 \\leq i \\leq n$$$) has $$$a_i$$$ illusion rate. To go from the $$$x$$$-th room to the $$$y$$$-th room, there must exist a tunnel between $$$x$$$ and $$$y$$$, and it takes $$$\\max(|a_x + a_y|, |a_x - a_y|)$$$ energy. $$$|z|$$$ denotes the absolute value of $$$z$$$.To prevent grave robbers, the maze can change the illusion rate of any room in it. Chanek and Indiana would ask $$$q$$$ queries.There are two types of queries to be done:  $$$1\\ u\\ c$$$ — The illusion rate of the $$$x$$$-th room is changed to $$$c$$$ ($$$1 \\leq u \\leq n$$$, $$$0 \\leq |c| \\leq 10^9$$$).  $$$2\\ u\\ v$$$ — Chanek and Indiana ask you the minimum sum of energy needed to take the secret treasure at room $$$v$$$ if they are initially at room $$$u$$$ ($$$1 \\leq u, v \\leq n$$$). Help them, so you can get a portion of the treasure!",
    "prob_desc_output_spec": "For each type $$$2$$$ query, output a line containing an integer — the minimum sum of energy needed for Chanek and Indiana to take the secret treasure.",
    "prob_desc_input_spec": "The first line contains two integers $$$n$$$ and $$$q$$$ ($$$2 \\leq n \\leq 10^5$$$, $$$1 \\leq q \\leq 10^5$$$) — the number of rooms in the maze and the number of queries. The second line contains $$$n$$$ integers $$$a_1, a_2, \\ldots, a_n$$$ ($$$0 \\leq |a_i| \\leq 10^9$$$) — inital illusion rate of each room. The $$$i$$$-th of the next $$$n-1$$$ lines contains two integers $$$s_i$$$ and $$$t_i$$$ ($$$1 \\leq s_i, t_i \\leq n$$$), meaning there is a tunnel connecting $$$s_i$$$-th room and $$$t_i$$$-th room. The given edges form a tree. The next $$$q$$$ lines contain the query as described. The given queries are valid.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3",
    "lang_cluster": "Python",
    "difficulty": 2300,
    "file_name": "train_102.jsonl",
    "code_uid": "84f05661557fd1a0cc492051130ef824",
    "prob_desc_memory_limit": "512 megabytes",
    "prob_desc_sample_inputs": "[\"6 4\\n10 -9 2 -1 4 -6\\n1 5\\n5 4\\n5 6\\n6 2\\n6 3\\n2 1 2\\n1 1 -3\\n2 1 2\\n2 3 3\"]",
    "exec_outcome": "PASSED",
    "source_code": "def naiveSolve():\r\n    \r\n    \r\n    \r\n    return\r\n\r\n\r\n\r\ndef solve():\r\n    \r\n    \r\n    \r\n    return\r\n\r\nfrom types import GeneratorType\r\ndef bootstrap(f, stack=[]):\r\n    def wrappedfunc(*args, **kwargs):\r\n        if stack:\r\n            return f(*args, **kwargs)\r\n        else:\r\n            to = f(*args, **kwargs)\r\n            while True:\r\n                if type(to) is GeneratorType:\r\n                    stack.append(to)\r\n                    to = next(to)\r\n                else:\r\n                    stack.pop()\r\n                    if not stack:\r\n                        break\r\n                    to = stack[-1].send(to)\r\n            return to\r\n    return wrappedfunc\r\n\r\nclass SegmentTree():\r\n    def __init__(self,arr,combinerFunction,isCommutative=True): # isCommutative means f(a,b)==f(b,a)\r\n        self.n=len(arr)\r\n        def cmb(a,b):\r\n            if a==None: return b\r\n            if b==None: return a\r\n            return combinerFunction(a,b)\r\n        self.cmb=cmb\r\n        self.sz=self.n if isCommutative else pow(2,((self.n-1).bit_length())) # non-commutative needs power of 2 size\r\n        self.t=[None]*(2*self.sz) # use None as initial value\r\n        for i in range(self.n): self.t[i+self.sz]=arr[i]\r\n        for i in range(self.sz-1,0,-1): self.pull(i)\r\n    def pull(self,p):\r\n        self.t[p]=self.cmb(self.t[2*p],self.t[2*p+1])\r\n    def update(self,idx,val): # set val at idx\r\n        idx+=self.sz\r\n        self.t[idx]=val\r\n        idx//=2\r\n        while idx>0:\r\n            self.pull(idx)\r\n            idx//=2\r\n    def query(self,l,r): # aggregated value in [l,r] inclusive\r\n        l+=self.sz; r+=self.sz+1\r\n        a=b=None\r\n        while l<r:\r\n            if l%2==1: a=self.cmb(a,self.t[l]); l+=1\r\n            if r%2==1: r-=1; b=self.cmb(self.t[r],b)\r\n            l//=2; r//=2\r\n        return self.cmb(a,b)\r\ndef getMaxSegTree(arr):\r\n    return SegmentTree(arr,lambda a,b:max(a,b),True)\r\ndef getMinSegTree(arr):\r\n    return SegmentTree(arr,lambda a,b:min(a,b),True)\r\ndef getSumSegTree(arr):\r\n    return SegmentTree(arr,lambda a,b:a+b,True)\r\n\r\ndef main():\r\n    \r\n    n,q=readIntArr()\r\n    a=readIntArr()\r\n    for i in range(n):\r\n        a[i]=abs(a[i])\r\n    \r\n    adj=[[] for _ in range(n)]\r\n    for _ in range(n-1):\r\n        u,v=readIntArr(); u-=1; v-=1\r\n        adj[u].append(v)\r\n        adj[v].append(u)\r\n    \r\n    # Using the fact that max(abs(x+y),abs(x-y))=abs(x)+abs(y),\r\n    # and using an Euler tour to \"flatten\" the tree to allow for querying.\r\n    # Store an array of size 2*n. Save the entry and exit indexes in the\r\n    # euler tour array. When entering, store abs(a) in euler tour array.\r\n    # When exiting, store -abs(a).\r\n    # To update, change the entry and exit indexes of euler tour array.\r\n    # To get distance from root, query from 0 to the entry index.\r\n    # Use LCA to find common ancestor, and subtract the dist from node to\r\n    # common ancestor.\r\n    \r\n    root=0 ## To modify accordingly\r\n    @bootstrap\r\n    def eulerTour(node,p): # O(n)\r\n        up[node][0]=p\r\n        tin[node]=time[0]\r\n        eulerTourArr[time[0]]=2*a[node] # add cost\r\n        time[0]+=1\r\n        for v in adj[node]: # adj[u]=[v1,v2,v3,...]\r\n            if v!=p:\r\n                yield eulerTour(v,node)\r\n        tout[node]=time[0]\r\n        eulerTourArr[time[0]]=-2*a[node] # subtract cost for prefix sum to give cost from root to node\r\n        time[0]+=1\r\n        yield None\r\n    time=[0]\r\n    tin=[-1]*(n) # this is also the node entry index in eulerTourArr\r\n    tout=[-1]*(n) # this is also the node exit index in eulerTourArr\r\n    maxPow=0\r\n    while pow(2,maxPow)<n:\r\n        maxPow+=1\r\n    maxPow+=1\r\n    up=[[-1 for _ in range(maxPow)] for __ in range(n+1)]\r\n    \r\n    eulerTourArr=[0]*(2*n) # stores the energy sum for 2 * node\r\n    \r\n    \r\n    eulerTour(root,-1)\r\n    for i in range(1,maxPow): # Build up in O(nlogn)\r\n        for u in range(1,n+1):\r\n            if up[u][i-1]==-1 or up[up[u][i-1]][i-1]==-1: # reached beyond root\r\n                continue\r\n            up[u][i]=up[up[u][i-1]][i-1]\r\n    \r\n    def isAncestor(u,v): # True if u is ancestor of v\r\n        return tin[u]<=tin[v] and tout[u]>=tout[v]\r\n    \r\n    def findLCA(u,v): # Find LCA in O(logn)\r\n        # traverse u to LCA\r\n        if not isAncestor(u,v):\r\n            u2=u\r\n            for i in range(maxPow-1,-1,-1):\r\n                if up[u2][i]!=-1 and not isAncestor(up[u2][i],v):\r\n                    u2=up[u2][i]\r\n            # next level up is lca\r\n            lca=up[u2][0]\r\n        else:\r\n            lca=u\r\n        return lca\r\n    \r\n    st=getSumSegTree(eulerTourArr)\r\n    allans=[]\r\n    # print(tin)\r\n    # print(tout)\r\n    for _ in range(q):\r\n        x,u,v=readIntArr(); u-=1\r\n        if x==1: # update u to c\r\n            c=abs(v)\r\n            st.update(tin[u],2*c)\r\n            st.update(tout[u],-2*c)\r\n            a[u]=c\r\n        else: # query u to v\r\n            v-=1\r\n            # print(eulerTourArr)\r\n            rootToU=st.query(0,tin[u])-a[root]-a[u]\r\n            rootToV=st.query(0,tin[v])-a[root]-a[v]\r\n            lca=findLCA(u,v)\r\n            rootToLCA=st.query(0,tin[lca])-a[root]-a[lca]\r\n            ans=rootToU+rootToV-2*rootToLCA\r\n            allans.append(ans)\r\n            # print('u:{} v:{} rootToU:{} roottoV:{} lca:{}'.format(\r\n                # u+1,v+1,rootToU,rootToV,lca+1))\r\n            \r\n    multiLineArrayPrint(allans)\r\n    \r\n    return\r\n\r\n\r\nimport sys\r\ninput=sys.stdin.buffer.readline #FOR READING PURE INTEGER INPUTS (space separation ok)\r\n# input=lambda: sys.stdin.readline().rstrip(\"\\r\\n\") #FOR READING STRING/TEXT INPUTS.\r\n\r\ndef oneLineArrayPrint(arr):\r\n    print(' '.join([str(x) for x in arr]))\r\ndef multiLineArrayPrint(arr):\r\n    print('\\n'.join([str(x) for x in arr]))\r\ndef multiLineArrayOfArraysPrint(arr):\r\n    print('\\n'.join([' '.join([str(x) for x in y]) for y in arr]))\r\n \r\ndef readIntArr():\r\n    return [int(x) for x in input().split()]\r\n# def readFloatArr():\r\n#     return [float(x) for x in input().split()]\r\n \r\ndef makeArr(defaultValFactory,dimensionArr): # eg. makeArr(lambda:0,[n,m])\r\n    dv=defaultValFactory;da=dimensionArr\r\n    if len(da)==1:return [dv() for _ in range(da[0])]\r\n    else:return [makeArr(dv,da[1:]) for _ in range(da[0])]\r\n \r\ndef queryInteractive(x):\r\n    print('{}'.format(x))\r\n    sys.stdout.flush()\r\n    return int(input())\r\n \r\ndef answerInteractive(ans):\r\n    print('! {}'.format(ans))\r\n    sys.stdout.flush()\r\n \r\ninf=float('inf')\r\n# MOD=10**9+7\r\n# MOD=998244353\r\n\r\nfrom math import gcd,floor,ceil\r\n# from math import floor,ceil # for Python2\r\n \r\nfor _abc in range(1):\r\n    main()",
    "prob_desc_created_at": "1633181700",
    "tags": [
        "data structures",
        "trees"
    ],
    "hidden_unit_tests": ""
}
{
    "prob_desc_time_limit": "3.5 seconds",
    "prob_desc_sample_outputs": "[\"? 1 2\\n! 1 2\", \"? 2 1\\n? 1 3\\n? 4 1\\n? 2 3\\n? 4 2\\n? 4 3\\n! 0 0\"]",
    "src_uid": "90a9d883408d5c283d6e7680c0b94c8b",
    "prob_desc_notes": "NoteIn the first sample input, we are given a city of three houses with one incoming road each. The user program asks one query: \"? 1 2\": asking whether we can reach from house $$$1$$$ to house $$$2$$$. The judge responds with \"Yes\". The user program now concludes that this is sufficient information to determine the correct answer. So, it outputs \"! 1 2\" and quits.In the second sample input, the user program queries for six different pairs of houses, and finally answers \"! 0 0\" as it is convinced that no two houses as desired in the question exist in this city.",
    "prob_desc_description": "This is an interactive problem. Remember to flush your output while communicating with the testing program. You may use fflush(stdout) in C++, system.out.flush() in Java, stdout.flush() in Python or flush(output) in Pascal to flush the output. If you use some other programming language, consult its documentation. You may also refer to the guide on interactive problems: https://codeforces.com/blog/entry/45307.There is a city in which Dixit lives. In the city, there are $$$n$$$ houses. There is  exactly one directed road between every pair of houses. For example, consider two houses A and B, then there is a directed road either from A to B or from B to A but not both. The number of roads leading to the $$$i$$$-th house is $$$k_i$$$.Two houses A and B are bi-reachable if A is reachable from B and B is reachable from A. We say that house B is reachable from house A when there is a path from house A to house B.Dixit wants to buy two houses in the city, that is, one for living and one for studying. Of course, he would like to travel from one house to another. So, he wants to find a pair of bi-reachable houses A and B. Among all such pairs, he wants to choose one with the maximum value of $$$|k_A - k_B|$$$, where $$$k_i$$$ is the number of roads leading to the house $$$i$$$. If more than one optimal pair exists, any of them is suitable.Since Dixit is busy preparing CodeCraft, can you help him find the desired pair of houses, or tell him that no such houses exist?In the problem input, you are not given the direction of each road. You are given — for each house — only the number of incoming roads to that house ($$$k_i$$$).You are allowed to ask only one type of query from the judge: give two houses A and B, and the judge answers whether B is reachable from A. There is no upper limit on the number of queries. But, you cannot ask more queries after the judge answers \"Yes\" to any of your queries. Also, you cannot ask the same query twice.Once you have exhausted all your queries (or the judge responds \"Yes\" to any of your queries), your program must output its guess for the two houses and quit.See the Interaction section below for more details.",
    "prob_desc_output_spec": null,
    "prob_desc_input_spec": "The first line contains a single integer $$$n$$$ ($$$3 \\le n \\le 500$$$) denoting the number of houses in the city. The next line contains $$$n$$$ space-separated integers $$$k_1, k_2, \\dots, k_n$$$ ($$$0 \\le k_i \\le n - 1$$$), the $$$i$$$-th of them represents the number of incoming roads to the $$$i$$$-th house.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3-64",
    "lang_cluster": "Python",
    "difficulty": 2200,
    "file_name": "train_107.jsonl",
    "code_uid": "5a6268e3fd0eb83fb22370944d3d1e40",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"3\\n1 1 1\\nYes\", \"4\\n1 2 0 3\\nNo\\nNo\\nNo\\nNo\\nNo\\nNo\"]",
    "exec_outcome": "PASSED",
    "source_code": "import os,sys\r\nfrom random import randint\r\nfrom io import BytesIO, IOBase\r\n\r\nfrom collections import defaultdict,deque,Counter\r\nfrom bisect import bisect_left,bisect_right\r\nfrom heapq import heappush,heappop\r\nfrom functools import lru_cache\r\nfrom itertools import accumulate\r\nimport math\r\n\r\n# Fast IO Region\r\nBUFSIZE = 8192\r\nclass FastIO(IOBase):\r\n    newlines = 0\r\n    def __init__(self, file):\r\n        self._fd = file.fileno()\r\n        self.buffer = BytesIO()\r\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\r\n        self.write = self.buffer.write if self.writable else None\r\n    def read(self):\r\n        while True:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            if not b:\r\n                break\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines = 0\r\n        return self.buffer.read()\r\n    def readline(self):\r\n        while self.newlines == 0:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            self.newlines = b.count(b\"\\n\") + (not b)\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines -= 1\r\n        return self.buffer.readline()\r\n    def flush(self):\r\n        if self.writable:\r\n            os.write(self._fd, self.buffer.getvalue())\r\n            self.buffer.truncate(0), self.buffer.seek(0)\r\nclass IOWrapper(IOBase):\r\n    def __init__(self, file):\r\n        self.buffer = FastIO(file)\r\n        self.flush = self.buffer.flush\r\n        self.writable = self.buffer.writable\r\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\r\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\r\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\r\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\r\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\r\n\r\n\r\n# for _ in range(int(input())):\r\n#     n = int(input())\r\n#     a = list(map(int, input().split()))\r\n\r\n# for _ in range(int(input())):\r\n#     n = int(input())\r\n#     for i in range(n, n + 100000000):\r\n#         s = str(i)\r\n#         x = 0\r\n#         for j in range(len(s)):\r\n#             x += int(s[j])\r\n#         if math.gcd(x, i) > 1:\r\n#             print(i)\r\n#             break\r\n\r\n# for _ in range(int(input())):\r\n#     n, w = list(map(int, input().split()))\r\n#     a = list(map(int, input().split()))\r\n#     cnt = Counter(a)\r\n#     cnt = sorted([[i, j] for i, j in cnt.items()])\r\n#     ans = 0\r\n#     tot = 0\r\n#     for i, j in cnt:\r\n#         tot += j\r\n#     while tot > 0:\r\n#         i = len(cnt) - 1\r\n#         cur = 0\r\n#         while i >= 0 and cur < w:\r\n#             wi, c = cnt[i]\r\n#             if wi * c <= w - cur:\r\n#                 cur += wi * c\r\n#                 cnt[i][1] = 0\r\n#                 tot -= c\r\n#             else:\r\n#                 k = (w - cur) // wi\r\n#                 cur += k * wi\r\n#                 cnt[i][1] -= k\r\n#                 tot -= k\r\n#             i -= 1\r\n#         ans += 1\r\n#     print(ans)\r\n\r\n# mod = 10 ** 9 + 7\r\n# for _ in range(int(input())):\r\n#     n, k = list(map(int, input().split()))\r\n#     if k == 1:\r\n#         print(1)\r\n#         continue\r\n#     if n == 1:\r\n#         print(2)\r\n#         continue\r\n#     ans = 1 + n\r\n#     a = [1] * (n - 1)\r\n#     for i in range(k - 2):\r\n#         if i % 2 == 0:\r\n#             for j in range(n - 2)[::-1]:\r\n#                 a[j] = (a[j] + a[j + 1]) % mod\r\n#         else:\r\n#             for j in range(1, n - 1):\r\n#                 a[j] = (a[j] + a[j - 1]) % mod\r\n#         ans += sum(a)\r\n#     print(ans % mod)\r\n\r\n# N = 10 ** 5\r\n# n, m = list(map(int, input().split()))\r\n# q = deque()\r\n# q.append(0)\r\n# vis = [0] * (m + 1)\r\n# vis[0] = 1\r\n# ans = [-1] * (m + 1)\r\n# for idx in range(n):\r\n#     t, x, y = list(map(int, input().split()))\r\n#     if t == 1:\r\n#         x = (x + N - 1) // N\r\n#         for i in range(x):\r\n#             k = -1\r\n#             for j in range(i, m + 1, x):\r\n#                 if vis[j] == 1:\r\n#                     k = 0\r\n#                 elif k != -1:\r\n#                     k += 1\r\n#                     if vis[j] == 0 and k <= y:\r\n#                         ans[j] = idx + 1\r\n#                         vis[j] = 1\r\n#     else:\r\n#         vis2 = [0] * (m + 1)\r\n#         for i in range(1, m + 1):\r\n#             if vis2[i] == 0:\r\n#                 vis2[i] = 1\r\n#                 j = i\r\n#                 k = -1\r\n#                 while j <= m:\r\n#                     vis2[j] = 1\r\n#                     if vis[j] == 1:\r\n#                         k = 0\r\n#                     elif k != -1:\r\n#                         k += 1\r\n#                         if vis[j] == 0 and k <= y:\r\n#                             ans[j] = idx + 1\r\n#                             vis[j] = 1\r\n#                     j = (j * x + N - 1) // N\r\n# print(*ans[1:])\r\n\r\ndef solve():           \r\n    n = int(input())\r\n    a = list(map(int, input().split()))\r\n    # id = [i for i in range(n)]\r\n    # id.sort(key=lambda x : a[x], reverse=True)\r\n    id = []\r\n    for i in range(n):\r\n        for j in range(n):\r\n            if a[i] > a[j] or (a[i] == a[j] and i != j):\r\n                id.append([i, j])\r\n    # print(id)\r\n    id.sort(key=lambda x : a[x[1]] - a[x[0]])\r\n    # for i in range(n):\r\n    #     for j in range(i + 1, n)[::-1]:\r\n    #         print('?', id[i] + 1, id[j] + 1)\r\n    #             sys.stdout.flush()\r\n    #             if input() == 'Yes':\r\n    #                 print('!', id[i] + 1, id[j] + 1)\r\n    #                 sys.stdout.flush()\r\n    #                 return\r\n    for i, j in id:\r\n        print('?', i + 1, j + 1)\r\n        sys.stdout.flush()\r\n        if input() == 'Yes':\r\n            print('!', i + 1, j + 1)\r\n            sys.stdout.flush()\r\n            return\r\n    print('!', 0, 0)\r\n    sys.stdout.flush()\r\nsolve()\r\n\r\n",
    "prob_desc_created_at": "1617028500",
    "tags": [
        "brute force",
        "graphs",
        "greedy",
        "interactive",
        "sortings"
    ],
    "hidden_unit_tests": ""
}
{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"3 1 4 2 7 5 6 \\n3 2 4 1 7 6 5 \\n1 2 3 4 \\n1 2 3 4 \\n3 4 5 1 2 7 6 \\n3 4 5 2 1 7 6 \\n1 \\n1\"]",
    "src_uid": "6e7b8742906ce40458d920121c33c54f",
    "prob_desc_notes": null,
    "prob_desc_description": "A permutation is a sequence of $$$n$$$ integers from $$$1$$$ to $$$n$$$, in which all numbers occur exactly once. For example, $$$[1]$$$, $$$[3, 5, 2, 1, 4]$$$, $$$[1, 3, 2]$$$ are permutations, and $$$[2, 3, 2]$$$, $$$[4, 3, 1]$$$, $$$[0]$$$ are not.Polycarp was presented with a permutation $$$p$$$ of numbers from $$$1$$$ to $$$n$$$. However, when Polycarp came home, he noticed that in his pocket, the permutation $$$p$$$ had turned into an array $$$q$$$ according to the following rule:   $$$q_i = \\max(p_1, p_2, \\ldots, p_i)$$$. Now Polycarp wondered what lexicographically minimal and lexicographically maximal permutations could be presented to him.An array $$$a$$$ of length $$$n$$$ is lexicographically smaller than an array $$$b$$$ of length $$$n$$$ if there is an index $$$i$$$ ($$$1 \\le i \\le n$$$) such that the first $$$i-1$$$ elements of arrays $$$a$$$ and $$$b$$$ are the same, and the $$$i$$$-th element of the array $$$a$$$ is less than the $$$i$$$-th element of the array $$$b$$$. For example, the array $$$a=[1, 3, 2, 3]$$$ is lexicographically smaller than the array $$$b=[1, 3, 4, 2]$$$.For example, if $$$n=7$$$ and $$$p=[3, 2, 4, 1, 7, 5, 6]$$$, then $$$q=[3, 3, 4, 4, 7, 7, 7]$$$ and the following permutations could have been as $$$p$$$ initially:   $$$[3, 1, 4, 2, 7, 5, 6]$$$ (lexicographically minimal permutation);  $$$[3, 1, 4, 2, 7, 6, 5]$$$;  $$$[3, 2, 4, 1, 7, 5, 6]$$$;  $$$[3, 2, 4, 1, 7, 6, 5]$$$ (lexicographically maximum permutation). For a given array $$$q$$$, find the lexicographically minimal and lexicographically maximal permutations that could have been originally presented to Polycarp.",
    "prob_desc_output_spec": "For each test case, output two lines:    on the first line output $$$n$$$ integers — lexicographically minimal permutation that could have been originally presented to Polycarp;  on the second line print $$$n$$$ integers — lexicographically maximal permutation that could have been originally presented to Polycarp; ",
    "prob_desc_input_spec": "The first line contains one integer $$$t$$$ ($$$1 \\le t \\le 10^4$$$). Then $$$t$$$ test cases follow. The first line of each test case contains one integer $$$n$$$ ($$$1 \\le n \\le 2 \\cdot 10^5$$$). The second line of each test case contains $$$n$$$ integers $$$q_1, q_2, \\ldots, q_n$$$ ($$$1 \\le q_i \\le n$$$). It is guaranteed that the array $$$q$$$ was obtained by applying the rule from the statement to some permutation $$$p$$$. It is guaranteed that the sum of $$$n$$$ over all test cases does not exceed $$$2 \\cdot 10^5$$$.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3-64",
    "lang_cluster": "Python",
    "difficulty": 1500,
    "file_name": "train_101.jsonl",
    "code_uid": "68048fd93c0beb121f1f596f2c4c9090",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"4\\n7\\n3 3 4 4 7 7 7\\n4\\n1 2 3 4\\n7\\n3 4 5 5 5 7 7\\n1\\n1\"]",
    "exec_outcome": "PASSED",
    "source_code": "import sys\r\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\r\n\r\nimport math\r\nfrom bisect import bisect_left, bisect_right\r\nfrom typing import Generic, Iterable, Iterator, TypeVar, Union, List\r\nT = TypeVar('T')\r\nclass SortedSet(Generic[T]):\r\n    BUCKET_RATIO = 50\r\n    REBUILD_RATIO = 170\r\n    \r\n    def _build(self, a=None) -> None:\r\n        \"Evenly divide `a` into buckets.\"\r\n        if a is None: a = list(self)\r\n        size = self.size = len(a)\r\n        bucket_size = int(math.ceil(math.sqrt(size / self.BUCKET_RATIO)))\r\n        self.a = [a[size * i // bucket_size : size * (i + 1) // bucket_size] for i in range(bucket_size)]\r\n    \r\n    def __init__(self, a: Iterable[T] = []) -> None:\r\n        \"Make a new SortedSet from iterable. / O(N) if sorted and unique / O(N log N)\"\r\n        a = list(a)\r\n        if not all(a[i] < a[i + 1] for i in range(len(a) - 1)):\r\n            a = sorted(set(a))\r\n        self._build(a)\r\n        \r\n    def __iter__(self) -> Iterator[T]:\r\n        for i in self.a:\r\n            for j in i: yield j\r\n            \r\n    def __reversed__(self) -> Iterator[T]:\r\n        for i in reversed(self.a):\r\n            for j in reversed(i): yield j\r\n    \r\n    def __len__(self) -> int:\r\n        return self.size\r\n    \r\n    def __repr__(self) -> str:\r\n        return \"SortedSet\" + str(self.a)\r\n    \r\n    def __str__(self) -> str:\r\n        s = str(list(self))\r\n        return \"{\" + s[1 : len(s) - 1] + \"}\"\r\n    \r\n    def _find_bucket(self, x: T) -> List[T]:\r\n        \"Find the bucket which should contain x. self must not be empty.\"\r\n        for a in self.a:\r\n            if x <= a[-1]: return a\r\n        return a\r\n    \r\n    def __contains__(self, x: T) -> bool:\r\n        if self.size == 0: return False\r\n        a = self._find_bucket(x)\r\n        i = bisect_left(a, x)\r\n        return i != len(a) and a[i] == x\r\n    \r\n    def add(self, x: T) -> bool:\r\n        \"Add an element and return True if added. / O(√N)\"\r\n        if self.size == 0:\r\n            self.a = [[x]]\r\n            self.size = 1\r\n            return True\r\n        a = self._find_bucket(x)\r\n        i = bisect_left(a, x)\r\n        if i != len(a) and a[i] == x: return False\r\n        a.insert(i, x)\r\n        self.size += 1\r\n        if len(a) > len(self.a) * self.REBUILD_RATIO:\r\n            self._build()\r\n        return True\r\n    \r\n    def discard(self, x: T) -> bool:\r\n        \"Remove an element and return True if removed. / O(√N)\"\r\n        if self.size == 0: return False\r\n        a = self._find_bucket(x)\r\n        i = bisect_left(a, x)\r\n        if i == len(a) or a[i] != x: return False\r\n        a.pop(i)\r\n        self.size -= 1\r\n        if len(a) == 0: self._build()\r\n        return True\r\n    \r\n    def lt(self, x: T) -> Union[T, None]:\r\n        \"Find the largest element < x, or None if it doesn't exist.\"\r\n        for a in reversed(self.a):\r\n            if a[0] < x:\r\n                return a[bisect_left(a, x) - 1]\r\n            \r\n    def le(self, x: T) -> Union[T, None]:\r\n        \"Find the largest element <= x, or None if it doesn't exist.\"\r\n        for a in reversed(self.a):\r\n            if a[0] <= x:\r\n                return a[bisect_right(a, x) - 1]\r\n            \r\n    def gt(self, x: T) -> Union[T, None]:\r\n        \"Find the smallest element > x, or None if it doesn't exist.\"\r\n        for a in self.a:\r\n            if a[-1] > x:\r\n                return a[bisect_right(a, x)]\r\n            \r\n    def ge(self, x: T) -> Union[T, None]:\r\n        \"Find the smallest element >= x, or None if it doesn't exist.\"\r\n        for a in self.a:\r\n            if a[-1] >= x:\r\n                return a[bisect_left(a, x)]\r\n    \r\n    def __getitem__(self, x: int) -> T:\r\n        \"Return the x-th element, or IndexError if it doesn't exist.\"\r\n        if x < 0: x += self.size\r\n        if x < 0: raise IndexError\r\n        for a in self.a:\r\n            if x < len(a): return a[x]\r\n            x -= len(a)\r\n        raise IndexError\r\n    \r\n    def index(self, x: T) -> int:\r\n        \"Count the number of elements < x.\"\r\n        ans = 0\r\n        for a in self.a:\r\n            if a[-1] >= x:\r\n                return ans + bisect_left(a, x)\r\n            ans += len(a)\r\n        return ans\r\n    \r\n    def index_right(self, x: T) -> int:\r\n        \"Count the number of elements <= x.\"\r\n        ans = 0\r\n        for a in self.a:\r\n            if a[-1] > x:\r\n                return ans + bisect_right(a, x)\r\n            ans += len(a)\r\n        return ans\r\n \r\ndef solve():\r\n    n = int(input())\r\n    a = list(map(int, input().split())) \r\n    \r\n    mn = [a[0]]\r\n    s = set(range(1, n + 1))\r\n    for i in a:\r\n        try:\r\n            s.remove(i)\r\n        except:\r\n            pass\r\n    l = sorted(list(s), reverse = True)\r\n    for i in range(1, n):\r\n        if a[i] != a[i - 1]:\r\n            mn.append(a[i])\r\n        else:\r\n            mn.append(l.pop())\r\n        \r\n    mx = [a[0]]\r\n    s = SortedSet(range(1, n + 1))\r\n    s.discard(a[0])\r\n    for i in range(1, n):\r\n        if a[i] != a[i - 1]:\r\n            mx.append(a[i])\r\n            s.discard(a[i])\r\n        else:\r\n            x = s.le(a[i])\r\n            mx.append(x)\r\n            s.discard(x)\r\n        \r\n    print(*mn)\r\n    print(*mx)\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\nfor _ in range(int(input())):\r\n    solve()",
    "prob_desc_created_at": "1616682900",
    "tags": [
        "constructive algorithms",
        "implementation"
    ],
    "hidden_unit_tests": ""
}
{
    "prob_desc_time_limit": "1 second",
    "prob_desc_sample_outputs": "[\"1\\nGRB\", \"3\\nRGBRGBR\"]",
    "src_uid": "e67b79e39511b0107a51edc0179afb82",
    "prob_desc_notes": null,
    "prob_desc_description": "You have a garland consisting of $$$n$$$ lamps. Each lamp is colored red, green or blue. The color of the $$$i$$$-th lamp is $$$s_i$$$ ('R', 'G' and 'B' — colors of lamps in the garland).You have to recolor some lamps in this garland (recoloring a lamp means changing its initial color to another) in such a way that the obtained garland is nice.A garland is called nice if any two lamps of the same color have distance divisible by three between them. I.e. if the obtained garland is $$$t$$$, then for each $$$i, j$$$ such that $$$t_i = t_j$$$ should be satisfied $$$|i-j|~ mod~ 3 = 0$$$. The value $$$|x|$$$ means absolute value of $$$x$$$, the operation $$$x~ mod~ y$$$ means remainder of $$$x$$$ when divided by $$$y$$$.For example, the following garlands are nice: \"RGBRGBRG\", \"GB\", \"R\", \"GRBGRBG\", \"BRGBRGB\". The following garlands are not nice: \"RR\", \"RGBG\".Among all ways to recolor the initial garland to make it nice you have to choose one with the minimum number of recolored lamps. If there are multiple optimal solutions, print any of them.",
    "prob_desc_output_spec": "In the first line of the output print one integer $$$r$$$ — the minimum number of recolors needed to obtain a nice garland from the given one. In the second line of the output print one string $$$t$$$ of length $$$n$$$ — a nice garland obtained from the initial one with minimum number of recolors. If there are multiple optimal solutions, print any of them.",
    "prob_desc_input_spec": "The first line of the input contains one integer $$$n$$$ ($$$1 \\le n \\le 2 \\cdot 10^5$$$) — the number of lamps. The second line of the input contains the string $$$s$$$ consisting of $$$n$$$ characters 'R', 'G' and 'B' — colors of lamps in the garland.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 2",
    "lang_cluster": "Python",
    "difficulty": 1300,
    "file_name": "train_013.jsonl",
    "code_uid": "7c9d2a770b443418413e1ef9a9ff8d43",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"3\\nBRB\", \"7\\nRGBGRBB\"]",
    "exec_outcome": "PASSED",
    "source_code": "from __future__ import division, print_function\n \nimport os,sys\nfrom io import BytesIO, IOBase\n \nif sys.version_info[0] < 3:\n    from __builtin__ import xrange as range\n    from future_builtins import ascii, filter, hex, map, oct, zip\nfrom itertools import permutations \n \ndef ii():  return int(input())\ndef si():  return input()\ndef mi():  return map(int,input().split(\" \"))\ndef msi(): return map(str,input().split(\" \"))\ndef li():  return list(mi())\n \ndef dmain():\n    sys.setrecursionlimit(1000000)\n    threading.stack_size(1024000)\n    thread = threading.Thread(target=main)\n    thread.start()\n    \nimport math\ndef getSum(n): \n    sum = 0\n    while(n > 0): \n        sum += int(n%10) \n        n = int(n/10) \n  \n    return sum\n\ndef isPowerOfTwo (x): return (x and (not(x & (x - 1))) )\n \ndef gcd(x, y):\n    while y:\n        x, y = y, x % y\n    return x\ndef egcd(a, b):  \n    if a == 0 :   \n        return b, 0, 1\n    gcd, x1, y1 = egcd(b%a, a)\n    x = y1 - (b//a) * x1  \n    y = x1  \n     \n    return gcd, x, y \n    \ndef checkPrime(n) : # Check Prime Number or not \n    if (n <= 1) : return False\n    if (n <= 3) : return True\n    if (n % 2 == 0 or n % 3 == 0) : return False\n    i = 5\n    while(i * i <= n) : \n        if (n % i == 0 or n % (i + 2) == 0) : \n            return False\n        i = i + 6\n    return True\ndef fib(n):\n    if n==0:\n        return (0,1)\n    p=fib(n>>1)\n    c=p[0]*(2*p[1]-p[0])\n    d=p[0]*p[0]+p[1]*p[1]\n    if (n&1):\n        return c+2*d \n    else:\n        return c+d \ndef read():\n    sys.stdin = open('input.txt', 'r')  \ndef powLog(x,y):\n    res=1\n    while y>0:\n        if y&1:\n            res=res*x\n        x=x*x\n        y>>=1\n    return res\ndef main():\n    n=ii()\n    s=si()\n    p=['RGB','RBG','BRG','BGR','GBR','GRB']\n    mcost=n\n    for i in p:\n        c=0\n        res= (i*(n//3+1))[:n]\n        for x in range(n):\n            if res[x] != s[x]:\n                c+=1\n        if c < mcost:\n            mcost = c\n            new_r = res\n     \n     \n    print (mcost)\n    print(new_r)\n# region fastio\n# template taken from https://github.com/cheran-senthil/PyRival/blob/master/templates/template.py\n \nBUFSIZE = 8192\n \n \nclass FastIO(IOBase):\n    newlines = 0\n \n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n \n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n \n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n \n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n \n \nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n \n \ndef print(*args, **kwargs):\n    \"\"\"Prints the values to a stream, or to sys.stdout by default.\"\"\"\n    sep, file = kwargs.pop(\"sep\", \" \"), kwargs.pop(\"file\", sys.stdout)\n    at_start = True\n    for x in args:\n        if not at_start:\n            file.write(sep)\n        file.write(str(x))\n        at_start = False\n    file.write(kwargs.pop(\"end\", \"\\n\"))\n    if kwargs.pop(\"flush\", False):\n        file.flush()\n \n \nif sys.version_info[0] < 3:\n    sys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)\nelse:\n    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\n \ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n \n# endregion\n \n \nif __name__ == \"__main__\":\n    #read()\n    main()\n    #dmain()\n \n# Comment Read()",
    "prob_desc_created_at": "1548254100",
    "tags": [
        "greedy",
        "math",
        "brute force"
    ],
    "hidden_unit_tests": ""
}
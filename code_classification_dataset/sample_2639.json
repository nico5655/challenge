{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"3\\n6 2 4\", \"-1\", \"0\", \"2\\n2 1\"]",
    "src_uid": "3336662e6362693b8ac9455d4c2fe158",
    "prob_desc_notes": "NoteIn the first example, it is possible to make all blocks black in $$$3$$$ operations. Start with changing blocks $$$6$$$ and $$$7$$$, so the sequence is \"BWWWWBBB\". Then change blocks $$$2$$$ and $$$3$$$, so the sequence is \"BBBWWBB\". And finally, change blocks $$$4$$$ and $$$5$$$, so all blocks are black.It is impossible to make all colors equal in the second example.All blocks are already white in the third example.In the fourth example it is possible to make all blocks white in two operations: first operation is to change blocks $$$2$$$ and $$$3$$$ (so the sequence is \"BBW\"), and then change blocks $$$1$$$ and $$$2$$$ (so all blocks are white).",
    "prob_desc_description": "There are $$$n$$$ blocks arranged in a row and numbered from left to right, starting from one. Each block is either black or white. You may perform the following operation zero or more times: choose two adjacent blocks and invert their colors (white block becomes black, and vice versa). You want to find a sequence of operations, such that they make all the blocks having the same color. You don't have to minimize the number of operations, but it should not exceed $$$3 \\cdot n$$$. If it is impossible to find such a sequence of operations, you need to report it.",
    "prob_desc_output_spec": "If it is impossible to make all the blocks having the same color, print $$$-1$$$. Otherwise, print an integer $$$k$$$ ($$$0 \\le k \\le 3 \\cdot n$$$) — the number of operations. Then print $$$k$$$ integers $$$p_1, p_2, \\dots, p_k$$$ $$$(1 \\le p_j \\le n - 1)$$$, where $$$p_j$$$ is the position of the left block in the pair of blocks that should be affected by the $$$j$$$-th operation. If there are multiple answers, print any of them.",
    "prob_desc_input_spec": "The first line contains one integer $$$n$$$ ($$$2 \\le n \\le 200$$$) — the number of blocks. The second line contains one string $$$s$$$ consisting of $$$n$$$ characters, each character is either \"W\" or \"B\". If the $$$i$$$-th character is \"W\", then the $$$i$$$-th block is white. If the $$$i$$$-th character is \"B\", then the $$$i$$$-th block is black. ",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 2",
    "lang_cluster": "Python",
    "difficulty": 1300,
    "file_name": "train_026.jsonl",
    "code_uid": "eaa1e3df065007dc9c2e536e873df6d4",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"8\\nBWWWWWWB\", \"4\\nBWBB\", \"5\\nWWWWW\", \"3\\nBWB\"]",
    "exec_outcome": "PASSED",
    "source_code": "#!/usr/bin/env pypy\nfrom __future__ import division, print_function\nfrom collections import defaultdict, Counter, deque\nfrom future_builtins import ascii, filter, hex, map, oct, zip\nfrom itertools import imap as map, izip as zip\nfrom __builtin__ import xrange as range\nfrom math import ceil, log\nfrom _continuation import continulet\nfrom cStringIO import StringIO\nfrom io import IOBase\nimport __pypy__\nfrom pprint import pprint\nfrom bisect import bisect, insort, bisect_left, bisect_right\nimport sys\nimport os\nimport re\ninf = float('inf')\nmod = int(1e9) + 7\nmod_ = 998244353\n\n'''\nCheck for special cases (n=1)\nOne wrong submission = 10 mins penalty!\ndo smth instead of nothing and stay organized\n'''\n\ndef solve(n, s):\n\tswaps = []\n\tfor i in range(n-1):\n\t\tif s[i] == '0' and s[i] == s[i+1]:\n\t\t\tswaps.append(i+1)\n\t\t\ts[i] = '1'\n\t\t\ts[i+1] = '1'\n\tif s.count('0')%2 == 1:\n\t\treturn [-1]\n\ti = 0\n\twhile i < n:\n\t\tif s[i] == '0':\n\t\t\tj = s.index('0', i+1)\n\t\t\tswaps += list(range(i+1, j+1))\n\t\t\ti = j+1\n\t\telse:\n\t\t\ti += 1\n\treturn swaps\n\t\ndef main():\n\tn = int(input())\n\ts = input()\n\tif len(set(s)) == 1:\n\t\tprint(0)\n\t\treturn\n\ts = s.replace('B', '1')\n\ts = s.replace('W', '0')\n\tans1 = solve(n, list(s))\n\ts = list(s)\n\tfor i in range(n):\n\t\tif s[i] == '1':\n\t\t\ts[i] = '0'\n\t\telse:\n\t\t\ts[i] = '1'\n\tans2 = solve(n, list(s))\n\tif ans1 != [-1] and len(ans1) <= 3*n:\n\t\tprint(len(ans1))\n\t\tprint(*ans1)\n\telif ans2 != [-1] and len(ans2) <= 3*n:\n\t\tprint(len(ans2))\n\t\tprint(*ans2)\n\telse:\n\t\tprint(-1)\n\t\n\n\nBUFSIZE = 8192\nclass FastI(IOBase):\n\tdef __init__(self, file):\n\t\tself._fd = file.fileno()\n\t\tself._buffer = StringIO()\n\t\tself.newlines = 0\n\n\tdef read(self):\n\t\twhile True:\n\t\t\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n\t\t\tif not b:\n\t\t\t\tbreak\n\t\t\tptr = self.buffer.tell()\n\t\t\tself.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n\t\tself.newlines = 0\n\t\treturn self.buffer.read()\n\n\tdef readline(self):\n\t\twhile self.newlines == 0:\n\t\t\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n\t\t\tself.newlines = b.count(\"\\n\") + (not b)\n\t\t\tptr = self._buffer.tell()\n\t\t\tself._buffer.seek(0, 2), self._buffer.write(\n\t\t\t\tb), self._buffer.seek(ptr)\n\t\tself.newlines -= 1\n\t\treturn self._buffer.readline()\nclass FastO(IOBase):\n\tdef __init__(self, file):\n\t\tself._fd = file.fileno()\n\t\tself._buffer = __pypy__.builders.StringBuilder()\n\t\tself.write = lambda s: self._buffer.append(s)\n\n\tdef flush(self):\n\t\tos.write(self._fd, self._buffer.build())\n\t\tself._buffer = __pypy__.builders.StringBuilder()\ndef print(*args, **kwargs):\n\tsep, file = kwargs.pop(\"sep\", \" \"), kwargs.pop(\"file\", sys.stdout)\n\tat_start = True\n\tfor x in args:\n\t\tif not at_start:\n\t\t\tfile.write(sep)\n\t\tfile.write(str(x))\n\t\tat_start = False\n\tfile.write(kwargs.pop(\"end\", \"\\n\"))\n\tif kwargs.pop(\"flush\", False):\n\t\tfile.flush()\ndef gcd(x, y):\n\twhile y:\n\t\tx, y = y, x % y\n\treturn x\nsys.stdin, sys.stdout = FastI(sys.stdin), FastO(sys.stdout)\ndef input(): return sys.stdin.readline().rstrip(\"\\r\\n\")\nif __name__ == \"__main__\":\n\tdef bootstrap(cont):\n\t\tcall, arg = cont.switch()\n\t\twhile True:\n\t\t\tcall, arg = cont.switch(to=continulet(\n\t\t\t\tlambda _, f, args: f(*args), call, arg))\n\tcont = continulet(bootstrap)\n\tcont.switch()\n\tmain()\n",
    "prob_desc_created_at": "1576401300",
    "tags": [
        "greedy",
        "math"
    ],
    "hidden_unit_tests": ""
}
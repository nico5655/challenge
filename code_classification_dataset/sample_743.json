{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"6 14 1 25\", \"12 10 12\"]",
    "src_uid": "f41be1fcb6164181c49b37ed9313696e",
    "prob_desc_notes": null,
    "prob_desc_description": "Musicians of a popular band \"Flayer\" have announced that they are going to \"make their exit\" with a world tour. Of course, they will visit Berland as well.There are n cities in Berland. People can travel between cities using two-directional train routes; there are exactly m routes, i-th route can be used to go from city vi to city ui (and from ui to vi), and it costs wi coins to use this route.Each city will be visited by \"Flayer\", and the cost of the concert ticket in i-th city is ai coins.You have friends in every city of Berland, and they, knowing about your programming skills, asked you to calculate the minimum possible number of coins they have to pay to visit the concert. For every city i you have to compute the minimum number of coins a person from city i has to spend to travel to some city j (or possibly stay in city i), attend a concert there, and return to city i (if j ≠ i).Formally, for every  you have to calculate , where d(i, j) is the minimum number of coins you have to spend to travel from city i to city j. If there is no way to reach city j from city i, then we consider d(i, j) to be infinitely large.",
    "prob_desc_output_spec": "Print n integers. i-th of them must be equal to the minimum number of coins a person from city i has to spend to travel to some city j (or possibly stay in city i), attend a concert there, and return to city i (if j ≠ i).",
    "prob_desc_input_spec": "The first line contains two integers n and m (2 ≤ n ≤ 2·105, 1 ≤ m ≤ 2·105). Then m lines follow, i-th contains three integers vi, ui and wi (1 ≤ vi, ui ≤ n, vi ≠ ui, 1 ≤ wi ≤ 1012) denoting i-th train route. There are no multiple train routes connecting the same pair of cities, that is, for each (v, u) neither extra (v, u) nor (u, v) present in input. The next line contains n integers a1, a2, ... ak (1 ≤ ai ≤ 1012) — price to attend the concert in i-th city.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3",
    "lang_cluster": "Python",
    "difficulty": 2000,
    "file_name": "train_004.jsonl",
    "code_uid": "6b530b28de0ae51d3e22876fe461e697",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"4 2\\n1 2 4\\n2 3 7\\n6 20 1 25\", \"3 3\\n1 2 1\\n2 3 1\\n1 3 1\\n30 10 20\"]",
    "exec_outcome": "PASSED",
    "source_code": "from __future__ import division, print_function\npy2 = round(0.5)\n\nif py2:\n    from future_builtins import ascii, filter, hex, map, oct, zip\n    range = xrange\n\nimport os, sys\nfrom io import BytesIO, IOBase\n\n# FastIO for PyPy2 and PyPy3 by Pajenegod,\nclass FastI(object):\n    def __init__(self, fd=0, buffersize=2**14):\n        self.stream = stream = BytesIO(); self.bufendl = 0\n        def read2buffer():\n            curpos = stream.tell(); s = os.read(fd, buffersize + os.fstat(fd).st_size)\n            stream.seek(0,2); stream.write(s); stream.seek(curpos); return s\n        self.read2buffer = read2buffer\n    def read(self):\n        while self.read2buffer(): pass\n        return self.stream.read() if self.stream.tell() else self.stream.getvalue()\n    def readline(self):\n        while self.bufendl == 0: s = self.read2buffer(); self.bufendl += s.count(b'\\n') + (not s)\n        self.bufendl -= 1; return self.stream.readline()\n    def input(self): return self.readline().rstrip(b'\\r\\n')\n    def readnumbers(self, n,zero=0):\n        conv = ord if py2 else lambda x:x\n        \n        A = []; numb = zero; sign = 1\n        \n        curpos = self.stream.tell()\n        self.stream.seek(0,2)\n        buffsize = self.stream.tell()\n        self.stream.seek(curpos)\n        \n        while len(A)<n:\n            if curpos>=buffsize:\n                buffsize += len(self.read2buffer())\n                if curpos==buffsize: break\n            small_buff = min(32,buffsize-curpos)\n            s = self.stream.read(small_buff)\n            i = 0\n            while i<small_buff and len(A)<n:\n                if s[i] >= b'0'[0]: numb = 10 * numb + (conv(s[i]) - 48)\n                elif s[i] != b'\\r'[0]: A.append(sign*numb); numb = zero; sign = 1\n                elif s[i] == b'-'[0]: sign = -1\n                i += 1\n            curpos += i\n        if curpos == buffsize and len(A)<n: A.append(sign*numb)\n        assert(len(A)==n)\n        if self.stream.tell()!=curpos: self.stream.seek(curpos)\n        return A\n\nclass FastO(IOBase):\n    def __init__(self, fd=1):\n        stream = BytesIO()\n        self.flush = lambda: os.write(1, stream.getvalue()) and not stream.truncate(0) and stream.seek(0)\n        self.write = stream.write if py2 else lambda s: stream.write(s.encode())\n\nsys.stdin, sys.stdout = FastI(), FastO()\ninput = sys.stdin.readline\n\nbig = 3E12\n\nclass segheap:\n    def __init__(self,data):\n        n = len(data)\n        m = 1\n        while m<n:m*=2\n        self.n = n\n        self.m = m\n\n        self.data = [big]*(2*m)\n        for i in range(n):\n            self.data[i+m] = data[i]\n        for i in reversed(range(m)):\n            self.data[i] = min(self.data[2*i],self.data[2*i+1])\n\n    def mini(self):\n        i = 1\n        while i<self.m:\n            if self.data[i]==self.data[2*i]:\n                i = 2*i\n            else:\n                i = 2*i+1\n        i -= self.m\n        self.setter(i,big)\n        return i\n    def setter(self,ind,val):\n        ind += self.m\n        if val<self.data[ind]:\n            while ind>0 and self.data[ind]>val:\n                self.data[ind] = val\n                ind //= 2\n        elif val>self.data[ind]:\n            old_val = self.data[ind]\n            self.data[ind] = val\n            ind //= 2\n            while ind>0 and self.data[ind]==old_val:\n                self.data[ind] = min(self.data[2*ind],self.data[2*ind+1])\n                ind //= 2\n\nn, m = [int(x) for x in sys.stdin.readline().split()]\n\ninp = sys.stdin.readnumbers(3*m, 0.0)\n\ncoupl = [[] for _ in range(n)]\ncost = [[] for _ in range(n)]\nfor _ in range(m):\n    v = int(inp[_*3+0]-1)\n    u = int(inp[_*3+1]-1)\n    w = inp[_*3+2]\n    coupl[v].append(u)\n    coupl[u].append(v)\n    cost[u].append(w)\n    cost[v].append(w)\n\ninp = sys.stdin.readnumbers(n, 0.0)\n\nbest = [inp[i] for i in range(n)]\n\nQ = segheap(best)\n\nwhile Q.data[1]!=big:\n    c = Q.data[1]\n    node = Q.mini()\n    if best[node]!=c:\n        continue\n    for j in range(len(coupl[node])):\n        nei = coupl[node][j]\n        C = c+2*cost[node][j]\n        if C<best[nei]:\n            best[nei] = C\n            Q.setter(nei,C)\n\nfor x in best:\n    sys.stdout.write(str(int(x)))\n    sys.stdout.write(' ')",
    "prob_desc_created_at": "1518793500",
    "tags": [
        "data structures",
        "graphs",
        "shortest paths"
    ],
    "hidden_unit_tests": ""
}
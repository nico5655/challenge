{
    "prob_desc_time_limit": "3 seconds",
    "prob_desc_sample_outputs": "[\"4\", \"10\", \"-1\", \"1000000000\"]",
    "src_uid": "1b36b12307b1a324b84e878d11efbbec",
    "prob_desc_notes": "NoteGraph described in the first and the second examples is illustrated below.  In the first example Masha can initially put a coin at vertex $$$1$$$. After that she can perform three operations: $$$1 \\to 3$$$, $$$3 \\to 4$$$ and $$$4 \\to 5$$$. Integers $$$1, 2, 3$$$ and $$$4$$$ will be written in the notepad.In the second example Masha can initially put a coin at vertex $$$2$$$. After that she can perform $$$99$$$ operations: $$$2 \\to 5$$$, $$$5 \\to 6$$$, $$$6 \\to 2$$$, $$$2 \\to 5$$$, and so on. Integers $$$10, 4, 5, 10, 4, 5, \\ldots, 10, 4, 5, 10$$$ will be written in the notepad.In the third example Masha won't be able to perform $$$4$$$ operations.",
    "prob_desc_description": "One day Masha was walking in the park and found a graph under a tree... Surprised? Did you think that this problem would have some logical and reasoned story? No way! So, the problem...Masha has an oriented graph which $$$i$$$-th vertex contains some positive integer $$$a_i$$$. Initially Masha can put a coin at some vertex. In one operation she can move a coin placed in some vertex $$$u$$$ to any other vertex $$$v$$$ such that there is an oriented edge $$$u \\to v$$$ in the graph. Each time when the coin is placed in some vertex $$$i$$$, Masha write down an integer $$$a_i$$$ in her notebook (in particular, when Masha initially puts a coin at some vertex, she writes an integer written at this vertex in her notebook). Masha wants to make exactly $$$k - 1$$$ operations in such way that the maximum number written in her notebook is as small as possible.",
    "prob_desc_output_spec": "Print one integer — the minimum value of the maximum number that Masha wrote in her notebook during optimal coin movements. If Masha won't be able to perform $$$k - 1$$$ operations, print $$$-1$$$.",
    "prob_desc_input_spec": "The first line contains three integers $$$n$$$, $$$m$$$ and $$$k$$$ ($$$1 \\le n \\le 2 \\cdot 10^5$$$, $$$0 \\le m \\le 2 \\cdot 10^5$$$, $$$1 \\le k \\le 10^{18}$$$) — the number of vertices and edges in the graph, and the number of operation that Masha should make. The second line contains $$$n$$$ integers $$$a_i$$$ ($$$1 \\le a_i \\le 10^9$$$) — the numbers written in graph vertices. Each of the following $$$m$$$ lines contains two integers $$$u$$$ and $$$v$$$ ($$$1 \\le u \\ne v \\le n$$$) — it means that there is an edge $$$u \\to v$$$ in the graph. It's guaranteed that graph doesn't contain loops and multi-edges.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3-64",
    "lang_cluster": "Python",
    "difficulty": 1900,
    "file_name": "train_099.jsonl",
    "code_uid": "825bfa79001226f757c821f8a6b237c2",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"6 7 4\\n1 10 2 3 4 5\\n1 2\\n1 3\\n3 4\\n4 5\\n5 6\\n6 2\\n2 5\", \"6 7 100\\n1 10 2 3 4 5\\n1 2\\n1 3\\n3 4\\n4 5\\n5 6\\n6 2\\n2 5\", \"2 1 5\\n1 1\\n1 2\", \"1 0 1\\n1000000000\"]",
    "exec_outcome": "PASSED",
    "source_code": "import os\r\nimport sys\r\nfrom io import BytesIO, IOBase\r\n\r\nBUFSIZE = 8192\r\n \r\nclass FastIO(IOBase):\r\n    newlines = 0\r\n \r\n    def __init__(self, file):\r\n        self._fd = file.fileno()\r\n        self.buffer = BytesIO()\r\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\r\n        self.write = self.buffer.write if self.writable else None\r\n \r\n    def read(self):\r\n        while True:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            if not b:\r\n                break\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines = 0\r\n        return self.buffer.read()\r\n \r\n    def readline(self):\r\n        while self.newlines == 0:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            self.newlines = b.count(b\"\\n\") + (not b)\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines -= 1\r\n        return self.buffer.readline()\r\n \r\n    def flush(self):\r\n        if self.writable:\r\n            os.write(self._fd, self.buffer.getvalue())\r\n            self.buffer.truncate(0), self.buffer.seek(0)\r\n \r\n \r\nclass IOWrapper(IOBase):\r\n    def __init__(self, file):\r\n        self.buffer = FastIO(file)\r\n        self.flush = self.buffer.flush\r\n        self.writable = self.buffer.writable\r\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\r\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\r\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\r\n \r\n \r\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\r\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\r\n\r\nfrom collections import defaultdict, deque\r\n\r\ndef memoize(function):\r\n    cache = {}\r\n    def decorated_function(*args):\r\n        try:\r\n            return cache[args]\r\n        except KeyError:\r\n            val = function(*args)\r\n            cache[args] = val\r\n            return val\r\n    return decorated_function\r\n\r\n@memoize\r\ndef can(limit, k):\r\n    G = defaultdict(list)\r\n \r\n    D = [0] * n\r\n\r\n    vcount = 0\r\n    for s, e in E:\r\n        if A[s] <= limit and A[e] <= limit:\r\n            G[s].append(e)\r\n            D[e] += 1\r\n            if D[e] == 1:\r\n                vcount += 1\r\n        else:\r\n            break\r\n\r\n    Q = deque()\r\n    for i, a in As:\r\n        if a <= limit:\r\n            if D[i] == 0:\r\n                Q.append((i, k - 1))\r\n                vcount += 1\r\n        else:\r\n            break\r\n\r\n    while Q:\r\n        s, d = Q.popleft()\r\n        if d == 0:\r\n            return True\r\n\r\n        vcount -= 1\r\n\r\n        if s in G:\r\n            for e in G[s]:\r\n                D[e] -= 1\r\n                if D[e] == 0:\r\n                    Q.append((e, d - 1))\r\n\r\n\r\n    return vcount >= 2\r\n                    \r\n\r\n\r\nn, m, k = map(int, input().split())\r\nA = list(map(int, input().split()))\r\n\r\nAs = list(enumerate(A))\r\nAs.sort(lambda e: e[1])\r\n\r\nE = []\r\nfor _ in range(m):\r\n    s, e = map(int, input().split())\r\n    E.append((s - 1, e - 1))\r\nE.sort(lambda e: max(A[e[0]], A[e[1]]))\r\n\r\n\r\nl, r = 0, n\r\nwhile l + 1 < r:\r\n    v = (l + r)//2\r\n    if can(As[v][1], k):\r\n        r = v\r\n    else:\r\n        l = v\r\n\r\nif (can(As[l][1], k) if l < n else False):\r\n    print(As[l][1])\r\nelif (can(As[r][1], k) if r < n else False):\r\n    print(As[r][1])\r\nelse:\r\n    print(\"-1\")\r\n",
    "prob_desc_created_at": "1652520900",
    "tags": [
        "binary search",
        "dfs and similar",
        "dp",
        "graphs"
    ],
    "hidden_unit_tests": ""
}
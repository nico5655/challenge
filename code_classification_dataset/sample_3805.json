{
    "prob_desc_time_limit": "1 second",
    "prob_desc_sample_outputs": "[\"YES\\nYES\\nYES\\nNO\\nYES\\nYES\\nNO\"]",
    "src_uid": "bde43491d2e5c0a27a63e283c0967a80",
    "prob_desc_notes": "NoteIn the first case, the sequence $$$b$$$ could be obtained from the sequence $$$a = [1, 2, 3, 1, 2, 3]$$$ with the following partition: $$$[\\color{red}{1}] + [\\color{blue}{2, 3, 1}] + [\\color{green}{2, 3}]$$$. The sequence $$$b$$$: $$$[\\color{red}{1}, 1, \\color{blue}{2, 3, 1}, 3, 2, \\color{green}{2, 3}]$$$.In the second case, the sequence $$$b$$$ could be obtained from the sequence $$$a = [12, 7, 5]$$$ with the following partition: $$$[\\color{red}{12}] + [\\color{green}{7, 5}]$$$. The sequence $$$b$$$: $$$[\\color{red}{12}, 1, 2, \\color{green}{7, 5}]$$$.In the third case, the sequence $$$b$$$ could be obtained from the sequence $$$a = [7, 8, 9, 10, 3]$$$ with the following partition: $$$[\\color{red}{7, 8, 9, 10, 3}]$$$. The sequence $$$b$$$: $$$[5, \\color{red}{7, 8, 9, 10, 3}]$$$.In the fourth case, there is no sequence $$$a$$$ such that changing $$$a$$$ for transmission over the network could produce a sequence $$$b$$$.",
    "prob_desc_description": "The sequence $$$a$$$ is sent over the network as follows:  sequence $$$a$$$ is split into segments (each element of the sequence belongs to exactly one segment, each segment is a group of consecutive elements of sequence);  for each segment, its length is written next to it, either to the left of it or to the right of it;  the resulting sequence $$$b$$$ is sent over the network. For example, we needed to send the sequence $$$a = [1, 2, 3, 1, 2, 3]$$$. Suppose it was split into segments as follows: $$$[\\color{red}{1}] + [\\color{blue}{2, 3, 1}] + [\\color{green}{2, 3}]$$$. Then we could have the following sequences:   $$$b = [1, \\color{red}{1}, 3, \\color{blue}{2, 3, 1}, \\color{green}{2, 3}, 2]$$$,  $$$b = [\\color{red}{1}, 1, 3, \\color{blue}{2, 3, 1}, 2, \\color{green}{2, 3}]$$$,  $$$b = [\\color{red}{1}, 1, \\color{blue}{2, 3, 1}, 3, 2, \\color{green}{2, 3}]$$$,  $$$b = [\\color{red}{1}, 1,\\color{blue}{2, 3, 1}, 3, \\color{green}{2, 3}, 2]$$$. If a different segmentation had been used, the sent sequence might have been different.The sequence $$$b$$$ is given. Could the sequence $$$b$$$ be sent over the network? In other words, is there such a sequence $$$a$$$ that converting $$$a$$$ to send it over the network could result in a sequence $$$b$$$?",
    "prob_desc_output_spec": "For each test case print on a separate line:   YES if sequence $$$b$$$ could be sent over the network, that is, if sequence $$$b$$$ could be obtained from some sequence $$$a$$$ to send $$$a$$$ over the network.  NO otherwise.  You can output YES and NO in any case (for example, strings yEs, yes, Yes and YES will be recognized as positive response).",
    "prob_desc_input_spec": "The first line of input data contains a single integer $$$t$$$ ($$$1 \\le t \\le 10^4$$$) — the number of test cases. Each test case consists of two lines. The first line of the test case contains an integer $$$n$$$ ($$$1 \\le n \\le 2 \\cdot 10^5$$$) — the size of the sequence $$$b$$$. The second line of test case contains $$$n$$$ integers $$$b_1, b_2, \\dots, b_n$$$ ($$$1 \\le b_i \\le 10^9$$$) — the sequence $$$b$$$ itself. It is guaranteed that the sum of $$$n$$$ over all test cases does not exceed $$$2 \\cdot 10^5$$$.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3-64",
    "lang_cluster": "Python",
    "difficulty": 1600,
    "file_name": "train_084.jsonl",
    "code_uid": "efc78aa46c0eb9b47344e6c4e8468d4a",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"7\\n\\n9\\n\\n1 1 2 3 1 3 2 2 3\\n\\n5\\n\\n12 1 2 7 5\\n\\n6\\n\\n5 7 8 9 10 3\\n\\n4\\n\\n4 8 6 2\\n\\n2\\n\\n3 1\\n\\n10\\n\\n4 6 2 1 9 4 9 3 4 2\\n\\n1\\n\\n1\"]",
    "exec_outcome": "PASSED",
    "source_code": "for _ in range(int(input())):\r\n    input()\r\n    a = [int(x) for x in input().split()]\r\n    possible = {}\r\n    alredyFound = set()\r\n    lastFound = set()\r\n    lastFound.add(0)\r\n    found = False\r\n    for i in range(len(a)):\r\n        n = a[i]\r\n        if i+n <= len(a) and i in lastFound:\r\n            if i not in alredyFound:\r\n                possible[i] = []\r\n            possible[i] +=[ (i, i+n+1) ]\r\n            alredyFound.add(i)\r\n            if i+n+1 == len(a):\r\n                found = True\r\n                break\r\n            lastFound.add(i+n+1)\r\n        if i-n >= 0 and i-n in lastFound:\r\n            if i-n not in alredyFound:\r\n                possible[i-n] = []\r\n                alredyFound.add(i-n)\r\n            possible[i-n] += [(i-n, i+1)]\r\n            if i+1 == len(a):\r\n                found = True\r\n                break\r\n            lastFound.add(i+1)\r\n    if found:\r\n        print(\"YES\")\r\n    else:\r\n        print(\"NO\")\r\n            \r\n\r\n                    \r\n            ",
    "prob_desc_created_at": "1665498900",
    "tags": [
        "dp"
    ],
    "hidden_unit_tests": ""
}
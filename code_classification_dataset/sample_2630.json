{
    "prob_desc_time_limit": "1 second",
    "prob_desc_sample_outputs": "[\"YES\\n4 1\\n4 2\\n1 3\", \"NO\"]",
    "src_uid": "5ecb8f82b073b374a603552fdd95391b",
    "prob_desc_notes": "NoteIn the first sample test a permutation transforms edge (4, 1) into edge (1, 4), edge (4, 2) into edge (1, 3) and edge (1, 3) into edge (4, 2). These edges all appear in the resulting tree.It can be shown that in the second sample test no tree satisfies the given condition.",
    "prob_desc_description": "A tree of size n is an undirected connected graph consisting of n vertices without cycles.Consider some tree with n vertices. We call a tree invariant relative to permutation p = p1p2... pn, if for any two vertices of the tree u and v the condition holds: \"vertices u and v are connected by an edge if and only if vertices pu and pv are connected by an edge\".You are given permutation p of size n. Find some tree size n, invariant relative to the given permutation.",
    "prob_desc_output_spec": "If the sought tree does not exist, print \"NO\" (without the quotes). Otherwise, print \"YES\", and then print n - 1 lines, each of which contains two integers — the numbers of vertices connected by an edge of the tree you found. The vertices are numbered from 1, the order of the edges and the order of the vertices within the edges does not matter. If there are multiple solutions, output any of them.",
    "prob_desc_input_spec": "The first line contains number n (1 ≤ n ≤ 105) — the size of the permutation (also equal to the size of the sought tree). The second line contains permutation pi (1 ≤ pi ≤ n).",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "Python 3",
    "lang_cluster": "Python",
    "difficulty": 2100,
    "file_name": "train_026.jsonl",
    "code_uid": "ecbec996a402bd9b83ed46b01ebe6c8c",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"4\\n4 3 2 1\", \"3\\n3 1 2\"]",
    "exec_outcome": "PASSED",
    "source_code": "m = int(input())\nL = list(map(int, input().split()))\n\nfor i in range(len(L)):\n    L[i] -= 1\n\ntemp = []\nd = set()\nflag1 = 0\nflag2 = 0\nflag3 = 0\nfor index, num in enumerate(L):\n    if num not in d:\n        t = 1\n        d.add(num)\n        ts = [num]\n        while num != index:\n            num = L[num]\n            d.add(num)\n            ts += num,\n            t += 1\n        if t == 1:\n            flag1 = 1\n            c = num\n            break\n        elif t == 2:\n            flag2 = 1\n            c = len(temp)\n            a = ts[0]\n            b = ts[1]\n        elif t % 2 == 1:\n            flag3 = 1\n        temp.append(ts)\n\nif flag1 == 1:\n    print('YES')\n    for i in L:\n        if not i == c:\n            print(i + 1, c + 1)\nelif flag2 == 0:\n    print('NO')\nelse:\n    if flag3 == 1:\n        print('NO')\n    else:\n        print('YES')\n        for index, i in enumerate(temp):\n            if index == c:\n                print(i[0]+1, i[1] + 1)\n                continue\n            for index, j in enumerate(i):\n                if index % 2 == 0:\n                    print(a + 1, j + 1)\n                else:\n                    print(b + 1, j + 1)\n    \n",
    "prob_desc_created_at": "1441902600",
    "tags": [],
    "hidden_unit_tests": ""
}
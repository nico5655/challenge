{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"4\"]",
    "src_uid": "22319b83f5874287e3aeaa6dd339e7cb",
    "prob_desc_notes": null,
    "prob_desc_description": "The pandemic is upon us, and the world is in shortage of the most important resource: toilet paper. As one of the best prepared nations for this crisis, BubbleLand promised to help all other world nations with this valuable resource. To do that, the country will send airplanes to other countries carrying toilet paper.In BubbleLand, there are $$$N$$$ toilet paper factories, and $$$N$$$ airports. Because of how much it takes to build a road, and of course legal issues, every factory must send paper to only one airport, and every airport can only take toilet paper from one factory.Also, a road can't be built between all airport-factory pairs, again because of legal issues. Every possible road has number $$$d$$$ given, number of days it takes to build that road.Your job is to choose $$$N$$$ factory-airport pairs, such that if the country starts building all roads at the same time, it takes the least amount of days to complete them.",
    "prob_desc_output_spec": "If there are no solutions, output -1. If there exists a solution, output the minimal number of days to complete all roads, equal to maximal $$$d$$$ among all chosen roads.",
    "prob_desc_input_spec": "The first line contains two integers $$$N$$$ $$$(1 \\leq N \\leq 10^4)$$$ - number of airports/factories, and $$$M$$$ $$$(1 \\leq M \\leq 10^5)$$$ - number of available pairs to build a road between. On next $$$M$$$ lines, there are three integers $$$u$$$, $$$v$$$ $$$(1 \\leq u,v \\leq N)$$$, $$$d$$$ $$$(1 \\leq d \\leq 10^9)$$$ - meaning that you can build a road between airport $$$u$$$ and factory $$$v$$$ for $$$d$$$ days.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3",
    "lang_cluster": "Python",
    "difficulty": 1900,
    "file_name": "train_002.jsonl",
    "code_uid": "e5788a6c4f240a69a3df5835ece2cbf9",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"3 5\\n1 2 1\\n2 3 2\\n3 3 3\\n2 1 4\\n2 2 5\"]",
    "exec_outcome": "PASSED",
    "source_code": "import os\nimport sys\nfrom io import BytesIO, IOBase\n# region fastio\nBUFSIZE = 8192\nclass FastIO(IOBase):\n    newlines = 0\n \n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n \n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n \n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n \n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n \n \nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n \n \nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n \n# ------------------------------\n \ndef RL(): return map(int, sys.stdin.readline().rstrip().split())\ndef RLL(): return list(map(int, sys.stdin.readline().rstrip().split()))\ndef N(): return int(input())\ndef print_list(l):\n    print(' '.join(map(str,l)))\n# import sys\n# sys.setrecursionlimit(5010)\n# from heapq import *\n# from collections import deque as dq\n# from math import ceil,floor,sqrt,pow\n# import bisect as bs\n# from collections import Counter\nfrom collections import defaultdict as dc \n\ndef judge(last,key,d1,d2):\n    if key>last:\n        for (a,b,c) in data:\n            if last<c<=key:\n                d1[a].add(b)\n                d2[b].add(a)\n\n    else:\n        for (a,b,c) in data:\n            if key<c<=last:\n                d1[a].remove(b)\n                if not d1[a]:\n                    del d1[a]\n                d2[b].remove(a)\n                if not d2[b]:\n                    del d2[b]\n    if len(d1.keys())<n or len(d2.keys())<n:\n        return False\n\n    for a in d1:\n        lone = 0\n        for b in d1[a]:\n            if len(d2[b])==1:\n                lone+=1\n                if lone>1:\n                    return False\n    for b in d2:\n        lone = 0\n        for a in d2[b]:\n            if len(d1[a])==1:\n                lone+=1\n                if lone>1:\n                    return False\n\n        \n    used = set()\n    for a in d1:\n        if a not in used:\n            s1,s2,now = {a},d1[a].copy(),d1[a].copy()\n            while now:\n                b = now.pop()\n                da = d2[b]-s1 \n                s1|=da \n                for aa in da:\n                    db = d1[aa]-s2\n                    now|=db\n                    s2|=db\n            if len(s1)!=len(s2):\n                return False\n            used|=s1\n    return True\n\n\nn,m = RL()\ndata = []\nfor _ in range(m):\n    data.append(tuple(map(int, sys.stdin.readline().split())))\nl,r = min(a[2] for a in data),max(a[2] for a in data)+1\nmd = r\nlast = 0\ndu = dc(set)\ndv = dc(set)\nwhile l<r:\n    key = (l+r)>>1\n    if judge(last,key,du,dv):\n        r = key\n    else:\n        l = key+1\n    last = key\nif l>=md:\n    print(-1)\nelse:\n    print(l)",
    "prob_desc_created_at": "1601903100",
    "tags": [
        "graph matchings",
        "binary search",
        "flows",
        "graphs"
    ],
    "hidden_unit_tests": ""
}
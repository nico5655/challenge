{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"Yes\\n1 0\\n1 1\\n0 1\\n0 0\\nNo\", \"Yes\\n1 0\\n1 1\\n2 1\\n2 2\\n1 2\\n1 1\\n0 1\\n0 0\\nYes\\n0 -2\\n2 -2\\n2 -1\\n1 -1\\n1 0\\n0 0\", \"Yes\\n2 0\\n2 3\\n3 3\\n3 7\\n4 7\\n4 12\\n0 12\\n0 0\\nNo\"]",
    "src_uid": "c8d8867789284b2e27fbb73ab3e59793",
    "prob_desc_notes": "NoteIn the first test case of the first example, the answer is Yes — for example, the following picture illustrates a square that satisfies the requirements:    In the first test case of the second example, the desired polyline also exists. Note that, the polyline contains self-intersections, but only in the endpoints:    In the second test case of the second example, the desired polyline could be like the one below:    Note that the following polyline is not a valid one, since it contains self-intersections that are not endpoints for some of the segments:    ",
    "prob_desc_description": "One drew a closed polyline on a plane, that consisted only of vertical and horizontal segments (parallel to the coordinate axes). The segments alternated between horizontal and vertical ones (a horizontal segment was always followed by a vertical one, and vice versa). The polyline did not contain strict self-intersections, which means that in case any two segments shared a common point, that point was an endpoint for both of them (please consult the examples in the notes section).Unfortunately, the polyline was erased, and you only know the lengths of the horizonal and vertical segments. Please construct any polyline matching the description with such segments, or determine that it does not exist.",
    "prob_desc_output_spec": "For each test case output Yes, if there exists at least one polyline satisfying the requirements, or No otherwise. If it does exist, in the following $$$n$$$ lines print the coordinates of the polyline vertices, in order of the polyline traversal: the $$$i$$$-th line should contain two integers $$$x_i$$$ and $$$y_i$$$ — coordinates of the $$$i$$$-th vertex. Note that, each polyline segment must be either horizontal or vertical, and the segments should alternate between horizontal and vertical. The coordinates should not exceed $$$10^9$$$ by their absolute value.",
    "prob_desc_input_spec": "The first line contains one integer $$$t$$$ ($$$1 \\leq t \\leq 200$$$) —the number of test cases. The first line of each test case contains one integer $$$h$$$ ($$$1 \\leq h \\leq 1000$$$) — the number of horizontal segments. The following line contains $$$h$$$ integers $$$l_1, l_2, \\dots, l_h$$$ ($$$1 \\leq l_i \\leq 1000$$$) — lengths of the horizontal segments of the polyline, in arbitrary order. The following line contains an integer $$$v$$$ ($$$1 \\leq v \\leq 1000$$$) — the number of vertical segments, which is followed by a line containing $$$v$$$ integers $$$p_1, p_2, \\dots, p_v$$$ ($$$1 \\leq p_i \\leq 1000$$$) — lengths of the vertical segments of the polyline, in arbitrary order. Test cases are separated by a blank line, and the sum of values $$$h + v$$$ over all test cases does not exceed $$$1000$$$.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3",
    "lang_cluster": "Python",
    "difficulty": 2900,
    "file_name": "train_027.jsonl",
    "code_uid": "68d9d087e43970f4cd36eafc1925fe66",
    "prob_desc_memory_limit": "512 megabytes",
    "prob_desc_sample_inputs": "[\"2\\n2\\n1 1\\n2\\n1 1\\n\\n2\\n1 2\\n2\\n3 3\", \"2\\n4\\n1 1 1 1\\n4\\n1 1 1 1\\n\\n3\\n2 1 1\\n3\\n2 1 1\", \"2\\n4\\n1 4 1 2\\n4\\n3 4 5 12\\n\\n4\\n1 2 3 6\\n2\\n1 3\"]",
    "exec_outcome": "PASSED",
    "source_code": "#!/usr/bin/env python\nimport os\nimport sys\nfrom io import BytesIO, IOBase\n\n\ndef main():\n    t = int(input())\n    for _ in range(t):\n        if _ != 0:\n            input()\n        h = int(input())\n        l1 = list(map(int,input().split()))\n        v = int(input())\n        l2 = list(map(int,input().split()))\n        hKnap = [1]\n        vKnap = [1]\n        if h != v or sum(l1) % 2 != 0 or sum(l2) % 2 != 0:\n            print(\"No\")\n            continue\n        for elem in l1:\n            hKnap.append((hKnap[-1] << elem) | hKnap[-1])\n        for elem in l2:\n            vKnap.append((vKnap[-1] << elem) | vKnap[-1])\n        hSet = []\n        hSet2 = []\n        vSet = []\n        vSet2 = []\n        if hKnap[-1] & 1 << (sum(l1) // 2):\n            curSum = sum(l1) // 2\n            for i in range(h - 1, -1, -1):\n                if curSum >= l1[i] and hKnap[i] & (1 << (curSum - l1[i])):\n                    curSum -= l1[i]\n                    hSet.append(l1[i])\n                else:\n                    hSet2.append(l1[i])\n        if vKnap[-1] & 1 << (sum(l2) // 2):\n            curSum = sum(l2) // 2\n            for i in range(v - 1, -1, -1):\n                if curSum >= l2[i] and vKnap[i] & (1 << (curSum - l2[i])):\n                    curSum -= l2[i]\n                    vSet.append(l2[i])\n                else:\n                    vSet2.append(l2[i])\n        if not hSet or not vSet:\n            print(\"No\")\n        else:\n            print(\"Yes\")\n            if len(hSet) < len(hSet2):\n                hTupleS = tuple(sorted(hSet))\n                hTupleL = tuple(sorted(hSet2))\n            else:\n                hTupleS = tuple(sorted(hSet2))\n                hTupleL = tuple(sorted(hSet))\n            if len(vSet) < len(vSet2):\n                vTupleS = tuple(sorted(vSet))\n                vTupleL = tuple(sorted(vSet2))\n            else:\n                vTupleS = tuple(sorted(vSet2))\n                vTupleL = tuple(sorted(vSet))\n            currentLoc = [0,0]\n            isHS = True\n            isHL = False\n            isVS = False\n            isVL = True\n            hIndex = len(hTupleS)-1\n            vIndex = 0\n            for i in range(h):\n                if isHS:\n                    currentLoc[0] += hTupleS[hIndex]\n                    hIndex -= 1\n                    if hIndex < 0:\n                        hIndex = len(hTupleL) - 1\n                        isHS = False\n                        isHL = True\n                elif isHL:\n                    currentLoc[0] -= hTupleL[hIndex]\n                    hIndex -= 1\n                print(str(currentLoc[0]) + \" \" + str(currentLoc[1]))\n                if isVL:\n                    currentLoc[1] += vTupleL[vIndex]\n                    vIndex += 1\n                    if vIndex >= len(vTupleL):\n                        vIndex = 0\n                        isVL = False\n                        isVH = True\n                elif isHL:\n                    currentLoc[1] -= vTupleS[vIndex]\n                    vIndex += 1\n                print(str(currentLoc[0]) + \" \" + str(currentLoc[1]))\n\n# region fastio\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n# endregion\n\nif __name__ == \"__main__\":\n    main()",
    "prob_desc_created_at": "1604228700",
    "tags": [
        "dp",
        "constructive algorithms",
        "geometry"
    ],
    "hidden_unit_tests": ""
}
{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"2.683281573000\", \"2.267786838055\"]",
    "src_uid": "18b1814234b05bae56ea4446506b543b",
    "prob_desc_notes": "NoteIn the first sample the jury should choose the following values: r1 = 3, p1 = 2, p2 = 1.",
    "prob_desc_description": "The World Programming Olympics Medal is a metal disk, consisting of two parts: the first part is a ring with outer radius of r1 cm, inner radius of r2 cm, (0 &lt; r2 &lt; r1) made of metal with density p1 g/cm3. The second part is an inner disk with radius r2 cm, it is made of metal with density p2 g/cm3. The disk is nested inside the ring.The Olympic jury decided that r1 will take one of possible values of x1, x2, ..., xn. It is up to jury to decide which particular value r1 will take. Similarly, the Olympic jury decided that p1 will take one of possible value of y1, y2, ..., ym, and p2 will take a value from list z1, z2, ..., zk.According to most ancient traditions the ratio between the outer ring mass mout and the inner disk mass min must equal , where A, B are constants taken from ancient books. Now, to start making medals, the jury needs to take values for r1, p1, p2 and calculate the suitable value of r2.The jury wants to choose the value that would maximize radius r2. Help the jury find the sought value of r2. Value r2 doesn't have to be an integer.Medal has a uniform thickness throughout the area, the thickness of the inner disk is the same as the thickness of the outer ring.",
    "prob_desc_output_spec": "Print a single real number — the sought value r2 with absolute or relative error of at most 10 - 6. It is guaranteed that the solution that meets the problem requirements exists.",
    "prob_desc_input_spec": "The first input line contains an integer n and a sequence of integers x1, x2, ..., xn. The second input line contains an integer m and a sequence of integers y1, y2, ..., ym. The third input line contains an integer k and a sequence of integers z1, z2, ..., zk. The last line contains two integers A and B. All numbers given in the input are positive and do not exceed 5000. Each of the three sequences contains distinct numbers. The numbers in the lines are separated by spaces.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 2",
    "lang_cluster": "Python",
    "difficulty": 1300,
    "file_name": "train_000.jsonl",
    "code_uid": "6a6bb6cdaa6a0cc8db980f87b4189cd7",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"3 1 2 3\\n1 2\\n3 3 2 1\\n1 2\", \"4 2 3 6 4\\n2 1 2\\n3 10 6 8\\n2 1\"]",
    "exec_outcome": "PASSED",
    "source_code": "#!/usr/bin/env pypy\nfrom __future__ import division, print_function\nfrom collections import defaultdict, Counter, deque\nfrom future_builtins import ascii, filter, hex, map, oct, zip\nfrom itertools import imap as map, izip as zip, permutations, combinations, combinations_with_replacement\nfrom __builtin__ import xrange as range\nfrom math import ceil, factorial, log,tan,pi,cos,sin,radians\nfrom _continuation import continulet\nfrom cStringIO import StringIO\nfrom io import IOBase\nimport __pypy__\nfrom bisect import bisect, insort, bisect_left, bisect_right\nfrom fractions import Fraction\nfrom functools import reduce\nfrom decimal import *\nimport string\nimport sys\nimport os\nimport re\ninf = float('inf')\nmod_ = int(1e9) + 7\nmod = 998244353\n\ndef factors(n):\n    from functools import reduce\n    return set(reduce(list.__add__, ([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0)))\n\ndef sieve(m):\n    n=1\n    primes = {}\n    arr=set([])\n    for i in range(2, int(m ** 0.5) + 1):\n        a = n // i\n        b = m // i\n        for k in range(max(2, a), b + 1):\n            c = i * k\n            primes[c] = 1\n\n    for i in range(max(n, 2), m + 1):\n        if i not in primes:\n            arr.add(i)\n\n    return arr\n\n\nclass DisjointSetUnion:\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.size = [1] * n\n        self.num_sets = n\n \n    def find(self, a):\n        acopy = a\n        while a != self.parent[a]:\n            a = self.parent[a]\n        while acopy != a:\n            self.parent[acopy], acopy = a, self.parent[acopy]\n        return a\n \n    def union(self, a, b):\n        a, b = self.find(a), self.find(b)\n        if a != b:\n            if self.size[a] < self.size[b]:\n                a, b = b, a\n \n            self.num_sets -= 1\n            self.parent[b] = a\n            self.size[a] += self.size[b]\n \n    def set_size(self, a):\n        return self.size[self.find(a)]\n \n    def __len__(self):\n        return self.num_sets\n\n\n\ndef main():\n    r1=max(list(map(int,input().split()))[1:])\n    p1=max(list(map(int,input().split()))[1:])\n    p2=list(map(int,input().split()))[1:]\n    a,b=map(int,input().split())\n    r2=0\n    for j in range(len(p2)):\n        ans=r1*(b*p1/(b*p1+a*p2[j]))**0.5\n        r2=max(r2,ans)\n    print(r2)\n\n\n\n\n\n\n\n\n\n\n\n    \n\n\n\n# region fastio\n\nBUFSIZE = 8192\n\nclass FastI(IOBase):\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self._buffer = StringIO()\n        self.newlines = 0\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(\"\\n\") + (not b)\n            ptr = self._buffer.tell()\n            self._buffer.seek(0, 2), self._buffer.write(b), self._buffer.seek(ptr)\n        self.newlines -= 1\n        return self._buffer.readline()\n\n\nclass FastO(IOBase):\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self._buffer = __pypy__.builders.StringBuilder()\n        self.write = lambda s: self._buffer.append(s)\n\n    def flush(self):\n        os.write(self._fd, self._buffer.build())\n        self._buffer = __pypy__.builders.StringBuilder()\n\n\ndef print(*args, **kwargs):\n    sep, file = kwargs.pop(\"sep\", \" \"), kwargs.pop(\"file\", sys.stdout)\n    at_start = True\n    for x in args:\n        if not at_start:\n            file.write(sep)\n        file.write(str(x))\n        at_start = False\n    file.write(kwargs.pop(\"end\", \"\\n\"))\n    if kwargs.pop(\"flush\", False):\n        file.flush()\n\ndef gcd(x, y):\n    while y:\n        x, y = y, x % y\n    return x\n\nsys.stdin, sys.stdout = FastI(sys.stdin), FastO(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n# endregion\n\nif __name__ == \"__main__\":\n    main()",
    "prob_desc_created_at": "1344267000",
    "tags": [
        "greedy",
        "math"
    ],
    "hidden_unit_tests": ""
}
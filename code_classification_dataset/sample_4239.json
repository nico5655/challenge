{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"2\\n1\\n0\"]",
    "src_uid": "c767a6a53cbd8bd64ac4af08c9846cc0",
    "prob_desc_notes": "Note    Picture from examples First example:  $$$0$$$ second: we explode a mine at the cell $$$(2, 2)$$$, it does not detonate any other mine since $$$k=0$$$.  $$$1$$$ second: we explode the mine at the cell $$$(0, 1)$$$, and the mine at the cell $$$(0, 0)$$$ explodes itself.  $$$2$$$ second: we explode the mine at the cell $$$(1, 1)$$$, and the mine at the cell $$$(1, 0)$$$ explodes itself.Second example:  $$$0$$$ second: we explode a mine at the cell $$$(2, 2)$$$ we get:       $$$1$$$ second: the mine at coordinate $$$(0, 0)$$$ explodes and since $$$k=2$$$ the explosion detonates mines at the cells $$$(0, 1)$$$ and $$$(1, 0)$$$, and their explosions detonate the mine at the cell $$$(1, 1)$$$ and there are no mines left on the field. ",
    "prob_desc_description": "Polycarp is very fond of playing the game Minesweeper. Recently he found a similar game and there are such rules.There are mines on the field, for each the coordinates of its location are known ($$$x_i, y_i$$$). Each mine has a lifetime in seconds, after which it will explode. After the explosion, the mine also detonates all mines vertically and horizontally at a distance of $$$k$$$ (two perpendicular lines). As a result, we get an explosion on the field in the form of a \"plus\" symbol ('+'). Thus, one explosion can cause new explosions, and so on.Also, Polycarp can detonate anyone mine every second, starting from zero seconds. After that, a chain reaction of explosions also takes place. Mines explode instantly and also instantly detonate other mines according to the rules described above.Polycarp wants to set a new record and asks you to help him calculate in what minimum number of seconds all mines can be detonated.",
    "prob_desc_output_spec": "Print $$$t$$$ lines, each of the lines must contain the answer to the corresponding set of input data  — the minimum number of seconds it takes to explode all the mines.",
    "prob_desc_input_spec": "The first line of the input contains an integer $$$t$$$ ($$$1 \\le t \\le 10^4$$$) — the number of test cases in the test. An empty line is written in front of each test suite. Next comes a line that contains integers $$$n$$$ and $$$k$$$ ($$$1 \\le n \\le 2 \\cdot 10^5$$$, $$$0 \\le k \\le 10^9$$$) — the number of mines and the distance that hit by mines during the explosion, respectively. Then $$$n$$$ lines follow, the $$$i$$$-th of which describes the $$$x$$$ and $$$y$$$ coordinates of the $$$i$$$-th mine and the time until its explosion ($$$-10^9 \\le x, y \\le 10^9$$$, $$$0 \\le timer \\le 10^9$$$). It is guaranteed that all mines have different coordinates. It is guaranteed that the sum of the values $$$n$$$ over all test cases in the test does not exceed $$$2 \\cdot 10^5$$$.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3",
    "lang_cluster": "Python",
    "difficulty": 2000,
    "file_name": "train_093.jsonl",
    "code_uid": "38a20f231af16f8e52c327c52b51b380",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"3\\n\\n5 0\\n0 0 1\\n0 1 4\\n1 0 2\\n1 1 3\\n2 2 9\\n\\n5 2\\n0 0 1\\n0 1 4\\n1 0 2\\n1 1 3\\n2 2 9\\n\\n6 1\\n1 -1 3\\n0 -1 9\\n0 1 7\\n-1 0 1\\n-1 1 9\\n-1 -1 7\"]",
    "exec_outcome": "PASSED",
    "source_code": "from collections import defaultdict\r\nimport sys \r\n\r\ninput = sys.stdin.buffer.readline\r\n\r\ndef find(pas, x):\r\n    if pas[x] != x:\r\n        pas[x] = find(pas, pas[x])\r\n    return pas[x] \r\n\r\ndef union(pas, x, y):\r\n    fx, fy = find(pas, x), find(pas, y)\r\n    if fx != fy:\r\n        pas[fx] = fy \r\n    return\r\n\r\ndef work(n, k, points, row, col, explosion_time):\r\n    pas = list(range(n))\r\n\r\n    for x in row:\r\n        ps = []\r\n        for i in row[x]:\r\n            px, py = points[i]\r\n            ps.append([py, px, i])\r\n\r\n        ps.sort()\r\n        for i in range(len(ps) - 1):\r\n            dist = abs(ps[i][0] - ps[i + 1][0])\r\n            if dist <= k:\r\n                union(pas, ps[i][2], ps[i + 1][2])\r\n\r\n    for y in col:\r\n        ps = []\r\n        for i in col[y]:\r\n            px, py = points[i]\r\n            ps.append([px, py, i])\r\n        ps.sort()\r\n        for i in range(len(ps) - 1):\r\n            dist = abs(ps[i][0] - ps[i + 1][0])\r\n            if dist <= k:\r\n                union(pas, ps[i][2], ps[i + 1][2])\r\n    \r\n    mint = defaultdict(int)\r\n    for i in range(n):\r\n        fi = find(pas, i)\r\n        time = explosion_time[i]\r\n        if fi not in mint:\r\n            mint[fi] = time \r\n        else:\r\n            mint[fi] = min(mint[fi], time)\r\n    nodes = []\r\n    for fa, time in mint.items():\r\n        nodes.append([time, fa])\r\n    nodes.sort()\r\n    ans = 0 \r\n    nodes.pop()\r\n    while nodes:\r\n        time, fa = nodes.pop()\r\n        if time > ans:\r\n            ans += 1 \r\n    return ans \r\n\r\n\r\ndef main():\r\n    test = int(input())\r\n\r\n    for _ in range(test):\r\n        _ = input()\r\n        n, k = map(int, input().split())\r\n        points = defaultdict(list)\r\n        row, col = defaultdict(list), defaultdict(list)\r\n        explosion_time = defaultdict(int)\r\n\r\n        for i in range(n):\r\n            x, y, t = map(int, input().split())\r\n            points[i] = [x, y]\r\n            row[x].append(i)\r\n            col[y].append(i)\r\n            explosion_time[i] = t \r\n        \r\n        res = work(n, k, points, row, col, explosion_time)\r\n        print(res)\r\n    \r\n    return \r\nif __name__ == \"__main__\":\r\n    main()\r\n\r\n",
    "prob_desc_created_at": "1640010900",
    "tags": [
        "binary search",
        "dfs and similar",
        "dsu",
        "greedy",
        "sortings"
    ],
    "hidden_unit_tests": ""
}
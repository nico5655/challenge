{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"3\\n5 1 3 6\\n4 2 7\\n5\\n1 2 8 11 4 13 9 15\\n6 14 3 7 10 5 12\"]",
    "src_uid": "b75ec87dcc25fdd04c3388a0051b8719",
    "prob_desc_notes": "NoteThe tree in the first test case with the weights of all nodes and edges is shown in the picture.  The costs of all paths are:   $$$3$$$;  $$$3\\oplus 7=4$$$;  $$$3\\oplus 7\\oplus 6=2$$$;  $$$3\\oplus 2=1$$$;  $$$3\\oplus 2\\oplus 1=0$$$;  $$$3\\oplus 2\\oplus 1\\oplus 4=4$$$;  $$$3\\oplus 2\\oplus 1\\oplus 4\\oplus 5=1$$$. The maximum cost of all these paths is $$$4$$$. We can show that it is impossible to assign the values and choose the root differently to achieve a smaller maximum cost of all paths.The tree in the second test case:   ",
    "prob_desc_description": "After the last regional contest, Hemose and his teammates finally qualified to the ICPC World Finals, so for this great achievement and his love of trees, he gave you this problem as the name of his team \"Hemose 3al shagra\" (Hemose on the tree).You are given a tree of $$$n$$$ vertices where $$$n$$$ is a power of $$$2$$$. You have to give each node and edge an integer value in the range $$$[1,2n -1]$$$ (inclusive), where all the values are distinct.After giving each node and edge a value, you should select some root for the tree such that the maximum cost of any simple path starting from the root and ending at any node or edge is minimized.The cost of the path between two nodes $$$u$$$ and $$$v$$$ or any node $$$u$$$ and edge $$$e$$$ is defined as the bitwise XOR of all the node's and edge's values between them, including the endpoints (note that in a tree there is only one simple path between two nodes or between a node and an edge).",
    "prob_desc_output_spec": "For each test case on the first line print the chosen root. On the second line, print $$$n$$$ integers separated by spaces, where the $$$i$$$-th integer represents the chosen value for the $$$i$$$-th node. On the third line, print $$$n-1$$$ integers separated by spaces, where the $$$i$$$-th integer represents the chosen value for the $$$i$$$-th edge. The edges are numerated in the order of their appearance in the input data. If there are multiple solutions, you may output any.",
    "prob_desc_input_spec": "The first line contains a single integer $$$t$$$ ($$$1 \\le t \\le 5\\cdot 10^4$$$) — the number of test cases. Then $$$t$$$ test cases follow. The first line of each test case contains a single integer $$$p$$$ ($$$1 \\le p \\le 17$$$), where $$$n$$$ (the number of vertices in the tree) is equal to $$$2^p$$$. Each of the next $$$n−1$$$ lines contains two integers $$$u$$$ and $$$v$$$ ($$$1 \\le u,v \\le n$$$) meaning that there is an edge between the vertices $$$u$$$ and $$$v$$$ in the tree. It is guaranteed that the given graph is a tree. It is guaranteed that the sum of $$$n$$$ over all test cases doesn't exceed $$$3\\cdot 10^5$$$.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "Python 3",
    "lang_cluster": "Python",
    "difficulty": 2200,
    "file_name": "train_100.jsonl",
    "code_uid": "776793d15c708299bc8a2834604a72d4",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"2\\n\\n2\\n\\n1 2\\n\\n2 3\\n\\n3 4\\n\\n3\\n\\n1 2\\n\\n2 3\\n\\n3 4\\n\\n1 5\\n\\n1 6\\n\\n5 7\\n\\n5 8\"]",
    "exec_outcome": "PASSED",
    "source_code": "# ---------------------------iye ha aam zindegi---------------------------------------------\r\nimport math\r\nimport random\r\nimport heapq, bisect\r\nimport sys\r\nfrom collections import deque, defaultdict\r\nfrom fractions import Fraction\r\nimport sys\r\nimport threading\r\nfrom collections import defaultdict\r\nthreading.stack_size(2**27)\r\nsys.setrecursionlimit(300000)\r\nmod = 10 ** 9 + 7\r\nmod1 = 998244353\r\n\r\n# ------------------------------warmup----------------------------\r\nimport os\r\nimport sys\r\nfrom io import BytesIO, IOBase\r\n\r\nBUFSIZE = 8192\r\n\r\n\r\nclass FastIO(IOBase):\r\n    newlines = 0\r\n\r\n    def __init__(self, file):\r\n        self._fd = file.fileno()\r\n        self.buffer = BytesIO()\r\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\r\n        self.write = self.buffer.write if self.writable else None\r\n\r\n    def read(self):\r\n        while True:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            if not b:\r\n                break\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines = 0\r\n        return self.buffer.read()\r\n\r\n    def readline(self):\r\n        while self.newlines == 0:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            self.newlines = b.count(b\"\\n\") + (not b)\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines -= 1\r\n        return self.buffer.readline()\r\n\r\n    def flush(self):\r\n        if self.writable:\r\n            os.write(self._fd, self.buffer.getvalue())\r\n            self.buffer.truncate(0), self.buffer.seek(0)\r\n\r\n\r\nclass IOWrapper(IOBase):\r\n    def __init__(self, file):\r\n        self.buffer = FastIO(file)\r\n        self.flush = self.buffer.flush\r\n        self.writable = self.buffer.writable\r\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\r\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\r\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\r\n\r\n\r\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\r\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\r\n\r\n\r\n# -------------------game starts now----------------------------------------------------import math\r\nclass TreeNode:\r\n    def __init__(self, k, v):\r\n        self.key = k\r\n        self.value = v\r\n        self.left = None\r\n        self.right = None\r\n        self.parent = None\r\n        self.height = 1\r\n        self.num_left = 1\r\n        self.num_total = 1\r\n\r\n\r\nclass AvlTree:\r\n\r\n    def __init__(self):\r\n        self._tree = None\r\n\r\n    def add(self, k, v):\r\n        if not self._tree:\r\n            self._tree = TreeNode(k, v)\r\n            return\r\n        node = self._add(k, v)\r\n        if node:\r\n            self._rebalance(node)\r\n\r\n    def _add(self, k, v):\r\n        node = self._tree\r\n        while node:\r\n            if k < node.key:\r\n                if node.left:\r\n                    node = node.left\r\n                else:\r\n                    node.left = TreeNode(k, v)\r\n                    node.left.parent = node\r\n                    return node.left\r\n            elif node.key < k:\r\n                if node.right:\r\n                    node = node.right\r\n                else:\r\n                    node.right = TreeNode(k, v)\r\n                    node.right.parent = node\r\n                    return node.right\r\n            else:\r\n                node.value = v\r\n                return\r\n\r\n    @staticmethod\r\n    def get_height(x):\r\n        return x.height if x else 0\r\n\r\n    @staticmethod\r\n    def get_num_total(x):\r\n        return x.num_total if x else 0\r\n\r\n    def _rebalance(self, node):\r\n\r\n        n = node\r\n        while n:\r\n            lh = self.get_height(n.left)\r\n            rh = self.get_height(n.right)\r\n            n.height = max(lh, rh) + 1\r\n            balance_factor = lh - rh\r\n            n.num_total = 1 + self.get_num_total(n.left) + self.get_num_total(n.right)\r\n            n.num_left = 1 + self.get_num_total(n.left)\r\n\r\n            if balance_factor > 1:\r\n                if self.get_height(n.left.left) < self.get_height(n.left.right):\r\n                    self._rotate_left(n.left)\r\n                self._rotate_right(n)\r\n            elif balance_factor < -1:\r\n                if self.get_height(n.right.right) < self.get_height(n.right.left):\r\n                    self._rotate_right(n.right)\r\n                self._rotate_left(n)\r\n            else:\r\n                n = n.parent\r\n\r\n    def _remove_one(self, node):\r\n        \"\"\"\r\n        Side effect!!! Changes node. Node should have exactly one child\r\n        \"\"\"\r\n        replacement = node.left or node.right\r\n        if node.parent:\r\n            if AvlTree._is_left(node):\r\n                node.parent.left = replacement\r\n            else:\r\n                node.parent.right = replacement\r\n            replacement.parent = node.parent\r\n            node.parent = None\r\n        else:\r\n            self._tree = replacement\r\n            replacement.parent = None\r\n        node.left = None\r\n        node.right = None\r\n        node.parent = None\r\n        self._rebalance(replacement)\r\n\r\n    def _remove_leaf(self, node):\r\n        if node.parent:\r\n            if AvlTree._is_left(node):\r\n                node.parent.left = None\r\n            else:\r\n                node.parent.right = None\r\n            self._rebalance(node.parent)\r\n        else:\r\n            self._tree = None\r\n        node.parent = None\r\n        node.left = None\r\n        node.right = None\r\n\r\n    def remove(self, k):\r\n        node = self._get_node(k)\r\n        if not node:\r\n            return\r\n        if AvlTree._is_leaf(node):\r\n            self._remove_leaf(node)\r\n            return\r\n        if node.left and node.right:\r\n            nxt = AvlTree._get_next(node)\r\n            node.key = nxt.key\r\n            node.value = nxt.value\r\n            if self._is_leaf(nxt):\r\n                self._remove_leaf(nxt)\r\n            else:\r\n                self._remove_one(nxt)\r\n            self._rebalance(node)\r\n        else:\r\n            self._remove_one(node)\r\n\r\n    def get(self, k):\r\n        node = self._get_node(k)\r\n        return node.value if node else -1\r\n\r\n    def _get_node(self, k):\r\n        if not self._tree:\r\n            return None\r\n        node = self._tree\r\n        while node:\r\n            if k < node.key:\r\n                node = node.left\r\n            elif node.key < k:\r\n                node = node.right\r\n            else:\r\n                return node\r\n        return None\r\n\r\n    def get_at(self, pos):\r\n        x = pos + 1\r\n        node = self._tree\r\n        while node:\r\n            if x < node.num_left:\r\n                node = node.left\r\n            elif node.num_left < x:\r\n                x -= node.num_left\r\n                node = node.right\r\n            else:\r\n                return (node.key, node.value)\r\n        raise IndexError(\"Out of ranges\")\r\n\r\n    @staticmethod\r\n    def _is_left(node):\r\n        return node.parent.left and node.parent.left == node\r\n\r\n    @staticmethod\r\n    def _is_leaf(node):\r\n        return node.left is None and node.right is None\r\n\r\n    def _rotate_right(self, node):\r\n        if not node.parent:\r\n            self._tree = node.left\r\n            node.left.parent = None\r\n        elif AvlTree._is_left(node):\r\n            node.parent.left = node.left\r\n            node.left.parent = node.parent\r\n        else:\r\n            node.parent.right = node.left\r\n            node.left.parent = node.parent\r\n        bk = node.left.right\r\n        node.left.right = node\r\n        node.parent = node.left\r\n        node.left = bk\r\n        if bk:\r\n            bk.parent = node\r\n        node.height = max(self.get_height(node.left), self.get_height(node.right)) + 1\r\n        node.num_total = 1 + self.get_num_total(node.left) + self.get_num_total(node.right)\r\n        node.num_left = 1 + self.get_num_total(node.left)\r\n\r\n    def _rotate_left(self, node):\r\n        if not node.parent:\r\n            self._tree = node.right\r\n            node.right.parent = None\r\n        elif AvlTree._is_left(node):\r\n            node.parent.left = node.right\r\n            node.right.parent = node.parent\r\n        else:\r\n            node.parent.right = node.right\r\n            node.right.parent = node.parent\r\n        bk = node.right.left\r\n        node.right.left = node\r\n        node.parent = node.right\r\n        node.right = bk\r\n        if bk:\r\n            bk.parent = node\r\n        node.height = max(self.get_height(node.left), self.get_height(node.right)) + 1\r\n        node.num_total = 1 + self.get_num_total(node.left) + self.get_num_total(node.right)\r\n        node.num_left = 1 + self.get_num_total(node.left)\r\n\r\n    @staticmethod\r\n    def _get_next(node):\r\n        if not node.right:\r\n            return node.parent\r\n        n = node.right\r\n        while n.left:\r\n            n = n.left\r\n        return n\r\n\r\n\r\n# -----------------------------------------------binary seacrh tree---------------------------------------\r\nclass SegmentTree1:\r\n    def __init__(self, data, default=2**51, func=lambda a, b: a & b):\r\n        \"\"\"initialize the segment tree with data\"\"\"\r\n        self._default = default\r\n        self._func = func\r\n        self._len = len(data)\r\n        self._size = _size = 1 << (self._len - 1).bit_length()\r\n\r\n        self.data = [default] * (2 * _size)\r\n        self.data[_size:_size + self._len] = data\r\n        for i in reversed(range(_size)):\r\n            self.data[i] = func(self.data[i + i], self.data[i + i + 1])\r\n\r\n    def __delitem__(self, idx):\r\n        self[idx] = self._default\r\n\r\n    def __getitem__(self, idx):\r\n        return self.data[idx + self._size]\r\n\r\n    def __setitem__(self, idx, value):\r\n        idx += self._size\r\n        self.data[idx] = value\r\n        idx >>= 1\r\n        while idx:\r\n            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])\r\n            idx >>= 1\r\n\r\n    def __len__(self):\r\n        return self._len\r\n\r\n    def query(self, start, stop):\r\n        if start == stop:\r\n            return self.__getitem__(start)\r\n        stop += 1\r\n        start += self._size\r\n        stop += self._size\r\n\r\n        res = self._default\r\n        while start < stop:\r\n            if start & 1:\r\n                res = self._func(res, self.data[start])\r\n                start += 1\r\n            if stop & 1:\r\n                stop -= 1\r\n                res = self._func(res, self.data[stop])\r\n            start >>= 1\r\n            stop >>= 1\r\n        return res\r\n\r\n    def __repr__(self):\r\n        return \"SegmentTree({0})\".format(self.data)\r\n\r\n\r\n# -------------------game starts now----------------------------------------------------import math\r\nclass SegmentTree:\r\n    def __init__(self, data, default=0, func=lambda a, b: a + b):\r\n        \"\"\"initialize the segment tree with data\"\"\"\r\n        self._default = default\r\n        self._func = func\r\n        self._len = len(data)\r\n        self._size = _size = 1 << (self._len - 1).bit_length()\r\n\r\n        self.data = [default] * (2 * _size)\r\n        self.data[_size:_size + self._len] = data\r\n        for i in reversed(range(_size)):\r\n            self.data[i] = func(self.data[i + i], self.data[i + i + 1])\r\n\r\n    def __delitem__(self, idx):\r\n        self[idx] = self._default\r\n\r\n    def __getitem__(self, idx):\r\n        return self.data[idx + self._size]\r\n\r\n    def __setitem__(self, idx, value):\r\n        idx += self._size\r\n        self.data[idx] = value\r\n        idx >>= 1\r\n        while idx:\r\n            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])\r\n            idx >>= 1\r\n\r\n    def __len__(self):\r\n        return self._len\r\n\r\n    def query(self, start, stop):\r\n        if start == stop:\r\n            return self.__getitem__(start)\r\n        stop += 1\r\n        start += self._size\r\n        stop += self._size\r\n\r\n        res = self._default\r\n        while start < stop:\r\n            if start & 1:\r\n                res = self._func(res, self.data[start])\r\n                start += 1\r\n            if stop & 1:\r\n                stop -= 1\r\n                res = self._func(res, self.data[stop])\r\n            start >>= 1\r\n            stop >>= 1\r\n        return res\r\n\r\n    def __repr__(self):\r\n        return \"SegmentTree({0})\".format(self.data)\r\n\r\n\r\n# -------------------------------iye ha chutiya zindegi-------------------------------------\r\nclass Factorial:\r\n    def __init__(self, MOD):\r\n        self.MOD = MOD\r\n        self.factorials = [1, 1]\r\n        self.invModulos = [0, 1]\r\n        self.invFactorial_ = [1, 1]\r\n\r\n    def calc(self, n):\r\n        if n <= -1:\r\n            print(\"Invalid argument to calculate n!\")\r\n            print(\"n must be non-negative value. But the argument was \" + str(n))\r\n            exit()\r\n        if n < len(self.factorials):\r\n            return self.factorials[n]\r\n        nextArr = [0] * (n + 1 - len(self.factorials))\r\n        initialI = len(self.factorials)\r\n        prev = self.factorials[-1]\r\n        m = self.MOD\r\n        for i in range(initialI, n + 1):\r\n            prev = nextArr[i - initialI] = prev * i % m\r\n        self.factorials += nextArr\r\n        return self.factorials[n]\r\n\r\n    def inv(self, n):\r\n        if n <= -1:\r\n            print(\"Invalid argument to calculate n^(-1)\")\r\n            print(\"n must be non-negative value. But the argument was \" + str(n))\r\n            exit()\r\n        p = self.MOD\r\n        pi = n % p\r\n        if pi < len(self.invModulos):\r\n            return self.invModulos[pi]\r\n        nextArr = [0] * (n + 1 - len(self.invModulos))\r\n        initialI = len(self.invModulos)\r\n        for i in range(initialI, min(p, n + 1)):\r\n            next = -self.invModulos[p % i] * (p // i) % p\r\n            self.invModulos.append(next)\r\n        return self.invModulos[pi]\r\n\r\n    def invFactorial(self, n):\r\n        if n <= -1:\r\n            print(\"Invalid argument to calculate (n^(-1))!\")\r\n            print(\"n must be non-negative value. But the argument was \" + str(n))\r\n            exit()\r\n        if n < len(self.invFactorial_):\r\n            return self.invFactorial_[n]\r\n        self.inv(n)  # To make sure already calculated n^-1\r\n        nextArr = [0] * (n + 1 - len(self.invFactorial_))\r\n        initialI = len(self.invFactorial_)\r\n        prev = self.invFactorial_[-1]\r\n        p = self.MOD\r\n        for i in range(initialI, n + 1):\r\n            prev = nextArr[i - initialI] = (prev * self.invModulos[i % p]) % p\r\n        self.invFactorial_ += nextArr\r\n        return self.invFactorial_[n]\r\n\r\n\r\nclass Combination:\r\n    def __init__(self, MOD):\r\n        self.MOD = MOD\r\n        self.factorial = Factorial(MOD)\r\n\r\n    def ncr(self, n, k):\r\n        if k < 0 or n < k:\r\n            return 0\r\n        k = min(k, n - k)\r\n        f = self.factorial\r\n        return f.calc(n) * f.invFactorial(max(n - k, k)) * f.invFactorial(min(k, n - k)) % self.MOD\r\n\r\n\r\n# --------------------------------------iye ha combinations ka zindegi---------------------------------\r\ndef powm(a, n, m):\r\n    if a == 1 or n == 0:\r\n        return 1\r\n    if n % 2 == 0:\r\n        s = powm(a, n // 2, m)\r\n        return s * s % m\r\n    else:\r\n        return a * powm(a, n - 1, m) % m\r\n\r\n\r\n# --------------------------------------iye ha power ka zindegi---------------------------------\r\ndef sort_list(list1, list2):\r\n    zipped_pairs = zip(list2, list1)\r\n\r\n    z = [x for _, x in sorted(zipped_pairs)]\r\n\r\n    return z\r\n\r\n\r\n# --------------------------------------------------product----------------------------------------\r\ndef product(l):\r\n    por = 1\r\n    for i in range(len(l)):\r\n        por *= l[i]\r\n    return por\r\n\r\n\r\n# --------------------------------------------------binary----------------------------------------\r\ndef binarySearchCount(arr, n, key):\r\n    left = 0\r\n    right = n - 1\r\n\r\n    count = 0\r\n\r\n    while (left <= right):\r\n        mid = int((right + left) / 2)\r\n\r\n        # Check if middle element is\r\n        # less than or equal to key\r\n        if (arr[mid] < key):\r\n            count = mid + 1\r\n            left = mid + 1\r\n\r\n        # If key is smaller, ignore right half\r\n        else:\r\n            right = mid - 1\r\n\r\n    return count\r\n\r\n\r\n# --------------------------------------------------binary----------------------------------------\r\ndef countdig(n):\r\n    c = 0\r\n    while (n > 0):\r\n        n //= 10\r\n        c += 1\r\n    return c\r\ndef binary(x, length):\r\n    y = bin(x)[2:]\r\n    return y if len(y) >= length else \"0\" * (length - len(y)) + y\r\n\r\ndef countGreater(arr, n, k):\r\n    l = 0\r\n    r = n - 1\r\n\r\n    # Stores the index of the left most element\r\n    # from the array which is greater than k\r\n    leftGreater = n\r\n\r\n    # Finds number of elements greater than k\r\n    while (l <= r):\r\n        m = int(l + (r - l) / 2)\r\n        if (arr[m] >= k):\r\n            leftGreater = m\r\n            r = m - 1\r\n\r\n        # If mid element is less than\r\n        # or equal to k update l\r\n        else:\r\n            l = m + 1\r\n\r\n    # Return the count of elements\r\n    # greater than k\r\n    return (n - leftGreater)\r\n\r\n\r\n# --------------------------------------------------binary------------------------------------\r\ndef main():\r\n    for ik in range(int(input())):\r\n        n = int(input())\r\n        graph = defaultdict(list)\r\n        ind = defaultdict(int)\r\n        n = 2 ** n\r\n        node = [0] * n\r\n        edge = [0] * (n - 1)\r\n        for i in range(n - 1):\r\n            a, b = map(int, input().split())\r\n            graph[a - 1].append(b - 1)\r\n            graph[b - 1].append(a - 1)\r\n            ind[(a - 1, b - 1)] = i\r\n            ind[(b - 1, a - 1)] = i\r\n        t = [0]\r\n        x = [n]\r\n\r\n        def dfs(v, p, lev):\r\n            if lev%2 == 1:\r\n                edge[ind[(v, p)]] = x[0] + t[0]\r\n                node[v] = t[0]\r\n            else:\r\n                node[v] = x[0] + t[0]\r\n                if p != -1:\r\n                    edge[ind[(v, p)]] = t[0]\r\n            t[0] += 1\r\n            for i in graph[v]:\r\n                if i != p:\r\n                    dfs(i, v, lev + 1)\r\n\r\n        dfs(0, -1, 0)\r\n        print(1)\r\n        print(*node)\r\n        print(*edge)\r\n\r\nt = threading.Thread(target=main)\r\nt.start()\r\nt.join()",
    "prob_desc_created_at": "1651847700",
    "tags": [
        "bitmasks",
        "constructive algorithms",
        "dfs and similar",
        "trees"
    ],
    "hidden_unit_tests": ""
}
{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"YES\\nNO\\nYES\"]",
    "src_uid": "5afb904f611d963ed3e302faefef3305",
    "prob_desc_notes": "NoteIn the first query of the third type $$$k = 3$$$, we can, for example, choose a sequence $$$[1, 2, 3]$$$, since $$$1 \\xrightarrow{\\text{a}} 2 \\xrightarrow{\\text{b}} 3$$$ and $$$3 \\xrightarrow{\\text{a}} 2 \\xrightarrow{\\text{b}} 1$$$.In the second query of the third type $$$k = 2$$$, and we can't find sequence $$$p_1, p_2$$$ such that arcs $$$(p_1, p_2)$$$ and $$$(p_2, p_1)$$$ have the same characters.In the third query of the third type, we can, for example, choose a sequence $$$[1, 2, 3, 2, 1]$$$, where $$$1 \\xrightarrow{\\text{a}} 2 \\xrightarrow{\\text{b}} 3 \\xrightarrow{\\text{d}} 2 \\xrightarrow{\\text{c}} 1$$$.",
    "prob_desc_description": "You are given a directed graph consisting of $$$n$$$ vertices. Each directed edge (or arc) labeled with a single character. Initially, the graph is empty.You should process $$$m$$$ queries with it. Each query is one of three types:   \"$$$+$$$ $$$u$$$ $$$v$$$ $$$c$$$\" — add arc from $$$u$$$ to $$$v$$$ with label $$$c$$$. It's guaranteed that there is no arc $$$(u, v)$$$ in the graph at this moment;  \"$$$-$$$ $$$u$$$ $$$v$$$\" — erase arc from $$$u$$$ to $$$v$$$. It's guaranteed that the graph contains arc $$$(u, v)$$$ at this moment;  \"$$$?$$$ $$$k$$$\" — find the sequence of $$$k$$$ vertices $$$v_1, v_2, \\dots, v_k$$$ such that there exist both routes $$$v_1 \\to v_2 \\to \\dots \\to v_k$$$ and $$$v_k \\to v_{k - 1} \\to \\dots \\to v_1$$$ and if you write down characters along both routes you'll get the same string. You can visit the same vertices any number of times. ",
    "prob_desc_output_spec": "For each query of the third type, print YES if there exist the sequence $$$v_1, v_2, \\dots, v_k$$$ described above, or NO otherwise.",
    "prob_desc_input_spec": "The first line contains two integers $$$n$$$ and $$$m$$$ ($$$2 \\le n \\le 2 \\cdot 10^5$$$; $$$1 \\le m \\le 2 \\cdot 10^5$$$) — the number of vertices in the graph and the number of queries. The next $$$m$$$ lines contain queries — one per line. Each query is one of three types:    \"$$$+$$$ $$$u$$$ $$$v$$$ $$$c$$$\" ($$$1 \\le u, v \\le n$$$; $$$u \\neq v$$$; $$$c$$$ is a lowercase Latin letter);  \"$$$-$$$ $$$u$$$ $$$v$$$\" ($$$1 \\le u, v \\le n$$$; $$$u \\neq v$$$);  \"$$$?$$$ $$$k$$$\" ($$$2 \\le k \\le 10^5$$$).  It's guaranteed that you don't add multiple edges and erase only existing edges. Also, there is at least one query of the third type.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3-64",
    "lang_cluster": "Python",
    "difficulty": 2400,
    "file_name": "train_094.jsonl",
    "code_uid": "504e29b459e6cdcae98ee1b8e3613d53",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"3 11\\n+ 1 2 a\\n+ 2 3 b\\n+ 3 2 a\\n+ 2 1 b\\n? 3\\n? 2\\n- 2 1\\n- 3 2\\n+ 2 1 c\\n+ 3 2 d\\n? 5\"]",
    "exec_outcome": "PASSED",
    "source_code": "import os, sys\r\nfrom io import BytesIO, IOBase\r\n\r\nfrom collections import defaultdict, deque, Counter\r\nfrom bisect import bisect_left, bisect_right\r\nfrom heapq import heappush, heappop\r\nfrom functools import lru_cache\r\nfrom itertools import accumulate\r\nimport math\r\nimport sys\r\n\r\n# sys.setrecursionlimit(10 ** 6)\r\n# Fast IO Region\r\nBUFSIZE = 8192\r\n\r\n\r\n#\r\nclass FastIO(IOBase):\r\n    newlines = 0\r\n\r\n    def __init__(self, file):\r\n        self._fd = file.fileno()\r\n        self.buffer = BytesIO()\r\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\r\n        self.write = self.buffer.write if self.writable else None\r\n\r\n    def read(self):\r\n        while True:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            if not b:\r\n                break\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines = 0\r\n        return self.buffer.read()\r\n\r\n    def readline(self):\r\n        while self.newlines == 0:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            self.newlines = b.count(b\"\\n\") + (not b)\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines -= 1\r\n        return self.buffer.readline()\r\n\r\n    def flush(self):\r\n        if self.writable:\r\n            os.write(self._fd, self.buffer.getvalue())\r\n            self.buffer.truncate(0), self.buffer.seek(0)\r\n\r\n\r\nclass IOWrapper(IOBase):\r\n    def __init__(self, file):\r\n        self.buffer = FastIO(file)\r\n        self.flush = self.buffer.flush\r\n        self.writable = self.buffer.writable\r\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\r\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\r\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\r\n\r\n\r\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\r\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\r\n# sys.setrecursionlimit(800)\r\n\r\n\r\nii = lambda: int(input())\r\nmii = lambda: map(int, input().split())\r\nlmii = lambda: list(map(int, input().split()))\r\ni2c = lambda n: chr(ord('a') + n)\r\nc2i = lambda c: ord(c) - ord('a')\r\n# mod = 998244353\r\nmod = 10 ** 9 + 7\r\n\r\n\r\ndef solve():\r\n    n, m = mii()\r\n    magic = 2184732\r\n    d = {}\r\n    bs = 0\r\n    bss = 0\r\n    for i in range(m):\r\n        ope = input().split()\r\n        if len(ope) == 4:\r\n            ch, u, v, c = ope\r\n            u = int(u) + magic\r\n            v = int(v) + magic\r\n            d[(u, v)] = c\r\n            if (v, u) in d and d[(v, u)] != '#':\r\n                bs += 1\r\n                if d[(v, u)] == c:\r\n                    bss += 1\r\n        elif len(ope) == 3:\r\n            ch, u, v = ope\r\n            u = int(u) + magic\r\n            v = int(v) + magic\r\n            if (v, u) in d and d[(v, u)] != '#':\r\n                bs -= 1\r\n                if d[(v, u)] == d[(u, v)]:\r\n                    bss -= 1\r\n            d[(u, v)] = '#'\r\n        else:\r\n            _, k = ope\r\n            k = int(k)\r\n            if k & 1:\r\n                if bs > 0:\r\n                    print('YES')\r\n                else:\r\n                    print('NO')\r\n            else:\r\n                if bss > 0:\r\n                    print('YES')\r\n                else:\r\n                    print('NO')\r\n\r\n\r\nfor _ in range(1):\r\n    solve()\r\n",
    "prob_desc_created_at": "1614696300",
    "tags": [
        "constructive algorithms",
        "data structures",
        "graphs",
        "hashing"
    ],
    "hidden_unit_tests": ""
}
{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"8\", \"18\", \"-1\"]",
    "src_uid": "adc23c13988fc955f4589c88829ef0e7",
    "prob_desc_notes": "NoteNotes to the samples:In the first sample from the first string you should take characters \"b\" and \"z\" with price 1 ruble, from the second string characters \"a\", \"e\" и \"b\" with price 2 rubles. The price of the string t in this case is 2·1 + 3·2 = 8.In the second sample from the first string you should take two characters \"a\" with price 1 ruble, from the second string character \"c\" with price 2 rubles, from the third string two characters \"a\" with price 3 rubles, from the fourth string two characters \"b\" with price 4 rubles. The price of the string t in this case is 2·1 + 1·2 + 2·3 + 2·4 = 18.In the third sample the solution doesn't exist because there is no character \"y\" in given strings.",
    "prob_desc_description": "You desperately need to build some string t. For that you've got n more strings s1, s2, ..., sn. To build string t, you are allowed to perform exactly |t| (|t| is the length of string t) operations on these strings. Each operation looks like that:  choose any non-empty string from strings s1, s2, ..., sn;  choose an arbitrary character from the chosen string and write it on a piece of paper;  remove the chosen character from the chosen string. Note that after you perform the described operation, the total number of characters in strings s1, s2, ..., sn decreases by 1. We are assumed to build string t, if the characters, written on the piece of paper, in the order of performed operations form string t.There are other limitations, though. For each string si you know number ai — the maximum number of characters you are allowed to delete from string si. You also know that each operation that results in deleting a character from string si, costs i rubles. That is, an operation on string s1 is the cheapest (it costs 1 ruble), and the operation on string sn is the most expensive one (it costs n rubles).Your task is to count the minimum amount of money (in rubles) you will need to build string t by the given rules. Consider the cost of building string t to be the sum of prices of the operations you use.",
    "prob_desc_output_spec": "Print a single number — the minimum money (in rubles) you need in order to build string t. If there is no solution, print -1.",
    "prob_desc_input_spec": "The first line of the input contains string t — the string that you need to build. The second line contains a single integer n (1 ≤ n ≤ 100) — the number of strings to which you are allowed to apply the described operation. Each of the next n lines contains a string and an integer. The i-th line contains space-separated string si and integer ai (0 ≤ ai ≤ 100). Number ai represents the maximum number of characters that can be deleted from string si. All strings in the input only consist of lowercase English letters. All strings are non-empty. The lengths of all strings do not exceed 100 characters.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "Python 3",
    "lang_cluster": "Python",
    "difficulty": 2000,
    "file_name": "train_077.jsonl",
    "code_uid": "5aff6bb79b79a18e4cfc5c325fe8f7d7",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"bbaze\\n3\\nbzb 2\\naeb 3\\nba 10\", \"abacaba\\n4\\naba 2\\nbcc 1\\ncaa 2\\nbbb 5\", \"xyz\\n4\\naxx 8\\nza 1\\nefg 4\\nt 1\"]",
    "exec_outcome": "PASSED",
    "source_code": "class Edge:\n    def __init__(self, to, cost, capacity, next_edge):\n        self.to = to\n        self.cost = cost\n        self.origin_cost = cost\n        self.capacity = capacity\n        self.next_edge = next_edge\n        self.pair = None\n\n\nclass MinCostMaxFlow:\n    def __init__(self, max_node):\n        self.null = Edge(0, 0, 0, None)\n        self.max_node = max_node + 3\n        self.total_cost = 0\n        self.current_cost = 0\n        self.visited = [False] * self.max_node\n        self.arc_list = []\n        self.edge_head = [self.null] * self.max_node\n        self.source = max_node + 1\n        self.sink = max_node + 2\n\n    def AddArcWithCapacityAndUnitCost(self, start_node, end_node, capacity, cost):\n        self.edge_head[start_node] = Edge(end_node, cost, capacity, self.edge_head[start_node])\n        self.edge_head[end_node] = Edge(start_node, -cost, 0, self.edge_head[end_node])\n        self.edge_head[start_node].pair = self.edge_head[end_node]\n        self.edge_head[end_node].pair = self.edge_head[start_node]\n        if start_node != self.source and start_node != self.sink and end_node != self.source and end_node != self.sink:\n            self.arc_list.append(self.edge_head[end_node])\n\n    def NumArcs(self):\n        return len(self.arc_list)\n\n    def Tail(self, index):\n        return self.arc_list[index].to\n\n    def Head(self, index):\n        return self.arc_list[index].pair.to\n\n    def UnitCost(self, index):\n        return self.arc_list[index].pair.origin_cost\n\n    def Flow(self, index):\n        return self.arc_list[index].capacity\n\n    def OptimalFlow(self):\n        edge = self.edge_head[self.sink]\n        total_flow = 0\n        while id(edge) != id(self.null):\n            total_flow += edge.capacity\n            edge = edge.next_edge\n        return total_flow\n\n    def OptimalCost(self):\n        return self.total_cost\n\n    def SetNodeSupply(self, node, supply):\n        if supply > 0:\n            self.AddArcWithCapacityAndUnitCost(self.source, node, supply, 0)\n        elif supply < 0:\n            self.AddArcWithCapacityAndUnitCost(node, self.sink, -supply, 0)\n\n    def aug(self, node_id, total_flow):\n        if node_id == self.sink:\n            self.total_cost += self.current_cost * total_flow\n            return total_flow\n        self.visited[node_id] = True\n        flow = total_flow\n        edge = self.edge_head[node_id]\n        while id(edge) != id(self.null):\n            if edge.capacity > 0 and edge.cost == 0 and not self.visited[edge.to]:\n                delta = self.aug(edge.to, min(flow, edge.capacity))\n                edge.capacity -= delta\n                edge.pair.capacity += delta\n                flow -= delta\n                if flow == 0:\n                    return total_flow\n            edge = edge.next_edge\n        return total_flow - flow\n\n    def modify_label(self):\n        min_cost = 1 << 63\n        for node_id in range(0, self.max_node):\n            if not self.visited[node_id]:\n                continue\n            edge = self.edge_head[node_id]\n            while id(edge) != id(self.null):\n                if edge.capacity > 0 and not self.visited[edge.to] and edge.cost < min_cost:\n                    min_cost = edge.cost\n                edge = edge.next_edge\n        if min_cost == 1 << 63:\n            return False\n        for node_id in range(0, self.max_node):\n            if not self.visited[node_id]:\n                continue\n            edge = self.edge_head[node_id]\n            while id(edge) != id(self.null):\n                edge.cost -= min_cost\n                edge.pair.cost += min_cost\n                edge = edge.next_edge\n        self.current_cost += min_cost\n        return True\n\n    def Solve(self):\n        while True:\n            while True:\n                self.visited = [False] * self.max_node\n                if self.aug(self.source, 1 << 63) == 0:\n                    break\n            if not self.modify_label():\n                break\n        return self.total_cost\n\n\ndef main():\n    s = input()\n    n = int(input())\n    source = 0\n    sink = n + 26 + 1\n    mcmf = MinCostMaxFlow(n + 28)\n    length = len(s)\n    num = [0] * 29\n    for i in range(0, length):\n        num[ord(s[i]) - ord('a') + 1] += 1\n    for i in range(1, 27):\n        if num[i] > 0:\n            mcmf.AddArcWithCapacityAndUnitCost(i, sink, num[i], 0)\n    for i in range(1, n + 1):\n        s, used = input().split(' ')\n        mcmf.AddArcWithCapacityAndUnitCost(source, 26 + i, int(used), 0)\n        num = [0] * 29\n        for j in range(0, len(s)):\n            num[ord(s[j]) - ord('a') + 1] += 1\n        for j in range(1, 27):\n            if num[j] > 0:\n                mcmf.AddArcWithCapacityAndUnitCost(26 + i, j, num[j], i)\n    mcmf.SetNodeSupply(source, 1 << 63)\n    mcmf.SetNodeSupply(sink, -(1 << 63))\n    mcmf.Solve()\n    if mcmf.OptimalFlow() != length:\n        print(\"-1\")\n    else:\n        print(mcmf.OptimalCost())\n\n\nif __name__ == '__main__':\n    main()\n",
    "prob_desc_created_at": "1351179000",
    "tags": [
        "flows",
        "graphs"
    ],
    "hidden_unit_tests": ""
}
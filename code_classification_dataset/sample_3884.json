{
    "prob_desc_time_limit": "1 second",
    "prob_desc_sample_outputs": "[\"0\\n2\\n3 4\\n9 10\\n1\\n2 11\"]",
    "src_uid": "07b52abebe1357f388e911f4a68afcfa",
    "prob_desc_notes": "NoteIn the first test case, the string is already balanced.In the second test case, the string will be transformed as follows: ())((()))( $$$\\to$$$ ()()(()))( $$$\\to$$$ ()()(())(), where the last string is balanced.In the third test case, the string will be transformed to ((()))((())), which is balanced.",
    "prob_desc_description": "Alina has a bracket sequence $$$s$$$ of length $$$2n$$$, consisting of $$$n$$$ opening brackets '(' and $$$n$$$ closing brackets ')'. As she likes balance, she wants to turn this bracket sequence into a balanced bracket sequence.In one operation, she can reverse any substring of $$$s$$$.What's the smallest number of operations that she needs to turn $$$s$$$ into a balanced bracket sequence? It can be shown that it's always possible in at most $$$n$$$ operations.As a reminder, a sequence of brackets is called balanced if one can turn it into a valid math expression by adding characters + and 1. For example, sequences (())(), (), and (()(())) are balanced, while )(, ((), and (()))( are not.",
    "prob_desc_output_spec": "For each test case, in the first line output a single integer $$$k$$$ $$$(0 \\le k \\le n)$$$  — the smallest number of operations required. The $$$i$$$-th of the next $$$k$$$ lines should contain two integers $$$l_i, r_i$$$ ($$$1 \\le l_i \\le r_i \\le 2n$$$), indicating that in the $$$i$$$-th operation, Alina will reverse the substring $$$s_ls_{l+1} \\ldots s_{r-1}s_r$$$. Here the numeration starts from $$$1$$$. If there are multiple sequences of operations with the smallest length which transform the sequence into a balanced one, you can output any of them.",
    "prob_desc_input_spec": "The first line of the input contains a single integer $$$t$$$ ($$$1 \\le t \\le 2 \\cdot 10^4$$$)  — the number of test cases. The description of the test cases follows. The first line of each test case contains a single integer $$$n$$$ ($$$1 \\le n \\le 10^5$$$). The second line of each test case contains a string $$$s$$$ of length $$$2n$$$, consisting of $$$n$$$ opening and $$$n$$$ closing brackets. The sum of $$$n$$$ over all test cases doesn't exceed $$$2\\cdot 10^5$$$.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 2",
    "lang_cluster": "Python",
    "difficulty": 2600,
    "file_name": "train_085.jsonl",
    "code_uid": "b0105f75b16627e39cd73388a5051ae7",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"3\\n\\n2\\n\\n(())\\n\\n5\\n\\n())((()))(\\n\\n6\\n\\n())((()))(()\"]",
    "exec_outcome": "PASSED",
    "source_code": "from __future__ import division, print_function\r\n\r\nimport os,sys\r\nfrom io import BytesIO, IOBase\r\n\r\nif sys.version_info[0] < 3:\r\n    from __builtin__ import xrange as range\r\n    from future_builtins import ascii, filter, hex, map, oct, zip\r\n\r\nfrom bisect import bisect_left as lower_bound, bisect_right as upper_bound \r\ndef so():  return int(input())\r\ndef st():  return input()\r\ndef mj():  return map(int,input().strip().split(\" \"))\r\ndef msj(): return list(map(str,input().strip().split(\" \")))\r\ndef le():  return list(map(int,input().split()))\r\ndef rc():  return map(float,input().split())\r\ndef lebe():return list(map(int, input()))\r\n\r\ndef dmain():\r\n    sys.setrecursionlimit(1000000)\r\n    threading.stack_size(1024000)\r\n    thread = threading.Thread(target=main)\r\n    thread.start()\r\ndef joro(L):\r\n    return(''.join(map(str, L)))\r\ndef joron(L):\r\n    return('\\n'.join(map(str, L)))\r\n\r\ndef decimalToBinary(n): return bin(n).replace(\"0b\",\"\")\r\n\r\n\r\ndef isprime(n):\r\n    for i in range(2,int(n**0.5)+1):\r\n        if n%i==0:\r\n            return False\r\n    return True\r\ndef npr(n, r):\r\n    return factorial(n) // factorial(n - r) if n >= r else 0\r\n \r\n \r\ndef ncr(n, r):\r\n    return factorial(n) // (factorial(r) * factorial(n - r)) if n >= r else 0\r\n \r\n \r\ndef lower_bound(li, num):\r\n    answer = -1\r\n    start = 0\r\n    end = len(li) - 1\r\n \r\n    while (start <= end):\r\n        middle = (end + start) // 2\r\n        if li[middle] >= num:\r\n            answer = middle\r\n            end = middle - 1\r\n        else:\r\n            start = middle + 1\r\n    return answer  # min index where x is not less than num\r\n \r\n \r\ndef upper_bound(li, num):\r\n    answer = -1\r\n    start = 0\r\n    end = len(li) - 1\r\n \r\n    while (start <= end):\r\n        middle = (end + start) // 2\r\n \r\n        if li[middle] <= num:\r\n            answer = middle\r\n            start = middle + 1\r\n \r\n        else:\r\n            end = middle - 1\r\n    return answer  # max index where x is not greater than num\r\ndef tir(a,b,c):\r\n    if(0==c):\r\n        return 1\r\n    if(len(a)<=b):\r\n        return 0\r\n    \r\n    if(c!=-1):\r\n        return (tir(a,1+b,c+a[b]) or tir(a,b+1,c-a[b]) or tir(a,1+b,c)) \r\n        \r\n        \r\n    else:\r\n        return (tir(a,1+b,a[b]) or tir(a,b+1,-a[b]) or tir(a,1+b,-1))\r\n   \r\n \r\ndef abs(x):\r\n    return x if x >= 0 else -x\r\n \r\n \r\ndef binary_search(li, val, lb, ub):\r\n    # print(lb, ub, li)\r\n    ans = -1\r\n    while (lb <= ub):\r\n        mid = (lb + ub) // 2\r\n        # print('mid is',mid, li[mid])\r\n        if li[mid] > val:\r\n            ub = mid - 1\r\n        elif val > li[mid]:\r\n            lb = mid + 1\r\n        else:\r\n            ans = mid  # return index\r\n            break\r\n    return ans\r\n \r\n \r\ndef kadane(x):  # maximum sum contiguous subarray\r\n    sum_so_far = 0\r\n    current_sum = 0\r\n    for i in x:\r\n        current_sum += i\r\n        if current_sum < 0:\r\n            current_sum = 0\r\n        else:\r\n            sum_so_far = max(sum_so_far, current_sum)\r\n    return sum_so_far\r\n\r\n                    \r\ndef pref(li):\r\n    pref_sum = [0]\r\n    for i in li:\r\n        pref_sum.append(pref_sum[-1] + i)\r\n    return pref_sum\r\n \r\n\r\n        \r\n        \r\ndef SieveOfEratosthenes(n):\r\n    prime = [True for i in range(n + 1)]\r\n    p = 2\r\n    li = []\r\n    while (p * p <= n):\r\n        if (prime[p] == True):\r\n            for i in range(p * p, n + 1, p):\r\n                prime[i] = False\r\n        p += 1\r\n \r\n    for p in range(2, len(prime)):\r\n        if prime[p]:\r\n            li.append(p)\r\n    return li\r\n \r\n \r\ndef primefactors(n):\r\n    factors = []\r\n    while (n % 2 == 0):\r\n        factors.append(2)\r\n        n //= 2\r\n    for i in range(3, int(sqrt(n)) + 1, 2):  # only odd factors left\r\n        while n % i == 0:\r\n            factors.append(i)\r\n            n //= i\r\n    if n > 2:  # incase of prime\r\n        factors.append(n)\r\n    return factors\r\n         \r\n    \r\ndef read():\r\n    sys.stdin  = open('input.txt', 'r')  \r\n    sys.stdout = open('output.txt', 'w') \r\ndef tr(n):\r\n    return n*(n+1)//2\r\nboi=int(998244353)\r\ndoi=int(1e9+7)\r\nhoi=int(3e5+5)\r\npoi=int(111)\r\ny=\"YES\"\r\nn=\"NO\"\r\n\r\n\r\ndef expo(a,b):\r\n    \r\n    r=1\r\n    while(b>0):\r\n        if(b&1):\r\n            r=(r*a)%boi\r\n        a=(a*a)%boi\r\n        b=b>>1\r\n    return r\r\n\r\ndef bulli(x):\r\n    return bin(x).count('1')\r\n\r\n\r\n    \r\n            \r\n    \r\n\r\n\r\n\r\n\r\n    \r\n\r\n            \r\ndef iu():\r\n    import sys\r\n    import math as my\r\n    import functools\r\n    input=sys.stdin.readline\r\n    from collections import deque, defaultdict\r\n    m=so()\r\n    L=[0]*(1+2*m)\r\n    t=list(st())\r\n    x,xx,xy,y,z,yy,zz,p,q,f=0,0,2*m,0,0,1,2*m,0,0,1\r\n    for i in range(1,1+2*m):\r\n        if('('!=t[i-1]):\r\n            L[i]=L[i-1]-1\r\n        else:\r\n            L[i]=1+L[i-1]\r\n        z=min(L[i],z)\r\n        if(L[i]>y):\r\n            x=i\r\n            y=L[i]\r\n    if(0<=z):\r\n        print(0)\r\n        return\r\n    for i in range(1,1+2*m):\r\n        if(0>L[i]):\r\n            zz=i\r\n            break\r\n    for i in range(2*m,0,-1):\r\n        if(0>L[i]):\r\n            yy=i\r\n            break\r\n    for i in range(1,1+zz):\r\n        if(p<L[i]):\r\n            xx=i\r\n            p=L[i]\r\n    for i in range(1+yy,1+2*m):\r\n        if(q<L[i]):\r\n            xy=i\r\n            q=L[i]\r\n    for i in range(1+zz,1+yy):\r\n        if(L[xx]+L[xy]<L[i]):\r\n            f=0\r\n    if(f==1):\r\n        print(1)\r\n        print(1+xx,xy)\r\n        return\r\n    print(2)\r\n    print(1,x)\r\n    print(1+x,2*m)\r\n    \r\n    \r\n            \r\n    \r\n    \r\n    \r\n                \r\n                \r\n        \r\n    \r\n    \r\n    \r\n    \r\n        \r\n    \r\n    \r\n    \r\n        \r\n           \r\ndef main():\r\n    for i in range(so()):\r\n        #print(\"Case #\"+str(i+1)+\": \",end=\"\")\r\n        iu()\r\n        \r\n               \r\n    \r\n            \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n        \r\n                \r\n            \r\n        \r\n        \r\n    \r\n    \r\n            \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n        \r\n            \r\n        \r\n    \r\n    \r\n    \r\n    \r\n        \r\n            \r\n    \r\n        \r\n        \r\n        \r\n\r\n    \r\n    \r\n    \r\n    \r\n        \r\n        \r\n    \r\n        \r\n    \r\n    \r\n            \r\n    \r\n    \r\n    \r\n                \r\n            \r\n            \r\n    \r\n        \r\n\r\n                \r\n    \r\n        \r\n        \r\n\r\n            \r\n                    \r\n                \r\n                    \r\n                    \r\n                    \r\n                    \r\n                    \r\n                    \r\n        \r\n                \r\n        \r\n        \r\n       \r\n    \r\n           \r\n          \r\n          \r\n                \r\n            \r\n        \r\n                \r\n    \r\n        \r\n        \r\n        \r\n       \r\n            \r\n                \r\n        \r\n\r\n\r\n\r\n\r\n# region fastio\r\n# template taken from https://github.com/cheran-senthil/PyRival/blob/master/templates/template.py\r\n\r\nBUFSIZE = 8192\r\n\r\n\r\nclass FastIO(IOBase):\r\n    newlines = 0\r\n\r\n    def __init__(self, file):\r\n        self._fd = file.fileno()\r\n        self.buffer = BytesIO()\r\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\r\n        self.write = self.buffer.write if self.writable else None\r\n\r\n    def read(self):\r\n        while True:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            if not b:\r\n                break\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines = 0\r\n        return self.buffer.read()\r\n\r\n    def readline(self):\r\n        while self.newlines == 0:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            self.newlines = b.count(b\"\\n\") + (not b)\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines -= 1\r\n        return self.buffer.readline()\r\n\r\n    def flush(self):\r\n        if self.writable:\r\n            os.write(self._fd, self.buffer.getvalue())\r\n            self.buffer.truncate(0), self.buffer.seek(0)\r\n\r\n\r\nclass IOWrapper(IOBase):\r\n    def __init__(self, file):\r\n        self.buffer = FastIO(file)\r\n        self.flush = self.buffer.flush\r\n        self.writable = self.buffer.writable\r\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\r\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\r\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\r\n\r\n\r\ndef print(*args, **kwargs):\r\n    \"\"\"Prints the values to a stream, or to sys.stdout by default.\"\"\"\r\n    sep, file = kwargs.pop(\"sep\", \" \"), kwargs.pop(\"file\", sys.stdout)\r\n    at_start = True\r\n    for x in args:\r\n        if not at_start:\r\n            file.write(sep)\r\n        file.write(str(x))\r\n        at_start = False\r\n    file.write(kwargs.pop(\"end\", \"\\n\"))\r\n    if kwargs.pop(\"flush\", False):\r\n        file.flush()\r\n\r\n\r\nif sys.version_info[0] < 3:\r\n    sys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)\r\nelse:\r\n    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\r\n\r\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\r\n\r\n# endregion\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    #read()\r\n    main()\r\n    #dmain()\r\n\r\n# Comment Read()",
    "prob_desc_created_at": "1653500100",
    "tags": [
        "constructive algorithms",
        "greedy"
    ],
    "hidden_unit_tests": ""
}
{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"2018\", \"10^9+7\", \"100^5\", \"2*10^9\"]",
    "src_uid": "ac29eb1b65fc33bef581d8391eaf48c1",
    "prob_desc_notes": "NoteThe third sample allows the answer 10^10 also of the length $$$5$$$.",
    "prob_desc_description": "Vasya is a regular participant at programming contests and is already experienced in finding important sentences in long statements. Of course, numbers constraints are important — factorization of a number less than 1000000 is easier than of a number less than 1000000000. However, sometimes it's hard to understand the number at the first glance. Could it be shortened? For example, instead of 1000000 you could write $$$10^{6}$$$, instead of 1000000000  —$$$10^{9}$$$, instead of 1000000007 — $$$10^{9}+7$$$.Vasya decided that, to be concise, the notation should follow several rules:   the notation should only consist of numbers, operations of addition (\"+\"), multiplication (\"*\") and exponentiation (\"^\"), in particular, the use of braces is forbidden;  the use of several exponentiation operations in a row is forbidden, for example, writing \"2^3^4\" is unacceptable;  the value of the resulting expression equals to the initial number;  the notation should consist of the minimal amount of symbols. Given $$$n$$$, find the equivalent concise notation for it.",
    "prob_desc_output_spec": "Output a concise notation of the number $$$n$$$. If there are several concise notations, output any of them.",
    "prob_desc_input_spec": "The only line contains a single integer $$$n$$$ ($$$1 \\leq n \\leq 10\\,000\\,000\\,000$$$).",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "Python 3",
    "lang_cluster": "Python",
    "difficulty": 2700,
    "file_name": "train_062.jsonl",
    "code_uid": "56e862847b4bf9a6de1b75f82b3b0878",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"2018\", \"1000000007\", \"10000000000\", \"2000000000\"]",
    "exec_outcome": "PASSED",
    "source_code": "import math\nimport itertools\n\npow10 = [1]\nfor i in range(10):\n    pow10.append(pow10[-1] * 10)\n\n\ndef getlen(x):\n    \"\"\"length of the decimal representation of integer x\"\"\"\n    return int(math.log10(x)) + 1\n\n\nclass ShortestRepresentation:\n\n    def __init__(self, n):\n        self.n = n\n        self._m = {}\n        self._s = [set() for i in range(10)]\n\n        self._generate_powers()\n        self._generate_power_and_power(7)\n        self._generate_simple_and_power(7)\n\n    def _generate_powers(self):\n        \"\"\"add to the collection all expressions of the form a^b\"\"\"\n        range_x = itertools.takewhile(\n            lambda x: x**2 <= self.n,\n            itertools.count(2))\n        for x in range_x:\n            c = x**2\n            p = 2\n            while c <= self.n:\n                self.update(c, '{}^{}'.format(x, p))\n                c *= x\n                p += 1\n\n    def _generate_power_and_power(self, maxlen):\n        \"\"\"add to the collection all expressions of the form a^b*c^d\"\"\"\n        for i in range(1, maxlen + 1):\n            range_j = itertools.takewhile(\n                lambda j: i + j + 1 <= maxlen,\n                itertools.count(i))\n            for j in range_j:\n                for x, y in itertools.product(self._s[i], self._s[j]):\n                    x2 = self.get(x)\n                    y2 = self.get(y)\n                    self.update(x * y, '{}*{}'.format(x2, y2))\n\n    def _generate_simple_and_power(self, maxlen):\n        \"\"\"add to the collection all expressions of the form a^b*c\"\"\"\n        for i in range(1, maxlen - 1):\n            range_xy = itertools.product(\n                range(1, pow10[maxlen - 1 - i]),\n                self._s[i])\n            for x, y in range_xy:\n                y2 = self.get(y)\n                self.update(x * y, '{}*{}'.format(x, y2))\n\n    def update(self, x, s):\n        \"\"\"update with s x'th entry of the collection\"\"\"\n        if x > self.n:\n            return\n\n        ls = len(s)\n        if ls >= getlen(x):  # length of s should be at least shorter\n            return\n\n        if x not in self._m:\n            self._m[x] = s\n            self._s[ls].add(x)\n        else:\n            lm = len(self._m[x])\n            if ls < lm:\n                self._s[lm].remove(x)\n                self._m[x] = s\n                self._s[ls].add(x)\n\n    def get(self, x):\n        \"\"\"retrieve shortest valid representation of number x\"\"\"\n        return self._m[x] if x in self._m else str(x)\n\n\nn = int(input())\nif n < 10**10:\n    sr = ShortestRepresentation(n)\n    ans = sr.get(n)\n\n    # check a*b and a+b\n    range_i = itertools.takewhile(\n        lambda i: i * 2 + 1 < len(ans),\n        itertools.count())\n    for i in range_i:\n        range_x = itertools.chain(\n            range(1, pow10[i] + 1),\n            sr._s[i])\n        for x in range_x:\n            ans = min(\n                ans, '{}+{}'.format(sr.get(x), sr.get(n - x)), key=len)\n            if n % x > 0:\n                continue\n            ans = min(\n                ans, '{}*{}'.format(sr.get(x), sr.get(n // x)), key=len)\n\n    print(ans)\nelse:\n    print('100^5')\n",
    "prob_desc_created_at": "1529768100",
    "tags": [
        "implementation",
        "greedy",
        "math",
        "brute force"
    ],
    "hidden_unit_tests": ""
}
{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"YES\\nYES\\nYES\\nYES\\nYES\\nNO\\nYES\\nNO\"]",
    "src_uid": "b58a18119ac8375f9ad21a282292a76c",
    "prob_desc_notes": null,
    "prob_desc_description": "You are given two integers $$$a$$$ and $$$b$$$. In one turn, you can do one of the following operations:   Take an integer $$$c$$$ ($$$c &gt; 1$$$ and $$$a$$$ should be divisible by $$$c$$$) and replace $$$a$$$ with $$$\\frac{a}{c}$$$;  Take an integer $$$c$$$ ($$$c &gt; 1$$$ and $$$b$$$ should be divisible by $$$c$$$) and replace $$$b$$$ with $$$\\frac{b}{c}$$$. Your goal is to make $$$a$$$ equal to $$$b$$$ using exactly $$$k$$$ turns.For example, the numbers $$$a=36$$$ and $$$b=48$$$ can be made equal in $$$4$$$ moves:   $$$c=6$$$, divide $$$b$$$ by $$$c$$$ $$$\\Rightarrow$$$ $$$a=36$$$, $$$b=8$$$;  $$$c=2$$$, divide $$$a$$$ by $$$c$$$ $$$\\Rightarrow$$$ $$$a=18$$$, $$$b=8$$$;  $$$c=9$$$, divide $$$a$$$ by $$$c$$$ $$$\\Rightarrow$$$ $$$a=2$$$, $$$b=8$$$;  $$$c=4$$$, divide $$$b$$$ by $$$c$$$ $$$\\Rightarrow$$$ $$$a=2$$$, $$$b=2$$$. For the given numbers $$$a$$$ and $$$b$$$, determine whether it is possible to make them equal using exactly $$$k$$$ turns.",
    "prob_desc_output_spec": "For each test case output:    \"Yes\", if it is possible to make the numbers $$$a$$$ and $$$b$$$ equal in exactly $$$k$$$ turns;  \"No\" otherwise.  The strings \"Yes\" and \"No\" can be output in any case.",
    "prob_desc_input_spec": "The first line contains one integer $$$t$$$ ($$$1 \\le t \\le 10^4$$$). Then $$$t$$$ test cases follow. Each test case is contains three integers $$$a$$$, $$$b$$$ and $$$k$$$ ($$$1 \\le a, b, k \\le 10^9$$$).",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3-64",
    "lang_cluster": "Python",
    "difficulty": 1700,
    "file_name": "train_097.jsonl",
    "code_uid": "ab54ac0b1b3f8a087b68987f89855600",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"8\\n36 48 2\\n36 48 3\\n36 48 4\\n2 8 1\\n2 8 2\\n1000000000 1000000000 1000000000\\n1 2 1\\n2 2 1\"]",
    "exec_outcome": "PASSED",
    "source_code": "from __future__ import division, print_function\r\nimport os,sys\r\nfrom io import BytesIO, IOBase\r\n\r\nif sys.version_info[0] < 3:\r\n    from __builtin__ import xrange as range\r\n    from future_builtins import ascii, filter, hex, map, oct, zip\r\n\r\n\r\n\r\n\r\nfrom math import ceil, floor, factorial, sqrt\r\n# from math import log,sqrt,cos,tan,sin,radians\r\nfrom bisect import bisect_left, bisect_right\r\nfrom collections import defaultdict\r\nfrom collections import deque, Counter, OrderedDict\r\n# from heapq import nsmallest, nlargest, heapify, heappop, heappush, heapreplace\r\n# from bisect import bisect,bisect_left,bisect_right,insort,insort_left,insort_right\r\n# from decimal import *\r\n\r\n# from itertools import permutations\r\n\r\n# ======================== Functions declaration Starts ========================\r\n\r\n\r\nabc='abcdefghijklmnopqrstuvwxyz'\r\nabd={'a':0,'b':1,'c':2,'d':3,'e':4,'f':5,'g':6,'h':7,'i':8,'j':9,'k':10,'l':11,'m':12,'n':13,'o':14,'p':15,'q':16,'r':17,'s':18,'t':19,'u':20,'v':21,'w':22,'x':23,'y':24,'z':25}\r\n\r\n\r\nM=1000000007\r\n# M=998244353\r\nINF = float(\"inf\")\r\nPI = 3.141592653589793\r\n\r\ndef copy2d(lst): return [x[:] for x in lst]   #Copy 2D list... Avoid Using Deepcopy\r\ndef isPowerOfTwo(x): return (x and (not(x & (x - 1))) )\r\n\r\nLB = bisect_left   # Lower bound\r\nUB = bisect_right  # Upper bound\r\n \r\ndef BS(a, x):      # Binary Search\r\n    i = bisect_left(a, x)\r\n    if i != len(a) and a[i] == x:\r\n        return i\r\n    else:\r\n        return -1\r\n\r\ndef gcd(x, y):\r\n    while y:\r\n        x, y = y, x % y\r\n    return x\r\n\r\ndef lcm(x, y):\r\n    return (x*y)//gcd(x,y)\r\n\r\n# import threading\r\n# def dmain():\r\n#     sys.setrecursionlimit(1000000)\r\n#     threading.stack_size(1024000)\r\n#     thread = threading.Thread(target=main)\r\n#     thread.start()\r\n    \r\n# ========================= Functions declaration Ends =========================\r\n\r\ndef isPrime(n):\r\n    if n <= 3: return n > 1\r\n    if n & 1 == 0 or n % 3 == 0: return False\r\n    for i in range(5, int(n**0.5)+2, 6):\r\n        if n % i == 0 or n % (i + 2) == 0:\r\n            return False\r\n    return True\r\n\r\ndef primesbelow(N=1000000):    # Faster version of Sieve of Erathostenes\r\n    \"\"\"\r\n    Input N>=3; Returns a list or set of all primes 2 <= p <= N \r\n    Use this to iterate over prime numbers.\r\n    Don't use this as a substitute for sieve() because\r\n    multiple lookups will be slower than sieve() as one lookup takes logN time.\r\n    \"\"\"\r\n    N += 1   # To make inclusive of N\r\n    correction = N % 6 > 1\r\n    N = {0:N, 1:N-1, 2:N+4, 3:N+3, 4:N+2, 5:N+1}[N%6]\r\n    sieve_bool = [True] * (N // 3)\r\n    sieve_bool[0] = False\r\n    for i in range(int(N ** .5) // 3 + 1):\r\n        if sieve_bool[i]:\r\n            k = (3 * i + 1) | 1\r\n            sieve_bool[k*k // 3::2*k] = [False] * ((N//6 - (k*k)//6 - 1)//k + 1)\r\n            sieve_bool[(k*k + 4*k - 2*k*(i%2)) // 3::2*k] = [False] * ((N // 6 - (k*k + 4*k - 2*k*(i%2))//6 - 1) // k + 1)\r\n    \r\n    # To return set\r\n    # return {(3 * i + 1) | 1 for i in range(1, N//3 - correction) if sieve_bool[i]}.union({2,3})\r\n    \r\n    # To return list\r\n    return [2, 3] + [(3 * i + 1) | 1 for i in range(1, N//3 - correction) if sieve_bool[i]]\r\n\r\nis_prime = []\r\ndef sieve(n=1000000):\r\n    global is_prime\r\n    is_prime = [True] * (n + 1)\r\n    is_prime[0] = is_prime[1] = False\r\n    for i in range(2, int(n ** 0.5) + 1):\r\n        if is_prime[i]:\r\n            for j in range(i * i, n + 1, i):\r\n                is_prime[j] = False\r\n\r\ndef primeFactors(n):\r\n    # cnt = defaultdict(int)\r\n    sm = 0\r\n    if n==1:\r\n        return sm\r\n    while not n%2:\r\n        # cnt[2]+=1\r\n        sm += 1\r\n        n = n // 2\r\n    for i in range(3,int(sqrt(n))+1,2):\r\n        while n % i== 0:\r\n            # cnt[i] += 1\r\n            sm += 1\r\n            n = n // i\r\n    if n > 2:\r\n        # cnt[n] += 1\r\n        sm += 1\r\n    return sm\r\n\r\n# def find_prime_factors(n):\r\n#     \"\"\"\r\n#     Returns a dictionary with all prime factors of n.\r\n#     \"\"\"\r\n#     return d\r\nfrom collections import Counter\r\n\r\n\r\ndef gcd(x, y):\r\n    \"\"\"greatest common divisor of x and y\"\"\"\r\n    while y:\r\n        x, y = y, x % y\r\n    return x\r\n\r\n\r\ndef memodict(f):\r\n    \"\"\"memoization decorator for a function taking a single argument\"\"\"\r\n    class memodict(dict):\r\n        def __missing__(self, key):\r\n            ret = self[key] = f(key)\r\n            return ret\r\n\r\n    return memodict().__getitem__\r\n\r\n\r\ndef pollard_rho(n):\r\n    \"\"\"returns a random factor of n\"\"\"\r\n    if n & 1 == 0:\r\n        return 2\r\n    if n % 3 == 0:\r\n        return 3\r\n\r\n    s = ((n - 1) & (1 - n)).bit_length() - 1\r\n    d = n >> s\r\n    for a in [2, 325, 9375, 28178, 450775, 9780504, 1795265022]:\r\n        p = pow(a, d, n)\r\n        if p == 1 or p == n - 1 or a % n == 0:\r\n            continue\r\n        for _ in range(s):\r\n            prev = p\r\n            p = (p * p) % n\r\n            if p == 1:\r\n                return gcd(prev - 1, n)\r\n            if p == n - 1:\r\n                break\r\n        else:\r\n            for i in range(2, n):\r\n                x, y = i, (i * i + 1) % n\r\n                f = gcd(abs(x - y), n)\r\n                while f == 1:\r\n                    x, y = (x * x + 1) % n, (y * y + 1) % n\r\n                    y = (y * y + 1) % n\r\n                    f = gcd(abs(x - y), n)\r\n                if f != n:\r\n                    return f\r\n    return n\r\n\r\n\r\n@memodict\r\ndef prime_factors(n):\r\n    \"\"\"returns a Counter of the prime factorization of n\"\"\"\r\n    if n <= 1:\r\n        return Counter()\r\n    f = pollard_rho(n)\r\n    return Counter([n]) if f == n else prime_factors(f) + prime_factors(n // f)\r\n\r\n\r\ndef distinct_factors(n):\r\n    \"\"\"returns a list of all distinct factors of n\"\"\"\r\n    factors = [1]\r\n    for p, exp in prime_factors(n).items():\r\n        factors += [p**i * factor for factor in factors for i in range(1, exp + 1)]\r\n    return factors\r\n\r\n\r\ndef all_factors(n):\r\n    \"\"\"returns a sorted list of all distinct factors of n\"\"\"\r\n    small, large = [], []\r\n    for i in range(1, int(n**0.5) + 1, 2 if n & 1 else 1):\r\n        if not n % i:\r\n            small.append(i)\r\n            large.append(n // i)\r\n    if small[-1] == large[-1]:\r\n        large.pop()\r\n    large.reverse()\r\n    small.extend(large)\r\n    return small\r\n\r\ndef main():\r\n    TestCases = 1\r\n    TestCases = int(input())\r\n    # primes = primesbelow(int(10**(4.5)))\r\n\r\n    # print(Counter(find_primes_factors(24)))\r\n    for _ in range(TestCases):\r\n        a,b,k = [int(i) for i in input().split()]\r\n        \r\n        if k==1:\r\n            if a==b==1:\r\n                print(\"NO\")\r\n                continue\r\n\r\n            if (a%b==0 or b%a==0) and a!=b:\r\n                print(\"YES\")\r\n                continue\r\n\r\n            print(\"NO\")\r\n            continue\r\n\r\n\r\n        \r\n        fac1 = prime_factors(a)\r\n        fac2 = prime_factors(b)\r\n\r\n        nof1 = 0\r\n        for f, pow in fac1.items():\r\n            nof1 += pow\r\n        \r\n        nof2 = 0\r\n        for f, pow in fac2.items():\r\n            nof2 += pow\r\n        \r\n        kmax = nof1 + nof2\r\n\r\n        print(\"YES\" if k <= kmax else \"NO\") \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n        # # A = defaultdict(int)\r\n        # # B = defaultdict(int)\r\n        # # sm = 0\r\n        # # a11,b11 = a, b\r\n        # # for i in primes:\r\n        # #     while a11 % i == 0 and sm<k and a11>1:\r\n        # #         # A[i] += 1\r\n        # #         sm += 1\r\n        # #         a11 //= i\r\n        # #     while b11 % i == 0 and sm<k and b11>1:\r\n        # #         # B[i] += 1\r\n        # #         sm += 1\r\n        # #         b11 //= i\r\n            \r\n        # #     if sm >= k or (a11==b11==1) or (i>a11 and i>b11):\r\n        # #         break\r\n\r\n        # sm = primeFactors(a) + primeFactors(b)\r\n\r\n        # # if a11>1:\r\n        # #     if isPrime(a11):\r\n        # #         sm += 1\r\n        # # if b11>1:\r\n        # #     if isPrime(b11):\r\n        # #         sm += 1\r\n\r\n        # kmax = sm\r\n        # print(\"YES\" if k<=kmax else \"NO\")\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n        # a1 = A-B\r\n        # b1 = B-A\r\n        # print(a1)\r\n        # print(b1)\r\n\r\n        # cnt = 0 \r\n        # for num,pow in a1.items():\r\n        #     cnt += pow\r\n        \r\n        # for num,pow in b1.items():\r\n        #     cnt += pow\r\n        \r\n        # if k < cnt:\r\n        #     print(\"NO\")\r\n        #     continue\r\n\r\n        # k -= cnt\r\n        # if k&1:\r\n        #     print(\"NO\")\r\n        #     continue\r\n\r\n        # intersection = A - a1\r\n        # for num, pow in intersection.items():\r\n        #     k -= pow*2\r\n        \r\n        # if k <= 0:\r\n        #     print(\"YES\")\r\n        # else:\r\n        #     print(\"NO\")\r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n# =============================== Region Fastio ===============================\r\nif not os.path.isdir('C:/users/acer'):\r\n    BUFSIZE = 8192\r\n    \r\n    \r\n    class FastIO(IOBase):\r\n        newlines = 0\r\n    \r\n        def __init__(self, file):\r\n            self._fd = file.fileno()\r\n            self.buffer = BytesIO()\r\n            self.writable = \"x\" in file.mode or \"r\" not in file.mode\r\n            self.write = self.buffer.write if self.writable else None\r\n    \r\n        def read(self):\r\n            while True:\r\n                b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n                if not b:\r\n                    break\r\n                ptr = self.buffer.tell()\r\n                self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n            self.newlines = 0\r\n            return self.buffer.read()\r\n    \r\n        def readline(self):\r\n            while self.newlines == 0:\r\n                b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n                self.newlines = b.count(b\"\\n\") + (not b)\r\n                ptr = self.buffer.tell()\r\n                self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n            self.newlines -= 1\r\n            return self.buffer.readline()\r\n    \r\n        def flush(self):\r\n            if self.writable:\r\n                os.write(self._fd, self.buffer.getvalue())\r\n                self.buffer.truncate(0), self.buffer.seek(0)\r\n    \r\n    \r\n    class IOWrapper(IOBase):\r\n        def __init__(self, file):\r\n            self.buffer = FastIO(file)\r\n            self.flush = self.buffer.flush\r\n            self.writable = self.buffer.writable\r\n            self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\r\n            self.read = lambda: self.buffer.read().decode(\"ascii\")\r\n            self.readline = lambda: self.buffer.readline().decode(\"ascii\")\r\n    \r\n    \r\n    def print(*args, **kwargs):\r\n        \"\"\"Prints the values to a stream, or to sys.stdout by default.\"\"\"\r\n        sep, file = kwargs.pop(\"sep\", \" \"), kwargs.pop(\"file\", sys.stdout)\r\n        at_start = True\r\n        for x in args:\r\n            if not at_start:\r\n                file.write(sep)\r\n            file.write(str(x))\r\n            at_start = False\r\n        file.write(kwargs.pop(\"end\", \"\\n\"))\r\n        if kwargs.pop(\"flush\", False):\r\n            file.flush()\r\n    \r\n    \r\n    if sys.version_info[0] < 3:\r\n        sys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)\r\n    else:\r\n        sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\r\n    \r\n    input = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\r\n\r\n# =============================== Endregion ===============================\r\n\r\nif __name__ == \"__main__\":\r\n    #read()\r\n    main()\r\n    #dmain()",
    "prob_desc_created_at": "1623335700",
    "tags": [
        "constructive algorithms",
        "math",
        "number theory"
    ],
    "hidden_unit_tests": ""
}
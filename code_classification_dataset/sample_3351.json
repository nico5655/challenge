{
    "prob_desc_time_limit": "3 seconds",
    "prob_desc_sample_outputs": "[\"1467417540\\n1467417541\\n1467417542\\n1467417599\\n1467503940\\n1467503940\", \"1467460800\\n1467547200\\n1468065600\"]",
    "src_uid": "f6cee8282e7a8543a043b0a5203e1474",
    "prob_desc_notes": "NoteThe moment of time 1467372658 after the midnight of January 1st, 1970 is 11:30:58 July 1st, 2016.",
    "prob_desc_description": "Sometime the classic solution are not powerful enough and we have to design our own. For the purpose of this problem you have to implement the part of the system of task scheduling.Each task should be executed at some particular moments of time. In our system you may set the exact value for the second, minute, hour, day of the week, day and month, when the task should be executed. Moreover, one can set a special value -1 that means any value of this parameter is valid.For example, if the parameter string is -1 59 23 -1 -1 -1, the problem will be executed every day at 23:59:00, 23:59:01, 23:59:02, ..., 23:59:59 (60 times in total).Seconds, minutes and hours are numbered starting from zero, while day, months and days of the week are numbered starting from one. The first day of the week is Monday.There is one special case that is treated separately. If both day of the week and day are given (i.e. differ from -1) to execute the task only one of these two (at least one, if both match this is fine too) parameters should match the current time (of course, all other parameters should match too). For example, the string of parameters 0 0 12 6 3 7 means that the task will be executed both on Saturday, July 2nd, 2016 and on Sunday, July 3rd, 2016 at noon.One should not forget about the existence of the leap years. The year is leap if it's number is divisible by 400, or is not divisible by 100, but is divisible by 4. Each leap year has 366 days instead of usual 365, by extending February to 29 days rather than the common 28.The current time is represented as the number of seconds passed after 00:00:00 January 1st, 1970 (Thursday).You are given the string of six parameters, describing the moments of time the task should be executed. You are also given a number of moments of time. For each of them you have to find the first moment of time strictly greater than the current when the task will be executed.",
    "prob_desc_output_spec": "Print n lines, the i-th of them should contain the first moment of time strictly greater than ti, when the task should be executed.",
    "prob_desc_input_spec": "The first line of the input contains six integers s, m, h, day, date and month (0 ≤ s, m ≤ 59, 0 ≤ h ≤ 23, 1 ≤ day ≤ 7, 1 ≤ date ≤ 31, 1 ≤ month ≤ 12). Each of the number can also be equal to  - 1. It's guaranteed, that there are infinitely many moments of time when this task should be executed. Next line contains the only integer n (1 ≤ n ≤ 1000) — the number of moments of time you have to solve the problem for. Each of the next n lines contains a single integer ti (0 ≤ ti ≤ 1012).",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "Python 2",
    "lang_cluster": "Python",
    "difficulty": 2800,
    "file_name": "train_054.jsonl",
    "code_uid": "229655083be726559786c109ac650bdb",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"-1 59 23 -1 -1 -1\\n6\\n1467372658\\n1467417540\\n1467417541\\n1467417598\\n1467417599\\n1467417600\", \"0 0 12 6 3 7\\n3\\n1467372658\\n1467460810\\n1467547200\"]",
    "exec_outcome": "PASSED",
    "source_code": "import datetime as dt \nimport calendar\n\nsecond,minute,hour,day,date,month = map(int,raw_input().split())\n\nn = int(raw_input())\nepoch = dt.datetime(year=1970, month=1, day=1)\n\nsafe = epoch.replace(year=2370)\nfourh = safe - epoch    \nfourh = fourh.days*60*60*24 + fourh.seconds\n\nfor x in xrange(n):\n    tm = int(raw_input())\n\n    ntm = tm % fourh\n    safe = tm - ntm\n\n    t = epoch + dt.timedelta(seconds=ntm)\n    t += dt.timedelta(seconds=1)\n\n    while True:\n        #print t\n        \n        while month != -1 and t.month != month:\n            try:\n                t = t.replace(month=t.month+1, day=1, hour=0,minute=0,second=0) \n            except:\n                t = t.replace(year=t.year+1, month=1,day=1, hour=0,minute=0,second=0)\n\n        ok = True\n        strict = not (day != -1 and date != -1)\n        if strict:\n            cond = (day != -1 and t.weekday()+1 != day) or (date != -1 and t.day != date)\n        else:\n            cond = (day != -1 and t.weekday()+1 != day) and (date != -1 and t.day != date)\n\n        while cond:\n            try:\n                t = t.replace(day=t.day+1, hour=0,minute=0,second=0) \n            except:\n                ok = False\n                break\n\n            if strict:\n                cond = (day != -1 and t.weekday()+1 != day) or (date != -1 and t.day != date)\n            else:\n                cond = (day != -1 and t.weekday()+1 != day) and (date != -1 and t.day != date)\n\n        if not ok:\n            try:\n                t = t.replace(month=t.month+1, day=1, hour=0,minute=0,second=0) \n            except:\n                t = t.replace(year=t.year+1, month=1,day=1, hour=0,minute=0,second=0)\n            continue\n\n        while (hour != -1 and hour != t.hour):\n            try:\n                t = t.replace(hour=t.hour+1,minute=0,second=0) \n            except:\n                ok = False\n                break\n\n        if not ok:\n            t = t.replace(hour=0,minute=0,second=0)\n            t += dt.timedelta(days=1)\n            continue\n\n        while (minute != -1 and minute != t.minute):\n            try:\n                t = t.replace(minute=t.minute+1,second=0) \n            except:\n                ok = False\n                break\n\n        if not ok:\n            t = t.replace(minute=0,second=0)\n            t += dt.timedelta(seconds=60*60)\n            continue\n\n        while (second != -1 and second != t.second):\n            try:\n                t = t.replace(second=t.second+1) \n            except:\n                ok = False\n                break\n\n        if not ok:\n            t = t.replace(second=0)\n            t += dt.timedelta(seconds=60)\n            continue\n\n        delt = (t-epoch)\n        #print t\n        print safe + delt.days*60*60*24 + delt.seconds\n        break",
    "prob_desc_created_at": "1468933500",
    "tags": [],
    "hidden_unit_tests": ""
}
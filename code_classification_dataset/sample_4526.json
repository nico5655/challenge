{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"YES\\n1 2 0\\n1 3 1\\n2 4 7\\n3 6 0\\n2 5 0\\nYES\\n1 2 1\\n1 3 0\\n1 4 1\\n4 5 1\\nNO\\nNO\"]",
    "src_uid": "884e547e8ccb05e618ec80904b2ea107",
    "prob_desc_notes": "NoteThe first test case is the image in the statement.One possible answer is assigning the value of the edge $$$(1, 2)$$$ to $$$5$$$, and the value of the edge $$$(2, 5)$$$ to $$$3$$$. This is correct because:   The first elf goes from node $$$2$$$ to node $$$3$$$. This elf's favorite number is $$$4$$$, so he remembers the value $$$1$$$ (as $$$4$$$ has an odd number of $$$1$$$ bits in its binary representation).  The second elf goes from node $$$2$$$ to node $$$5$$$. This elf's favorite number is $$$3$$$, so he remembers the value $$$0$$$ (as $$$3$$$ has an even number of $$$1$$$ bits in its binary representation).  The third elf goes from node $$$5$$$ to node $$$6$$$. This elf's favorite number is $$$7$$$, so he remembers the value $$$1$$$ (as $$$7$$$ has an odd number of $$$1$$$ bits in its binary representation).  The fourth elf goes from node $$$6$$$ to node $$$1$$$. This elf's favorite number is $$$1$$$, so he remembers the value $$$1$$$ (as $$$1$$$ has an odd number of $$$1$$$ bits in its binary representation).  The fifth elf goes from node $$$4$$$ to node $$$5$$$. This elf's favorite number is $$$4$$$, so he remembers the number $$$1$$$ (as $$$4$$$ has an odd number of $$$1$$$ bits in its binary representation). Note that there are other possible answers.",
    "prob_desc_description": "'Twas the night before Christmas, and Santa's frantically setting up his new Christmas tree! There are $$$n$$$ nodes in the tree, connected by $$$n-1$$$ edges. On each edge of the tree, there's a set of Christmas lights, which can be represented by an integer in binary representation.  He has $$$m$$$ elves come over and admire his tree. Each elf is assigned two nodes, $$$a$$$ and $$$b$$$, and that elf looks at all lights on the simple path between the two nodes. After this, the elf's favorite number becomes the bitwise XOR of the values of the lights on the edges in that path.However, the North Pole has been recovering from a nasty bout of flu. Because of this, Santa forgot some of the configurations of lights he had put on the tree, and he has already left the North Pole! Fortunately, the elves came to the rescue, and each one told Santa what pair of nodes he was assigned $$$(a_i, b_i)$$$, as well as the parity of the number of set bits in his favorite number. In other words, he remembers whether the number of $$$1$$$'s when his favorite number is written in binary is odd or even.Help Santa determine if it's possible that the memories are consistent, and if it is, remember what his tree looked like, and maybe you'll go down in history!",
    "prob_desc_output_spec": "For each test case, first print either YES or NO (in any case), whether there's a tree consistent with Santa's memory or not.  If the answer is YES, print $$$n-1$$$ lines each containing three integers: $$$x$$$, $$$y$$$, and $$$v$$$ ($$$1 \\le x, y \\le n$$$; $$$0 \\le v &lt; 2^{30}$$$) — the edge and the integer on that edge. The set of edges must be the same as in the input, and if the value of some edge was specified earlier, it can not change. You can print the edges in any order. If there are multiple answers, print any.",
    "prob_desc_input_spec": "The first line contains one integer $$$t$$$ ($$$1 \\leq t \\leq 2 \\cdot 10^4$$$) — the number of test cases. Then $$$t$$$ cases follow. The first line of each test case contains two integers, $$$n$$$ and $$$m$$$ ($$$2 \\leq n \\leq 2 \\cdot 10^5$$$; $$$1 \\leq m \\leq 2 \\cdot 10^5$$$) — the size of tree and the number of elves respectively. The next $$$n-1$$$ lines of each test case each contains three integers, $$$x$$$, $$$y$$$, and $$$v$$$ ($$$1 \\leq x, y \\leq n$$$; $$$-1 \\leq v &lt; 2^{30}$$$) — meaning that there's an edge between nodes $$$x$$$ and $$$y$$$. If    $$$v = -1$$$: Santa doesn't remember what the set of lights were on for this edge.  $$$v \\geq 0$$$: The set of lights on the edge is $$$v$$$.  The next $$$m$$$ lines of each test case each contains three integers, $$$a$$$, $$$b$$$, and $$$p$$$ ($$$1 \\leq a, b \\leq n$$$; $$$a \\neq b$$$; $$$0 \\leq p \\leq 1$$$) — the nodes that the elf was assigned to, and the parity of the number of set bits in the elf's favorite number. It is guaranteed that the sum of all $$$n$$$ and the sum of all $$$m$$$ don't exceed $$$2 \\cdot 10^5$$$ each. It is guaranteed that the given edges form a tree.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3",
    "lang_cluster": "Python",
    "difficulty": 2200,
    "file_name": "train_100.jsonl",
    "code_uid": "47043625e837648a6cba1669566b4359",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"4\\n6 5\\n1 2 -1\\n1 3 1\\n4 2 7\\n6 3 0\\n2 5 -1\\n2 3 1\\n2 5 0\\n5 6 1\\n6 1 1\\n4 5 1\\n5 3\\n1 2 -1\\n1 3 -1\\n1 4 1\\n4 5 -1\\n2 4 0\\n3 4 1\\n2 3 1\\n3 3\\n1 2 -1\\n1 3 -1\\n1 2 0\\n1 3 1\\n2 3 0\\n2 1\\n1 2 1\\n1 2 0\"]",
    "exec_outcome": "PASSED",
    "source_code": "from sys import stdin, stdout\r\nfrom collections import deque\r\n\r\ndef parity(n):\r\n    parity = 0\r\n    while n:\r\n        parity = 1-parity\r\n        n = n & (n-1)\r\n    return parity\r\n\r\nt = int(stdin.readline())\r\n\r\nfor _ in range(t):\r\n    n, m = [int(x) for x in stdin.readline().split()]\r\n    edges = []\r\n    fake_edges = {i: [] for i in range(n)}\r\n    possible = True\r\n\r\n    for bar in range(n-1):\r\n        x, y, v = [int(z) for z in stdin.readline().split()]\r\n        x -= 1\r\n        y -= 1\r\n        edges.append((x,y,v))\r\n        if v >= 0:\r\n            p = parity(v)\r\n            fake_edges[x].append((y,p))\r\n            fake_edges[y].append((x,p))\r\n\r\n    for bar in range(m):\r\n        x, y, v = [int(z) for z in stdin.readline().split()]\r\n        x -= 1\r\n        y -= 1\r\n        fake_edges[x].append((y,v))\r\n        fake_edges[y].append((x,v))\r\n\r\n    r_values = [-1]*n\r\n    touched = [False]*n\r\n\r\n    for i in range(n):\r\n        if not possible:\r\n            break\r\n        if not touched[i]:\r\n            queue = deque()\r\n            queue.append(i)\r\n            r_values[i] = 0\r\n            touched[i] = True\r\n\r\n            while len(queue) > 0:\r\n                if not possible:\r\n                    break\r\n                v = queue.popleft()\r\n                for w,p in fake_edges[v]:\r\n                    if r_values[w] == -1:\r\n                        r_values[w] = r_values[v] ^ p\r\n                        touched[w] = True\r\n                        queue.append(w)\r\n                    else:\r\n                        if r_values[w] != r_values[v] ^ p:\r\n                            possible = False\r\n                            break\r\n\r\n    if possible:\r\n        stdout.write('YES\\n')\r\n        for v, w, new_temp in edges:\r\n            if new_temp == -1:\r\n                new_temp = r_values[v] ^ r_values[w]\r\n            stdout.write('{} {} {}\\n'.format(v+1,w+1,new_temp))\r\n\r\n    else:\r\n        stdout.write('NO\\n')\r\n",
    "prob_desc_created_at": "1640356500",
    "tags": [
        "bitmasks",
        "dfs and similar",
        "dsu",
        "graphs",
        "trees"
    ],
    "hidden_unit_tests": ""
}
{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"1 1 0 1 \\n0 1 1 0 0 0 1 \\n0 0 0 \\n0 0 0 1 \\n1 0 1\"]",
    "src_uid": "9dc1bee4e53ced89d827826f2d83dabf",
    "prob_desc_notes": "NoteHere's the explanation for the first test case. Given that $$$A=[1,1,0,1]$$$, we can construct each $$$B_i$$$:   $$$B_1=[\\color{blue}{1},1,0,1]$$$;  $$$B_2=[\\color{blue}{1},\\color{blue}{1},0,1]$$$;  $$$B_3=[\\color{blue}{0},\\color{blue}{1},\\color{blue}{1},1]$$$;  $$$B_4=[\\color{blue}{0},\\color{blue}{1},\\color{blue}{1},\\color{blue}{1}]$$$  And then, we can sum up each column above to get $$$C=[1+1+0+0,1+1+1+1,0+0+1+1,1+1+1+1]=[2,4,2,4]$$$.",
    "prob_desc_description": "Suppose you had an array $$$A$$$ of $$$n$$$ elements, each of which is $$$0$$$ or $$$1$$$.Let us define a function $$$f(k,A)$$$ which returns another array $$$B$$$, the result of sorting the first $$$k$$$ elements of $$$A$$$ in non-decreasing order. For example, $$$f(4,[0,1,1,0,0,1,0]) = [0,0,1,1,0,1,0]$$$. Note that the first $$$4$$$ elements were sorted.Now consider the arrays $$$B_1, B_2,\\ldots, B_n$$$ generated by $$$f(1,A), f(2,A),\\ldots,f(n,A)$$$. Let $$$C$$$ be the array obtained by taking the element-wise sum of $$$B_1, B_2,\\ldots, B_n$$$.For example, let $$$A=[0,1,0,1]$$$. Then we have $$$B_1=[0,1,0,1]$$$, $$$B_2=[0,1,0,1]$$$, $$$B_3=[0,0,1,1]$$$, $$$B_4=[0,0,1,1]$$$. Then $$$C=B_1+B_2+B_3+B_4=[0,1,0,1]+[0,1,0,1]+[0,0,1,1]+[0,0,1,1]=[0,2,2,4]$$$.You are given $$$C$$$. Determine a binary array $$$A$$$ that would give $$$C$$$ when processed as above. It is guaranteed that an array $$$A$$$ exists for given $$$C$$$ in the input. ",
    "prob_desc_output_spec": "For each test case, output a single line containing $$$n$$$ integers $$$a_1, a_2, \\ldots, a_n$$$ ($$$a_i$$$ is $$$0$$$ or $$$1$$$). If there are multiple answers, you may output any of them.",
    "prob_desc_input_spec": "The first line contains a single integer $$$t$$$ ($$$1 \\leq t \\leq 1000$$$)  — the number of test cases. Each test case has two lines. The first line contains a single integer $$$n$$$ ($$$1 \\leq n \\leq 2 \\cdot 10^5$$$). The second line contains $$$n$$$ integers $$$c_1, c_2, \\ldots, c_n$$$ ($$$0 \\leq c_i \\leq n$$$). It is guaranteed that a valid array $$$A$$$ exists for the given $$$C$$$. The sum of $$$n$$$ over all test cases does not exceed $$$2 \\cdot 10^5$$$.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3-64",
    "lang_cluster": "Python",
    "difficulty": 1900,
    "file_name": "train_110.jsonl",
    "code_uid": "f3d4714fc7e831eadbe1b17d4a2e5d34",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"5\\n4\\n2 4 2 4\\n7\\n0 3 4 2 3 2 7\\n3\\n0 0 0\\n4\\n0 0 0 4\\n3\\n1 2 3\"]",
    "exec_outcome": "PASSED",
    "source_code": "import sys\r\n\r\ninput = lambda: sys.stdin.buffer.readline().decode().strip()\r\nfor _ in range(int(input())):\r\n    n, a = int(input()), [int(x) for x in input().split()]\r\n    ans, ones = [], sum(a) // n\r\n    mem = [0] * (n + 1)\r\n\r\n    for i in reversed(range(n)):\r\n        mem[i] += mem[i + 1]\r\n        a[i] -= mem[i]\r\n\r\n        if a[i] == i + 1:\r\n            mem[i] += 1\r\n            mem[i - ones] -= 1\r\n            ones -= 1\r\n            ans.append(1)\r\n        elif a[i] == 1:\r\n            mem[i] += 1\r\n            mem[i - ones] -= 1\r\n            ans.append(0)\r\n        else:\r\n            ans.extend([0] * (i + 1))\r\n            break\r\n    print(*ans[::-1])\r\n",
    "prob_desc_created_at": "1650206100",
    "tags": [
        "constructive algorithms",
        "data structures",
        "greedy",
        "implementation",
        "math",
        "two pointers"
    ],
    "hidden_unit_tests": ""
}
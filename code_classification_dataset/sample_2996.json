{
    "prob_desc_time_limit": "1 second",
    "prob_desc_sample_outputs": "[\"3\", \"0\\n2\"]",
    "src_uid": "d7ffedb180378b3ab70e5f05c79545f5",
    "prob_desc_notes": "NoteIn the first example, child 1 is waiting for toy 2, which child 2 has, while child 2 is waiting for top 3, which child 3 has. When child 3 makes his last request, the toy he requests is held by child 1. Each of the three children is waiting for a toy held by another child and no one is playing, so all the three will start crying.In the second example, at the beginning, child i is holding toy i for 1 ≤ i ≤ 4. Children 1 and 3 have completed their lovely sets. After they finish playing, toy 3 will be free while toy 1 will be taken by child 2 who has just completed his lovely set. After he finishes, toys 1 and 2 will be free and child 5 will take toy 1. Now:  In the first query, child 5 will take toy 3 and after he finishes playing, child 4 can play. In the second query, child 5 will request toy 4 which is held by child 4. At the same time, child 4 is waiting for toy 1 which is now held by child 5. None of them can play and they will start crying. ",
    "prob_desc_description": "Sagheer is working at a kindergarten. There are n children and m different toys. These children use well-defined protocols for playing with the toys:  Each child has a lovely set of toys that he loves to play with. He requests the toys one after another at distinct moments of time. A child starts playing if and only if he is granted all the toys in his lovely set. If a child starts playing, then sooner or later he gives the toys back. No child keeps the toys forever. Children request toys at distinct moments of time. No two children request a toy at the same time. If a child is granted a toy, he never gives it back until he finishes playing with his lovely set. If a child is not granted a toy, he waits until he is granted this toy. He can't request another toy while waiting. If two children are waiting for the same toy, then the child who requested it first will take the toy first.Children don't like to play with each other. That's why they never share toys. When a child requests a toy, then granting the toy to this child depends on whether the toy is free or not. If the toy is free, Sagheer will give it to the child. Otherwise, the child has to wait for it and can't request another toy.Children are smart and can detect if they have to wait forever before they get the toys they want. In such case they start crying. In other words, a crying set is a set of children in which each child is waiting for a toy that is kept by another child in the set.Now, we have reached a scenario where all the children made all the requests for their lovely sets, except for one child x that still has one last request for his lovely set. Some children are playing while others are waiting for a toy, but no child is crying, and no one has yet finished playing. If the child x is currently waiting for some toy, he makes his last request just after getting that toy. Otherwise, he makes the request right away. When child x will make his last request, how many children will start crying?You will be given the scenario and q independent queries. Each query will be of the form x y meaning that the last request of the child x is for the toy y. Your task is to help Sagheer find the size of the maximal crying set when child x makes his last request.",
    "prob_desc_output_spec": "For each query, print on a single line the number of children who will start crying when child x makes his last request for toy y. Please answer all queries independent of each other.",
    "prob_desc_input_spec": "The first line contains four integers n, m, k, q (1 ≤ n, m, k, q ≤ 105) — the number of children, toys, scenario requests and queries. Each of the next k lines contains two integers a, b (1 ≤ a ≤ n and 1 ≤ b ≤ m) — a scenario request meaning child a requests toy b. The requests are given in the order they are made by children. Each of the next q lines contains two integers x, y (1 ≤ x ≤ n and 1 ≤ y ≤ m) — the request to be added to the scenario meaning child x will request toy y just after getting the toy he is waiting for (if any). It is guaranteed that the scenario requests are consistent and no child is initially crying. All the scenario requests are distinct and no query coincides with a scenario request.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3",
    "lang_cluster": "Python",
    "difficulty": 2700,
    "file_name": "train_037.jsonl",
    "code_uid": "e3d87d652482d805ba50dd86ac041a93",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"3 3 5 1\\n1 1\\n2 2\\n3 3\\n1 2\\n2 3\\n3 1\", \"5 4 7 2\\n1 1\\n2 2\\n2 1\\n5 1\\n3 3\\n4 4\\n4 1\\n5 3\\n5 4\"]",
    "exec_outcome": "PASSED",
    "source_code": "from sys import stdin\nfrom sys import stdout\n\nn, m, k, q = map(int, stdin.readline().split())\nd = [None for i in range(m)]\nroots = set(range(n))\nmatrix = [[] for i in range(n)]\nfor i in range(k):\n    x, y = map(int, stdin.readline().split())\n    if d[y - 1] is None:\n        d[y - 1] = x - 1\n    else:\n        matrix[d[y - 1]].append(x - 1)\n        roots.discard(x - 1)\n        d[y - 1] = x - 1\nlocation = [None for i in range(n)]\ncomp_of_conn = []\ngraph = [matrix[i][:] for i in range(n)]\nfor i in roots:\n    stack = []\n    time = 1\n    queue = [[i, time]]\n    while queue:\n        j = queue[-1]\n        time += 1\n        if len(graph[j[0]]) == 0:\n            stack.append(queue.pop() + [time])\n        else:\n            queue.append([graph[j[0]].pop(), time])\n    stack.reverse()\n    if len(stack) > 1:\n        for j in range(len(stack)):\n            location[stack[j][0]] = [len(comp_of_conn), j]\n        for j in range(len(stack) - 1, -1, -1):\n            app = 0\n            for u in matrix[stack[j][0]]:\n                app += stack[location[u][1]][3]\n            stack[j].append(app + 1)\n        comp_of_conn.append(stack)\nfor i in range(q):\n    x, y = map(int, stdin.readline().split())\n    x -= 1\n    y = d[y - 1]\n    if y is None:\n        stdout.write('0\\n')\n    elif location[x] is not None and location[y] is not None and location[x][0] == location[y][0]:\n        c = location[x][0]\n        ind_x = location[x][1]\n        ind_y = location[y][1]\n        if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][\n            2]:\n            stdout.write(str(comp_of_conn[c][ind_x][3]) + '\\n')\n        else:\n            stdout.write('0\\n')\n    else:\n        stdout.write('0\\n')\n",
    "prob_desc_created_at": "1496326500",
    "tags": [
        "implementation",
        "dfs and similar",
        "trees",
        "graphs"
    ],
    "hidden_unit_tests": ""
}
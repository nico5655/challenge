{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"6\\n5\\n4\\n5\", \"200001\"]",
    "src_uid": "6c75268b5fb64576ff941a4ec41fe59b",
    "prob_desc_notes": "NoteIn the first example test, the program must proceed through $$$4$$$ updates.The sequence after the first update is $$$[2,3,2,4,5]$$$. One sequence of operations that achieves the number $$$6$$$ the following.   Initially, the blackboard has numbers $$$[2,3,2,4,5]$$$.  Erase two copies of $$$2$$$ and write $$$3$$$, yielding $$$[3,4,5,\\color{red}{3}]$$$.  Erase two copies of $$$3$$$ and write $$$4$$$, yielding $$$[4,5,\\color{red}{4}]$$$.  Erase two copies of $$$4$$$ and write $$$5$$$, yielding $$$[5,\\color{red}{5}]$$$.  Erase two copies of $$$5$$$ and write $$$6$$$, yielding $$$[\\color{red}{6}]$$$. Then, in the second update, the array is changed to $$$[2,3,2,4,3]$$$. This time, Mark cannot achieve $$$6$$$. However, one sequence that Mark can use to achieve $$$5$$$ is shown below.   Initially, the blackboard has $$$[2,3,2,4,3]$$$.  Erase two copies of $$$2$$$ and write $$$3$$$, yielding $$$[3,4,3,\\color{red}{3}]$$$.  Erase two copies of $$$3$$$ and write $$$4$$$, yielding $$$[3,4,\\color{red}{4}]$$$.  Erase two copies of $$$4$$$ and write $$$5$$$, yielding $$$[3,\\color{red}{5}]$$$. In the third update, the array is changed to $$$[2,3,2,1,3]$$$. One way to achieve $$$4$$$ is shown below.   Initially, the blackboard has $$$[2,3,2,1,3]$$$.  Erase two copies of $$$3$$$ and write $$$4$$$, yielding $$$[2,2,1,\\color{red}{4}]$$$. ",
    "prob_desc_description": "After watching a certain anime before going to sleep, Mark dreams of standing in an old classroom with a blackboard that has a sequence of $$$n$$$ positive integers $$$a_1, a_2,\\dots,a_n$$$ on it.Then, professor Koro comes in. He can perform the following operation:  select an integer $$$x$$$ that appears at least $$$2$$$ times on the board,  erase those $$$2$$$ appearances, and  write $$$x+1$$$ on the board. Professor Koro then asks Mark the question, \"what is the maximum possible number that could appear on the board after some operations?\"Mark quickly solves this question, but he is still slower than professor Koro. Thus, professor Koro decides to give Mark additional challenges. He will update the initial sequence of integers $$$q$$$ times. Each time, he will choose positive integers $$$k$$$ and $$$l$$$, then change $$$a_k$$$ to $$$l$$$. After each update, he will ask Mark the same question again.Help Mark answer these questions faster than Professor Koro!Note that the updates are persistent. Changes made to the sequence $$$a$$$ will apply when processing future updates.",
    "prob_desc_output_spec": "Print $$$q$$$ lines. The $$$i$$$-th line should consist of a single integer — the answer after the $$$i$$$-th update.",
    "prob_desc_input_spec": "The first line of the input contains two integers $$$n$$$ and $$$q$$$ ($$$2\\leq n\\leq 2\\cdot 10^5$$$, $$$1\\leq q\\leq 2\\cdot 10^5$$$) — the length of the sequence $$$a$$$ and the number of updates, respectively. The second line contains $$$n$$$ integers $$$a_1,a_2,\\dots,a_n$$$ ($$$1\\leq a_i\\leq 2\\cdot 10^5$$$) Then, $$$q$$$ lines follow, each consisting of two integers $$$k$$$ and $$$l$$$ ($$$1\\leq k\\leq n$$$, $$$1\\leq l\\leq 2\\cdot 10^5$$$), telling to update $$$a_k$$$ to $$$l$$$.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3-64",
    "lang_cluster": "Python",
    "difficulty": 2300,
    "file_name": "train_100.jsonl",
    "code_uid": "36b5d5006d4b3633cc0660d5ad3973e9",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"5 4\\n2 2 2 4 5\\n2 3\\n5 3\\n4 1\\n1 4\", \"2 1\\n200000 1\\n2 200000\"]",
    "exec_outcome": "PASSED",
    "source_code": "import sys\r\nimport os\r\nfrom io import BytesIO, IOBase\r\nfrom math import floor\r\nfrom random import randint\r\nimport time\r\n\r\n# region fastio\r\nBUFSIZE = 8192\r\n \r\nclass FastIO(IOBase):\r\n    newlines = 0\r\n \r\n    def __init__(self, file):\r\n        self._fd = file.fileno()\r\n        self.buffer = BytesIO()\r\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\r\n        self.write = self.buffer.write if self.writable else None\r\n \r\n    def read(self):\r\n        while True:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            if not b:\r\n                break\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines = 0\r\n        return self.buffer.read()\r\n \r\n    def readline(self):\r\n        while self.newlines == 0:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            self.newlines = b.count(b\"\\n\") + (not b)\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines -= 1\r\n        return self.buffer.readline()\r\n \r\n    def flush(self):\r\n        if self.writable:\r\n            os.write(self._fd, self.buffer.getvalue())\r\n            self.buffer.truncate(0), self.buffer.seek(0)\r\n \r\nclass IOWrapper(IOBase):\r\n    def __init__(self, file):\r\n        self.buffer = FastIO(file)\r\n        self.flush = self.buffer.flush\r\n        self.writable = self.buffer.writable\r\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\r\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\r\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\r\n\r\nif sys.version_info[0] < 3:\r\n    sys.stdin = BytesIO(os.read(0, os.fstat(0).st_size))\r\nelse:\r\n    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\r\n\r\nfile = sys.stdin\r\nif os.environ.get('USER') == \"loic\":\r\n    file = open(\"data.in\")\r\n    \r\nline = lambda: file.readline().split()\r\nui = lambda: int(line()[0])\r\nti = lambda: map(int,line())\r\nli = lambda: list(ti())\r\n\r\n#######################################################################\r\n\r\n# From https://github.com/cheran-senthil/PyRival/blob/master/pyrival/data_structures/SortedList.py\r\nclass IntervalList:\r\n    def __init__(self, iterable=[], _load=5000):\r\n        \"\"\"Initialize sorted list instance.\"\"\"\r\n        values = sorted(iterable)\r\n        self._len = _len = len(values)\r\n        self._load = _load\r\n        self._lists = _lists = [values[i:i + _load] for i in range(0, _len, _load)]\r\n        self._list_lens = [len(_list) for _list in _lists]\r\n        self._mins = [_list[0] for _list in _lists]\r\n        self._fen_tree = []\r\n        self._rebuild = True\r\n\r\n    def _fen_build(self):\r\n        \"\"\"Build a fenwick tree instance.\"\"\"\r\n        self._fen_tree[:] = self._list_lens\r\n        _fen_tree = self._fen_tree\r\n        for i in range(len(_fen_tree)):\r\n            if i | i + 1 < len(_fen_tree):\r\n                _fen_tree[i | i + 1] += _fen_tree[i]\r\n        self._rebuild = False\r\n\r\n    def _fen_update(self, index, value):\r\n        \"\"\"Update `fen_tree[index] += value`.\"\"\"\r\n        if not self._rebuild:\r\n            _fen_tree = self._fen_tree\r\n            while index < len(_fen_tree):\r\n                _fen_tree[index] += value\r\n                index |= index + 1\r\n\r\n    def _fen_query(self, end):\r\n        \"\"\"Return `sum(_fen_tree[:end])`.\"\"\"\r\n        if self._rebuild:\r\n            self._fen_build()\r\n\r\n        _fen_tree = self._fen_tree\r\n        x = 0\r\n        while end:\r\n            x += _fen_tree[end - 1]\r\n            end &= end - 1\r\n        return x\r\n\r\n    def _fen_findkth(self, k):\r\n        \"\"\"Return a pair of (the largest `idx` such that `sum(_fen_tree[:idx]) <= k`, `k - sum(_fen_tree[:idx])`).\"\"\"\r\n        _list_lens = self._list_lens\r\n        if k < _list_lens[0]:\r\n            return 0, k\r\n        if k >= self._len - _list_lens[-1]:\r\n            return len(_list_lens) - 1, k + _list_lens[-1] - self._len\r\n        if self._rebuild:\r\n            self._fen_build()\r\n\r\n        _fen_tree = self._fen_tree\r\n        idx = -1\r\n        for d in reversed(range(len(_fen_tree).bit_length())):\r\n            right_idx = idx + (1 << d)\r\n            if right_idx < len(_fen_tree) and k >= _fen_tree[right_idx]:\r\n                idx = right_idx\r\n                k -= _fen_tree[idx]\r\n        return idx + 1, k\r\n\r\n    def _delete(self, pos, idx):\r\n        \"\"\"Delete value at the given `(pos, idx)`.\"\"\"\r\n        _lists = self._lists\r\n        _mins = self._mins\r\n        _list_lens = self._list_lens\r\n\r\n        self._len -= 1\r\n        self._fen_update(pos, -1)\r\n        del _lists[pos][idx]\r\n        _list_lens[pos] -= 1\r\n\r\n        if _list_lens[pos]:\r\n            _mins[pos] = _lists[pos][0]\r\n        else:\r\n            del _lists[pos]\r\n            del _list_lens[pos]\r\n            del _mins[pos]\r\n            self._rebuild = True\r\n\r\n    def _loc_left(self, value):\r\n        \"\"\"Return an index pair that corresponds to the first position of `value` in the sorted list.\"\"\"\r\n        if not self._len:\r\n            return 0, 0\r\n\r\n        _lists = self._lists\r\n        _mins = self._mins\r\n\r\n        lo, pos = -1, len(_lists) - 1\r\n        while lo + 1 < pos:\r\n            mi = (lo + pos) >> 1\r\n            if value <= _mins[mi]:\r\n                pos = mi\r\n            else:\r\n                lo = mi\r\n\r\n        if pos and value <= _lists[pos - 1][-1]:\r\n            pos -= 1\r\n\r\n        _list = _lists[pos]\r\n        lo, idx = -1, len(_list)\r\n        while lo + 1 < idx:\r\n            mi = (lo + idx) >> 1\r\n            if value <= _list[mi]:\r\n                idx = mi\r\n            else:\r\n                lo = mi\r\n\r\n        return pos, idx\r\n\r\n    def _loc_right(self, value):\r\n        \"\"\"Return an index pair that corresponds to the last position of `value` in the sorted list.\"\"\"\r\n        if not self._len:\r\n            return 0, 0\r\n\r\n        _lists = self._lists\r\n        _mins = self._mins\r\n\r\n        pos, hi = 0, len(_lists)\r\n        while pos + 1 < hi:\r\n            mi = (pos + hi) >> 1\r\n            if value < _mins[mi]:\r\n                hi = mi\r\n            else:\r\n                pos = mi\r\n\r\n        _list = _lists[pos]\r\n        lo, idx = -1, len(_list)\r\n        while lo + 1 < idx:\r\n            mi = (lo + idx) >> 1\r\n            if value < _list[mi]:\r\n                idx = mi\r\n            else:\r\n                lo = mi\r\n\r\n        return pos, idx\r\n\r\n    def _prev_interval(self, pos, idx):\r\n        _lists = self._lists\r\n        if idx < 0 or pos < 0:\r\n            raise ValueError(\"idx or pos < 0 \", (idx,pos))\r\n        if idx > 0:\r\n            return pos, idx - 1, _lists[pos][idx - 1]\r\n        if pos > 0:\r\n            last = self._list_lens[pos - 1] - 1\r\n            return pos - 1, last, _lists[pos - 1][last]\r\n        return -1, -1, None\r\n    \r\n    def _next_interval(self, pos, idx):\r\n        _lists = self._lists\r\n        _list_lens = self._list_lens\r\n        if idx < 0 or pos < 0:\r\n            raise ValueError(\"idx or pos < 0 \", (idx,pos))\r\n        if idx < _list_lens[pos] - 1:\r\n            return pos, idx + 1, _lists[pos][idx + 1]\r\n        if pos < len(_lists) - 1:\r\n            return pos + 1, 0, _lists[pos + 1][0]\r\n        return -1, -1, None\r\n\r\n    def _insert(self, pos, idx, l, r):\r\n        _load = self._load\r\n        _lists = self._lists\r\n        _mins = self._mins\r\n        _list_lens = self._list_lens\r\n        \r\n        if _lists:\r\n            _list = _lists[pos]\r\n            self._fen_update(pos, 1)\r\n            _list.insert(idx, Interval(l, r))\r\n            _list_lens[pos] += 1\r\n            _mins[pos] = _list[0]\r\n            if _load + _load < len(_list):\r\n                _lists.insert(pos + 1, _list[_load:])\r\n                _list_lens.insert(pos + 1, len(_list) - _load)\r\n                _mins.insert(pos + 1, _list[_load])\r\n                _list_lens[pos] = _load\r\n                del _list[_load:]\r\n                self._rebuild = True\r\n        else:\r\n            itv = Interval(l, r)\r\n            _lists.append([itv])\r\n            _mins.append(itv)\r\n            _list_lens.append(1)\r\n            self._rebuild = True\r\n        \r\n        self._len += 1\r\n\r\n    def get_left_interval(self, position):\r\n        pos, idx = self._loc_right(Interval(position, position))\r\n        prev_pos, prev_idx, prev_itv = self._prev_interval(pos, idx)\r\n        if prev_itv is not None:\r\n            return prev_pos, prev_idx, prev_itv\r\n        return -1, -1, None\r\n\r\n    def get_right_interval(self, position):\r\n        prev_pos, prev_idx, prev_itv = self.get_left_interval(position)\r\n        if prev_itv is not None:\r\n            if position <= prev_itv.r:\r\n                return prev_pos, prev_idx, prev_itv\r\n            else:\r\n                return self._next_interval(prev_pos, prev_idx)\r\n        if self._lists:\r\n            return 0, 0, self._lists[0][0]\r\n        return -1, -1, None\r\n\r\n    def add(self, l, r):\r\n        _load = self._load\r\n        _lists = self._lists\r\n        _mins = self._mins\r\n        _list_lens = self._list_lens\r\n\r\n        if not _lists:\r\n            self._insert(0, 0, l, r)\r\n            \r\n        pos, idx = self._loc_right(Interval(l,r))\r\n        prev_pos, prev_idx, prev_itv = self._prev_interval(pos, idx)\r\n        \r\n        in_left = False\r\n        if prev_itv is not None and l <= prev_itv.r:\r\n            if r <= prev_itv.r:\r\n                return\r\n            in_left = True\r\n        \r\n        in_right = False\r\n        rem = []\r\n\r\n        nxt_pos,nxt_idx,nxt_itv = self._next_interval(prev_pos,prev_idx) if prev_itv is not None else (0, 0, self._lists[0][0])\r\n        while nxt_itv is not None and r >= nxt_itv.r:\r\n            rem.append((nxt_pos,nxt_idx))\r\n            nxt_pos,nxt_idx,nxt_itv = self._next_interval(nxt_pos,nxt_idx)\r\n        \r\n        for rem_pos,rem_idx in reversed(rem):\r\n            self._delete(rem_pos, rem_idx)\r\n    \r\n        if nxt_itv is not None and nxt_itv.l <= r:\r\n            in_right = True\r\n        \r\n        if not in_left and not in_right:\r\n            self._insert(pos, idx, l, r)\r\n        elif in_left and not in_right:\r\n            prev_itv.r = r\r\n        elif not in_left and in_right:\r\n            nxt_itv.l = l\r\n        else:\r\n            nxt_itv.l = prev_itv.l\r\n            self._delete(prev_pos, prev_idx)\r\n\r\n    def discard(self, l, r):\r\n        _load = self._load\r\n        _lists = self._lists\r\n        _mins = self._mins\r\n        _list_lens = self._list_lens\r\n\r\n        if _lists:\r\n            pos, idx = self._loc_right(Interval(l,r))\r\n            prev_pos, prev_idx, prev_itv = self._prev_interval(pos, idx)\r\n            in_left = False\r\n            in_right = False\r\n            if prev_itv is not None:\r\n                if prev_itv.l < l < prev_itv.r:\r\n                    in_left = True\r\n                if prev_itv.l < r < prev_itv.r:\r\n                    in_right = True\r\n            else:\r\n                prev_pos, prev_idx, prev_itv = pos, idx, _lists[pos][idx]\r\n            \r\n            rem = []\r\n            nxt_pos,nxt_idx,nxt_itv = prev_pos, prev_idx, prev_itv\r\n            while nxt_itv is not None and nxt_itv.r <= r:\r\n                if l <= nxt_itv.l:\r\n                    rem.append((nxt_pos,nxt_idx))\r\n                nxt_pos,nxt_idx,nxt_itv = self._next_interval(nxt_pos,nxt_idx)\r\n            \r\n            for rem_pos,rem_idx in reversed(rem):\r\n                self._delete(rem_pos, rem_idx)\r\n            \r\n            if in_left and in_right:\r\n                if l != r:\r\n                    self._insert(pos, idx, r, prev_itv.r)\r\n                    prev_itv.r = l\r\n                return\r\n            elif in_left:\r\n                prev_itv.r = l\r\n            \r\n            if nxt_itv is not None and nxt_itv.l < r < nxt_itv.r:\r\n                nxt_itv.l = r\r\n\r\n    def pop(self, index=-1):\r\n        \"\"\"Remove and return value at `index` in sorted list.\"\"\"\r\n        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)\r\n        value = self._lists[pos][idx]\r\n        self._delete(pos, idx)\r\n        return value\r\n\r\n    def bisect_left(self, value):\r\n        \"\"\"Return the left most index to insert `value` in the sorted list\r\n           Index == size if insertion is after last element\"\"\"\r\n        pos, idx = self._loc_left(value)\r\n        return self._fen_query(pos) + idx\r\n\r\n    def bisect_right(self, value):\r\n        \"\"\"Return the right most index to insert `value` in the sorted list\r\n           Index == size if insertion is after last element\"\"\"\r\n        pos, idx = self._loc_right(value)\r\n        return self._fen_query(pos) + idx\r\n\r\n    def count(self, value):\r\n        \"\"\"Return number of occurrences of `value` in the sorted list.\"\"\"\r\n        return self.bisect_right(value) - self.bisect_left(value)\r\n\r\n    def __len__(self):\r\n        \"\"\"Return the size of the sorted list.\"\"\"\r\n        return self._len\r\n\r\n    def __getitem__(self, index):\r\n        \"\"\"Lookup value at `index` in sorted list.\"\"\"\r\n        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)\r\n        return self._lists[pos][idx]\r\n\r\n    def __delitem__(self, index):\r\n        \"\"\"Remove value at `index` from sorted list.\"\"\"\r\n        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)\r\n        self._delete(pos, idx)\r\n\r\n    def __contains__(self, value):\r\n        \"\"\"Return true if `value` is an element of the sorted list.\"\"\"\r\n        _lists = self._lists\r\n        if _lists:\r\n            pos, idx = self._loc_left(value)\r\n            return idx < len(_lists[pos]) and _lists[pos][idx] == value\r\n        return False\r\n\r\n    def __iter__(self):\r\n        \"\"\"Return an iterator over the sorted list.\"\"\"\r\n        return (value for _list in self._lists for value in _list)\r\n\r\n    def __reversed__(self):\r\n        \"\"\"Return a reverse iterator over the sorted list.\"\"\"\r\n        return (value for _list in reversed(self._lists) for value in reversed(_list))\r\n\r\n    def __repr__(self):\r\n        \"\"\"Return string representation of sorted list.\"\"\"\r\n        return '[' + \", \".join(str(itvl) for itvl in list(self)) + ']'\r\n\r\n\r\nclass Interval:\r\n    def __init__(self, l, r):\r\n        self.l = l\r\n        self.r = r\r\n\r\n    def __str__(self):\r\n        return \"(\" + str(self.l) + \", \" +  str(self.r) + \")\"\r\n    \r\n    def __repr__(self):\r\n        return self.__str__()\r\n    \r\n    def __eq__(self, other):\r\n        return self.l == other.l and self.r == other.r\r\n    \r\n    def __lt__(self, other):\r\n        return self.l < other.l\r\n    \r\n    def __le__(self, other):\r\n        return self.l <= other.l\r\n\r\ndef rem(il,val):\r\n    pos,idx,itv = il.get_right_interval(val)\r\n    if itv is not None and val >= itv.l:\r\n        il.discard(floor(val), floor(val) + 1)\r\n    else:\r\n        left = itv.l\r\n        il.add(floor(val),left)\r\n        il.discard(left, left + 1)\r\n\r\ndef add(il,val):\r\n    pos,idx,itv = il.get_left_interval(val)\r\n    if itv is not None and val <= itv.r:\r\n        right = itv.r\r\n        il.discard(floor(val),right)\r\n        il.add(right, right + 1)\r\n    else:\r\n        il.add(floor(val), floor(val) + 1)\r\n\r\ndef solve():\r\n    \r\n    res = []\r\n    il = IntervalList([], 300)\r\n    \r\n    for val in A:\r\n        add(il, val + 0.5)\r\n    \r\n    for _ in range(Q):\r\n        idx, val = ti()\r\n        idx -= 1\r\n        \r\n        rem(il, A[idx] + 0.5)\r\n        A[idx] = val\r\n        add(il, val + 0.5)\r\n        \r\n        res.append(il[-1].r - 1)\r\n    \r\n    \r\n    return \"\\n\".join(str(v) for v in res)\r\n\r\nfor test in range(1,1+1):\r\n    N,Q = ti()\r\n    A = li()\r\n    \r\n    print(solve())\r\n    \r\nfile.close()",
    "prob_desc_created_at": "1657892100",
    "tags": [
        "binary search",
        "bitmasks",
        "brute force",
        "combinatorics",
        "data structures",
        "greedy"
    ],
    "hidden_unit_tests": ""
}
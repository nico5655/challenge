{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"YES\\n3 2 4 5 1\", \"NO\", \"NO\"]",
    "src_uid": "9dfd415d4ed6247d6bee84e8a6558543",
    "prob_desc_notes": "NoteThe order of patterns after the rearrangement in the first example is the following:   aaaa  __b_  ab__  _bcd  _b_d Thus, the first string matches patterns ab__, _bcd, _b_d in that order, the first of them is ab__, that is indeed $$$p[4]$$$. The second string matches __b_ and ab__, the first of them is __b_, that is $$$p[2]$$$. The last string matches _bcd and _b_d, the first of them is _bcd, that is $$$p[5]$$$.The answer to that test is not unique, other valid orders also exist.In the second example cba doesn't match __c, thus, no valid order exists.In the third example the order (a_, _b) makes both strings match pattern $$$1$$$ first and the order (_b, a_) makes both strings match pattern $$$2$$$ first. Thus, there is no order that produces the result $$$1$$$ and $$$2$$$.",
    "prob_desc_description": "You are given $$$n$$$ patterns $$$p_1, p_2, \\dots, p_n$$$ and $$$m$$$ strings $$$s_1, s_2, \\dots, s_m$$$. Each pattern $$$p_i$$$ consists of $$$k$$$ characters that are either lowercase Latin letters or wildcard characters (denoted by underscores). All patterns are pairwise distinct. Each string $$$s_j$$$ consists of $$$k$$$ lowercase Latin letters.A string $$$a$$$ matches a pattern $$$b$$$ if for each $$$i$$$ from $$$1$$$ to $$$k$$$ either $$$b_i$$$ is a wildcard character or $$$b_i=a_i$$$.You are asked to rearrange the patterns in such a way that the first pattern the $$$j$$$-th string matches is $$$p[mt_j]$$$. You are allowed to leave the order of the patterns unchanged.Can you perform such a rearrangement? If you can, then print any valid order.",
    "prob_desc_output_spec": "Print \"NO\" if there is no way to rearrange the patterns in such a way that the first pattern that the $$$j$$$-th string matches is $$$p[mt_j]$$$. Otherwise, print \"YES\" in the first line. The second line should contain $$$n$$$ distinct integers from $$$1$$$ to $$$n$$$ — the order of the patterns. If there are multiple answers, print any of them.",
    "prob_desc_input_spec": "The first line contains three integers $$$n$$$, $$$m$$$ and $$$k$$$ ($$$1 \\le n, m \\le 10^5$$$, $$$1 \\le k \\le 4$$$) — the number of patterns, the number of strings and the length of each pattern and string. Each of the next $$$n$$$ lines contains a pattern — $$$k$$$ characters that are either lowercase Latin letters or underscores. All patterns are pairwise distinct. Each of the next $$$m$$$ lines contains a string — $$$k$$$ lowercase Latin letters, and an integer $$$mt$$$ ($$$1 \\le mt \\le n$$$) — the index of the first pattern the corresponding string should match.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3-64",
    "lang_cluster": "Python",
    "difficulty": 2300,
    "file_name": "train_102.jsonl",
    "code_uid": "206439a1f8c4c9a5176bfc9ca44841ee",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"5 3 4\\n_b_d\\n__b_\\naaaa\\nab__\\n_bcd\\nabcd 4\\nabba 2\\ndbcd 5\", \"1 1 3\\n__c\\ncba 1\", \"2 2 2\\na_\\n_b\\nab 1\\nab 2\"]",
    "exec_outcome": "PASSED",
    "source_code": "import sys\r\ninput = sys.stdin.buffer.readline \r\n\r\ndef toposort(graph):\r\n    res, found = [], [0] * len(graph)\r\n    stack = list(range(len(graph)))\r\n    while stack:\r\n        node = stack.pop()\r\n        if node < 0:\r\n            res.append(~node)\r\n        elif not found[node]:\r\n            found[node] = 1\r\n            stack.append(~node)\r\n            stack += graph[node]\r\n\r\n    # cycle check\r\n    for node in res:\r\n        if any(found[nei] for nei in graph[node]):\r\n            return None\r\n        found[node] = 0\r\n\r\n    return res[::-1]\r\n\r\n\r\ndef kahn(graph):\r\n    n = len(graph)\r\n\r\n    indeg, idx = [0] * n, [0] * n\r\n    for i in range(n):\r\n        for e in graph[i]:\r\n            indeg[e] += 1\r\n\r\n    q, res = [], []\r\n    for i in range(n):\r\n        if indeg[i] == 0:\r\n            q.append(i)  # heappush(q, -i)\r\n\r\n    nr = 0\r\n    while q:\r\n        res.append(q.pop())  # res.append(-heappop(q))\r\n        idx[res[-1]], nr = nr, nr + 1\r\n        for e in graph[res[-1]]:\r\n            indeg[e] -= 1\r\n            if indeg[e] == 0:\r\n                q.append(e)  # heappush(q, -e)\r\n\r\n    return res, idx, nr == n\r\n\r\n\r\ndef make_string(s):\r\n    k = len(s)\r\n    answer = 0\r\n    for i in range(k):\r\n        if s[i]=='_':\r\n            entry = 26\r\n        else:\r\n            entry = ord(s[i])-ord('a')\r\n        answer = 27*answer+entry\r\n    return answer\r\n    \r\ndef make_strings(s):\r\n    k = len(s)\r\n    answer = [0]\r\n    for i in range(k):\r\n        answer2 = []\r\n        for x in answer:\r\n            for y in [26, ord(s[i])-ord('a')]:\r\n                answer2.append(27*x+y)\r\n        answer = answer2\r\n    return answer\r\n    \r\n\r\ndef process(P, S):\r\n    n = len(P)\r\n    m = len(S)\r\n    k = len(P[0])\r\n    d = [[None, None] for i in range(27**k)]\r\n    for i in range(n):\r\n        x = make_string(P[i])\r\n        d[x][0] = i+1\r\n    graph = [[] for i in range(n)]\r\n    for i in range(m):\r\n        s1, x1 = S[i]\r\n        works = False\r\n        for s2 in make_strings(s1):\r\n            if d[s2][0] is not None:\r\n                y = d[s2][0]\r\n                if y != x1:\r\n                    graph[x1-1].append(y-1)\r\n                if y==x1:\r\n                    works = True\r\n        if not works:\r\n            sys.stdout.write('NO\\n')\r\n            return\r\n    a, b, c = kahn(graph)\r\n    if not c:\r\n        sys.stdout.write('NO\\n')\r\n        return\r\n    answer = [None for i in range(n)]\r\n    for i in range(n):\r\n        answer[b[i]] = i+1\r\n    sys.stdout.write('YES\\n')\r\n    answer = ' '.join(map(str, answer))\r\n    sys.stdout.write(f'{answer}\\n')\r\n        \r\nn, m, k = [int(x) for x in input().split()]\r\nP = []\r\nfor i in range(n):\r\n    p = input().decode().strip()\r\n    P.append(p)\r\nS = []\r\nfor i in range(m):\r\n    s, x = input().decode().strip().split()\r\n    x = int(x)\r\n    S.append([s, x])\r\nprocess(P, S)",
    "prob_desc_created_at": "1611930900",
    "tags": [
        "bitmasks",
        "data structures",
        "dfs and similar",
        "graphs",
        "hashing",
        "sortings",
        "strings"
    ],
    "hidden_unit_tests": ""
}
{
    "prob_desc_time_limit": "2.5 seconds",
    "prob_desc_sample_outputs": "[\"YES\\nYES\\nNO\", \"NO\\nYES\\nNO\\nYES\"]",
    "src_uid": "39e7083c9d16a8cb92fc93bd8185fad2",
    "prob_desc_notes": "NoteIn the first sample, the array initially is {2, 6, 3}. For query 1, the first two numbers already have their gcd as 2.For query 2, we can achieve a gcd of 3 by changing the first element of the array to 3. Note that the changes made during queries of type 1 are temporary and do not get reflected in the array. After query 3, the array is now {9, 6, 3}. For query 4, no matter which element you change, you cannot get the gcd of the range to be 2. ",
    "prob_desc_description": "Bash likes playing with arrays. He has an array a1, a2, ... an of n integers. He likes to guess the greatest common divisor (gcd) of different segments of the array. Of course, sometimes the guess is not correct. However, Bash will be satisfied if his guess is almost correct.Suppose he guesses that the gcd of the elements in the range [l, r] of a is x. He considers the guess to be almost correct if he can change at most one element in the segment such that the gcd of the segment is x after making the change. Note that when he guesses, he doesn't actually change the array — he just wonders if the gcd of the segment can be made x. Apart from this, he also sometimes makes changes to the array itself.Since he can't figure it out himself, Bash wants you to tell him which of his guesses are almost correct. Formally, you have to process q queries of one of the following forms:  1 l r x — Bash guesses that the gcd of the range [l, r] is x. Report if this guess is almost correct.  2 i y — Bash sets ai to y. Note: The array is 1-indexed.",
    "prob_desc_output_spec": "For each query of first type, output \"YES\" (without quotes) if Bash's guess is almost correct and \"NO\" (without quotes) otherwise.",
    "prob_desc_input_spec": "The first line contains an integer n (1 ≤ n ≤ 5·105)  — the size of the array. The second line contains n integers a1, a2, ..., an (1 ≤ ai ≤ 109)  — the elements of the array. The third line contains an integer q (1 ≤ q ≤ 4·105)  — the number of queries. The next q lines describe the queries and may have one of the following forms:   1 l r x (1 ≤ l ≤ r ≤ n, 1 ≤ x ≤ 109).  2 i y (1 ≤ i ≤ n, 1 ≤ y ≤ 109).  Guaranteed, that there is at least one query of first type.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 2",
    "lang_cluster": "Python",
    "difficulty": 1900,
    "file_name": "train_050.jsonl",
    "code_uid": "fe32e8eff270252594a5f5a7729d7b33",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"3\\n2 6 3\\n4\\n1 1 2 2\\n1 1 3 3\\n2 1 9\\n1 1 3 2\", \"5\\n1 2 3 4 5\\n6\\n1 1 4 2\\n2 3 6\\n1 1 4 2\\n1 1 5 2\\n2 5 10\\n1 1 5 2\"]",
    "exec_outcome": "PASSED",
    "source_code": "#!/usr/bin/env python2\n\"\"\"\nThis file is part of https://github.com/cheran-senthil/PyRival\nCopyright 2019 Cheran Senthilkumar <hello@cheran.io>\n\n\"\"\"\nfrom __future__ import division, print_function\n\nimport itertools\nimport os\nimport sys\nfrom atexit import register\nfrom io import BytesIO\n\n\nclass dict(dict):\n    \"\"\"dict() -> new empty dictionary\"\"\"\n\n    def items(self):\n        \"\"\"D.items() -> a set-like object providing a view on D's items\"\"\"\n        return dict.iteritems(self)\n\n    def keys(self):\n        \"\"\"D.keys() -> a set-like object providing a view on D's keys\"\"\"\n        return dict.iterkeys(self)\n\n    def values(self):\n        \"\"\"D.values() -> an object providing a view on D's values\"\"\"\n        return dict.itervalues(self)\n\n\ndef gcd(x, y):\n    \"\"\"greatest common divisor of x and y\"\"\"\n    while y:\n        x, y = y, x % y\n    return x\n\n\nrange = xrange\n\nfilter = itertools.ifilter\nmap = itertools.imap\nzip = itertools.izip\n\ninput = BytesIO(os.read(0, os.fstat(0).st_size)).readline\nsys.stdout = BytesIO()\nregister(lambda: os.write(1, sys.stdout.getvalue()))\n\n\ndef main():\n    a = [0] * (524288 << 1 | 1)\n    n, arr = int(input()), [int(num) for num in input().split()]\n\n    for i in range(n):\n        p = i + 524289\n        a[p] = arr[i]\n        while p != 1:\n            p >>= 1\n            a[p] = gcd(a[p << 1], a[p << 1 | 1])\n\n    for i in range(int(input())):\n        q = [int(num) for num in input().split()]\n\n        if q[0] == 1:\n            p = 524288 + q[1]\n\n            while p != 1 and (a[p] % q[3] == 0):\n                if p & (p + 1) == 0:\n                    p = n + 524289\n                    break\n                p = (p + 1) >> 1\n\n            while p < 524288:\n                p <<= 1\n                p += int(a[p] % q[3] == 0)\n\n            if p - 524288 >= q[2]:\n                print('YES')\n            else:\n                p += 1\n\n                while p != 1 and (a[p] % q[3] == 0):\n                    if p & (p + 1) == 0:\n                        p = n + 524289\n                        break\n                    p = (p + 1) >> 1\n\n                while p < 524288:\n                    p <<= 1\n                    p += int(a[p] % q[3] == 0)\n\n                print('YES' if p - 524288 > q[2] else 'NO')\n\n        else:\n            p = q[1] + 524288\n            a[p] = q[2]\n\n            while p != 1:\n                p >>= 1\n                a[p] = gcd(a[p << 1], a[p << 1 | 1])\n\n\nif __name__ == '__main__':\n    main()\n",
    "prob_desc_created_at": "1516462500",
    "tags": [
        "data structures",
        "number theory"
    ],
    "hidden_unit_tests": ""
}
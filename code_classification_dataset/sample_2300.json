{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"2\", \"2\"]",
    "src_uid": "03d6b61be6ca0ac9dd8259458f41da59",
    "prob_desc_notes": null,
    "prob_desc_description": "Jzzhu is the president of country A. There are n cities numbered from 1 to n in his country. City 1 is the capital of A. Also there are m roads connecting the cities. One can go from city ui to vi (and vise versa) using the i-th road, the length of this road is xi. Finally, there are k train routes in the country. One can use the i-th train route to go from capital of the country to city si (and vise versa), the length of this route is yi.Jzzhu doesn't want to waste the money of the country, so he is going to close some of the train routes. Please tell Jzzhu the maximum number of the train routes which can be closed under the following condition: the length of the shortest path from every city to the capital mustn't change.",
    "prob_desc_output_spec": "Output a single integer representing the maximum number of the train routes which can be closed.",
    "prob_desc_input_spec": "The first line contains three integers n, m, k (2 ≤ n ≤ 105; 1 ≤ m ≤ 3·105; 1 ≤ k ≤ 105). Each of the next m lines contains three integers ui, vi, xi (1 ≤ ui, vi ≤ n; ui ≠ vi; 1 ≤ xi ≤ 109). Each of the next k lines contains two integers si and yi (2 ≤ si ≤ n; 1 ≤ yi ≤ 109). It is guaranteed that there is at least one way from every city to the capital. Note, that there can be multiple roads between two cities. Also, there can be multiple routes going to the same city from the capital.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3",
    "lang_cluster": "Python",
    "difficulty": 2000,
    "file_name": "train_020.jsonl",
    "code_uid": "52bf62e6730c6c8583a3a54a5108ae71",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"5 5 3\\n1 2 1\\n2 3 2\\n1 3 3\\n3 4 4\\n1 5 5\\n3 5\\n4 5\\n5 5\", \"2 2 3\\n1 2 2\\n2 1 3\\n2 1\\n2 2\\n2 3\"]",
    "exec_outcome": "PASSED",
    "source_code": "import os, sys\nfrom io import IOBase, BytesIO\n\npy2 = round(0.5)\nif py2:\n    from future_builtins import ascii, filter, hex, map, oct, zip\n\n    range = xrange\nBUFSIZE = 8192\n\n\nclass FastIO(BytesIO):\n    newlines = 0\n\n    def __init__(self, file):\n        self._file = file\n        self._fd = file.fileno()\n        self.writable = \"x\" in file.mode or \"w\" in file.mode\n        self.write = super(FastIO, self).write if self.writable else None\n\n    def _fill(self):\n        s = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n        self.seek((self.tell(), self.seek(0, 2), super(FastIO, self).write(s))[0])\n        return s\n\n    def read(self):\n        while self._fill():\n            pass\n        return super(FastIO, self).read()\n\n    def readline(self):\n        while self.newlines == 0:\n            s = self._fill()\n            self.newlines = s.count(b\"\\n\") + (not s)\n        self.newlines -= 1\n        return super(FastIO, self).readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.getvalue())\n            self.truncate(0), self.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        if py2:\n            self.write = self.buffer.write\n            self.read = self.buffer.read\n            self.readline = self.buffer.readline\n        else:\n            self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n            self.read = lambda: self.buffer.read().decode(\"ascii\")\n            self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n# Cout implemented in Python\nimport sys\n\n\nclass ostream:\n    def __lshift__(self, a):\n        sys.stdout.write(str(a))\n        return self\n\n\ncout = ostream()\nendl = \"\\n\"\n\nimport heapq\n\ndef solve():\n    \"\"\"\n    1. First we calculate shortest path using dijkstra. We \n        1.1) While comparison of distances, in case of equal shortest paths, -> Maybe we can keep (dist, num_trains_encountered, next_node) in heapq.\n                choose the one with more train network.\n    2. All train paths not on shortest path can be eliminated.\n    \"\"\"\n\n    n, m, k = map(int, input().split())\n\n    adj_list = {x: [] for x in range(n + 1)}\n    dist = [float(\"inf\")] * (n + 1)\n    dist[1] = 0\n\n    hq = [(0, 1)]\n\n    for _ in range(m):\n        u, v, x = map(int, input().split())\n        adj_list[u].append((v, x, False))\n        adj_list[v].append((u, x, False))\n\n    for _ in range(k):\n        v, y = map(int, input().split())\n        adj_list[1].append((v, y, True))\n        adj_list[v].append((1, y, True))\n\n    visited = [False] * (n + 1)\n    prev = {}\n    train_used = [0] * (n + 1)\n    \n\n    # Dist, Train found, Next Node.\n\n    while hq:\n\n        d, node = heapq.heappop(hq)\n\n        if visited[node]:\n            continue\n\n        visited[node] = True\n        for edge in adj_list[node]:\n            nxt, w, isTrain = edge\n            if not visited[nxt]:\n                if d + w < dist[nxt]:\n                    dist[nxt] = d + w\n                    if isTrain:\n                        train_used[nxt] = 1\n                if d + w == dist[nxt] and train_used[nxt] == 1 and not isTrain:\n                    train_used[nxt] = 0\n                heapq.heappush(hq, (d + w, nxt))\n    cout<<k - sum(train_used)<<\"\\n\"\n\n\ndef main():\n    solve()\n\n\nif __name__ == \"__main__\":\n    main()\n",
    "prob_desc_created_at": "1405774800",
    "tags": [
        "graphs",
        "greedy",
        "shortest paths"
    ],
    "hidden_unit_tests": ""
}
{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"3\\n1 1\\n2 3\", \"-1\", \"-1\"]",
    "src_uid": "045c8f116415f277fb7cf1109488b589",
    "prob_desc_notes": null,
    "prob_desc_description": "Nura wants to buy k gadgets. She has only s burles for that. She can buy each gadget for dollars or for pounds. So each gadget is selling only for some type of currency. The type of currency and the cost in that currency are not changing.Nura can buy gadgets for n days. For each day you know the exchange rates of dollar and pound, so you know the cost of conversion burles to dollars or to pounds.Each day (from 1 to n) Nura can buy some gadgets by current exchange rate. Each day she can buy any gadgets she wants, but each gadget can be bought no more than once during n days.Help Nura to find the minimum day index when she will have k gadgets. Nura always pays with burles, which are converted according to the exchange rate of the purchase day. Nura can't buy dollars or pounds, she always stores only burles. Gadgets are numbered with integers from 1 to m in order of their appearing in input.",
    "prob_desc_output_spec": "If Nura can't buy k gadgets print the only line with the number -1. Otherwise the first line should contain integer d — the minimum day index, when Nura will have k gadgets. On each of the next k lines print two integers qi, di — the number of gadget and the day gadget should be bought. All values qi should be different, but the values di can coincide (so Nura can buy several gadgets at one day). The days are numbered from 1 to n. In case there are multiple possible solutions, print any of them.",
    "prob_desc_input_spec": "First line contains four integers n, m, k, s (1 ≤ n ≤ 2·105, 1 ≤ k ≤ m ≤ 2·105, 1 ≤ s ≤ 109) — number of days, total number and required number of gadgets, number of burles Nura has. Second line contains n integers ai (1 ≤ ai ≤ 106) — the cost of one dollar in burles on i-th day. Third line contains n integers bi (1 ≤ bi ≤ 106) — the cost of one pound in burles on i-th day. Each of the next m lines contains two integers ti, ci (1 ≤ ti ≤ 2, 1 ≤ ci ≤ 106) — type of the gadget and it's cost. For the gadgets of the first type cost is specified in dollars. For the gadgets of the second type cost is specified in pounds.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "Python 2",
    "lang_cluster": "Python",
    "difficulty": 2000,
    "file_name": "train_013.jsonl",
    "code_uid": "25db4d1852986035ca0a86dad394667f",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"5 4 2 2\\n1 2 3 2 1\\n3 2 1 2 3\\n1 1\\n2 1\\n1 2\\n2 2\", \"4 3 2 200\\n69 70 71 72\\n104 105 106 107\\n1 1\\n2 2\\n1 2\", \"4 3 1 1000000000\\n900000 910000 940000 990000\\n990000 999000 999900 999990\\n1 87654\\n2 76543\\n1 65432\"]",
    "exec_outcome": "PASSED",
    "source_code": "n,m,k,s=map(int, raw_input().split())\n\ndollar=map(int, raw_input().split())\npound=map(int, raw_input().split())\n\nforDollars=[]\nforPounds=[]\nfor i in xrange(m):\n    t,c=map(int, raw_input().split())\n    if t==1:\n        forDollars.append([c,i])\n    else:\n        forPounds.append([c,i])\n\ndef prepro(gadgeds):\n    gadgeds.sort()\n    aggregated=[0]*(len(gadgeds)+1)\n    for i in xrange(1, len(aggregated)):\n        aggregated[i]=aggregated[i-1]+gadgeds[i-1][0]\n    return aggregated; \n        \naggDollars=prepro(forDollars)\naggPounds=prepro(forPounds)\n\n\nbestChangeDollar=[dollar[0], 0]\nbestChangePound=[pound[0], 0]\n\nimport bisect\ndef best_buy(aggregated, maxValue):\n    dN=bisect.bisect_right(aggregated, maxValue)\n    return dN-1\n    \ndef getCosts(costs, n, exchangeRate):\n    m=len(costs)\n    taken=0 if n==0 else costs[n-1][0]\n    next=2**60 if n==m else costs[n][0]\n    return (taken*exchangeRate, next*exchangeRate)\n \n#it would be easy if we could recalculate the costs in s and resort the values - just take the minimal ones\n# we dont have time for that, so try to find the last gadgeds in dollars and pfound with binary search   \ndef find_best_pair():\n\n    n_d=0;\n    n_p=best_buy(aggPounds, s/bestChangePound[0])\n     \n    low_d=0\n    up_d=min(len(aggDollars), best_buy(aggDollars, s/bestChangeDollar[0])+1)\n    \n    while(low_d+1<up_d):\n        middle=(low_d+up_d)/2\n        costGadgeds=aggDollars[middle]*bestChangeDollar[0]\n        if(costGadgeds>s):\n            up_d=middle\n        else:\n            maxPound=(s-costGadgeds)/bestChangePound[0]\n            p_middle=best_buy(aggPounds, maxPound)\n            \n            d_taken, d_next=getCosts(forDollars,  middle, bestChangeDollar[0])\n            p_taken, p_next=getCosts(forPounds, p_middle, bestChangePound[0])     \n            \n            if d_taken<=p_next:\n                low_d=middle\n                n_p=p_middle\n                n_d=middle\n            else:\n                up_d=middle\n                 \n    return (n_d, n_p)\n\ndef print_result(enumerated, n_d, day):\n    for i in range(n_d):\n        print enumerated[i][1]+1, day\n        \ndef print_result_and_exit(n_d, n_p, n):\n    print max(bestChangeDollar[1]+1, bestChangePound[1]+1)\n    print_result(forDollars, min(n_d, n), bestChangeDollar[1]+1)\n    print_result(forPounds, min(n_p, n-n_d), bestChangePound[1]+1)\n    exit(0)\n\nn_d, n_p=find_best_pair() \n\nif(n_d+n_p>=k):\n    print_result_and_exit(n_d, n_p, k)\n    \nfor i  in range(1, n):\n    bestChangeDollar=min(bestChangeDollar, [dollar[i], i])\n    bestChangePound=min(bestChangePound, [pound[i], i])\n    if bestChangePound[1]==i or bestChangeDollar[1]==i:\n        n_d, n_p=find_best_pair()\n        if(n_d+n_p>=k):\n            print_result_and_exit(n_d, n_p, k)\n      \n# cannot be achieved:\nprint -1  ",
    "prob_desc_created_at": "1450537200",
    "tags": [
        "two pointers",
        "binary search",
        "greedy"
    ],
    "hidden_unit_tests": ""
}
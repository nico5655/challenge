{
    "prob_desc_time_limit": "4 seconds",
    "prob_desc_sample_outputs": "[\"GGG\\nMGG\\nMGG\"]",
    "src_uid": "0e909868441b3af5be297f44d3459dac",
    "prob_desc_notes": null,
    "prob_desc_description": "Marin feels exhausted after a long day of cosplay, so Gojou invites her to play a game!Marin and Gojou take turns to place one of their tokens on an $$$n \\times n$$$ grid with Marin starting first. There are some restrictions and allowances on where to place tokens:   Apart from the first move, the token placed by a player must be more than Manhattan distance $$$k$$$ away from the previous token placed on the matrix. In other words, if a player places a token at $$$(x_1, y_1)$$$, then the token placed by the other player in the next move must be in a cell $$$(x_2, y_2)$$$ satisfying $$$|x_2 - x_1| + |y_2 - y_1| &gt; k$$$.  Apart from the previous restriction, a token can be placed anywhere on the matrix, including cells where tokens were previously placed by any player. Whenever a player places a token on cell $$$(x, y)$$$, that player gets $$$v_{x,\\ y}$$$ points. All values of $$$v$$$ on the grid are distinct. You still get points from a cell even if tokens were already placed onto the cell. The game finishes when each player makes $$$10^{100}$$$ moves.Marin and Gojou will play $$$n^2$$$ games. For each cell of the grid, there will be exactly one game where Marin places a token on that cell on her first move. Please answer for each game, if Marin and Gojou play optimally (after Marin's first move), who will have more points at the end? Or will the game end in a draw (both players have the same points at the end)?",
    "prob_desc_output_spec": "You should print $$$n$$$ lines. In the $$$i$$$-th line, print $$$n$$$ characters, where the $$$j$$$-th character is the result of the game in which Marin places her first token in the cell $$$(i, j)$$$. Print 'M' if Marin wins, 'G' if Gojou wins, and 'D' if the game ends in a draw. Do not print spaces between the characters in one line.",
    "prob_desc_input_spec": "The first line contains two integers $$$n$$$, $$$k$$$ ($$$3 \\le n \\le 2000$$$, $$$1 \\leq k \\leq n - 2$$$). Note that under these constraints it is always possible to make a move. The following $$$n$$$ lines contains $$$n$$$ integers each. The $$$j$$$-th integer in the $$$i$$$-th line is $$$v_{i,j}$$$ ($$$1 \\le v_{i,j} \\le n^2$$$). All elements in $$$v$$$ are distinct.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3",
    "lang_cluster": "Python",
    "difficulty": 2500,
    "file_name": "train_095.jsonl",
    "code_uid": "d8009d79447155bc6847efa7829010b3",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"3 1\\n1 2 4\\n6 8 3\\n9 5 7\"]",
    "exec_outcome": "PASSED",
    "source_code": "import heapq\r\n\r\nimport os\r\nimport sys\r\nfrom io import BytesIO, IOBase\r\n\r\n_str = str\r\nstr = lambda x=b\"\": x if type(x) is bytes else _str(x).encode()\r\n\r\nBUFSIZE = 8192\r\n\r\n\r\nclass FastIO(IOBase):\r\n    newlines = 0\r\n\r\n    def __init__(self, file):\r\n        self._fd = file.fileno()\r\n        self.buffer = BytesIO()\r\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\r\n        self.write = self.buffer.write if self.writable else None\r\n\r\n    def read(self):\r\n        while True:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            if not b:\r\n                break\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines = 0\r\n        return self.buffer.read()\r\n\r\n    def readline(self):\r\n        while self.newlines == 0:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            self.newlines = b.count(b\"\\n\") + (not b)\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines -= 1\r\n        return self.buffer.readline()\r\n\r\n    def flush(self):\r\n        if self.writable:\r\n            os.write(self._fd, self.buffer.getvalue())\r\n            self.buffer.truncate(0), self.buffer.seek(0)\r\n\r\n\r\nclass IOWrapper(IOBase):\r\n    def __init__(self, file):\r\n        self.buffer = FastIO(file)\r\n        self.flush = self.buffer.flush\r\n        self.writable = self.buffer.writable\r\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\r\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\r\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\r\n\r\n\r\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\r\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\r\n\r\n\r\ndef f(x, y, x1, y1, x2, y2):\r\n    return x1 + y1 <= x + y <= x2 + y2 and x1 - y1 <= x - y <= x2 - y2\r\n\r\ndef out(x, y, x1, y1, x2, y2):\r\n    return not (x1 + y1 <= x + y <= x2 + y2) and not (x1 - y1 <= x - y <= x2 - y2)\r\n\r\ndef merge(x1, y1, x2, y2, x3, y3, x4, y4):\r\n    new = [0] * 4\r\n    if f(x1, y1, x3, y3, x4, y4):\r\n        new[0], new[1] = x1, y1\r\n    elif out(x1, y1, x3, y3, x4, y4):\r\n        new[0], new[1] = x3, y4\r\n    else:\r\n        if x3 - y3 <= x1 - y1 <= x4 - y4:\r\n            num = ((x1 - y1) - (x3 - y3)) / 2\r\n            new[0], new[1] = x3 + num, y3 - num\r\n        else:\r\n            num = ((x1 + y1) - (x3 + y3)) / 2\r\n            new[0], new[1] = x3 + num, y3 + num\r\n    if f(x2, y2, x3, y3, x4, y4):\r\n        new[2], new[3] = x2, y2\r\n    elif out(x2, y2, x3, y3, x4, y4):\r\n        new[2], new[3] = x4, y4\r\n    else:\r\n        if x3 + y3 <= x2 + y2 <= x4 + y4:\r\n            num = (x4 + y4 - (x2 + y2)) / 2\r\n            new[2], new[3] = x4 - num, y4 - num\r\n        else:\r\n            num = ((x4 - y4) - (x2 - y2)) / 2\r\n            new[2], new[3] = x4 - num, y4 + num\r\n    return new\r\n\r\n\r\ndef main():\r\n    n, k = list(map(int, input().split(' ')))\r\n    v = [list(map(int, input().split(' '))) for _ in range(n)]\r\n    max_id = None\r\n    d = [0] *(n * n + 1)\r\n    for i in range(n):\r\n        for j in range(n):\r\n            d[v[i][j]] = i * (n + 1) + j\r\n            if v[i][j] == n * n:\r\n                max_id = [i, j]\r\n    valid = [(max_id[0] - k), max_id[1], (max_id[0] + k), max_id[1]]\r\n    \r\n    for vnow in range(n * n, 0, -1):\r\n        x, y = d[vnow] // (n + 1), d[vnow] % (n + 1)\r\n        #print(valid, vnow, x, y)\r\n        if not f(x, y, valid[0], valid[1], valid[2], valid[3]):\r\n            continue\r\n        if f(valid[0], valid[1], x - k, y, x + k, y) and f(valid[2], valid[3], x - k, y, x + k, y):\r\n            continue\r\n        new = merge(valid[0], valid[1], valid[2], valid[3], x - k, y, x + k, y)\r\n        valid.clear()\r\n        valid = new\r\n    \r\n    #print(valid)\r\n    for i in range(n):\r\n        res = ['G'] * n\r\n        for j in range(n):\r\n            if f(i, j, valid[0], valid[1], valid[2], valid[3]):\r\n                res[j] = 'M'\r\n        print(''.join(res))\r\n            \r\n    return\r\n\r\nmain()",
    "prob_desc_created_at": "1648391700",
    "tags": [
        "data structures",
        "dp",
        "games",
        "hashing",
        "implementation",
        "math",
        "number theory",
        "sortings"
    ],
    "hidden_unit_tests": ""
}
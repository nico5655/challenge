{
    "prob_desc_time_limit": "1 second",
    "prob_desc_sample_outputs": "[\"ababcb\\n-1\\nacbac\"]",
    "src_uid": "98c08a3b5e5b5bb78804ff797ba24d87",
    "prob_desc_notes": "NoteIn the first test case, all possible correct answers are \"ababcb\", \"abcacb\", \"abcbcb\", \"acabcb\" and \"acbacb\". The two answers \"abcbab\" and \"abaabc\" are incorrect, because you can replace only '?' characters and the resulting string must be beautiful.In the second test case, it is impossible to create a beautiful string, because the $$$4$$$-th and $$$5$$$-th characters will be always equal.In the third test case, the only answer is \"acbac\".",
    "prob_desc_description": "A string is called beautiful if no two consecutive characters are equal. For example, \"ababcb\", \"a\" and \"abab\" are beautiful strings, while \"aaaaaa\", \"abaa\" and \"bb\" are not.Ahcl wants to construct a beautiful string. He has a string $$$s$$$, consisting of only characters 'a', 'b', 'c' and '?'. Ahcl needs to replace each character '?' with one of the three characters 'a', 'b' or 'c', such that the resulting string is beautiful. Please help him!More formally, after replacing all characters '?', the condition $$$s_i \\neq s_{i+1}$$$ should be satisfied for all $$$1 \\leq i \\leq |s| - 1$$$, where $$$|s|$$$ is the length of the string $$$s$$$.",
    "prob_desc_output_spec": "For each test case given in the input print the answer in the following format:   If it is impossible to create a beautiful string, print \"-1\" (without quotes);  Otherwise, print the resulting beautiful string after replacing all '?' characters. If there are multiple answers, you can print any of them. ",
    "prob_desc_input_spec": "The first line contains positive integer $$$t$$$ ($$$1 \\leq t \\leq 1000$$$) — the number of test cases. Next $$$t$$$ lines contain the descriptions of test cases. Each line contains a non-empty string $$$s$$$ consisting of only characters 'a', 'b', 'c' and '?'.  It is guaranteed that in each test case a string $$$s$$$ has at least one character '?'. The sum of lengths of strings $$$s$$$ in all test cases does not exceed $$$10^5$$$.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3",
    "lang_cluster": "Python",
    "difficulty": 1000,
    "file_name": "train_001.jsonl",
    "code_uid": "417bc2728bc89a2d172372b56c934cde",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"3\\na???cb\\na??bbc\\na?b?c\"]",
    "exec_outcome": "PASSED",
    "source_code": "\"\"\"\n    Satwik_Tiwari ;) .\n    16th AUGUST , 2020  - SUNDAY\n\"\"\"\n\n#===============================================================================================\n#importing some useful libraries.\nfrom __future__ import division, print_function\n\nfrom fractions import Fraction\nimport sys\nimport os\nfrom io import BytesIO, IOBase\n\nfrom itertools import *\nimport bisect\nfrom heapq import *\nfrom math import *\nfrom copy import *\nfrom collections import deque\nfrom collections import Counter as counter  # Counter(list)  return a dict with {key: count}\nfrom itertools import combinations as comb # if a = [1,2,3] then print(list(comb(a,2))) -----> [(1, 2), (1, 3), (2, 3)]\nfrom itertools import permutations as permutate\nfrom bisect import bisect_left as bl\n#If the element is already present in the list,\n# the left most position where element has to be inserted is returned.\nfrom bisect import bisect_right as br\nfrom bisect import bisect\n#If the element is already present in the list,\n# the right most position where element has to be inserted is returned\n\n#==============================================================================================\n#fast I/O region\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\ndef print(*args, **kwargs):\n    \"\"\"Prints the values to a stream, or to sys.stdout by default.\"\"\"\n    sep, file = kwargs.pop(\"sep\", \" \"), kwargs.pop(\"file\", sys.stdout)\n    at_start = True\n    for x in args:\n        if not at_start:\n            file.write(sep)\n        file.write(str(x))\n        at_start = False\n    file.write(kwargs.pop(\"end\", \"\\n\"))\n    if kwargs.pop(\"flush\", False):\n        file.flush()\n\n\nif sys.version_info[0] < 3:\n    sys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)\nelse:\n    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\n\n# inp = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n#===============================================================================================\n### START ITERATE RECURSION ###\nfrom types import GeneratorType\ndef iterative(f, stack=[]):\n  def wrapped_func(*args, **kwargs):\n    if stack: return f(*args, **kwargs)\n    to = f(*args, **kwargs)\n    while True:\n      if type(to) is GeneratorType:\n        stack.append(to)\n        to = next(to)\n        continue\n      stack.pop()\n      if not stack: break\n      to = stack[-1].send(to)\n    return to\n  return wrapped_func\n#### END ITERATE RECURSION ####\n\n#===============================================================================================\n#some shortcuts\n\nmod = 1000000007\ndef inp(): return sys.stdin.readline().rstrip(\"\\r\\n\") #for fast input\ndef out(var): sys.stdout.write(str(var))  #for fast output, always take string\ndef lis(): return list(map(int, inp().split()))\ndef stringlis(): return list(map(str, inp().split()))\ndef sep(): return map(int, inp().split())\ndef strsep(): return map(str, inp().split())\n# def graph(vertex): return [[] for i in range(0,vertex+1)]\ndef zerolist(n): return [0]*n\ndef nextline(): out(\"\\n\")  #as stdout.write always print sring.\ndef testcase(t):\n    for p in range(t):\n        solve()\ndef printlist(a) :\n    for p in range(0,len(a)):\n        out(str(a[p]) + ' ')\ndef lcm(a,b): return (a*b)//gcd(a,b)\ndef power(x, y, p) :\n    res = 1     # Initialize result\n    x = x % p  # Update x if it is more , than or equal to p\n    if (x == 0) :\n        return 0\n    while (y > 0) :\n        if ((y & 1) == 1) : # If y is odd, multiply, x with result\n            res = (res * x) % p\n\n        y = y >> 1      # y = y/2\n        x = (x * x) % p\n    return res\ndef ncr(n,r): return factorial(n)//(factorial(r)*factorial(max(n-r,1)))\ndef isPrime(n) :\n    if (n <= 1) : return False\n    if (n <= 3) : return True\n    if (n % 2 == 0 or n % 3 == 0) : return False\n    i = 5\n    while(i * i <= n) :\n        if (n % i == 0 or n % (i + 2) == 0) :\n            return False\n        i = i + 6\n    return True\n\n#===============================================================================================\n# code here ;))\n\ndef solve():\n    s=  list(inp())\n    n= len(s)\n    # print(s)\n    for i in range(1,n):\n        if(s[i]==s[i-1] and s[i]!='?'):\n            print(-1)\n            return\n    put = ['a','b','c']\n    if(n==1):\n        if(s[0] == '?'):\n            print('a')\n        else:\n            print(s[0])\n        return \n\n    for i in range(n):\n        if(i==0 and s[i] == '?'):\n            if(s[i+1]=='?'):\n                s[i] = 'a'\n            else:\n                if(s[i+1] == 'a'):\n                    s[i] = 'b'\n                else:\n                    s[i] = 'a'\n            continue\n        if(i==n-1 and s[i] == '?'):\n            if(s[i-1] == 'a'):\n                s[i] = 'b'\n            else:\n                s[i] = 'a'\n            continue\n\n        if(i==0 or i==n-1):\n            continue\n        if(s[i] == '?'):\n            vis = [False]*3\n            for ii in range(3):\n                if(s[i-1]==put[ii]):\n                    vis[ii] = True\n            for ii in range(3):\n                if(s[i+1]==put[ii]):\n                    vis[ii] = True\n            for ii in range(3):\n                if(vis[ii]==False):\n                    s[i] = put[ii]\n    print(''.join(s))\n\n\n\n# testcase(1)\ntestcase(int(inp()))\n",
    "prob_desc_created_at": "1575556500",
    "tags": [
        "constructive algorithms",
        "greedy"
    ],
    "hidden_unit_tests": ""
}
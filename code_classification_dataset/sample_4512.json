{
    "prob_desc_time_limit": "3 seconds",
    "prob_desc_sample_outputs": "[\"2\\n3 2\", \"-1\", \"0\"]",
    "src_uid": "a0bceeb856fd95ece1990a0f98658d1a",
    "prob_desc_notes": null,
    "prob_desc_description": "Joseph really likes the culture of Japan. Last year he learned Japanese traditional clothes and visual arts and now he is trying to find out the secret of the Japanese game called Nonogram.In the one-dimensional version of the game, there is a row of $$$n$$$ empty cells, some of which are to be filled with a pen. There is a description of a solution called a profile — a sequence of positive integers denoting the lengths of consecutive sets of filled cells. For example, the profile of $$$[4, 3, 1]$$$ means that there are sets of four, three, and one filled cell, in that order, with at least one empty cell between successive sets. A suitable solution for $$$n = 12$$$ and $$$p = [4, 3, 1]$$$.  A wrong solution: the first four filled cells should be consecutive.  A wrong solution: there should be at least one empty cell before the last filled cell. Joseph found out that for some numbers $$$n$$$ and profiles $$$p$$$ there are lots of ways to fill the cells to satisfy the profile. Now he is in the process of solving a nonogram consisting of $$$n$$$ cells and a profile $$$p$$$. He has already created a mask of $$$p$$$ — he has filled all the cells that must be filled in every solution of the nonogram. The mask for $$$n = 12$$$ and $$$p = [4, 3, 1]$$$: all the filled cells above are filled in every solution. After a break, he lost the source profile $$$p$$$. He only has $$$n$$$ and the mask $$$m$$$. Help Joseph find any profile $$$p'$$$ with the mask $$$m$$$ or say that there is no such profile and Joseph has made a mistake.",
    "prob_desc_output_spec": "If there is no profile with the mask $$$m$$$, output the number $$$-1$$$. Otherwise, on the first line, output an integer $$$k$$$ — the number of integers in the profile $$$p'$$$. On the second line, output $$$k$$$ integers of the profile $$$p'$$$.",
    "prob_desc_input_spec": "The only line contains a string $$$m$$$ — the mask of the source profile $$$p$$$. The length of $$$m$$$ is $$$n$$$ ($$$1 \\le n \\le 100\\,000$$$). The string $$$m$$$ consists of symbols # and _ — denoting filled and empty cells respectively.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3",
    "lang_cluster": "Python",
    "difficulty": 2700,
    "file_name": "train_099.jsonl",
    "code_uid": "39bca825532bbcec505c933ae44d5f62",
    "prob_desc_memory_limit": "512 megabytes",
    "prob_desc_sample_inputs": "[\"__#_____\", \"_#\", \"___\"]",
    "exec_outcome": "PASSED",
    "source_code": "import copy\nfrom collections import defaultdict as dd\nfrom collections import deque\nimport math\nimport sys\nimport os\n\n# sys.setrecursionlimit(10**5)  # This uses something like 128 MB RAM. I guess only play with this if I expect recursion depth problems.\n\n#region  set up dbg commands\n# set up debug stuff.\n# remember .bashrc should contain `export PYTHON_CONTEST_HELPER=\"dummy\"`\nif os.environ.get(\"PYTHON_CONTEST_HELPER\"):\n    OUT_RED_BOLD = \"\\033[31;1m\"\n    OUT_GREEN = \"\\033[32m\"\n    OUT_RESET = \"\\033[0m\"\n    OUT_BOLD = \"\\033[;1m\"\n    OUT_CYAN = \"\\033[36;1m\"\n    OUT_PURPLE = \"\\033[35;1m\"\n    OUT_YELLOW = \"\\033[33;1m\"\n    OUT_BACKGROUND = \"\\033[41;30;1m\"\n\n    def dbgBase(*args, **kwargs):\n        color_helper = kwargs.pop('color', OUT_CYAN)\n        print(f\"{OUT_RED_BOLD}{sys._getframe().f_back.f_back.f_lineno: >20} {OUT_BOLD}: {color_helper}\", end='', file=sys.stderr)\n        end_maybe = kwargs.get('end', '\\n')\n        kwargs['end']=f\"{OUT_RESET}{end_maybe}\"\n        print(*args, file=sys.stderr, **kwargs)\n\n    def dbg(*args, **kwargs): dbgBase(color=OUT_CYAN, *args, **kwargs)\n    dbgB = dbg\n    def dbgG(*args, **kwargs): dbgBase(color=OUT_GREEN, *args, **kwargs)\n    def dbgP(*args, **kwargs): dbgBase(color=OUT_PURPLE, *args, **kwargs)\n    def dbgY(*args, **kwargs): dbgBase(color=OUT_YELLOW, *args, **kwargs)\n    def dbgBackground(*args, **kwargs): dbgBase(color=OUT_BACKGROUND, *args, **kwargs)\n    def el(n=1): print('\\n'*n, file=sys.stderr, end='')\nelse:\n    def dbg(*args, **kwargs): pass\n    def dbgB(*args, **kwargs): pass\n    def dbgG(*args, **kwargs): pass\n    def dbgP(*args, **kwargs): pass\n    def dbgY(*args, **kwargs): pass\n    def dbgBackground(*args, **kwargs): pass\n    def el(n=1): pass\n#endregion\n#region  FastIO\nfrom io import BytesIO, IOBase\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n#endregion\n\ndef nn():\n    return int(input())\n\ndef li():\n    return list(input())\n\ndef lm():\n    return list(map(int, input().split()))\n\n\n# To print while flushing output for interactive problems:\n# print(x, flush=True)\n\n\n#########################################################################\n# Problem specific code usually goes below this line.\n#########################################################################\n\n# ! Read the sample cases before writing code!\n\n\n\n\n\n\n\n\ndef solve(testID):\n    dat = input()\n    dbg(dat)\n    min_space = -1\n    if dat[0] == \"#\" or dat[-1] == \"#\":\n        min_space = 0\n    curr_cell = 0\n    total_blocks = []\n    while curr_cell < len(dat):\n        curr_spaces = 0\n        while curr_cell < len(dat) and dat[curr_cell] == \"_\":\n            curr_spaces += 1\n            curr_cell += 1\n        if curr_spaces != 0 and (min_space == -1 or curr_spaces < min_space):\n            min_space = curr_spaces\n        curr_block_size = 0\n        start_cell = curr_cell\n        while curr_cell < len(dat) and dat[curr_cell] == \"#\":\n            curr_block_size += 1\n            curr_cell += 1\n        if curr_block_size > 0:\n            total_blocks.append((start_cell, curr_block_size))\n    dbgB(min_space)\n    dbgB(total_blocks)\n    if len(total_blocks) == 0:\n        print(0)\n        print()\n        return\n    for slack in range(min_space + 1):\n        last_allowed_spot = 0\n        success = True\n        for pos, block_size in total_blocks:\n            dbgP(slack, pos, block_size, last_allowed_spot)\n            prior_empty_space = pos - last_allowed_spot\n            space_to_fill = prior_empty_space - slack\n            dbgY(space_to_fill)\n            if space_to_fill < 0:\n                success = False\n                break\n            if space_to_fill > 0 and slack == 0:\n                success = False\n                break\n            if space_to_fill == 1:\n                success = False\n                break\n            if space_to_fill % 2 == 1 and slack == 1:\n                success = False\n                break\n            last_allowed_spot = pos + block_size + 1\n            dbgP(last_allowed_spot)\n        if not success:\n            continue\n        remaining_space = len(dat) - last_allowed_spot + 1 - slack\n        dbgG(remaining_space)\n        if (remaining_space > 0 and slack == 0) or remaining_space < 0 or remaining_space == 1 or (remaining_space % 2 == 1 and slack == 1):\n            success = False\n            continue\n        break\n    if not success:\n        print(-1)\n        return\n    dbgY(slack)\n\n    profile_ints = []\n    last_allowed_spot = 0\n    for pos, block_size in total_blocks:\n        space_to_fill = pos - last_allowed_spot - slack\n        dbgB(space_to_fill)\n        if space_to_fill % 2 == 1:\n            profile_ints.append(2)\n            space_to_fill -= 3\n        while space_to_fill > 0:\n            profile_ints.append(1)\n            space_to_fill -= 2\n        profile_ints.append(block_size + slack)\n        last_allowed_spot = pos + block_size + 1\n    remaining_space = len(dat) - last_allowed_spot + 1 - slack\n    dbgP(remaining_space)\n    if remaining_space > 0:\n        if remaining_space % 2 == 1:\n            profile_ints.append(2)\n            remaining_space -= 3\n        while remaining_space > 0:\n            profile_ints.append(1)\n            remaining_space -= 2\n\n    dbgG(profile_ints)\n\n    print(len(profile_ints))\n    print(\" \".join([str(x) for x in profile_ints]))\n\n    return\n\n\nT = 1\n# dbgBackground(\"Loading num cases!!!!!\"); T = nn()  # ! Comment this out for single-case problems!\nfor testID in range(1, T+1):\n    el()\n    dbgBackground(f\"Case {testID}\")\n    solve(testID)\n",
    "prob_desc_created_at": "1617523500",
    "tags": [
        "constructive algorithms",
        "math"
    ],
    "hidden_unit_tests": ""
}
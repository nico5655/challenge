{
    "prob_desc_time_limit": "1 second",
    "prob_desc_sample_outputs": "[\"YES\\n3 1 6 1 2\\nYES\\n3 1 1 1 2\\nYES\\n3 3 5 5\\nNO\\nYES\\n4 4 4 4 3 1\\nYES\\n3 1 3 1 7 7\\nYES\\n2 3 1 1 1 1\"]",
    "src_uid": "729b33519cc2c02b929f7028edf23269",
    "prob_desc_notes": "NoteThe first test case is described in the statement.In the second test case, $$$x=3$$$ because the colors are equal at indices $$$2,4,5$$$. And $$$y=4$$$ because they share the colors $$$1,1,1,2$$$.In the third test case, $$$x=0$$$ because there is no index where the colors are the same. But $$$y=4$$$ because they share the colors $$$3,3,5,5$$$.In the fourth test case, it can be proved that no solution exists.",
    "prob_desc_description": "In the game of Mastermind, there are two players  — Alice and Bob. Alice has a secret code, which Bob tries to guess. Here, a code is defined as a sequence of $$$n$$$ colors. There are exactly $$$n+1$$$ colors in the entire universe, numbered from $$$1$$$ to $$$n+1$$$ inclusive.When Bob guesses a code, Alice tells him some information about how good of a guess it is, in the form of two integers $$$x$$$ and $$$y$$$.The first integer $$$x$$$ is the number of indices where Bob's guess correctly matches Alice's code. The second integer $$$y$$$ is the size of the intersection of the two codes as multisets. That is, if Bob were to change the order of the colors in his guess, $$$y$$$ is the maximum number of indices he could get correct.For example, suppose $$$n=5$$$, Alice's code is $$$[3,1,6,1,2]$$$, and Bob's guess is $$$[3,1,1,2,5]$$$. At indices $$$1$$$ and $$$2$$$ colors are equal, while in the other indices they are not equal. So $$$x=2$$$. And the two codes have the four colors $$$1,1,2,3$$$ in common, so $$$y=4$$$.  Solid lines denote a matched color for the same index. Dashed lines denote a matched color at a different index. $$$x$$$ is the number of solid lines, and $$$y$$$ is the total number of lines. You are given Bob's guess and two values $$$x$$$ and $$$y$$$. Can you find one possibility of Alice's code so that the values of $$$x$$$ and $$$y$$$ are correct?",
    "prob_desc_output_spec": "For each test case, on the first line, output \"YES\" if there is a solution, or \"NO\" if there is no possible secret code consistent with the described situation. You can print each character in any case (upper or lower). If the answer is \"YES\", on the next line output $$$n$$$ integers $$$a_1,\\ldots,a_n$$$ ($$$1\\le a_i\\le n+1$$$)  — Alice's secret code, where $$$a_i$$$ is the $$$i$$$-th color of the code. If there are multiple solutions, output any.",
    "prob_desc_input_spec": "The first line contains a single integer $$$t$$$ ($$$1\\le t\\le 1000$$$)  — the number of test cases. Next $$$2t$$$ lines contain descriptions of test cases. The first line of each test case contains three integers $$$n,x,y$$$ ($$$1\\le n\\le 10^5, 0\\le x\\le y\\le n$$$)  — the length of the codes, and two values Alice responds with. The second line of each test case contains $$$n$$$ integers $$$b_1,\\ldots,b_n$$$ ($$$1\\le b_i\\le n+1$$$)  — Bob's guess, where $$$b_i$$$ is the $$$i$$$-th color of the guess. It is guaranteed that the sum of $$$n$$$ across all test cases does not exceed $$$10^5$$$.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "Python 3",
    "lang_cluster": "Python",
    "difficulty": 2500,
    "file_name": "train_009.jsonl",
    "code_uid": "220049098db3337da5d1248e7bcbab29",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"7\\n5 2 4\\n3 1 1 2 5\\n5 3 4\\n1 1 2 1 2\\n4 0 4\\n5 5 3 3\\n4 1 4\\n2 3 2 3\\n6 1 2\\n3 2 1 1 1 1\\n6 2 4\\n3 3 2 1 1 1\\n6 2 6\\n1 1 3 2 1 1\"]",
    "exec_outcome": "PASSED",
    "source_code": "from heapq import *\nfrom collections import Counter\nimport sys\n\nsys.setrecursionlimit(10 ** 5)\nint1 = lambda x: int(x) - 1\np2D = lambda x: print(*x, sep=\"\\n\")\ndef II(): return int(sys.stdin.readline())\ndef MI(): return map(int, sys.stdin.readline().split())\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef LLI(rows_number): return [LI() for _ in range(rows_number)]\ndef SI(): return sys.stdin.readline()[:-1]\n\nfor _ in range(II()):\n    ng=False\n    n,x,y=MI()\n    bb=LI()\n\n    use=[False]*(n+1)\n    for b in bb:use[b-1]=True\n    unuse=0\n    for b in range(1,n+2):\n        if use[b-1]==False:\n            unuse=b\n            break\n    aa=[unuse]*n\n\n    cnt=[[] for _ in range(n+2)]\n    for i,b in enumerate(bb):\n        cnt[b].append(i)\n    #print(cnt)\n\n    hp=[]\n    for b,ii in enumerate(cnt):\n        if not ii:continue\n        heappush(hp,[-len(ii)]+[b]+ii)\n    #print(hp)\n\n    if (y-x)%2:\n        if len(hp)>2 and y-x>2:\n            ii0=heappop(hp)\n            ii1=heappop(hp)\n            ii2=heappop(hp)\n            b0=ii0[1]\n            b1=ii1[1]\n            b2=ii2[1]\n            i0=ii0.pop()\n            i1=ii1.pop()\n            i2=ii2.pop()\n            ii0[0]+=1\n            ii1[0]+=1\n            ii2[0]+=1\n            if ii0[0]<0:heappush(hp,ii0)\n            if ii1[0]<0:heappush(hp,ii1)\n            if ii2[0]<0:heappush(hp,ii2)\n            aa[i0]=b1\n            aa[i1]=b2\n            aa[i2]=b0\n            y-=3\n        elif len(hp)>1:\n            ii0=heappop(hp)\n            ii1=heappop(hp)\n            b0=ii0[1]\n            b1=ii1[1]\n            i0=ii0.pop()\n            i1=ii1.pop()\n            ii0[0]+=1\n            ii1[0]+=1\n            if ii0[0]<0:heappush(hp,ii0)\n            if ii1[0]<0:heappush(hp,ii1)\n            aa[i0]=b1\n            y-=1\n        else:\n            print(\"NO\")\n            continue\n\n    for _ in range((y-x)//2):\n        if len(hp)<2:\n            ng=True\n            break\n        ii0 = heappop(hp)\n        ii1 = heappop(hp)\n        b0 = ii0[1]\n        b1 = ii1[1]\n        i0 = ii0.pop()\n        i1 = ii1.pop()\n        ii0[0] += 1\n        ii1[0] += 1\n        if ii0[0] < 0: heappush(hp, ii0)\n        if ii1[0] < 0: heappush(hp, ii1)\n        aa[i0] = b1\n        aa[i1] = b0\n    if ng:\n        print(\"NO\")\n        continue\n\n    ii0=[]\n    for _ in range(x):\n        if len(ii0)<3:\n            if not hp:\n                ng=True\n                break\n            else:\n                ii0 = heappop(hp)\n        b0 = ii0[1]\n        i0 = ii0.pop()\n        aa[i0] = b0\n    if ng:\n        print(\"NO\")\n        continue\n\n    print(\"YES\")\n    print(*aa)\n",
    "prob_desc_created_at": "1595342100",
    "tags": [
        "greedy",
        "constructive algorithms",
        "two pointers",
        "graph matchings",
        "implementation",
        "sortings"
    ],
    "hidden_unit_tests": ""
}
{
    "prob_desc_time_limit": "4 seconds",
    "prob_desc_sample_outputs": "[\"1 0 1 2 -1 -1 \\n1 \\n-1 -1 -1 \\n1 0 0 0 0 \\n1 1 2 1\"]",
    "src_uid": "055346dd6d2e0cff043b52a395e31fdf",
    "prob_desc_notes": null,
    "prob_desc_description": "You are given a directed graph $$$G$$$ which can contain loops (edges from a vertex to itself). Multi-edges are absent in $$$G$$$ which means that for all ordered pairs $$$(u, v)$$$ exists at most one edge from $$$u$$$ to $$$v$$$. Vertices are numbered from $$$1$$$ to $$$n$$$.A path from $$$u$$$ to $$$v$$$ is a sequence of edges such that:  vertex $$$u$$$ is the start of the first edge in the path;  vertex $$$v$$$ is the end of the last edge in the path;  for all pairs of adjacent edges next edge starts at the vertex that the previous edge ends on. We will assume that the empty sequence of edges is a path from $$$u$$$ to $$$u$$$.For each vertex $$$v$$$ output one of four values:  $$$0$$$, if there are no paths from $$$1$$$ to $$$v$$$;  $$$1$$$, if there is only one path from $$$1$$$ to $$$v$$$;  $$$2$$$, if there is more than one path from $$$1$$$ to $$$v$$$ and the number of paths is finite;  $$$-1$$$, if the number of paths from $$$1$$$ to $$$v$$$ is infinite. Let's look at the example shown in the figure.  Then:  the answer for vertex $$$1$$$ is $$$1$$$: there is only one path from $$$1$$$ to $$$1$$$ (path with length $$$0$$$);  the answer for vertex $$$2$$$ is $$$0$$$: there are no paths from $$$1$$$ to $$$2$$$;  the answer for vertex $$$3$$$ is $$$1$$$: there is only one path from $$$1$$$ to $$$3$$$ (it is the edge $$$(1, 3)$$$);  the answer for vertex $$$4$$$ is $$$2$$$: there are more than one paths from $$$1$$$ to $$$4$$$ and the number of paths are finite (two paths: $$$[(1, 3), (3, 4)]$$$ and $$$[(1, 4)]$$$);  the answer for vertex $$$5$$$ is $$$-1$$$: the number of paths from $$$1$$$ to $$$5$$$ is infinite (the loop can be used in a path many times);  the answer for vertex $$$6$$$ is $$$-1$$$: the number of paths from $$$1$$$ to $$$6$$$ is infinite (the loop can be used in a path many times). ",
    "prob_desc_output_spec": "Output $$$t$$$ lines. The $$$i$$$-th line should contain an answer for the $$$i$$$-th test case: a sequence of $$$n$$$ integers from $$$-1$$$ to $$$2$$$.",
    "prob_desc_input_spec": "The first contains an integer $$$t$$$ ($$$1 \\le t \\le 10^4$$$) — the number of test cases in the input. Then $$$t$$$ test cases follow. Before each test case, there is an empty line. The first line of the test case contains two integers $$$n$$$ and $$$m$$$ ($$$1 \\le n \\le 4 \\cdot 10^5, 0 \\le m \\le 4 \\cdot 10^5$$$) — numbers of vertices and edges in graph respectively. The next $$$m$$$ lines contain edges descriptions. Each line contains two integers $$$a_i$$$, $$$b_i$$$ ($$$1 \\le a_i, b_i \\le n$$$) — the start and the end of the $$$i$$$-th edge. The vertices of the graph are numbered from $$$1$$$ to $$$n$$$. The given graph can contain loops (it is possible that $$$a_i = b_i$$$), but cannot contain multi-edges (it is not possible that $$$a_i = a_j$$$ and $$$b_i = b_j$$$ for $$$i \\ne j$$$). The sum of $$$n$$$ over all test cases does not exceed $$$4 \\cdot 10^5$$$. Similarly, the sum of $$$m$$$ over all test cases does not exceed $$$4 \\cdot 10^5$$$.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3-64",
    "lang_cluster": "Python",
    "difficulty": 2100,
    "file_name": "train_103.jsonl",
    "code_uid": "f6678b90251659960cf811b8f860934c",
    "prob_desc_memory_limit": "512 megabytes",
    "prob_desc_sample_inputs": "[\"5\\n\\n6 7\\n1 4\\n1 3\\n3 4\\n4 5\\n2 1\\n5 5\\n5 6\\n\\n1 0\\n\\n3 3\\n1 2\\n2 3\\n3 1\\n\\n5 0\\n\\n4 4\\n1 2\\n2 3\\n1 4\\n4 3\"]",
    "exec_outcome": "PASSED",
    "source_code": "from collections import Counter, deque\r\n# from itertools import combinations\r\nimport bisect\r\nimport heapq\r\nfrom locale import currency\r\nimport math\r\nfrom re import S\r\nimport sys\r\nfrom types import GeneratorType\r\n\r\n\r\n\r\n# sys.stdin = open('grey.in', 'r')\r\n# sys.setrecursionlimit(1 * 10**9)\r\n\r\n\r\ndef bootstrap(f, stack=[]):\r\n    def wrappedfunc(*args, **kwargs):\r\n        if stack:\r\n            return f(*args, **kwargs)\r\n        else:\r\n            to = f(*args, **kwargs)\r\n            while True:\r\n                if type(to) is GeneratorType:\r\n                    stack.append(to)\r\n                    to = next(to)\r\n                else:\r\n                    stack.pop()\r\n                    if not stack:\r\n                        break\r\n                    to = stack[-1].send(to)\r\n            return to\r\n \r\n    return wrappedfunc\r\n \r\nresult = []\r\n\r\n\r\n\r\nLOG = 18\r\n\r\narray = [1, 2, 3, 4, 5, 6, 7, 8]\r\n\r\n\r\n\r\n\r\n\r\n\r\ndef calc(numOne, numTwo):\r\n    \r\n    currentSum = 0\r\n    for i in range(32):\r\n        firstBit, secondBit = min(1, numOne & (1 << i)), min(1, numTwo & (1 << i))\r\n        \r\n        currentSum += (firstBit ^ secondBit)\r\n\r\n    return currentSum    \r\n\r\n\r\n# counter = Counter()\r\n# for i in range(0, 119000):\r\n#     counter[calc(i, i + 1)] += 1\r\n\r\n\r\n# print(counter)\r\n\r\n\r\n\r\n \r\ninput = sys.stdin.readline\r\n \r\n \r\n\r\n# t = int(input())\r\n# result = []\r\n# for _ in range(t):\r\n#     a, b = map(int, input().split())\r\n\r\n\r\n#     def solve():\r\n#         state = False\r\n#         count = 0\r\n        \r\n#         currentMin = float('inf')\r\n#         for z in range(0, b + 5):\r\n#             currentB = b + z\r\n#             count = 0\r\n#             for i in range(32):\r\n#                 firstBit, secondBit = a & (1 << i), currentB & (1 << i)\r\n\r\n#                 if secondBit and not firstBit:\r\n#                     state = True\r\n#                     continue\r\n\r\n#                 if firstBit and not secondBit:\r\n#                     count += (2**i)\r\n#             currentMin = min(currentMin, count + 1 + z if state else count + z)        \r\n#         return min(currentMin, b - a)\r\n\r\n#     print(solve())           \r\n\r\n# # print(result)\r\n\r\n\r\n\r\nclass SegmentTree2D:\r\n\r\n    \r\n    def __init__(self, row, col, inMatrix):\r\n        self.rows = row\r\n        self.cols = col\r\n        self.inMatrix = inMatrix\r\n        self.matrix = [[0 for z in range(col + 1)] for i in range(row + 1)]\r\n        self.genTable()\r\n\r\n\r\n    \r\n\r\n    def genTable(self):\r\n        self.matrix[0][0] = 0\r\n\r\n\r\n        for row in range(self.rows):\r\n            currentSum = 0\r\n            for col in range(self.cols):\r\n                currentSum += self.inMatrix[row][col]\r\n                above = self.matrix[row][col + 1]\r\n                self.matrix[row + 1][col + 1] = currentSum + above\r\n\r\n    \r\n\r\n\r\n    def sumRegion(self, rowOne, colOne, rowTwo, colTwo):\r\n        rowOne += 1\r\n        rowTwo += 1\r\n        colOne += 1\r\n        colTwo += 1\r\n\r\n        bottomRight, above = self.matrix[rowTwo][colTwo], self.matrix[rowOne - 1][colTwo]\r\n        left, topLeft = self.matrix[rowTwo][colOne - 1], self.matrix[rowOne - 1][colOne - 1]\r\n        return bottomRight - above - left + topLeft\r\n\r\n\r\n\r\n\r\n\r\n\r\nclass LCA:\r\n    def __init__(self, neighbourNodes, rootNode):\r\n        self.neighbourNodes = neighbourNodes\r\n        self.log = 18\r\n        self.parentNode = [[i for i in range(self.log)] for z in range(len(neighbourNodes))]\r\n        self.depth = [0 for i in range(len(neighbourNodes))]\r\n        self.bfs(rootNode, rootNode, 0)\r\n \r\n \r\n \r\n    def bfs(self, currentNode, parentNode, currentDepth):\r\n        queue = deque()\r\n        queue.append((currentNode, parentNode, currentDepth))\r\n \r\n \r\n        while(queue):\r\n            currentNode, parentNode, currentDepth = queue.popleft()\r\n \r\n            self.parentNode[currentNode][0] = parentNode\r\n \r\n \r\n            for i in range(1, self.log):\r\n                self.parentNode[currentNode][i] = self.parentNode[self.parentNode[currentNode][i - 1]][i - 1]\r\n \r\n \r\n            for node in self.neighbourNodes[currentNode]:\r\n                if node != parentNode:\r\n                    queue.append((node, currentNode, currentDepth + 1))\r\n \r\n            self.depth[currentNode] = currentDepth            \r\n \r\n \r\n    def lca(self, nodeOne, nodeTwo):\r\n        \r\n        diff = abs(self.depth[nodeOne] - self.depth[nodeTwo])\r\n        \r\n \r\n        if self.depth[nodeOne] < self.depth[nodeTwo]:\r\n            nodeOne, nodeTwo = nodeTwo, nodeOne\r\n \r\n        for i in reversed(range(self.log)):\r\n            if diff & (1 << i):\r\n                nodeOne = self.parentNode[nodeOne][i]\r\n \r\n        if nodeOne == nodeTwo:\r\n            return nodeOne\r\n \r\n        for i in reversed(range(self.log)):\r\n            if self.parentNode[nodeOne][i] != self.parentNode[nodeTwo][i]:\r\n                nodeOne, nodeTwo = self.parentNode[nodeOne][i], self.parentNode[nodeTwo][i]\r\n \r\n        return self.parentNode[nodeOne][0]   \r\n \r\n\r\n\r\ndef power(a, b, mod):\r\n    if not b:\r\n        return 1\r\n\r\n    temp = power(a, b // 2, mod)\r\n    result = temp * temp if b % 2 == 0 else temp * temp * a\r\n    result %= mod\r\n    return result    \r\n\r\n\r\n\r\n\r\n\r\n\r\ndef bootstrap(f, stack=[]):\r\n    def wrappedfunc(*args, **kwargs):\r\n        if stack:\r\n            return f(*args, **kwargs)\r\n        else:\r\n            to = f(*args, **kwargs)\r\n            while True:\r\n                if type(to) is GeneratorType:\r\n                    stack.append(to)\r\n                    to = next(to)\r\n                else:\r\n                    stack.pop()\r\n                    if not stack:\r\n                        break\r\n                    to = stack[-1].send(to)\r\n            return to\r\n \r\n    return wrappedfunc\r\n\r\n\r\n\r\n\r\ndef genSparseTable(array, comp):\r\n        \r\n    sparseTable = [[float('inf') for i in range(LOG)] for x in range(len(array))]\r\n\r\n\r\n    for i in range(len(array)):\r\n        sparseTable[i][0] = array[i]\r\n\r\n\r\n\r\n    for i in range(1, LOG):\r\n        j = 0\r\n        while((j + (1 << i) - 1) < len(array)):\r\n            sparseTable[j][i] = comp(sparseTable[j][i - 1], sparseTable[j + (1 << (i  - 1))][i - 1])\r\n            j += 1\r\n\r\n    return sparseTable\r\n\r\ndef query(l, r, sparseTable, comp):\r\n    length = (r - l) + 1\r\n    idx = int(math.log(length, 2))\r\n    return comp(sparseTable[l][idx], sparseTable[r - (1 << idx) + 1][idx])\r\n\r\n\r\n\r\n# t = int(input())\r\n\r\n\r\n# for _ in range(t):\r\n#     n, x, y = map(int, input().split())\r\n    \r\n#     stringOne, stringTwo = map(int, input().split())\r\n\r\n#     def solve():\r\n\r\n#         rightMostIdx = None\r\n\r\n#         cnt = 0\r\n\r\n#         for numOne, numTwo in zip(stringOne, stringTwo):\r\n#             if numOne != numTwo:\r\n#                 cnt += 1\r\n\r\n#         if cnt % 2:\r\n#             return -1\r\n\r\n#         for i in reversed(range(n)):\r\n#             if stringOne[i] == stringTwo[i]:\r\n#                 rightMostIdx = i\r\n#                 break\r\n\r\n#         leftMostIdx = None\r\n\r\n#         currentIdx = 0\r\n        \r\n#         total = 0\r\n#         while(currentIdx < n - 1):\r\n#             if stringOne[currentIdx] != stringTwo[currentIdx] and stringOne[currentIdx + 1] != stringTwo[currentIdx + 1]:\r\n#                 if rightMostIdx is not None and rightMostIdx - 1 > currentIdx + 1:\r\n#                     total += min(x, 2 * y)\r\n#                 elif leftMostIdx is not None and leftMostIdx + 1 < currentIdx:\r\n#                     total += min(x, 2 * y)\r\n#                 else:\r\n#                     total += x\r\n#                     if leftMostIdx is None:\r\n#                         leftMostIdx = currentIdx\r\n#                 currentIdx += 2        \r\n#             elif stringOne[currentIdx] != stringTwo[currentIdx]:\r\n\r\n \r\ninput = sys.stdin.readline\r\n \r\n \r\n \r\nt = int(input())\r\n \r\n \r\nfor _ in range(t):\r\n    input()\r\n    n, m = map(int, input().split())\r\n    \r\n    \r\n    neighbourNodes = [[] for i in range(n)]\r\n    \r\n    \r\n    for i in range(m):\r\n        path, toPath = map(int, input().split())\r\n        path -= 1\r\n        toPath -= 1\r\n        neighbourNodes[path].append(toPath)\r\n    \r\n    def solve():\r\n        \r\n        revNeighbourNodes = [[] for i in range(n)]\r\n        \r\n        for node in range(n):\r\n            for neighbour in neighbourNodes[node]:\r\n                revNeighbourNodes[neighbour].append(node)\r\n        \r\n        \r\n        \r\n        component = [node for node in range(n)]\r\n        visited = [False for node in range(n)]\r\n        \r\n        stack = []\r\n        @bootstrap\r\n        def dfsOne(currentNode):\r\n            \r\n            if visited[currentNode]:\r\n                yield None\r\n            \r\n            \r\n            visited[currentNode] = True\r\n                \r\n            for node in revNeighbourNodes[currentNode]:\r\n                (yield dfsOne(node))\r\n            \r\n            stack.append(currentNode)\r\n            \r\n            yield None;\r\n        \r\n        \r\n        \r\n        for node in range(n):\r\n            if not visited[node]:\r\n                dfsOne(node)                    \r\n        \r\n        \r\n        \r\n        @bootstrap\r\n        def dfsTwo(currentNode, comp):\r\n            \r\n            if visited[currentNode]:\r\n                yield None\r\n            \r\n            visited[currentNode] = True\r\n            \r\n            component[currentNode] = comp\r\n            \r\n            for node in neighbourNodes[currentNode]:\r\n                if not visited[node]:\r\n                    (yield dfsTwo(node, comp))\r\n            \r\n            yield None        \r\n                        \r\n            \r\n        \r\n        visited = [False for node in range(n)]    \r\n        \r\n        \r\n        while(stack):\r\n            currentNode = stack.pop()\r\n            if not visited[currentNode]:\r\n                dfsTwo(currentNode, currentNode)\r\n        \r\n        \r\n        isCycle = [False for node in range(n)]\r\n        \r\n        counter = Counter(component)\r\n        \r\n        for comp in counter:\r\n            if counter[comp] > 1:\r\n                isCycle[comp] = True\r\n        \r\n        for node in range(n):\r\n            for neighbour in neighbourNodes[node]:\r\n                if node == neighbour:\r\n                    isCycle[component[node]] = True\r\n                    break\r\n        \r\n        \r\n        newEdges = [[] for node in range(n)]\r\n        \r\n        \r\n        for node in range(n):\r\n            for neighbour in neighbourNodes[node]:\r\n                if component[node] != component[neighbour]:\r\n                    newEdges[component[node]].append(component[neighbour])\r\n        \r\n        \r\n        result = [0 for node in range(n)]\r\n        \r\n        \r\n        visited = [False for node in range(n)]\r\n\r\n        toBeVisited = []\r\n\r\n        @bootstrap             \r\n        def dfsThree(currentNode, currentAns):\r\n            \r\n            result[currentNode] += currentAns\r\n            visited[currentNode] = True\r\n            for node in newEdges[currentNode]:\r\n                if visited[node]:\r\n                    result[node] += currentAns\r\n                    toBeVisited.append(node)\r\n                    continue\r\n                \r\n                newAns = currentAns if not isCycle[node] else float('inf')\r\n                (yield dfsThree(node, newAns))                  \r\n            \r\n            yield None\r\n            \r\n        \r\n       \r\n                \r\n        \r\n        \r\n        ans = 1 if not isCycle[component[0]] else float('inf')\r\n        dfsThree(component[0], ans) \r\n        \r\n        \r\n        visited = [False for node in range(n)]\r\n\r\n        @bootstrap\r\n        def dfsFour(currentNode, ans):\r\n            \r\n            result[currentNode] += ans\r\n            visited[currentNode] = True\r\n            \r\n            for node in newEdges[currentNode]:\r\n                if not visited[node]:\r\n                    (yield dfsFour(node, max(ans, result[currentNode])))\r\n            \r\n            yield None        \r\n        \r\n        toBeVisited.sort(reverse = True, key = lambda x: (result[x]))\r\n        for node in toBeVisited:\r\n            if not visited[node]:\r\n                dfsFour(node, result[node])               \r\n        \r\n        \r\n        for node in range(n):\r\n            ans = result[component[node]]\r\n            \r\n            if ans not in [-1, 0, 1, 2]:\r\n                if ans == float('inf'):\r\n                    ans = -1\r\n                elif ans > 1:\r\n                    ans = 2\r\n                else:\r\n                    ans = 0\r\n                            \r\n            result[node] = ans    \r\n        \r\n        result = [str(re) for re in result]\r\n        \r\n        for i in range(len(result)):\r\n            if result[i] == \"inf\":\r\n                result[i] = str(-1)\r\n        return result\r\n                  \r\n    \r\n    print(' '.join(solve()))\r\n\r\n\r\n\r\n",
    "prob_desc_created_at": "1625927700",
    "tags": [
        "dfs and similar",
        "dp",
        "graphs",
        "trees"
    ],
    "hidden_unit_tests": ""
}
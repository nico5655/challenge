{
    "prob_desc_time_limit": "3 seconds",
    "prob_desc_sample_outputs": "[\"0 1\\n0 0\\n0 1 3 2\\n0 0 1 1\\n5 3 0 7 2 6 1 4\\n-1\"]",
    "src_uid": "4c9c50f9ebe06a3e86c20aee2a0ee797",
    "prob_desc_notes": "NoteThe colouring and the permuted hypercube for the first test case is shown below:   The colouring and the permuted hypercube for the second test case is shown below:   The permuted hypercube for the third test case is given in the problem statement. However, it can be shown that there exists no way to colour that cube satifying all the conditions. Note that some other permutations like $$$[0, 5, 7, 3, 1, 2, 4, 6]$$$ and $$$[0, 1, 5, 2, 7, 4, 3, 6]$$$ will also give the same permuted hypercube.",
    "prob_desc_description": "Finally, you have defeated Razor and now, you are the Most Wanted street racer. Sergeant Cross has sent the full police force after you in a deadly pursuit. Fortunately, you have found a hiding spot but you fear that Cross and his force will eventually find you. To increase your chances of survival, you want to tune and repaint your BMW M3 GTR.The car can be imagined as a permuted $$$n$$$-dimensional hypercube. A simple $$$n$$$-dimensional hypercube is an undirected unweighted graph built recursively as follows:   Take two simple $$$(n-1)$$$-dimensional hypercubes one having vertices numbered from $$$0$$$ to $$$2^{n-1}-1$$$ and the other having vertices numbered from $$$2^{n-1}$$$ to $$$2^{n}-1$$$. A simple $$$0$$$-dimensional Hypercube is just a single vertex.  Add an edge between the vertices $$$i$$$ and $$$i+2^{n-1}$$$ for each $$$0\\leq i &lt; 2^{n-1}$$$. A permuted $$$n$$$-dimensional hypercube is formed by permuting the vertex numbers of a simple $$$n$$$-dimensional hypercube in any arbitrary manner.Examples of a simple and permuted $$$3$$$-dimensional hypercubes are given below:  Note that a permuted $$$n$$$-dimensional hypercube has the following properties:   There are exactly $$$2^n$$$ vertices.  There are exactly $$$n\\cdot 2^{n-1}$$$ edges.  Each vertex is connected to exactly $$$n$$$ other vertices.  There are no self-loops or duplicate edges. Let's denote the permutation used to generate the permuted $$$n$$$-dimensional hypercube, representing your car, from a simple $$$n$$$-dimensional hypercube by $$$P$$$. Before messing up the functionalities of the car, you want to find this permutation so that you can restore the car if anything goes wrong. But the job isn't done yet.You have $$$n$$$ different colours numbered from $$$0$$$ to $$$n-1$$$. You want to colour the vertices of this permuted $$$n$$$-dimensional hypercube in such a way that for each and every vertex $$$u$$$ satisfying $$$0\\leq u &lt; 2^n$$$ and for each and every colour $$$c$$$ satisfying $$$0\\leq c &lt; n$$$, there is at least one vertex $$$v$$$ adjacent to $$$u$$$ having a colour $$$c$$$. In other words, from each and every vertex, it must be possible to reach a vertex of any colour by just moving to an adjacent vertex. Given the permuted $$$n$$$-dimensional hypercube, find any valid permutation $$$P$$$ and colouring.",
    "prob_desc_output_spec": "For each test case, print two lines. In the first line, output any permutation $$$P$$$ of length $$$2^n$$$ that can be used to transform a simple $$$n$$$-dimensional hypercube to the permuted $$$n$$$-dimensional hypercube given in the input. Two permuted hypercubes are considered the same if they have the same set of edges. If there are multiple answers, output any of them. In the second line, print the colouring. If there is no way to colour the vertices satisfying the conditions, output $$$-1$$$. Otherwise, output a single line containing $$$2^n$$$ space separated integers. The $$$i$$$-th integer must be the colour of the vertex numbered $$$(i-1)$$$ in the permuted $$$n$$$-dimensional hypercube. If there are multiple answers, output any of them.",
    "prob_desc_input_spec": "The first line of input contains a single integer $$$t$$$ ($$$1\\leq t\\leq 4096$$$) â€” the number of test cases. For each test case, the first line contains a single integer $$$n$$$ ($$$1\\leq n\\leq 16$$$). Each of the next $$$n\\cdot 2^{n-1}$$$ lines contain two integers $$$u$$$ and $$$v$$$ ($$$0\\leq u, v &lt; 2^n$$$) denoting that there is an edge between the vertices numbered $$$u$$$ and $$$v$$$. It is guaranteed that the graph described in the input is a permuted $$$n$$$-dimensional hypercube. Additionally, it is guaranteed that the sum of $$$2^n$$$ over all test cases does not exceed $$$2^{16}=65\\,536$$$.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3",
    "lang_cluster": "Python",
    "difficulty": 2700,
    "file_name": "train_091.jsonl",
    "code_uid": "ae0d50e1348523fabc089358e6773d31",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"3\\n1\\n0 1\\n2\\n0 1\\n1 2\\n2 3\\n3 0\\n3\\n0 1\\n0 5\\n0 7\\n1 2\\n1 4\\n2 5\\n2 6\\n3 5\\n3 6\\n3 7\\n4 6\\n4 7\"]",
    "exec_outcome": "PASSED",
    "source_code": "from collections import deque\r\nfrom sys import stdin\r\nimport sys\r\n \r\ntt = int(stdin.readline())\r\n \r\nfor loop in range(tt):\r\n \r\n    n = int(stdin.readline())\r\n \r\n    lis = [ [] for i in range(2**n)]\r\n \r\n    for i in range(n*(2**(n-1))):\r\n \r\n        u,v = map(int,stdin.readline().split())\r\n        lis[u].append(v)\r\n        lis[v].append(u)\r\n \r\n    rp = [0] * (2**n)\r\n    d = [float(\"inf\")] * (2**n)\r\n \r\n    d[0] = 0\r\n \r\n    q = deque()\r\n    for i in range(n):\r\n        nexv = lis[0][i]\r\n        rp[nexv] = 2**i\r\n        d[nexv] = 1\r\n        q.append(nexv)\r\n \r\n    while q:\r\n        v = q.popleft()\r\n        for nexv in lis[v]:\r\n \r\n            if d[nexv] == float(\"inf\"):\r\n                d[nexv] = d[v] + 1\r\n                q.append(nexv)\r\n \r\n            if d[nexv] > d[v]:\r\n                rp[nexv] |= rp[v]\r\n \r\n    p = [None] * (2**n)\r\n    for i in range(2**n):\r\n        p[rp[i]] = i\r\n \r\n    print (*p)\r\n \r\n    if (2**n) % n == 0:\r\n \r\n        c = [None] * (2**n)\r\n        \r\n        for i in range(2**n):\r\n \r\n            now = 0\r\n            for j in range(n):\r\n                if 2**j & i > 0:\r\n                    now ^= j\r\n            c[p[i]] = now\r\n \r\n        print (*c)\r\n \r\n    else:\r\n        print (-1)",
    "prob_desc_created_at": "1625668500",
    "tags": [
        "bitmasks",
        "constructive algorithms",
        "divide and conquer",
        "graphs",
        "greedy",
        "math"
    ],
    "hidden_unit_tests": ""
}
{
    "prob_desc_time_limit": "1.5 seconds",
    "prob_desc_sample_outputs": "[\"1 2 1 1 1 \\n0 0 1\"]",
    "src_uid": "a4101af56ea6afdfaa510572eedd6320",
    "prob_desc_notes": "Note  In example case $$$1$$$,    For $$$k = 0$$$, there is $$$1$$$ path that is from $$$2$$$ to $$$3$$$ as $$$MEX([2, 3]) = 0$$$.  For $$$k = 1$$$, there are $$$2$$$ paths that is from $$$0$$$ to $$$2$$$ as $$$MEX([0, 2]) = 1$$$ and $$$0$$$ to $$$3$$$ as $$$MEX([0, 2, 3]) = 1$$$.  For $$$k = 2$$$, there is $$$1$$$ path that is from $$$0$$$ to $$$1$$$ as $$$MEX([0, 1]) = 2$$$.  For $$$k = 3$$$, there is $$$1$$$ path that is from $$$1$$$ to $$$2$$$ as $$$MEX([1, 0, 2]) = 3$$$  For $$$k = 4$$$, there is $$$1$$$ path that is from $$$1$$$ to $$$3$$$ as $$$MEX([1, 0, 2, 3]) = 4$$$.   In example case $$$2$$$,    For $$$k = 0$$$, there are no such paths.  For $$$k = 1$$$, there are no such paths.  For $$$k = 2$$$, there is $$$1$$$ path that is from $$$0$$$ to $$$1$$$ as $$$MEX([0, 1]) = 2$$$.  ",
    "prob_desc_description": "You are given a tree with $$$n$$$ nodes, numerated from $$$0$$$ to $$$n-1$$$. For each $$$k$$$ between $$$0$$$ and $$$n$$$, inclusive, you have to count the number of unordered pairs $$$(u,v)$$$, $$$u \\neq v$$$, such that the MEX of all the node labels in the shortest path from $$$u$$$ to $$$v$$$ (including end points) is $$$k$$$.The MEX of a sequence of integers is the smallest non-negative integer that does not belong to the sequence.",
    "prob_desc_output_spec": "For each test case, print $$$n+1$$$ integers: the number of paths in the tree, such that the MEX of all the node labels in that path is $$$k$$$ for each $$$k$$$ from $$$0$$$ to $$$n$$$.",
    "prob_desc_input_spec": "The first line contains a single integer $$$t$$$ ($$$1 \\le t \\le 10^4$$$) â€” the number of test cases.  The first line of each test case contains a single integer $$$n$$$ ($$$2 \\le n \\le 2 \\cdot 10^{5}$$$). The next $$$n-1$$$ lines of each test case describe the tree that has to be constructed. These lines contain two integers $$$u$$$ and $$$v$$$ ($$$0 \\le u,v \\le n-1$$$) denoting an edge between $$$u$$$ and $$$v$$$ ($$$u \\neq v$$$). It is guaranteed that the given edges form a tree. It is also guaranteed that the sum of $$$n$$$ for all test cases does not exceed $$$2 \\cdot 10^{5}$$$.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3-64",
    "lang_cluster": "Python",
    "difficulty": 2400,
    "file_name": "train_085.jsonl",
    "code_uid": "84fcbbead088d2584d8a95a2557697de",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"2\\n4\\n0 1\\n0 2\\n2 3\\n2\\n1 0\"]",
    "exec_outcome": "PASSED",
    "source_code": "import sys\r\ninput = sys.stdin.buffer.readline \r\n\r\nclass RangeQuery:\r\n    def __init__(self, data, func=min):\r\n        self.func = func\r\n        self._data = _data = [list(data)]\r\n        i, n = 1, len(_data[0])\r\n        while 2 * i <= n:\r\n            prev = _data[-1]\r\n            _data.append([func(prev[j], prev[j + i]) for j in range(n - 2 * i + 1)])\r\n            i <<= 1\r\n\r\n    def query(self, begin, end):\r\n        depth = (end - begin).bit_length() - 1\r\n        return self.func(self._data[depth][begin], self._data[depth][end - (1 << depth)])\r\n\r\n\r\nclass LCA:\r\n    def __init__(self, root, graph):\r\n        self.time = [-1] * len(graph)\r\n        self.path = [-1] * len(graph)\r\n        P = [-1] * len(graph)\r\n        t = -1\r\n        dfs = [root]\r\n        while dfs:\r\n            node = dfs.pop()\r\n            self.path[t] = P[node]\r\n            self.time[node] = t = t + 1\r\n            for nei in graph[node]:\r\n                if self.time[nei] == -1:\r\n                    P[nei] = node\r\n                    dfs.append(nei)\r\n        self.rmq = RangeQuery(self.time[node] for node in self.path)\r\n\r\n    def __call__(self, a, b):\r\n        if a == b:\r\n            return a\r\n        a = self.time[a]\r\n        b = self.time[b]\r\n        if a > b:\r\n            a, b = b, a\r\n        return self.path[self.rmq.query(a, b)]\r\n    \r\n\r\ndef process(n, G):\r\n    g = [[] for i in range(n)]\r\n    for u, v in G:\r\n        g[u].append(v)\r\n        g[v].append(u)\r\n    \"\"\"\r\n    Step One:\r\n         Generate LCA and size of all subtrees \r\n         rooted at zero.\r\n    \"\"\"\r\n    L = LCA(0, g)\r\n    size = [0 for i in range(n)]\r\n    parent = [None for i in range(n)]\r\n    depth = [[0]]\r\n    parent[0] = -1\r\n    while True:\r\n        next_s = []\r\n        for x in depth[-1]:\r\n            for y in g[x]:\r\n                if parent[y] is None:\r\n                    parent[y] = x\r\n                    next_s.append(y)\r\n        if len(next_s)==0:\r\n            break\r\n        depth.append(next_s)\r\n    while len(depth) > 0:\r\n        for x in depth.pop():\r\n            size[x]+=1\r\n            if parent[x] != -1:\r\n                size[parent[x]]+=size[x]\r\n    seen_yet = [0 for i in range(n+2)]\r\n    \"\"\"\r\n    Step 2:\r\n        answer1[i] = number of pairs with mex >= i\r\n        IE \r\n        number of pairs whose path includes\r\n        everything from 0 to i-1\r\n    \"\"\"\r\n    answer1 = [None for i in range(n+1)]\r\n    \"\"\"\r\n    Step 3:\r\n        answer1[0] = all possible pairs.\r\n    \"\"\"\r\n    answer1[0] = n*(n-1)//2\r\n    \"\"\"\r\n    Step 4:\r\n        answer1[1] = all possible pairs\r\n        except those in the same subtree of 0\r\n    \"\"\"\r\n    answer1[1] = n*(n-1)//2\r\n    for x in g[0]:\r\n        s1 = size[x]\r\n        answer1[1]-=(s1*(s1-1))//2\r\n    \"\"\"\r\n    Step 5:\r\n        answer1[2] = all possible pairs\r\n        where one is a descendant of 1\r\n        and the other is a descendant of 0\r\n        (but on another subtree)\r\n    \"\"\"\r\n    path = [1]\r\n    while path[-1] != 0:\r\n        x = path[-1]\r\n        path.append(parent[x])\r\n    s1 = size[1]\r\n    s0 = 1\r\n    for x in g[0]:\r\n        if x != path[-2]:\r\n            s0+=size[x]\r\n    answer1[2] = s1*s0\r\n    \"\"\"\r\n    Step 6:\r\n        Everything on the path from 1 to 0\r\n        if we have say, 2, 3, 4, 5\r\n        then they are the same as 2\r\n    \"\"\"\r\n    for x in path:\r\n        seen_yet[x] = 1\r\n    smallest_unseen = 1\r\n    while seen_yet[smallest_unseen]==1:\r\n        answer1[smallest_unseen+1] = answer1[2]\r\n        smallest_unseen+=1\r\n    \r\n    \"\"\"\r\n    Step 7:\r\n        we have a path from 1 to 0\r\n        that also contains\r\n        2, ..., I-1, if anything\r\n        \r\n        find the first my_mex after that\r\n        such that my_mex-1 is not a descendant of 1\r\n        \r\n        or on that series of paths.\r\n    \"\"\"\r\n    p1 = 0\r\n    p2 = 1\r\n    \"\"\"\r\n    Step 8:\r\n        Similar but now separate subtrees.\r\n    \"\"\"\r\n    last_bad = None\r\n    while smallest_unseen <= n-1:\r\n        if answer1[smallest_unseen+1] is None:\r\n            if L(smallest_unseen, p2)==p2:\r\n                path = [smallest_unseen]\r\n                while path[-1] != p2:\r\n                    x2 = path[-1]\r\n                    path.append(parent[x2])\r\n                s1 = size[smallest_unseen]\r\n                if p1==0:\r\n                    s2 = s0\r\n                else:\r\n                    s2 = size[p1]\r\n                for x2 in path:\r\n                    seen_yet[x2] = 1\r\n                p2 = smallest_unseen\r\n                while seen_yet[smallest_unseen]==1:\r\n                    answer1[smallest_unseen+1] = s1*s2\r\n                    smallest_unseen+=1\r\n            elif L(smallest_unseen, p1)==p1 and (p1 > 0 or L(smallest_unseen, p2)==p1):\r\n                path = [smallest_unseen]\r\n                while path[-1] != p1:\r\n                    x2 = path[-1]\r\n                    path.append(parent[x2])\r\n                s1 = size[smallest_unseen]\r\n                s2 = size[p2]\r\n                p1 = smallest_unseen\r\n                for x2 in path:\r\n                    seen_yet[x2] = 1\r\n                while seen_yet[smallest_unseen]==1:\r\n                    answer1[smallest_unseen+1] = s1*s2\r\n                    smallest_unseen+=1\r\n            else:\r\n                last_bad = smallest_unseen+1\r\n                break\r\n    if last_bad is not None:\r\n        for i in range(last_bad, n+1):\r\n            answer1[i] = 0\r\n    answer = [None for i in range(n+1)]\r\n    for i in range(n):\r\n        answer[i] = answer1[i]-answer1[i+1]\r\n    answer[n] = answer1[n]\r\n    answer = ' '.join(map(str, answer))\r\n    sys.stdout.write(f'{answer}\\n')\r\n            \r\n    \r\nt = int(input())\r\nfor i in range(t):\r\n    n = int(input())\r\n    G = []\r\n    for i in range(n-1):\r\n        u, v = [int(x) for x in input().split()]\r\n        G.append([u, v])\r\n    process(n, G)",
    "prob_desc_created_at": "1621521300",
    "tags": [
        "combinatorics",
        "dfs and similar",
        "implementation",
        "math",
        "trees"
    ],
    "hidden_unit_tests": ""
}
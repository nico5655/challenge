{
    "prob_desc_time_limit": "1 second",
    "prob_desc_sample_outputs": "[\"8\\n42\"]",
    "src_uid": "5aa709f292f266799f177b174c8bc14b",
    "prob_desc_notes": "NoteIn the first test case we can, for example, obtain the following nice matrix in $$$8$$$ operations:2 24 44 42 2In the second test case we can, for example, obtain the following nice matrix in $$$42$$$ operations:5 6 6 56 6 6 65 6 6 5",
    "prob_desc_description": "A matrix of size $$$n \\times m$$$ is called nice, if all rows and columns of the matrix are palindromes. A sequence of integers $$$(a_1, a_2, \\dots , a_k)$$$ is a palindrome, if for any integer $$$i$$$ ($$$1 \\le i \\le k$$$) the equality $$$a_i = a_{k - i + 1}$$$ holds.Sasha owns a matrix $$$a$$$ of size $$$n \\times m$$$. In one operation he can increase or decrease any number in the matrix by one. Sasha wants to make the matrix nice. He is interested what is the minimum number of operations he needs.Help him!",
    "prob_desc_output_spec": "For each test output the smallest number of operations required to make the matrix nice.",
    "prob_desc_input_spec": "The first line contains a single integer $$$t$$$ — the number of test cases ($$$1 \\le t \\le 10$$$). The $$$t$$$ tests follow. The first line of each test contains two integers $$$n$$$ and $$$m$$$ ($$$1 \\le n, m \\le 100$$$) — the size of the matrix. Each of the next $$$n$$$ lines contains $$$m$$$ integers $$$a_{i, j}$$$ ($$$0 \\le a_{i, j} \\le 10^9$$$) — the elements of the matrix.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "Python 3",
    "lang_cluster": "Python",
    "difficulty": 1300,
    "file_name": "train_005.jsonl",
    "code_uid": "1880f4b48edc5dfafe5bf513d38ea703",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"2\\n4 2\\n4 2\\n2 4\\n4 2\\n2 4\\n3 4\\n1 2 3 4\\n5 6 7 8\\n9 10 11 18\"]",
    "exec_outcome": "PASSED",
    "source_code": "##############--->>>>> Deepcoder Amit Kumar Bhuyan <<<<<---##############\n\n\"\"\"\n Perfection is achieved not when there is nothing more to add, but rather when there is nothing more to take away.\n\"\"\"\nfrom __future__ import division, print_function\n \nimport os,sys\nfrom io import BytesIO, IOBase\n \nif sys.version_info[0] < 3:\n    from __builtin__ import xrange as range\n    from future_builtins import ascii, filter, hex, map, oct, zip\n \n \ndef ii():  return int(input())\ndef si():  return input()\ndef mi():  return map(int,input().strip().split(\" \"))\ndef msi(): return map(str,input().strip().split(\" \"))\ndef li():  return list(mi())\n \ndef dmain():\n    sys.setrecursionlimit(1000000)\n    threading.stack_size(1024000)\n    thread = threading.Thread(target=main)\n    thread.start()\n    \n#from collections import deque, Counter, OrderedDict,defaultdict\n#from heapq import nsmallest, nlargest, heapify,heappop ,heappush, heapreplace\n#from math import log,sqrt,factorial,cos,tan,sin,radians\n#from bisect import bisect,bisect_left,bisect_right,insort,insort_left,insort_right\n#from decimal import *\n#import threading\n#from itertools import permutations\n#Copy 2D list  m = [x[:] for x in mark] .. Avoid Using Deepcopy\nimport sys\ninput = sys.stdin.readline\nscanner = lambda: int(input())\nstring = lambda: input().rstrip()\nget_list = lambda: list(read())\nread = lambda: map(int, input().split())\nget_float = lambda: map(float, input().split())\n# from bisect import bisect_left as lower_bound;\n# from bisect import bisect_right as upper_bound;\n# from math import ceil, factorial;\n\n \ndef ceil(x):\n    if x != int(x):\n        x = int(x) + 1\n    return x\n \ndef factorial(x, m):\n\tval = 1\n\twhile x>0:\n\t\tval = (val * x) % m\n\t\tx -= 1\n\treturn val\n\ndef fact(x):\n\tval = 1\n\twhile x > 0:\n\t\tval *= x\n\t\tx -= 1\n\treturn val\n    \n# swap_array function\ndef swaparr(arr, a,b):\n    temp = arr[a];\n    arr[a] = arr[b];\n    arr[b] = temp;\n \n## gcd function\ndef gcd(a,b):\n    if b == 0:\n        return a;\n    return gcd(b, a % b);\n\n## lcm function\ndef lcm(a, b):\n\treturn (a * b) // math.gcd(a, b)\n\ndef is_integer(n):\n\treturn math.ceil(n) == math.floor(n)\n \n## nCr function efficient using Binomial Cofficient\ndef nCr(n, k): \n\tif k > n:\n\t\treturn 0\n\tif(k > n - k):\n\t\tk = n - k\n\tres = 1\n\tfor i in range(k):\n\t\tres = res * (n - i)\n\t\tres = res / (i + 1)\n\treturn int(res)\n \n## upper bound function code -- such that e in a[:i] e < x;\n\n \n## prime factorization\ndef primefs(n):\n    ## if n == 1    ## calculating primes\n    primes = {}\n    while(n%2 == 0 and n > 0):\n        primes[2] = primes.get(2, 0) + 1\n        n = n//2\n    for i in range(3, int(n**0.5)+2, 2):\n        while(n%i == 0 and n > 0):\n            primes[i] = primes.get(i, 0) + 1\n            n = n//i\n    if n > 2:\n        primes[n] = primes.get(n, 0) + 1\n    ## prime factoriazation of n is stored in dictionary\n    ## primes and can be accesed. O(sqrt n)\n    return primes\n \n## MODULAR EXPONENTIATION FUNCTION\ndef power(x, y, p): \n    res = 1\n    x = x % p  \n    if (x == 0) : \n        return 0\n    while (y > 0) : \n        if ((y & 1) == 1) : \n            res = (res * x) % p \n        y = y >> 1      \n        x = (x * x) % p \n    return res \n \n## DISJOINT SET UNINON FUNCTIONS\ndef swap(a,b):\n    temp = a\n    a = b\n    b = temp\n    return a,b;\n \n# find function with path compression included (recursive)\n# def find(x, link):\n#     if link[x] == x:\n#         return x\n#     link[x] = find(link[x], link);\n#     return link[x];\n \n# find function with path compression (ITERATIVE)\ndef find(x, link):\n    p = x;\n    while( p != link[p]):\n        p = link[p];\n    \n    while( x != p):\n        nex = link[x];\n        link[x] = p;\n        x = nex;\n    return p;\n \n \n# the union function which makes union(x,y)\n# of two nodes x and y\ndef union(x, y, link, size):\n    x = find(x, link)\n    y = find(y, link)\n    if size[x] < size[y]:\n        x,y = swap(x,y)\n    if x != y:\n        size[x] += size[y]\n        link[y] = x\n \n## returns an array of boolean if primes or not USING SIEVE OF ERATOSTHANES\ndef sieve(n): \n    prime = [True for i in range(n+1)] \n    prime[0], prime[1] = False, False\n    p = 2\n    while (p * p <= n): \n        if (prime[p] == True): \n            for i in range(p * p, n+1, p):\n                prime[i] = False\n        p += 1\n    return prime\n\n# Euler's Toitent Function phi\ndef phi(n) : \n  \n    result = n \n    p = 2\n    while(p * p<= n) : \n        if (n % p == 0) : \n            while (n % p == 0) : \n                n = n // p \n            result = result * (1.0 - (1.0 / (float) (p))) \n        p = p + 1\n    if (n > 1) : \n        result = result * (1.0 - (1.0 / (float)(n))) \n   \n    return (int)(result) \n\ndef is_prime(n):\n\tif n == 0:\n\t\treturn False\n\tif n == 1:\n\t\treturn True\n\tfor i in range(2, int(n ** (1 / 2)) + 1):\n\t\tif not n % i:\n\t\t\treturn False\n \n\treturn True\n\ndef next_prime(n, primes):\n\twhile primes[n] != True:\n\t\tn += 1\n\treturn n\n\n \n#### PRIME FACTORIZATION IN O(log n) using Sieve ####\nMAXN = int(1e5 + 5)\ndef spf_sieve():\n    spf[1] = 1;\n    for i in range(2, MAXN):\n        spf[i] = i;\n    for i in range(4, MAXN, 2):\n        spf[i] = 2;\n    for i in range(3, ceil(MAXN ** 0.5), 2):\n        if spf[i] == i:\n            for j in range(i*i, MAXN, i):\n                if spf[j] == j:\n                    spf[j] = i;\n    ## function for storing smallest prime factors (spf) in the array\n \n################## un-comment below 2 lines when using factorization #################\nspf = [0 for i in range(MAXN)]\n# spf_sieve();\ndef factoriazation(x):\n    res = []\n    for i in range(2, int(x ** 0.5) + 1):\n    \twhile x % i == 0:\n    \t\tres.append(i)\n    \t\tx //= i\n    if x != 1:\n   \t\tres.append(x)\n    return res\n    ## this function is useful for multiple queries only, o/w use\n    ## primefs function above. complexity O(log n)\n\ndef factors(n):\n\tres = []\n\tfor i in range(1, int(n ** 0.5) + 1):\n\t\tif n % i == 0:\n\t\t\tres.append(i)\n\t\t\tres.append(n // i)\n\treturn list(set(res))\n \n## taking integer array input\ndef int_array():\n    return list(map(int, input().strip().split()));\n \ndef float_array():\n    return list(map(float, input().strip().split()));\n \n## taking string array input\ndef str_array():\n    return input().strip().split();\n\ndef binary_search(low, high, w, h, n):\n\twhile low < high:\n\t\tmid = low + (high - low) // 2\n\t\t# print(low, mid, high)\n\t\tif check(mid, w, h, n):\n\t\t\tlow = mid + 1\n\t\telse:\n\t\t\thigh = mid\n\treturn low\n\n## for checking any conditions\ndef check(moves, n):\n\tval = (moves + 1) // 2\n\trem = moves - val\n\tsol = (val + 1) * (rem + 1)\n\treturn sol < n\n\t\n\n## for sorting according to second position\ndef sortSecond(val):\n\treturn val[1]\n\t\n\n \n#defining a couple constants\nMOD = int(1e9)+7;\nCMOD = 998244353;\nINF = float('inf'); NINF = -float('inf');\nalphs = \"abcdefghijklmnopqrstuvwxyz\"\n \n################### ---------------- TEMPLATE ENDS HERE ---------------- ###################\n \nfrom itertools import permutations\nimport math\nimport bisect as bis\nimport random\nimport sys\nimport collections as collect\nimport functools as fnt\n# from sys import stdout\n# import numpy as np\n\"\"\"\n_______________\nrough work here\n_______________\n\nn x m => nice\n8 6 6 8\n6 6 6 6\n\n8 6 6 8\n\n\"\"\"\n\ndef solve():\n    n, m = read()\n    a = [get_list() for x in range(n)]\n    s = 0\n    for i in range(n):\n        for j in range(m):\n            b = [a[i][j], a[i][m - j - 1], a[n - i - 1][j]]\n            b.sort()\n            a[i][j] = a[i][m - j - 1] = a[n - i - 1][j] = b[1]\n            s += b[2] - b[1] + b[1] - b[0]\n    print(s)\n\n\n\n    \n\n\n\n\n# region fastio\n# template taken from https://github.com/cheran-senthil/PyRival/blob/master/templates/template.py\n \nBUFSIZE = 8192\n \n \nclass FastIO(IOBase):\n    newlines = 0\n \n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n \n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n \n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n \n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n \n \nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n \n \ndef print(*args, **kwargs):\n    \"\"\"Prints the values to a stream, or to sys.stdout by default.\"\"\"\n    sep, file = kwargs.pop(\"sep\", \" \"), kwargs.pop(\"file\", sys.stdout)\n    at_start = True\n    for x in args:\n        if not at_start:\n            file.write(sep)\n        file.write(str(x))\n        at_start = False\n    file.write(kwargs.pop(\"end\", \"\\n\"))\n    if kwargs.pop(\"flush\", False):\n        file.flush()\n \n \nif sys.version_info[0] < 3:\n    sys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)\nelse:\n    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\n \ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n \n# endregion\n \n \nif __name__ == \"__main__\":\n    #read()\n    # sys.stdin = open(\"input.txt\", \"r\")\n    # sys.stdout = open(\"output.txt\", \"w\")\n    t = scanner()\n    for i in range(t):\n    \tsolve()\n    #dmain()\n \n# Comment Read()\n\t# fin_time = datetime.now()\n# \tprint(\"Execution time (for loop): \", (fin_time-init_time))\n",
    "prob_desc_created_at": "1601827500",
    "tags": [
        "implementation",
        "greedy",
        "math"
    ],
    "hidden_unit_tests": ""
}
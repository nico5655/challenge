{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"0\", \"7\"]",
    "src_uid": "4400a330ace0af1baa0ad521bfa677ad",
    "prob_desc_notes": "NoteIn the first sample test it is optimal to play the first note on the first string, the second note on the second string, the third note on the sixth string, the fourth note on the fourth string, the fifth note on the fifth string, and the sixth note on the third string. In this case the $$$100$$$-th fret is used each time, so the difference is $$$100 - 100 = 0$$$.  In the second test it's optimal, for example, to play the second note on the first string, and all the other notes on the sixth string. Then the maximal fret will be $$$10$$$, the minimal one will be $$$3$$$, and the answer is $$$10 - 3 = 7$$$.  ",
    "prob_desc_description": "After battling Shikamaru, Tayuya decided that her flute is too predictable, and replaced it with a guitar. The guitar has $$$6$$$ strings and an infinite number of frets numbered from $$$1$$$. Fretting the fret number $$$j$$$ on the $$$i$$$-th string produces the note $$$a_{i} + j$$$.Tayuya wants to play a melody of $$$n$$$ notes. Each note can be played on different string-fret combination. The easiness of performance depends on the difference between the maximal and the minimal indices of used frets. The less this difference is, the easier it is to perform the technique. Please determine the minimal possible difference.For example, if $$$a = [1, 1, 2, 2, 3, 3]$$$, and the sequence of notes is $$$4, 11, 11, 12, 12, 13, 13$$$ (corresponding to the second example), we can play the first note on the first string, and all the other notes on the sixth string. Then the maximal fret will be $$$10$$$, the minimal one will be $$$3$$$, and the answer is $$$10 - 3 = 7$$$, as shown on the picture.  ",
    "prob_desc_output_spec": "Print the minimal possible difference of the maximal and the minimal indices of used frets.",
    "prob_desc_input_spec": "The first line contains $$$6$$$ space-separated numbers $$$a_{1}$$$, $$$a_{2}$$$, ..., $$$a_{6}$$$ ($$$1 \\leq a_{i} \\leq 10^{9}$$$) which describe the Tayuya's strings. The second line contains the only integer $$$n$$$ ($$$1 \\leq n \\leq 100\\,000$$$) standing for the number of notes in the melody. The third line consists of $$$n$$$ integers $$$b_{1}$$$, $$$b_{2}$$$, ..., $$$b_{n}$$$ ($$$1 \\leq b_{i} \\leq 10^{9}$$$), separated by space. They describe the notes to be played. It's guaranteed that $$$b_i &gt; a_j$$$ for all $$$1\\leq i\\leq n$$$ and $$$1\\leq j\\leq 6$$$, in other words, you can play each note on any string.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "Python 3",
    "lang_cluster": "Python",
    "difficulty": 1900,
    "file_name": "train_020.jsonl",
    "code_uid": "00ae89e18e76b95f7defa1837e7630e2",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"1 4 100 10 30 5\\n6\\n101 104 105 110 130 200\", \"1 1 2 2 3 3\\n7\\n13 4 11 12 11 13 12\"]",
    "exec_outcome": "PASSED",
    "source_code": "from collections import deque as _deque\nfrom itertools import chain as _chain\nimport sys as _sys\n\n\ndef main():\n    a_seq = tuple(_read_ints())\n    n, = _read_ints()\n    notes = tuple(_read_ints())\n    result = find_minimal_melody_difficulty(a_seq, notes)\n    print(result)\n\n\ndef find_minimal_melody_difficulty(strings_values, notes):\n    strings_values = set(strings_values)\n    strings_values = sorted(strings_values, reverse=True)\n    if len(strings_values) == 1:\n        return max(notes) - min(notes)\n    \n    frets_by_notes_indices = [[note - x for x in strings_values] for note in notes]\n    # frets_by_notes_indices[i_note] is sorted for every correct i_note\n    del strings_values\n    del notes\n    \n    max_from_initially_selected_frets = max(frets[0] for frets in frets_by_notes_indices)\n    for frets in frets_by_notes_indices:\n        i_first_interesting_fret = 0\n        while i_first_interesting_fret + 1 < len(frets) \\\n                and frets[i_first_interesting_fret+1] <= max_from_initially_selected_frets:\n            i_first_interesting_fret += 1\n        frets[:] = frets[i_first_interesting_fret:]\n    \n    selected_frets = [frets[0] for frets in frets_by_notes_indices]\n    selected_frets.sort()\n    selected_frets = _deque(selected_frets)\n    \n    available_selections = _chain.from_iterable(\n        zip(frets[1:], frets[0:])\n        for frets in frets_by_notes_indices\n    )\n    available_selections = sorted(available_selections)\n    \n    # defaultdict(int) is slower\n    frets_to_unselect = dict()\n    for frets in frets_by_notes_indices:\n        for fret in frets:\n            frets_to_unselect[fret] = 0\n    \n    min_selected_fret = selected_frets[0]\n    max_selected_fret = max(selected_frets)\n    result = max_selected_fret - min_selected_fret\n    \n    for new_fret, fret_to_unselect in available_selections:\n        frets_to_unselect[fret_to_unselect] += 1\n        _clean_deque_begin(selected_frets, frets_to_unselect)\n        selected_frets.append(new_fret)\n        \n        min_selected_fret = selected_frets[0]\n        max_selected_fret = new_fret\n        result = min(result, max_selected_fret - min_selected_fret)\n    \n    return result\n\n\ndef _clean_deque_begin(deque, deletions_ns):\n    while deque and deletions_ns[deque[0]] > 0:\n        deleted_element = deque.popleft()\n        deletions_ns[deleted_element] -= 1\n\n\ndef _read_line():\n    result = _sys.stdin.readline()\n    assert result[-1] == \"\\n\"\n    return result[:-1]\n\n\ndef _read_ints():\n    return map(int, _read_line().split())\n\n\nif __name__ == '__main__':\n    main()\n",
    "prob_desc_created_at": "1603623900",
    "tags": [
        "dp",
        "two pointers",
        "implementation",
        "sortings",
        "binary search",
        "brute force"
    ],
    "hidden_unit_tests": ""
}
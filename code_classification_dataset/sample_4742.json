{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"NNOTA\\nAANN\\nAAAAAA\\nTNNTAOOA\"]",
    "src_uid": "f17445aca588e5fbc1dc6a595c811bd6",
    "prob_desc_notes": "NoteFor the first testcase, it takes $$$7$$$ seconds for Anton's body to transform NNOTA to ANTON: NNOTA $$$\\to$$$ NNOAT $$$\\to$$$ NNAOT $$$\\to$$$ NANOT $$$\\to$$$ NANTO $$$\\to$$$ ANNTO $$$\\to$$$ ANTNO $$$\\to$$$ ANTON. Note that you cannot output strings such as AANTON, ANTONTRYGUB, AAAAA and anton as it is not a permutation of ANTON.For the second testcase, it takes $$$2$$$ seconds for Anton's body to transform AANN to NAAN. Note that other strings such as NNAA and ANNA will also be accepted.",
    "prob_desc_description": "After rejecting $$$10^{100}$$$ data structure problems, Errorgorn is very angry at Anton and decided to kill him.Anton's DNA can be represented as a string $$$a$$$ which only contains the characters \"ANTON\" (there are only $$$4$$$ distinct characters). Errorgorn can change Anton's DNA into string $$$b$$$ which must be a permutation of $$$a$$$. However, Anton's body can defend against this attack. In $$$1$$$ second, his body can swap $$$2$$$ adjacent characters of his DNA to transform it back to $$$a$$$. Anton's body is smart and will use the minimum number of moves.To maximize the chance of Anton dying, Errorgorn wants to change Anton's DNA the string that maximizes the time for Anton's body to revert his DNA. But since Errorgorn is busy making more data structure problems, he needs your help to find the best string $$$B$$$. Can you help him?",
    "prob_desc_output_spec": "For each testcase, print a single string, $$$b$$$. If there are multiple answers, you can output any one of them. $$$b$$$ must be a permutation of the string $$$a$$$.",
    "prob_desc_input_spec": "The first line of input contains a single integer $$$t$$$ $$$(1 \\leq t \\leq 100000)$$$ â€” the number of testcases. The first and only line of each testcase contains $$$1$$$ string $$$a$$$ ($$$1 \\leq |a| \\leq 100000$$$). $$$a$$$ consists of only the characters \"A\", \"N\", \"O\" and \"T\". It is guaranteed that the sum of $$$|a|$$$ over all testcases does not exceed $$$100000$$$.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 2",
    "lang_cluster": "Python",
    "difficulty": 2200,
    "file_name": "train_105.jsonl",
    "code_uid": "fe06f76b8f10ce8623638aa7d8174ff4",
    "prob_desc_memory_limit": "512 megabytes",
    "prob_desc_sample_inputs": "[\"4\\nANTON\\nNAAN\\nAAAAAA\\nOAANTTON\"]",
    "exec_outcome": "PASSED",
    "source_code": "from __future__ import division, print_function\r\n\r\nimport os,sys\r\nfrom io import BytesIO, IOBase\r\n\r\nif sys.version_info[0] < 3:\r\n    from __builtin__ import xrange as range\r\n    from future_builtins import ascii, filter, hex, map, oct, zip\r\n\r\nfrom bisect import bisect_left as lower_bound, bisect_right as upper_bound \r\ndef so():  return int(input())\r\ndef st():  return input()\r\ndef mj():  return map(int,input().strip().split(\" \"))\r\ndef msj(): return list(map(str,input().strip().split(\" \")))\r\ndef le():  return list(map(int,input().split()))\r\ndef rc():  return map(float,input().split())\r\ndef lebe():return list(map(int, input()))\r\n\r\ndef dmain():\r\n    sys.setrecursionlimit(1000000)\r\n    threading.stack_size(1024000)\r\n    thread = threading.Thread(target=main)\r\n    thread.start()\r\ndef joro(L):\r\n    return(''.join(map(str, L)))\r\ndef joron(L):\r\n    return('\\n'.join(map(str, L)))\r\n\r\ndef decimalToBinary(n): return bin(n).replace(\"0b\",\"\")\r\n\r\n\r\ndef isprime(n):\r\n    for i in range(2,int(n**0.5)+1):\r\n        if n%i==0:\r\n            return False\r\n    return True\r\ndef npr(n, r):\r\n    return factorial(n) // factorial(n - r) if n >= r else 0\r\n \r\n \r\ndef ncr(n, r):\r\n    return factorial(n) // (factorial(r) * factorial(n - r)) if n >= r else 0\r\n \r\n \r\ndef lower_bound(li, num):\r\n    answer = -1\r\n    start = 0\r\n    end = len(li) - 1\r\n \r\n    while (start <= end):\r\n        middle = (end + start) // 2\r\n        if li[middle] >= num:\r\n            answer = middle\r\n            end = middle - 1\r\n        else:\r\n            start = middle + 1\r\n    return answer  # min index where x is not less than num\r\n \r\n \r\ndef upper_bound(li, num):\r\n    answer = -1\r\n    start = 0\r\n    end = len(li) - 1\r\n \r\n    while (start <= end):\r\n        middle = (end + start) // 2\r\n \r\n        if li[middle] <= num:\r\n            answer = middle\r\n            start = middle + 1\r\n \r\n        else:\r\n            end = middle - 1\r\n    return answer  # max index where x is not greater than num\r\ndef tir(a,b,c):\r\n    if(0==c):\r\n        return 1\r\n    if(len(a)<=b):\r\n        return 0\r\n    \r\n    if(c!=-1):\r\n        return (tir(a,1+b,c+a[b]) or tir(a,b+1,c-a[b]) or tir(a,1+b,c)) \r\n        \r\n        \r\n    else:\r\n        return (tir(a,1+b,a[b]) or tir(a,b+1,-a[b]) or tir(a,1+b,-1))\r\n   \r\n \r\ndef abs(x):\r\n    return x if x >= 0 else -x\r\n \r\n \r\ndef binary_search(li, val, lb, ub):\r\n    # print(lb, ub, li)\r\n    ans = -1\r\n    while (lb <= ub):\r\n        mid = (lb + ub) // 2\r\n        # print('mid is',mid, li[mid])\r\n        if li[mid] > val:\r\n            ub = mid - 1\r\n        elif val > li[mid]:\r\n            lb = mid + 1\r\n        else:\r\n            ans = mid  # return index\r\n            break\r\n    return ans\r\n \r\n \r\ndef kadane(x):  # maximum sum contiguous subarray\r\n    sum_so_far = 0\r\n    current_sum = 0\r\n    for i in x:\r\n        current_sum += i\r\n        if current_sum < 0:\r\n            current_sum = 0\r\n        else:\r\n            sum_so_far = max(sum_so_far, current_sum)\r\n    return sum_so_far\r\n\r\n                    \r\ndef pref(li):\r\n    pref_sum = [0]\r\n    for i in li:\r\n        pref_sum.append(pref_sum[-1] + i)\r\n    return pref_sum\r\n \r\n\r\n        \r\n        \r\ndef SieveOfEratosthenes(n):\r\n    prime = [True for i in range(n + 1)]\r\n    p = 2\r\n    li = []\r\n    while (p * p <= n):\r\n        if (prime[p] == True):\r\n            for i in range(p * p, n + 1, p):\r\n                prime[i] = False\r\n        p += 1\r\n \r\n    for p in range(2, len(prime)):\r\n        if prime[p]:\r\n            li.append(p)\r\n    return li\r\n \r\n \r\ndef primefactors(n):\r\n    factors = []\r\n    while (n % 2 == 0):\r\n        factors.append(2)\r\n        n //= 2\r\n    for i in range(3, int(sqrt(n)) + 1, 2):  # only odd factors left\r\n        while n % i == 0:\r\n            factors.append(i)\r\n            n //= i\r\n    if n > 2:  # incase of prime\r\n        factors.append(n)\r\n    return factors\r\n         \r\n    \r\ndef read():\r\n    sys.stdin  = open('input.txt', 'r')  \r\n    sys.stdout = open('output.txt', 'w') \r\ndef tr(n):\r\n    return n*(n+1)//2\r\nboi=int(998244353)\r\ndoi=int(1e9+7)\r\nhoi=int(1e5+50)\r\npoi=int(10+2**20)\r\ny=\"YES\"\r\nn=\"NO\"\r\ndef gosa(x, y): \r\n  \r\n   while(y): \r\n       x, y = y, x % y \r\n  \r\n   return x\r\nL=[0]*hoi\r\nM=[0]*hoi\r\n\r\n\r\n        \r\n        \r\n\r\n\r\n            \r\n\r\ndef bulli(x):\r\n    return bin(x).count('1')\r\n\r\n\r\n\r\n\r\n        \r\n    \r\n    \r\n        \r\n\r\n\r\n\r\n\r\n            \r\ndef iu():\r\n    import sys\r\n    import math as my\r\n    import functools\r\n    input=sys.stdin.readline\r\n    from collections import deque, defaultdict\r\n    bec=-1\r\n    e=[]\r\n    t=list(st())\r\n    de=\"\"\r\n    U=[]\r\n    V=[]\r\n    zs=defaultdict(int)\r\n    m=len(t)\r\n    for i in range(1,5):\r\n        for j in range(1,5):\r\n            for k in range(1,5):\r\n                for h in range(1,5):\r\n                    if(i!=j and i!=k and h!=i and j!=k and j!=h and h!=k):\r\n                        df=0\r\n                        for p in range(1,6):\r\n                            M[p]=0\r\n                        L[ord('A')]=i\r\n                        L[ord('N')]=j\r\n                        L[ord('T')]=k\r\n                        L[ord('O')]=h\r\n                        for fg in range(1,1+m):\r\n                            df=df+M[L[ord(t[fg-1])]+1]\r\n                            for dg in range(1,1+L[ord(t[fg-1])]):\r\n                                M[dg]=1+M[dg]\r\n                        if(bec<df):\r\n                            pp=i\r\n                            qq=j\r\n                            rr=k\r\n                            ss=h\r\n                            bec=df\r\n    \r\n    L[ord('A')]=pp\r\n    L[ord('N')]=qq\r\n    L[ord('T')]=rr\r\n    L[ord('O')]=ss\r\n    e.append([L[ord('A')],'A'])\r\n    e.append([L[ord('N')],'N'])\r\n    e.append([L[ord('T')],'T'])\r\n    e.append([L[ord('O')],'O'])\r\n    e.sort()\r\n    #print(e)\r\n    for i in e:\r\n      de+=(t.count(i[1]))*i[1]\r\n    print(de)\r\n      \r\n      \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n            \r\n            \r\n    \r\n    \r\n    \r\n            \r\n    \r\n        \r\n        \r\n        \r\ndef main():\r\n    for i in range(so()):\r\n        #print(\"Case #\"+str(i+1)+\": \",end=\"\")\r\n        iu()        \r\n    \r\n    \r\n    \r\n    \r\n        \r\n        \r\n    \r\n        \r\n    \r\n    \r\n            \r\n    \r\n    \r\n    \r\n                \r\n            \r\n            \r\n    \r\n        \r\n\r\n                \r\n    \r\n        \r\n        \r\n\r\n            \r\n                    \r\n                \r\n                    \r\n                    \r\n                    \r\n                    \r\n                    \r\n                    \r\n        \r\n                \r\n        \r\n        \r\n       \r\n    \r\n           \r\n          \r\n          \r\n                \r\n            \r\n        \r\n                \r\n    \r\n        \r\n        \r\n        \r\n       \r\n            \r\n                \r\n        \r\n\r\n\r\n\r\n\r\n# region fastio\r\n# template taken from https://github.com/cheran-senthil/PyRival/blob/master/templates/template.py\r\n\r\nBUFSIZE = 8192\r\n\r\n\r\nclass FastIO(IOBase):\r\n    newlines = 0\r\n\r\n    def __init__(self, file):\r\n        self._fd = file.fileno()\r\n        self.buffer = BytesIO()\r\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\r\n        self.write = self.buffer.write if self.writable else None\r\n\r\n    def read(self):\r\n        while True:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            if not b:\r\n                break\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines = 0\r\n        return self.buffer.read()\r\n\r\n    def readline(self):\r\n        while self.newlines == 0:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            self.newlines = b.count(b\"\\n\") + (not b)\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines -= 1\r\n        return self.buffer.readline()\r\n\r\n    def flush(self):\r\n        if self.writable:\r\n            os.write(self._fd, self.buffer.getvalue())\r\n            self.buffer.truncate(0), self.buffer.seek(0)\r\n\r\n\r\nclass IOWrapper(IOBase):\r\n    def __init__(self, file):\r\n        self.buffer = FastIO(file)\r\n        self.flush = self.buffer.flush\r\n        self.writable = self.buffer.writable\r\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\r\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\r\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\r\n\r\n\r\ndef print(*args, **kwargs):\r\n    \"\"\"Prints the values to a stream, or to sys.stdout by default.\"\"\"\r\n    sep, file = kwargs.pop(\"sep\", \" \"), kwargs.pop(\"file\", sys.stdout)\r\n    at_start = True\r\n    for x in args:\r\n        if not at_start:\r\n            file.write(sep)\r\n        file.write(str(x))\r\n        at_start = False\r\n    file.write(kwargs.pop(\"end\", \"\\n\"))\r\n    if kwargs.pop(\"flush\", False):\r\n        file.flush()\r\n\r\n\r\nif sys.version_info[0] < 3:\r\n    sys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)\r\nelse:\r\n    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\r\n\r\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\r\n\r\n# endregion\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    #read()\r\n    main()\r\n    #dmain()\r\n\r\n# Comment Read()",
    "prob_desc_created_at": "1622210700",
    "tags": [
        "brute force",
        "constructive algorithms",
        "data structures",
        "math",
        "strings"
    ],
    "hidden_unit_tests": ""
}
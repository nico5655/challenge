{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"YES\\nNO\\nNO\\nNO\\nYES\\nYES\"]",
    "src_uid": "19f12c275f2b389ed5a1af66808d1bbd",
    "prob_desc_notes": null,
    "prob_desc_description": "There is a grid, consisting of $$$n$$$ rows and $$$m$$$ columns. The rows are numbered from $$$1$$$ to $$$n$$$ from bottom to top. The columns are numbered from $$$1$$$ to $$$m$$$ from left to right. The $$$i$$$-th column has the bottom $$$a_i$$$ cells blocked (the cells in rows $$$1, 2, \\dots, a_i$$$), the remaining $$$n - a_i$$$ cells are unblocked.A robot is travelling across this grid. You can send it commands — move up, right, down or left. If a robot attempts to move into a blocked cell or outside the grid, it explodes.However, the robot is broken — it executes each received command $$$k$$$ times. So if you tell it to move up, for example, it will move up $$$k$$$ times ($$$k$$$ cells). You can't send it commands while the robot executes the current one.You are asked $$$q$$$ queries about the robot. Each query has a start cell, a finish cell and a value $$$k$$$. Can you send the robot an arbitrary number of commands (possibly, zero) so that it reaches the finish cell from the start cell, given that it executes each command $$$k$$$ times?The robot must stop in the finish cell. If it visits the finish cell while still executing commands, it doesn't count.",
    "prob_desc_output_spec": "For each query, print \"YES\" if you can send the robot an arbitrary number of commands (possibly, zero) so that it reaches the finish cell from the start cell, given that it executes each command $$$k$$$ times. Otherwise, print \"NO\".",
    "prob_desc_input_spec": "The first line contains two integers $$$n$$$ and $$$m$$$ ($$$1 \\le n \\le 10^9$$$; $$$1 \\le m \\le 2 \\cdot 10^5$$$) — the number of rows and columns of the grid. The second line contains $$$m$$$ integers $$$a_1, a_2, \\dots, a_m$$$ ($$$0 \\le a_i \\le n$$$) — the number of blocked cells on the bottom of the $$$i$$$-th column. The third line contains a single integer $$$q$$$ ($$$1 \\le q \\le 2 \\cdot 10^5$$$) — the number of queries. Each of the next $$$q$$$ lines contain five integers $$$x_s, y_s, x_f, y_f$$$ and $$$k$$$ ($$$a[y_s] &lt; x_s \\le n$$$; $$$1 \\le y_s \\le m$$$; $$$a[y_f] &lt; x_f \\le n$$$; $$$1 \\le y_f \\le m$$$; $$$1 \\le k \\le 10^9$$$) — the row and the column of the start cell, the row and the column of the finish cell and the number of times each your command is executed. The start and the finish cell of each query are unblocked.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3-64",
    "lang_cluster": "Python",
    "difficulty": 1700,
    "file_name": "train_090.jsonl",
    "code_uid": "093cc368f2568b7d5dda1edc6a20e3bb",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"11 10\\n9 0 0 10 3 4 8 11 10 8\\n6\\n1 2 1 3 1\\n1 2 1 3 2\\n4 3 4 5 2\\n5 3 11 5 3\\n5 3 11 5 2\\n11 9 9 10 1\"]",
    "exec_outcome": "PASSED",
    "source_code": "# stdin = open(\"testcase.txt\")\n \n# def input():\n# \treturn stdin.readline().strip()\n \n \n# import io, os\n# import sys\n \n # sys.stdout.write(str( (n-1)*(n-2) + 1 ) + \"\\n\")\n# input = io.BytesIO(os.read(0, \\\n#          os.fstat(0).st_size)).readline\nfrom math import log, ceil\n# # import sys\n# import sys\n# sys.setrecursionlimit(10000)\nfrom sys import stdin, stdout\n \n# from collections import Counter, defaultdict\n# from queue import PriorityQueue\n# from bisect import bisect_left, bisect_right\n# mod = 1000000007\n \ninput = stdin.readline\n \ndef integer_list():\n\treturn list(map(int, input().split()))\n \n# def string_list():\n# \treturn list(map(str, input().split()))\n \n# def hetro_list():\n# \treturn list(input().split())\ndef segment_tree_build(a: list, n: int):\n\tglobal tree\n \n\t# assign values to leaves of the segment tree\n\tfor i in range(n):\n\t\ttree[n + i] = a[i]\n \n\t# assign values to internal nodes\n\t# to compute maximum in a given range */\n\tfor i in range(n - 1, 0, -1):\n\t\ttree[i] = max(tree[2 * i], tree[2 * i + 1])\n \n \n \n \n \ndef range_query(left: int, right: int, n: int) -> int:\n\tglobal tree\n \n\t# Basically the left and right indices will move\n\t# towards right and left respectively and with\n\t# every each next higher level and compute the\n\t# maximum at each height.\n\t# change the index to leaf node first\n\tleft += n\n\tright += n\n \n\t# initialize maximum to a very low value\n\tma = -1\n\twhile left < right:\n \n\t\t# if left index in odd\n\t\tif left & 1:\n\t\t\t\n\t\t\tma = max(ma, tree[left])\n\t\t\tleft += 1\n \n\t\t# make left index even\n \n \n\t\t# if right index in odd\n\t\tif right & 1:\n \n\t\t# make right index even\n\t\t\tright -= 1\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n \n\t\t\tma = max(ma, tree[right])\n \n\t\t# move to the next higher level\n\t\tleft //= 2\n\t\tright //= 2\n\treturn ma\n \n \n \nfor _ in range(1):\n\tn, m = integer_list()\n \n\tlst = integer_list()\n \n\ttree = [0]*(2*m)\n\tsegment_tree_build(lst, m)\n \n \n \n \n\tq = int(input())\n\tfor j in range(q):\n\t\tx1 , y1 , x2 , y2 , k = integer_list()\n \n\t\txs , ys = x1 , y1\n\t\ty1 , y2 = min(y1 , y2) , max(y1 , y2)\n\t\tx1 , x2 = min(x1 , x2) , max(x1 , x2)\n \n\t\tif((x2 - x1) % k):\n\t\t\tstdout.write('NO' + \"\\n\")\n\t\t\tcontinue\n\t\tif((y2 - y1) % k):\n\t\t\tstdout.write('NO' + \"\\n\")\n\t\t\tcontinue\n \n\t\tbound = xs + k * ((n - xs) // k)\n\t\t\n\t\tif range_query(y1-1, y2, m) < bound:\n\t\t\tstdout.write('YES' + \"\\n\")\n\t\t\t\n\t\telse:\n\t\t\tstdout.write('NO' + \"\\n\")\n \n \n ",
    "prob_desc_created_at": "1658414100",
    "tags": [
        "binary search",
        "data structures",
        "greedy",
        "math"
    ],
    "hidden_unit_tests": ""
}
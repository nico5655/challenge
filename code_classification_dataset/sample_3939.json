{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"1 \\n-1\\n2 1 3 \\n1 2 4 3 5 6 \\n3 2 1\"]",
    "src_uid": "7197b4a353ecb25cfad80726f6868fe3",
    "prob_desc_notes": "NoteFor the first and second test, the list of almost sorted permutations with $$$n = 1$$$ is $$$\\{[1]\\}$$$.For the third and fifth test, the list of almost sorted permutations with $$$n = 3$$$ is $$$\\{[1, 2, 3], [1, 3, 2], [2, 1, 3], [3, 2, 1]\\}$$$.",
    "prob_desc_description": "Seiji Maki doesn't only like to observe relationships being unfolded, he also likes to observe sequences of numbers, especially permutations. Today, he has his eyes on almost sorted permutations.A permutation $$$a_1, a_2, \\dots, a_n$$$ of $$$1, 2, \\dots, n$$$ is said to be almost sorted if the condition $$$a_{i + 1} \\ge a_i - 1$$$ holds for all $$$i$$$ between $$$1$$$ and $$$n - 1$$$ inclusive.Maki is considering the list of all almost sorted permutations of $$$1, 2, \\dots, n$$$, given in lexicographical order, and he wants to find the $$$k$$$-th permutation in this list. Can you help him to find such permutation?Permutation $$$p$$$ is lexicographically smaller than a permutation $$$q$$$ if and only if the following holds: in the first position where $$$p$$$ and $$$q$$$ differ, the permutation $$$p$$$ has a smaller element than the corresponding element in $$$q$$$.",
    "prob_desc_output_spec": "For each test case, print a single line containing the $$$k$$$-th almost sorted permutation of length $$$n$$$ in lexicographical order, or $$$-1$$$ if it doesn't exist.",
    "prob_desc_input_spec": "The first line contains a single integer $$$t$$$ ($$$1\\le t\\le 1000$$$) â€” the number of test cases. Each test case consists of a single line containing two integers $$$n$$$ and $$$k$$$ ($$$1 \\le n \\le 10^5$$$, $$$1 \\le k \\le 10^{18}$$$). It is guaranteed that the sum of $$$n$$$ over all test cases does not exceed $$$10^5$$$.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3",
    "lang_cluster": "Python",
    "difficulty": 1800,
    "file_name": "train_087.jsonl",
    "code_uid": "6b7f8305d2427338e811acb2f83b889c",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"5\\n1 1\\n1 2\\n3 3\\n6 5\\n3 4\"]",
    "exec_outcome": "PASSED",
    "source_code": "import os\r\nimport sys\r\nfrom io import BytesIO, IOBase\r\nfrom collections import Counter\r\nimport math as mt\r\nimport random\r\n\r\nBUFSIZE = 8192\r\n\r\n\r\nclass FastIO(IOBase):\r\n    newlines = 0\r\n\r\n    def __init__(self, file):\r\n        self._fd = file.fileno()\r\n        self.buffer = BytesIO()\r\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\r\n        self.write = self.buffer.write if self.writable else None\r\n\r\n    def read(self):\r\n        while True:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            if not b:\r\n                break\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines = 0\r\n        return self.buffer.read()\r\n\r\n    def readline(self):\r\n        while self.newlines == 0:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            self.newlines = b.count(b\"\\n\") + (not b)\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines -= 1\r\n        return self.buffer.readline()\r\n\r\n    def flush(self):\r\n        if self.writable:\r\n            os.write(self._fd, self.buffer.getvalue())\r\n            self.buffer.truncate(0), self.buffer.seek(0)\r\n\r\n\r\nclass IOWrapper(IOBase):\r\n    def __init__(self, file):\r\n        self.buffer = FastIO(file)\r\n        self.flush = self.buffer.flush\r\n        self.writable = self.buffer.writable\r\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\r\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\r\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\r\n\r\n\r\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\r\n\r\n\r\ndef gcd(a, b):\r\n    if a == 0:\r\n        return b\r\n    return gcd(b % a, a)\r\n\r\n\r\ndef lcm(a, b):\r\n    return (a * b) / gcd(a, b)\r\n\r\n\r\nmod = int(1e9) + 7\r\n\r\n\r\ndef power(k, n):\r\n    if n == 0:\r\n        return 1\r\n    if n % 2:\r\n        return (power(k, n - 1) * k) % mod\r\n    t = power(k, n // 2)\r\n    return (t * t) % mod\r\n\r\n\r\ndef totalPrimeFactors(n):\r\n    count = 0\r\n    if (n % 2) == 0:\r\n        count += 1\r\n        while (n % 2) == 0:\r\n            n //= 2\r\n\r\n    i = 3\r\n    while i * i <= n:\r\n        if (n % i) == 0:\r\n            count += 1\r\n            while (n % i) == 0:\r\n                n //= i\r\n        i += 2\r\n    if n > 2:\r\n        count += 1\r\n    return count\r\n\r\n\r\n# #MAXN = int(1e7 + 1)\r\n# # spf = [0 for i in range(MAXN)]\r\n#\r\n#\r\n# def sieve():\r\n#     spf[1] = 1\r\n#     for i in range(2, MAXN):\r\n#         spf[i] = i\r\n#     for i in range(4, MAXN, 2):\r\n#         spf[i] = 2\r\n#\r\n#     for i in range(3, mt.ceil(mt.sqrt(MAXN))):\r\n#         if (spf[i] == i):\r\n#             for j in range(i * i, MAXN, i):\r\n#                 if (spf[j] == j):\r\n#                     spf[j] = i\r\n#\r\n#\r\n# def getFactorization(x):\r\n#     ret = 0\r\n#     while (x != 1):\r\n#         k = spf[x]\r\n#         ret += 1\r\n#         # ret.add(spf[x])\r\n#         while x % k == 0:\r\n#             x //= k\r\n#\r\n#     return ret\r\n\r\n\r\n# Driver code\r\n\r\n# precalculating Smallest Prime Factor\r\n# sieve()\r\n\r\ndef main():\r\n    dp = [0 for i in range(int(1e5 + 1))]\r\n    dp[1] = 1\r\n    dp[0] = 1\r\n    c = 1\r\n    for i in range(2, int(1e5 + 1)):\r\n        dp[i] += c + 1\r\n        c += dp[i]\r\n        c=min(c, int(1e18))\r\n    #print(dp[:62])\r\n    for _ in range(int(input())):\r\n        n, k = map(int, input().split())\r\n        ans = [-1 for i in range(n)]\r\n        i = 0\r\n        used = [0 for i in range(n + 1)]\r\n        if k>dp[n]:\r\n            print(-1)\r\n            continue\r\n        while i < n:\r\n            prev = 0\r\n            now=0\r\n            j = i + 1\r\n            while prev + dp[n - j] < k:\r\n                if j > n or prev + dp[n - j]> k:\r\n                    j -= 1\r\n                    break\r\n                prev += dp[n - j]+now\r\n                #now=prev\r\n\r\n                j += 1\r\n            k -= prev\r\n            m = i\r\n            while j:\r\n                if used[j]:\r\n                    break\r\n                ans[m] = j\r\n                used[j] = 1\r\n                j -= 1\r\n                m += 1\r\n            i = m\r\n        print(*ans)\r\n\r\n\r\n    return\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    main()\r\n",
    "prob_desc_created_at": "1618583700",
    "tags": [
        "binary search",
        "combinatorics",
        "constructive algorithms",
        "implementation"
    ],
    "hidden_unit_tests": ""
}
{
    "prob_desc_time_limit": "1 second",
    "prob_desc_sample_outputs": "[\"YES\\n2\\n1 3 5\\n2 3 4\", \"NO\"]",
    "src_uid": "b381b484eba0fa01df8744b043098ff7",
    "prob_desc_notes": "NoteIn the first sample the shown output corresponds to the following solution:   1 1 0 1 1 (initial state);  0 1 1 1 0 (the flipped positions are the first, the third and the fifth elements);  0 0 0 0 0 (the flipped positions are the second, the third and the fourth elements). Other answers are also possible. In this test the number of operations should not exceed $$$\\lfloor \\frac{5}{3} \\rfloor + 12 = 1 + 12 = 13$$$.In the second sample the only available operation is to flip all the elements. This way it is only possible to obtain the arrays 0 1 0 and 1 0 1, but it is impossible to make all elements equal to zero.",
    "prob_desc_description": "You are given an array $$$a$$$ of length $$$n$$$ that consists of zeros and ones.You can perform the following operation multiple times. The operation consists of two steps:   Choose three integers $$$1 \\le x &lt; y &lt; z \\le n$$$, that form an arithmetic progression ($$$y - x = z - y$$$).  Flip the values $$$a_x, a_y, a_z$$$ (i.e. change $$$1$$$ to $$$0$$$, change $$$0$$$ to $$$1$$$). Determine if it is possible to make all elements of the array equal to zero. If yes, print the operations that lead the the all-zero state. Your solution should not contain more than $$$(\\lfloor \\frac{n}{3} \\rfloor + 12)$$$ operations. Here $$$\\lfloor q \\rfloor$$$ denotes the number $$$q$$$ rounded down. We can show that it is possible to make all elements equal to zero in no more than this number of operations whenever it is possible to do so at all.",
    "prob_desc_output_spec": "Print \"YES\" (without quotes) if the answer exists, otherwise print \"NO\" (without quotes). You can print each letter in any case (upper or lower). If there is an answer, in the second line print an integer $$$m$$$ ($$$0 \\le m \\le (\\lfloor \\frac{n}{3} \\rfloor + 12)$$$) — the number of operations in your answer. After that in ($$$i + 2$$$)-th line print the $$$i$$$-th operations — the integers $$$x_i, y_i, z_i$$$. You can print them in arbitrary order.",
    "prob_desc_input_spec": "The first line contains a single integer $$$n$$$ ($$$3 \\le n \\le 10^5$$$) — the length of the array. The second line contains $$$n$$$ integers $$$a_1, a_2, \\ldots, a_n$$$ ($$$0 \\le a_i \\le 1$$$) — the elements of the array.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3",
    "lang_cluster": "Python",
    "difficulty": 2600,
    "file_name": "train_066.jsonl",
    "code_uid": "8224a845431f31be614d9ac90add77f4",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"5\\n1 1 0 1 1\", \"3\\n0 1 0\"]",
    "exec_outcome": "PASSED",
    "source_code": "def solve(a):\n    l = len(a)\n    d = sum(a[i] * 2 ** i for i in range(l))\n    if d == 0:\n        return []\n    usable = []\n    if l >= 3:\n        for i in range(l - 2):\n            usable.append(0b111 << i)\n    if l >= 5:\n        for i in range(l - 4):\n            usable.append(0b10101 << i)\n    if l >= 7:\n        for i in range(l - 6):\n            usable.append(0b1001001 << i)\n    ul = len(usable)\n    best_answer = None\n    for mask in range(1 << ul):\n        start = 0\n        clone = mask\n        cnt = 0\n        while clone:\n            if clone % 2 == 1:\n                start ^= usable[cnt]\n            clone //= 2\n            cnt += 1\n        if start == d:\n            answer = []\n            clone = mask\n            cnt = 0\n            while clone:\n                if clone % 2 == 1:\n                    answer.append([])\n                    used = usable[cnt]\n                    cnt2 = 1\n                    while used:\n                        if used % 2 == 1:\n                            answer[-1].append(cnt2)\n                        cnt2 += 1\n                        used //= 2\n                clone //= 2\n                cnt += 1\n            if best_answer is None or len(best_answer) > len(answer):\n                best_answer = answer\n    return best_answer\n\n\nif __name__ == '__main__':\n    n = int(input())\n    a = list(map(int, input().split()))\n    if len(a) <= 10:\n        sol = solve(a)\n        if sol is None:\n            print(\"NO\")\n            exit(0)\n        print(\"YES\")\n        print(len(sol))\n        for t in sol:\n            print(' '.join(map(str, t)))\n        exit(0)\n    operations = []\n    while len(a) > 10:\n        l = len(a)\n        last = a[-3:]\n        if last == [1, 1, 1]:\n            operations.append([l - 2, l - 1, l])\n        elif last == [1, 1, 0]:\n            operations.append([l - 3, l - 2, l - 1])\n            a[-4] ^= 1\n        elif last == [1, 0, 1]:\n            operations.append([l - 4, l - 2, l])\n            a[-5] ^= 1\n        elif last == [0, 1, 1]:\n            nxt = a[-6:-3]\n            if nxt == [1, 1, 1]:\n                operations.append([l - 8, l - 4, l])\n                operations.append([l - 5, l - 3, l - 1])\n                a[-9] ^= 1\n            elif nxt == [1, 1, 0]:\n                operations.append([l - 8, l - 4, l])\n                operations.append([l - 9, l - 5, l - 1])\n                a[-9] ^= 1\n                a[-10] ^= 1\n            elif nxt == [1, 0, 1]:\n                operations.append([l - 6, l - 3, l])\n                operations.append([l - 9, l - 5, l - 1])\n                a[-7] ^= 1\n                a[-10] ^= 1\n            elif nxt == [0, 1, 1]:\n                operations.append([l - 6, l - 3, l])\n                operations.append([l - 7, l - 4, l - 1])\n                a[-7] ^= 1\n                a[-8] ^= 1\n            elif nxt == [1, 0, 0]:\n                operations.append([l - 2, l - 1, l])\n                operations.append([l - 8, l - 5, l - 2])\n                a[-9] ^= 1\n            elif nxt == [0, 1, 0]:\n                operations.append([l - 2, l - 1, l])\n                operations.append([l - 6, l - 4, l - 2])\n                a[-7] ^= 1\n            elif nxt == [0, 0, 1]:\n                operations.append([l - 10, l - 5, l])\n                operations.append([l - 5, l - 3, l - 1])\n                a[-11] ^= 1\n            elif nxt == [0, 0, 0]:\n                operations.append([l - 8, l - 4, l])\n                operations.append([l - 7, l - 4, l - 1])\n                a[-9] ^= 1\n                a[-8] ^= 1\n            a.pop()\n            a.pop()\n            a.pop()\n        elif last == [1, 0, 0]:\n            operations.append([l - 4, l - 3, l - 2])\n            a[-5] ^= 1\n            a[-4] ^= 1\n        elif last == [0, 1, 0]:\n            operations.append([l - 5, l - 3, l - 1])\n            a[-6] ^= 1\n            a[-4] ^= 1\n        elif last == [0, 0, 1]:\n            operations.append([l - 6, l - 3, l])\n            a[-7] ^= 1\n            a[-4] ^= 1\n        a.pop()\n        a.pop()\n        a.pop()\n    while len(a) < 8:\n        a.append(0)\n    sol = solve(a)\n    print(\"YES\")\n    sol = operations + sol\n    print(len(sol))\n    for t in sol:\n        print(' '.join(map(str, t)))\n",
    "prob_desc_created_at": "1540109400",
    "tags": [
        "constructive algorithms"
    ],
    "hidden_unit_tests": ""
}
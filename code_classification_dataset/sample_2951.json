{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"3\\n6 4 10\\n0\\n\\n-1\\n7\\n2 6 2 6 2 2 6\"]",
    "src_uid": "debd7001018f90de4b80c3c6423b6a75",
    "prob_desc_notes": "NoteIn the first test case, string $$$a$$$ changes as follows:   after the first reversal: 1000101011;  after the second reversal: 0001101011;  after the third reversal: 1101011000. ",
    "prob_desc_description": "You have two strings $$$a$$$ and $$$b$$$ of equal even length $$$n$$$ consisting of characters 0 and 1.We're in the endgame now. To finally make the universe perfectly balanced, you need to make strings $$$a$$$ and $$$b$$$ equal.In one step, you can choose any prefix of $$$a$$$ of even length and reverse it. Formally, if $$$a = a_1 a_2 \\ldots a_n$$$, you can choose a positive even integer $$$p \\le n$$$ and set $$$a$$$ to $$$a_p a_{p-1} \\ldots a_1 a_{p+1} a_{p+2} \\ldots a_n$$$.Find a way to make $$$a$$$ equal to $$$b$$$ using at most $$$n + 1$$$ reversals of the above kind, or determine that such a way doesn't exist. The number of reversals doesn't have to be minimized.",
    "prob_desc_output_spec": "For each test case, if it's impossible to make $$$a$$$ equal to $$$b$$$ in at most $$$n + 1$$$ reversals, output a single integer $$$-1$$$. Otherwise, output an integer $$$k$$$ ($$$0 \\le k \\le n + 1$$$), denoting the number of reversals in your sequence of steps, followed by $$$k$$$ even integers $$$p_1, p_2, \\ldots, p_k$$$ ($$$2 \\le p_i \\le n$$$; $$$p_i \\bmod 2 = 0$$$), denoting the lengths of prefixes of $$$a$$$ to be reversed, in chronological order. Note that $$$k$$$ doesn't have to be minimized. If there are many solutions, output any of them.",
    "prob_desc_input_spec": "The first line contains a single integer $$$t$$$ ($$$1 \\le t \\le 2000$$$), denoting the number of test cases. Each test case consists of two lines. The first line contains a string $$$a$$$ of length $$$n$$$, and the second line contains a string $$$b$$$ of the same length ($$$2 \\le n \\le 4000$$$; $$$n \\bmod 2 = 0$$$). Both strings consist of characters 0 and 1. The sum of $$$n$$$ over all $$$t$$$ test cases doesn't exceed $$$4000$$$.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3",
    "lang_cluster": "Python",
    "difficulty": 3300,
    "file_name": "train_036.jsonl",
    "code_uid": "de193e7fa483ccdead93d62e14bd3f8b",
    "prob_desc_memory_limit": "512 megabytes",
    "prob_desc_sample_inputs": "[\"4\\n0100011011\\n1101011000\\n10101010\\n10101010\\n0011\\n1001\\n100011\\n110010\"]",
    "exec_outcome": "PASSED",
    "source_code": "import os\nimport sys\nfrom io import BytesIO, IOBase\n# region fastio\nBUFSIZE = 8192\nclass FastIO(IOBase):\n    newlines = 0\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n \nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\ndef solve_case():\n    a = [int(x) for x in input()]\n    b = [int(x) for x in input()]\n    n = len(a)\n    \n    a_rev = []\n    b_rev = []\n    \n    def rev_a(x):\n        if not x:\n            return\n        nonlocal a\n        a = a[:x][::-1] + a[x:]\n        a_rev.append(x)\n\n    def rev_b(x):\n        if not x:\n            return\n        nonlocal b\n        b = b[:x][::-1] + b[x:]\n        b_rev.append(x)\n\n    def answer():\n        #cleaning up\n        nonlocal a_rev\n        nonlocal b_rev\n        b_rev.reverse()\n        a_rev += b_rev\n        while True:\n            final = []\n            i = 0\n            repl = False\n            while i < len(a_rev):\n                if i < len(a_rev) - 1 and a_rev[i] == a_rev[i + 1]:\n                    repl = True\n                    i += 2\n                else:\n                    final.append(a_rev[i])\n                    i += 1\n            a_rev = final\n            if not repl:\n                break\n        print(len(a_rev))\n        print(*a_rev)\n    \n    a_occ = [[0, 0], [0, 0]]\n    b_occ = [[0, 0], [0, 0]]\n    \n    for i in range(0, n, 2):\n        a_occ[a[i]][a[i + 1]] += 1\n\n    for i in range(0, n, 2):\n        b_occ[b[i]][b[i + 1]] += 1\n    \n    if a_occ[0][0] != b_occ[0][0] or a_occ[1][1] != b_occ[1][1]:\n        print(-1)\n        return\n    \n    balanced = a_occ[0][1] == b_occ[1][0]\n    if not balanced:\n        zero, one = 0, 0\n        for i in range(0, n, 2):\n            if a[i] + a[i + 1] == 1:\n                zero, one = zero + a[i], one + a[i + 1]\n                if zero + (a_occ[0][1] - one) == b_occ[1][0]:\n                    balanced = True\n                    rev_a(i + 2)\n                    break\n    \n    if not balanced:\n        zero, one = 0, 0\n        for i in range(0, n, 2):\n            if b[i] + b[i + 1] == 1:\n                zero, one = zero + b[i], one + b[i + 1]\n                if zero + (b_occ[0][1] - one) == a_occ[1][0]:\n                    balanced = True\n                    rev_b(i + 2)\n                    break\n \n    for i in range(0, n, 2):\n        for j in range(i, n, 2):\n            if a[j] == b[n - i - 1] and a[j + 1] == b[n - i - 2]:\n                rev_a(j)\n                rev_a(j + 2)\n                break\n    \n    answer()\n\ndef main():\n    for _ in range(int(input())):\n        solve_case()\n            \nmain()",
    "prob_desc_created_at": "1571236500",
    "tags": [
        "constructive algorithms"
    ],
    "hidden_unit_tests": ""
}
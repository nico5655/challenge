{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"YES\\n01\\n11\\nYES\\n0011\\n1111\\n1111\\n1100\\nNO\\nYES\\n01111\\n11000\\n10000\\n10000\\n10000\"]",
    "src_uid": "95e2ea3e270af683706b9832557c3442",
    "prob_desc_notes": "NoteFor the first test case, you only have to delete cell $$$(1, 1)$$$.For the second test case, you could choose to delete cells $$$(1,1)$$$, $$$(1,2)$$$, $$$(4,3)$$$ and $$$(4,4)$$$.For the third test case, it is no solution because the cells in the diagonal will always form a strictly increasing sequence of length $$$5$$$.",
    "prob_desc_description": "You are given an $$$n \\times n$$$ grid. We write $$$(i, j)$$$ to denote the cell in the $$$i$$$-th row and $$$j$$$-th column. For each cell, you are told whether yon can delete it or not. Given an integer $$$k$$$, you are asked to delete exactly $$$(n-k+1)^2$$$ cells from the grid such that the following condition holds.   You cannot find $$$k$$$ not deleted cells $$$(x_1, y_1), (x_2, y_2), \\dots, (x_k, y_k)$$$ that are strictly increasing, i.e., $$$x_i &lt; x_{i+1}$$$ and $$$y_i &lt; y_{i+1}$$$ for all $$$1 \\leq i &lt; k$$$.  Your task is to find a solution, or report that it is impossible. ",
    "prob_desc_output_spec": "For each test case, if there is no way to delete exactly $$$(n-k+1)^2$$$ cells to meet the condition, output \"NO\" (without quotes). Otherwise, output \"YES\" (without quotes). Then, output $$$n$$$ lines. The $$$i$$$-th line should contain a binary string $$$t_i$$$ of length $$$n$$$. The $$$j$$$-th character of $$$t_i$$$ is 0 if cell $$$(i, j)$$$ is deleted, and 1 otherwise. If there are multiple solutions, you can output any of them. You can output \"YES\" and \"NO\" in any case (for example, strings \"yEs\", \"yes\" and \"Yes\" will be recognized as a positive response).",
    "prob_desc_input_spec": "Each test contains multiple test cases. The first line contains an integer $$$t$$$ ($$$1 \\leq t \\leq 10^5$$$) â€” the number of test cases. The following lines contain the description of each test case. The first line of each test case contains two integers $$$n$$$ and $$$k$$$ ($$$2 \\leq k \\leq n \\leq 1000$$$).  Then $$$n$$$ lines follow. The $$$i$$$-th line contains a binary string $$$s_i$$$ of length $$$n$$$. The $$$j$$$-th character of $$$s_i$$$ is 1 if you can delete cell $$$(i, j)$$$, and 0 otherwise. It's guaranteed that the sum of $$$n^2$$$ over all test cases does not exceed $$$10^6$$$.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3-64",
    "lang_cluster": "Python",
    "difficulty": 2900,
    "file_name": "train_103.jsonl",
    "code_uid": "0a79b53880ffffbb8485731019bba663",
    "prob_desc_memory_limit": "512 megabytes",
    "prob_desc_sample_inputs": "[\"4\\n\\n2 2\\n\\n10\\n\\n01\\n\\n4 3\\n\\n1110\\n\\n0101\\n\\n1010\\n\\n0111\\n\\n5 5\\n\\n01111\\n\\n10111\\n\\n11011\\n\\n11101\\n\\n11110\\n\\n5 2\\n\\n10000\\n\\n01111\\n\\n01111\\n\\n01111\\n\\n01111\"]",
    "exec_outcome": "PASSED",
    "source_code": "import os\r\nimport sys \r\nfrom io import BytesIO, IOBase\r\n \r\nBUFSIZE = 8192\r\n  \r\nclass FastIO(IOBase):\r\n    newlines = 0\r\n  \r\n    def __init__(self, file):\r\n        self._fd = file.fileno() \r\n        self.buffer = BytesIO()  \r\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\r\n        self.write = self.buffer.write if self.writable else None\r\n \r\n    def read(self):\r\n        while True:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            if not b:\r\n                break  \r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines = 0 \r\n        return self.buffer.read()\r\n \r\n    def readline(self):\r\n        while self.newlines == 0:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) \r\n            self.newlines = b.count(b\"\\n\") + (not b)  \r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines -= 1    \r\n        return self.buffer.readline()\r\n \r\n    def flush(self): \r\n        if self.writable: \r\n            os.write(self._fd, self.buffer.getvalue())\r\n            self.buffer.truncate(0), self.buffer.seek(0)   \r\n \r\n \r\nclass IOWrapper(IOBase):\r\n    def __init__(self, file):\r\n        self.buffer = FastIO(file)\r\n        self.flush = self.buffer.flush\r\n        self.writable = self.buffer.writable\r\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\r\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\r\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\r\n \r\n \r\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\r\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\r\n\r\ndef solve():\r\n    n, K = map(int, input().split())\r\n    S = [list(input()) for _ in range(n)]\r\n    A = [[] for _ in range(n)]    \r\n    for i in range(n - 1, -1, -1):\r\n        for j in range(n):\r\n            if S[i][j] == \"0\":\r\n                A[j].append(i)            \r\n\r\n    used = [[False] * n for _ in range(n)]\r\n    add = n - K + 2\r\n    cc = 0\r\n    for j in range(K - 1): \r\n        x = n - 1\r\n        for i in range(j, j + add):\r\n            if not A[i] or A[i][-1] > x:\r\n                nx = x\r\n            else:\r\n                nx = A[i][-1]\r\n                while A[i] and A[i][-1] <= x:\r\n                    A[i].pop()\r\n            nx = min(nx, n - 1 - (K - 2 - j))\r\n            if i == j + add - 1:\r\n                nx = 0\r\n            \r\n            for k in range(nx, x + 1):\r\n                if used[k][i]:\r\n                    print(\"NO\")\r\n                    return\r\n                used[k][i] = True\r\n                cc += 1\r\n            x = nx\r\n\r\n    \r\n    for i in range(n):\r\n        if A[i]:\r\n            print(\"NO\")\r\n            return\r\n\r\n    ans = [[1] * n for _ in range(n)]\r\n    c = (n - K + 1) ** 2\r\n    assert c + cc == n ** 2\r\n    for i in range(n):\r\n        for j in range(n):\r\n            if used[i][j]:\r\n                continue\r\n            if S[i][j] == \"1\":\r\n                c -= 1\r\n                ans[i][j] = 0\r\n            else:\r\n                print(\"NO\")\r\n                return\r\n            \r\n    if c != 0:\r\n        print(\"NO\")\r\n    else:\r\n        print(\"YES\")\r\n        for row in ans:\r\n            print(*row, sep=\"\")\r\n\r\n\r\n\r\n\r\nfor _ in range(int(input())):\r\n    solve()   ",
    "prob_desc_created_at": "1664548500",
    "tags": [
        "constructive algorithms",
        "dp",
        "greedy",
        "math"
    ],
    "hidden_unit_tests": ""
}
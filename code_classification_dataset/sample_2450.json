{
    "prob_desc_time_limit": "4 seconds",
    "prob_desc_sample_outputs": "[\"42\", \"30\"]",
    "src_uid": "5179d7554a08d713da7597db41f0ed43",
    "prob_desc_notes": "NoteThe following figure shows all $$$10$$$ possible paths for which one endpoint is an ancestor of another endpoint. The sum of beauties of all these paths is equal to $$$42$$$:  ",
    "prob_desc_description": "Kamil likes streaming the competitive programming videos. His MeTube channel has recently reached $$$100$$$ million subscribers. In order to celebrate this, he posted a video with an interesting problem he couldn't solve yet. Can you help him?You're given a tree — a connected undirected graph consisting of $$$n$$$ vertices connected by $$$n - 1$$$ edges. The tree is rooted at vertex $$$1$$$. A vertex $$$u$$$ is called an ancestor of $$$v$$$ if it lies on the shortest path between the root and $$$v$$$. In particular, a vertex is an ancestor of itself.Each vertex $$$v$$$ is assigned its beauty $$$x_v$$$ — a non-negative integer not larger than $$$10^{12}$$$. This allows us to define the beauty of a path. Let $$$u$$$ be an ancestor of $$$v$$$. Then we define the beauty $$$f(u, v)$$$ as the greatest common divisor of the beauties of all vertices on the shortest path between $$$u$$$ and $$$v$$$. Formally, if $$$u=t_1, t_2, t_3, \\dots, t_k=v$$$ are the vertices on the shortest path between $$$u$$$ and $$$v$$$, then $$$f(u, v) = \\gcd(x_{t_1}, x_{t_2}, \\dots, x_{t_k})$$$. Here, $$$\\gcd$$$ denotes the greatest common divisor of a set of numbers. In particular, $$$f(u, u) = \\gcd(x_u) = x_u$$$.Your task is to find the sum$$$$$$ \\sum_{u\\text{ is an ancestor of }v} f(u, v). $$$$$$As the result might be too large, please output it modulo $$$10^9 + 7$$$.Note that for each $$$y$$$, $$$\\gcd(0, y) = \\gcd(y, 0) = y$$$. In particular, $$$\\gcd(0, 0) = 0$$$.",
    "prob_desc_output_spec": "Output the sum of the beauties on all paths $$$(u, v)$$$ such that $$$u$$$ is ancestor of $$$v$$$. This sum should be printed modulo $$$10^9 + 7$$$.",
    "prob_desc_input_spec": "The first line contains a single integer $$$n$$$ ($$$2 \\le n \\le 100\\,000$$$) — the number of vertices in the tree. The following line contains $$$n$$$ integers $$$x_1, x_2, \\dots, x_n$$$ ($$$0 \\le x_i \\le 10^{12}$$$). The value $$$x_v$$$ denotes the beauty of vertex $$$v$$$. The following $$$n - 1$$$ lines describe the edges of the tree. Each of them contains two integers $$$a, b$$$ ($$$1 \\le a, b \\le n$$$, $$$a \\neq b$$$) — the vertices connected by a single edge.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 2",
    "lang_cluster": "Python",
    "difficulty": 2000,
    "file_name": "train_023.jsonl",
    "code_uid": "1f4f2d3e8d4997aa850c286fe1a02901",
    "prob_desc_memory_limit": "768 megabytes",
    "prob_desc_sample_inputs": "[\"5\\n4 5 6 0 8\\n1 2\\n1 3\\n1 4\\n4 5\", \"7\\n0 2 3 0 0 0 0\\n1 2\\n1 3\\n2 4\\n2 5\\n3 6\\n3 7\"]",
    "exec_outcome": "PASSED",
    "source_code": "from __future__ import division, print_function\nfrom collections import deque\ndef main():\n    def gcd(a,b):\n        if a<b:\n            a,b=b,a\n        while b:\n            a,b=b,a%b\n        return a\n    \n    n=int(input())\n    val=list(map(int,input().split()))\n    gcds=[ {} for _ in range(n) ]\n    edges={}\n    for i in range(n-1):\n        u,v=map(int,input().split())\n        if u not in edges:\n            edges[u]=[v]\n        else :\n            edges[u].append(v)\n        if v not in edges:\n            edges[v]=[u]\n        else :\n            edges[v].append(u)\n    visited=[0]*n\n    \n    q=deque()\n    q.append(1)\n    visited[0]=1\n    mod=10**9+7\n    result=0\n    while q:\n        u=q.popleft()\n        x=val[u-1]\n        if x not in gcds[u-1]:\n            gcds[u-1][x]=1\n        else :\n            gcds[u-1][x]+=1\n        for k in gcds[u-1]:\n            result=(result+gcds[u-1][k]*k)%mod\n        for v in edges[u]:\n            if visited[v-1]==0:\n                temp=val[v-1]\n                for item in gcds[u-1]:\n                    a=gcd(item,temp)\n                    if a not in gcds[v-1]:\n                        gcds[v-1][a]=gcds[u-1][item]\n                    else :\n                        gcds[v-1][a]+=gcds[u-1][item]\n                visited[v-1]=1\n                q.append(v)\n    print(result)\n        \n\n######## Python 2 and 3 footer by Pajenegod and c1729\n\n# Note because cf runs old PyPy3 version which doesn't have the sped up\n# unicode strings, PyPy3 strings will many times be slower than pypy2.\n# There is a way to get around this by using binary strings in PyPy3\n# but its syntax is different which makes it kind of a mess to use.\n\n# So on cf, use PyPy2 for best string performance.\n\npy2 = round(0.5)\nif py2:\n    from future_builtins import ascii, filter, hex, map, oct, zip\n    range = xrange\n\nimport os, sys\nfrom io import IOBase, BytesIO\n\nBUFSIZE = 8192\nclass FastIO(BytesIO):\n    newlines = 0\n\n    def __init__(self, file):\n        self._file = file\n        self._fd = file.fileno()\n        self.writable = \"x\" in file.mode or \"w\" in file.mode\n        self.write = super(FastIO, self).write if self.writable else None\n\n    def _fill(self):\n        s = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n        self.seek((self.tell(), self.seek(0,2), super(FastIO, self).write(s))[0])\n        return s\n\n    def read(self):\n        while self._fill(): pass\n        return super(FastIO,self).read()\n\n    def readline(self):\n        while self.newlines == 0:\n            s = self._fill(); self.newlines = s.count(b\"\\n\") + (not s)\n        self.newlines -= 1\n        return super(FastIO, self).readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.getvalue())\n            self.truncate(0), self.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        if py2:\n            self.write = self.buffer.write\n            self.read = self.buffer.read\n            self.readline = self.buffer.readline\n        else:\n            self.write = lambda s:self.buffer.write(s.encode('ascii'))\n            self.read = lambda:self.buffer.read().decode('ascii')\n            self.readline = lambda:self.buffer.readline().decode('ascii')\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip('\\r\\n')\n\n# Cout implemented in Python\nimport sys\nclass ostream:\n    def __lshift__(self,a):\n        sys.stdout.write(str(a))\n        return self\ncout = ostream()\nendl = '\\n'\n\n# Read all remaining integers in stdin, type is given by optional argument, this is fast\ndef readnumbers(zero = 0):\n    conv = ord if py2 else lambda x:x\n    A = []; numb = zero; sign = 1; i = 0; s = sys.stdin.buffer.read()\n    try:\n        while True:\n            if s[i] >= b'0' [0]:\n                numb = 10 * numb + conv(s[i]) - 48\n            elif s[i] == b'-' [0]: sign = -1\n            elif s[i] != b'\\r' [0]:\n                A.append(sign*numb)\n                numb = zero; sign = 1\n            i += 1\n    except:pass\n    if s and s[-1] >= b'0' [0]:\n        A.append(sign*numb)\n    return A\n\nif __name__== \"__main__\":\n  main()",
    "prob_desc_created_at": "1569143100",
    "tags": [
        "dp",
        "graphs",
        "number theory",
        "math",
        "data structures",
        "binary search",
        "dfs and similar",
        "trees"
    ],
    "hidden_unit_tests": ""
}
{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"100\", \"-1\", \"2\", \"2\"]",
    "src_uid": "a9ccc8ab91d7ea2a2de074fdc305c3c8",
    "prob_desc_notes": "NoteIn the first test it is possible to place a detachment in $$$(0, 0)$$$, so that it is possible to check all the detachments for $$$t = 100$$$. It can be proven that it is impossible to check all detachments for $$$t &lt; 100$$$; thus the answer is $$$100$$$.In the second test, there is no such $$$t$$$ that it is possible to check all detachments, even with adding at most one new detachment, so the answer is $$$-1$$$.In the third test, it is possible to place a detachment in $$$(1, 0)$$$, so that Brimstone can check all the detachments for $$$t = 2$$$. It can be proven that it is the minimal such $$$t$$$.In the fourth test, there is no need to add any detachments, because the answer will not get better ($$$t = 2$$$). It can be proven that it is the minimal such $$$t$$$.",
    "prob_desc_description": "There are $$$n$$$ detachments on the surface, numbered from $$$1$$$ to $$$n$$$, the $$$i$$$-th detachment is placed in a point with coordinates $$$(x_i, y_i)$$$. All detachments are placed in different points.Brimstone should visit each detachment at least once. You can choose the detachment where Brimstone starts.To move from one detachment to another he should first choose one of four directions of movement (up, right, left or down) and then start moving with the constant speed of one unit interval in a second until he comes to a detachment. After he reaches an arbitrary detachment, he can repeat the same process.Each $$$t$$$ seconds an orbital strike covers the whole surface, so at that moment Brimstone should be in a point where some detachment is located. He can stay with any detachment as long as needed.Brimstone is a good commander, that's why he can create at most one detachment and place it in any empty point with integer coordinates he wants before his trip. Keep in mind that Brimstone will need to visit this detachment, too.Help Brimstone and find such minimal $$$t$$$ that it is possible to check each detachment. If there is no such $$$t$$$ report about it.",
    "prob_desc_output_spec": "Output such minimal integer $$$t$$$ that it is possible to check all the detachments adding at most one new detachment. If there is no such $$$t$$$, print $$$-1$$$.",
    "prob_desc_input_spec": "The first line contains a single integer $$$n$$$ $$$(2 \\le n \\le 1000)$$$ — the number of detachments. In each of the next $$$n$$$ lines there is a pair of integers $$$x_i$$$, $$$y_i$$$ $$$(|x_i|, |y_i| \\le 10^9)$$$ — the coordinates of $$$i$$$-th detachment. It is guaranteed that all points are different.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3",
    "lang_cluster": "Python",
    "difficulty": 2800,
    "file_name": "train_043.jsonl",
    "code_uid": "0eaf4f1cc58548705d07d08061346718",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"4\\n100 0\\n0 100\\n-100 0\\n0 -100\", \"7\\n0 2\\n1 0\\n-3 0\\n0 -2\\n-1 -1\\n-1 -3\\n-2 -3\", \"5\\n0 0\\n0 -1\\n3 0\\n-2 0\\n-2 1\", \"5\\n0 0\\n2 0\\n0 -1\\n-2 0\\n-2 1\"]",
    "exec_outcome": "PASSED",
    "source_code": "# import numpy as npy\nimport functools\nimport math\n\nn=int(input())\nx=[0 for i in range(n+2)]\ny=[0 for i in range(n+2)]\nadj=[[] for i in range(n+2)]\nidx=[]\nidy=[]\nfor i in range(n):\n    x[i],y[i]=map(int,input().split())\n    idx.append(i)\n    idy.append(i)\n\ndef cmpx(a,b):\n    if x[a]!=x[b]:\n        if x[a]<x[b]:\n            return -1\n        else:\n            return 1\n    if y[a]!=y[b]:\n        if y[a]<y[b]:\n            return -1\n        else:\n            return 1\n    return 0\n    \ndef cmpy(a,b):\n    if y[a]!=y[b]:\n        if y[a]<y[b]:\n            return -1\n        else:\n            return 1\n    if x[a]!=x[b]:\n        if x[a]<x[b]:\n            return -1\n        else:\n            return 1\n    return 0\n\nidx=sorted(idx,key=functools.cmp_to_key(cmpx))\nidy=sorted(idy,key=functools.cmp_to_key(cmpy))\n\n# print(idx)\n# print(idy)\n\ndef disx(a,b):\n    if x[a]!=x[b]:\n        return 1e18\n    return y[b]-y[a]\n    \ndef disy(a,b):\n    if y[a]!=y[b]:\n        return 1e18\n    return x[b]-x[a]\n\nl=0\nr=2000000000\nans=-1\n\nwhile l<=r:\n    # print(l,r)\n    mid=(l+r)//2\n    for i in range(n):\n        adj[i]=[]\n    for i in range(n-1):\n        if disx(idx[i],idx[i+1])<=mid:\n            adj[idx[i]].append(idx[i+1])\n            adj[idx[i+1]].append(idx[i])\n            # print(idx[i],idx[i+1])\n        if disy(idy[i],idy[i+1])<=mid:\n            adj[idy[i]].append(idy[i+1])\n            adj[idy[i+1]].append(idy[i])\n            # print(idy[i],idy[i+1])\n    col=[0 for i in range(n)]\n    cur=0\n    def dfs(x):\n        col[x]=cur\n        for i in range(len(adj[x])):\n            if col[adj[x][i]]==0:\n                dfs(adj[x][i])\n    for i in range(n):\n        if col[i]==0:\n            cur=cur+1\n            dfs(i)\n    ok=0\n    if cur>4:\n        ok=0\n    if cur==1:\n        ok=1\n    if cur==2:\n        for i in range(n):\n            for j in range(i+1,n):\n                if (col[i]!=col[j]):\n                    d1=abs(x[i]-x[j])\n                    d2=abs(y[i]-y[j])\n                    if d1==0 or d2==0:\n                        if d1+d2<=2*mid:\n                            ok=1\n                    if d1<=mid and d2<=mid:\n                        ok=1\n    if cur==3:\n        for i in range(n-1):\n            px=idx[i]\n            py=idx[i+1]\n            if x[px]==x[py] and col[px]!=col[py]:\n                for j in range(n):\n                    if col[px]!=col[j] and col[py]!=col[j]:\n                        d1=abs(y[px]-y[j])\n                        d2=abs(y[py]-y[j])\n                        d3=abs(x[px]-x[j])\n                        if d1<=mid and d2<=mid and d3<=mid:\n                            ok=1\n        for i in range(n-1):\n            px=idy[i]\n            py=idy[i+1]\n            if y[px]==y[py] and col[px]!=col[py]:\n                for j in range(n):\n                    if col[px]!=col[j] and col[py]!=col[j]:\n                        d1=abs(x[px]-x[j])\n                        d2=abs(x[py]-x[j])\n                        d3=abs(y[px]-y[j])\n                        if d1<=mid and d2<=mid and d3<=mid:\n                            ok=1\n    if cur==4:\n        for i in range(n-1):\n            px=idx[i]\n            py=idx[i+1]\n            if x[px]==x[py] and col[px]!=col[py]:\n                for j in range(n-1):\n                    pz=idy[j]\n                    pw=idy[j+1]\n                    if y[pz]==y[pw] and col[pz]!=col[pw]:\n                        if col[pz]!=col[px] and col[pz]!=col[py]:\n                            if col[pw]!=col[px] and col[pw]!=col[py]:\n                                d1=abs(y[px]-y[pz])\n                                d2=abs(y[py]-y[pz])\n                                d3=abs(x[pz]-x[px])\n                                d4=abs(x[pw]-x[px])\n                                if d1<=mid and d2<=mid and d3<=mid and d4<=mid:\n                                    ok=1\n    if ok:\n        ans=mid\n        r=mid-1\n    else:\n        l=mid+1\nprint(ans)",
    "prob_desc_created_at": "1600526100",
    "tags": [
        "graphs",
        "dsu",
        "implementation",
        "data structures",
        "binary search",
        "dfs and similar"
    ],
    "hidden_unit_tests": ""
}
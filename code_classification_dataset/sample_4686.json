{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"2\\n1 3 2 4\\n3\\n1 2 3 4 5 6\\n3\\n6 5 4 3 2 1\"]",
    "src_uid": "152aba87aaf14d1841f6622dc66051af",
    "prob_desc_notes": "NoteFor the first test case, permutation $$$a = [1,3,2,4]$$$ and threshold $$$k = 2$$$ will produce sequence $$$b$$$ as follows.   When $$$i = 1$$$, $$$x = a_i = 1 \\leq k$$$, there is no $$$a_j$$$ ($$$1 \\leq j &lt; i$$$) that $$$a_j &gt; k$$$. Therefore, $$$b_1 = n + 1 = 5$$$.  When $$$i = 2$$$, $$$x = a_i = 3 &gt; k$$$, the last element $$$a_j$$$ that $$$a_j \\leq k$$$ is $$$a_1$$$. Therefore, $$$b_3 = a_1 = 1$$$.  When $$$i = 3$$$, $$$x = a_i = 2 \\leq k$$$, the last element $$$a_j$$$ that $$$a_j &gt; k$$$ is $$$a_2$$$. Therefore, $$$b_2 = a_2 = 3$$$.  When $$$i = 4$$$, $$$x = a_i = 4 &gt; k$$$, the last element $$$a_j$$$ that $$$a_j \\leq k$$$ is $$$a_3$$$. Therefore, $$$b_4 = a_3 = 2$$$.  Finally, we obtain sequence $$$b = [5,3,1,2]$$$. For the second test case, permutation $$$a = [1,2,3,4,5,6]$$$ and threshold $$$k = 3$$$ will produce sequence $$$b$$$ as follows.   When $$$i = 1, 2, 3$$$, $$$a_i \\leq k$$$, there is no $$$a_j$$$ ($$$1 \\leq j &lt; i$$$) that $$$a_j &gt; k$$$. Therefore, $$$b_1 = b_2 = b_3 = n + 1 = 7$$$.  When $$$i = 4, 5, 6$$$, $$$a_i &gt; k$$$, the last element $$$a_j$$$ that $$$a_j \\leq k$$$ is $$$a_3$$$. Therefore, $$$b_4 = b_5 = b_6 = a_3 = 3$$$.  Finally, we obtain sequence $$$b = [7,7,7,3,3,3]$$$. For the third test case, permutation $$$a = [6,5,4,3,2,1]$$$ and threshold $$$k = 3$$$ will produce sequence $$$b$$$ as follows.   When $$$i = 1, 2, 3$$$, $$$a_i &gt; k$$$, there is no $$$a_j$$$ ($$$1 \\leq j &lt; i$$$) that $$$a_j \\leq k$$$. Therefore, $$$b_4 = b_5 = b_6 = 0$$$.  When $$$i = 4, 5, 6$$$, $$$a_i \\leq k$$$, the last element $$$a_j$$$ that $$$a_j &gt; k$$$ is $$$a_3$$$. Therefore, $$$b_1 = b_2 = b_3 = a_3 = 4$$$.  Finally, we obtain sequence $$$b = [4,4,4,0,0,0]$$$. ",
    "prob_desc_description": "Given a permutation $$$a_1, a_2, \\dots, a_n$$$ of integers from $$$1$$$ to $$$n$$$, and a threshold $$$k$$$ with $$$0 \\leq k \\leq n$$$, you compute a sequence $$$b_1, b_2, \\dots, b_n$$$ as follows. For every $$$1 \\leq i \\leq n$$$ in increasing order, let $$$x = a_i$$$.   If $$$x \\leq k$$$, set $$$b_{x}$$$ to the last element $$$a_j$$$ ($$$1 \\leq j &lt; i$$$) that $$$a_j &gt; k$$$. If no such element $$$a_j$$$ exists, set $$$b_{x} = n+1$$$.  If $$$x &gt; k$$$, set $$$b_{x}$$$ to the last element $$$a_j$$$ ($$$1 \\leq j &lt; i$$$) that $$$a_j \\leq k$$$. If no such element $$$a_j$$$ exists, set $$$b_{x} = 0$$$. Unfortunately, after the sequence $$$b_1, b_2, \\dots, b_n$$$ has been completely computed, the permutation $$$a_1, a_2, \\dots, a_n$$$ and the threshold $$$k$$$ are discarded. Now you only have the sequence $$$b_1, b_2, \\dots, b_n$$$. Your task is to find any possible permutation $$$a_1, a_2, \\dots, a_n$$$ and threshold $$$k$$$ that produce the sequence $$$b_1, b_2, \\dots, b_n$$$. It is guaranteed that there exists at least one pair of permutation $$$a_1, a_2, \\dots, a_n$$$ and threshold $$$k$$$ that produce the sequence $$$b_1, b_2, \\dots, b_n$$$.A permutation of integers from $$$1$$$ to $$$n$$$ is a sequence of length $$$n$$$ which contains all integers from $$$1$$$ to $$$n$$$ exactly once. ",
    "prob_desc_output_spec": "For each test case, output the threshold $$$k$$$ ($$$0 \\leq k \\leq n$$$) in the first line, and then output the permutation $$$a_1, a_2, \\dots, a_n$$$ ($$$1 \\leq a_i \\leq n$$$) in the second line such that the permutation $$$a_1, a_2, \\dots, a_n$$$ and threshold $$$k$$$ produce the sequence $$$b_1, b_2, \\dots, b_n$$$. If there are multiple solutions, you can output any of them.",
    "prob_desc_input_spec": "Each test contains multiple test cases. The first line contains an integer $$$t$$$ ($$$1 \\leq t \\leq 10^5$$$) â€” the number of test cases. The following lines contain the description of each test case. The first line of each test case contains an integer $$$n$$$ ($$$1 \\leq n \\leq 10^5$$$), indicating the length of the permutation $$$a$$$. The second line of each test case contains $$$n$$$ integers $$$b_1, b_2, \\dots, b_n$$$ ($$$0 \\leq b_i \\leq n+1$$$), indicating the elements of the sequence $$$b$$$. It is guaranteed that there exists at least one pair of permutation $$$a_1, a_2, \\dots, a_n$$$ and threshold $$$k$$$ that produce the sequence $$$b_1, b_2, \\dots, b_n$$$. It is guaranteed that the sum of $$$n$$$ over all test cases does not exceed $$$10^5$$$.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3",
    "lang_cluster": "Python",
    "difficulty": 1900,
    "file_name": "train_103.jsonl",
    "code_uid": "3a5d1f990fe376dad986c5bd1509379b",
    "prob_desc_memory_limit": "512 megabytes",
    "prob_desc_sample_inputs": "[\"3\\n\\n4\\n\\n5 3 1 2\\n\\n6\\n\\n7 7 7 3 3 3\\n\\n6\\n\\n4 4 4 0 0 0\"]",
    "exec_outcome": "PASSED",
    "source_code": "\r\n# def dfs(node, stack, next, visited):\r\n#     if node == -1 or node in visited:\r\n#         return\r\n#     visited.add(node)\r\n#     # print(node, next)\r\n#     dfs(next[node], stack, next, visited)\r\n#     stack.append(node)\r\nimport sys\r\nfrom collections import defaultdict\r\n# sys.setrecursionlimit(200000)\r\n\r\n\r\ndef dfs(node, parents, stack):\r\n    # print(\"node\", node)\r\n\r\n    dStack = [node]\r\n    while len(dStack) > 0:\r\n        # print(dStack)\r\n        e = dStack.pop()\r\n        stack.append(e)\r\n\r\n        noParents = []\r\n        withParents = []\r\n        for p in parents[e]:\r\n            if len(parents[p]) == 0:\r\n                noParents.append(p)\r\n            else:\r\n                withParents.append(p)\r\n        # print(noParents + withParents)\r\n        for p in withParents + noParents:\r\n            dStack.append(p)\r\n\r\n\r\nt = int(input())\r\nfor _ in range(t):\r\n    n = int(input())\r\n    b = [int(e)-1 for e in input().split(' ')]\r\n\r\n    next = [-1]*n\r\n    parent = defaultdict(list)\r\n    left = -1\r\n    right = n-1\r\n    for x, bx in enumerate(b):\r\n        if bx == -1:\r\n            right = min(x-1, right)\r\n            continue\r\n\r\n        if bx == n:\r\n            left = max(x, left)\r\n            continue\r\n\r\n        if x < bx:\r\n            left = max(x, left)\r\n            right = min(bx-1, right)\r\n        else:\r\n            left = max(bx, left)\r\n            right = min(x-1, right)\r\n\r\n        next[x] = bx\r\n        parent[bx].append(x)\r\n\r\n    k = left+1\r\n    visited = set()\r\n    start = None\r\n    # print(parent, next)\r\n    for i in range(n):\r\n        if len(parent[i]) != 0 and next[i] == -1:\r\n            start = i\r\n\r\n    stack = []\r\n    # print(start)\r\n    if start is not None:\r\n        dfs(start, parent, stack)\r\n    # print(stack)\r\n    # for i in range(n):\r\n    #     if next[i] == -1 or i in visited:\r\n    #         continue\r\n\r\n    #     dfs(i, stack, next, visited)\r\n    add = []\r\n    for i in range(n):\r\n        if len(parent[i]) == 0 and next[i] == -1:\r\n            add.append(i)\r\n    print(k)\r\n    print(' '.join([str(e+1) for e in add+stack]))\r\n",
    "prob_desc_created_at": "1664548500",
    "tags": [
        "constructive algorithms",
        "data structures",
        "dfs and similar",
        "dsu",
        "graphs",
        "trees"
    ],
    "hidden_unit_tests": ""
}
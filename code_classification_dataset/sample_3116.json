{
    "prob_desc_time_limit": "1 second",
    "prob_desc_sample_outputs": "[\"Yes\", \"No\", \"Yes\"]",
    "src_uid": "bcfdab268a330ef1404d264793809952",
    "prob_desc_notes": "NoteHere is the picture of maze described in the first example:    In the first example, the doll can walk in this way:  The doll is in the cell $$$(1, 1)$$$, looks to the direction $$$1$$$. Move straight;  The doll is in the cell $$$(1, 2)$$$, looks to the direction $$$1$$$. Move straight;  The doll is in the cell $$$(1, 3)$$$, looks to the direction $$$1$$$. Turn right;  The doll is in the cell $$$(1, 3)$$$, looks to the direction $$$2$$$. Move straight;  The doll is in the cell $$$(2, 3)$$$, looks to the direction $$$2$$$. Move straight;  The doll is in the cell $$$(3, 3)$$$, looks to the direction $$$2$$$. Turn right;  The doll is in the cell $$$(3, 3)$$$, looks to the direction $$$3$$$. Move straight;  The doll is in the cell $$$(3, 2)$$$, looks to the direction $$$3$$$. Move straight;  The doll is in the cell $$$(3, 1)$$$, looks to the direction $$$3$$$. The goal is achieved, all cells of the maze without obstacles passed exactly once. ",
    "prob_desc_description": "Alice got a new doll these days. It can even walk!Alice has built a maze for the doll and wants to test it. The maze is a grid with $$$n$$$ rows and $$$m$$$ columns. There are $$$k$$$ obstacles, the $$$i$$$-th of them is on the cell $$$(x_i, y_i)$$$, which means the cell in the intersection of the $$$x_i$$$-th row and the $$$y_i$$$-th column.However, the doll is clumsy in some ways. It can only walk straight or turn right at most once in the same cell (including the start cell). It cannot get into a cell with an obstacle or get out of the maze.More formally, there exist $$$4$$$ directions, in which the doll can look:  The doll looks in the direction along the row from the first cell to the last. While moving looking in this direction the doll will move from the cell $$$(x, y)$$$ into the cell $$$(x, y + 1)$$$;  The doll looks in the direction along the column from the first cell to the last. While moving looking in this direction the doll will move from the cell $$$(x, y)$$$ into the cell $$$(x + 1, y)$$$;  The doll looks in the direction along the row from the last cell to first. While moving looking in this direction the doll will move from the cell $$$(x, y)$$$ into the cell $$$(x, y - 1)$$$;  The doll looks in the direction along the column from the last cell to the first. While moving looking in this direction the doll will move from the cell $$$(x, y)$$$ into the cell $$$(x - 1, y)$$$. .Standing in some cell the doll can move into the cell in the direction it looks or it can turn right once. Turning right once, the doll switches it's direction by the following rules: $$$1 \\to 2$$$, $$$2 \\to 3$$$, $$$3 \\to 4$$$, $$$4 \\to 1$$$. Standing in one cell, the doll can make at most one turn right.Now Alice is controlling the doll's moves. She puts the doll in of the cell $$$(1, 1)$$$ (the upper-left cell of the maze). Initially, the doll looks to the direction $$$1$$$, so along the row from the first cell to the last. She wants to let the doll walk across all the cells without obstacles exactly once and end in any place. Can it be achieved?",
    "prob_desc_output_spec": "Print 'Yes' (without quotes) if the doll can walk across all the cells without obstacles exactly once by the rules, described in the statement. If it is impossible to walk across the maze by these rules print 'No' (without quotes).",
    "prob_desc_input_spec": "The first line contains three integers $$$n$$$, $$$m$$$ and $$$k$$$, separated by spaces ($$$1 \\leq n,m \\leq 10^5, 0 \\leq k \\leq 10^5$$$) — the size of the maze and the number of obstacles. Next $$$k$$$ lines describes the obstacles, the $$$i$$$-th line contains two integer numbers $$$x_i$$$ and $$$y_i$$$, separated by spaces ($$$1 \\leq x_i \\leq n,1 \\leq y_i \\leq m$$$), which describes the position of the $$$i$$$-th obstacle. It is guaranteed that no two obstacles are in the same cell and no obstacle is in cell $$$(1, 1)$$$.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3",
    "lang_cluster": "Python",
    "difficulty": 2300,
    "file_name": "train_042.jsonl",
    "code_uid": "a68fe5d2195034e11fda936f81f675cc",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"3 3 2\\n2 2\\n2 1\", \"3 3 2\\n3 1\\n2 2\", \"3 3 8\\n1 2\\n1 3\\n2 1\\n2 2\\n2 3\\n3 1\\n3 2\\n3 3\"]",
    "exec_outcome": "PASSED",
    "source_code": "from sys import stdout\nprintn = lambda x: stdout.write(x)\ninn = lambda : int(input())\ninl   = lambda: list(map(int, input().split()))\ninm   = lambda:      map(int, input().split()) \nDBG = True  and False\nBIG = 999999999\nR = 10**9 + 7\n\ndef ddprint(x):\n  if DBG:\n    print(x)\n\nn,m,k = inm() \nhx = {}\nhy = {}\ncnt = 0\nfor i in range(k):\n  x,y = inm()\n  x -= 1\n  y -= 1\n  cnt += 1\n  if x in hx:\n    hx[x].append(y)\n  else:\n    hx[x] = [y]\n  if y in hy:\n    hy[y].append(x)\n  else:\n    hy[y] = [x]\n\nddprint(hx)\nddprint(hy)\nx,y = 0,0\ndir = 1\nif m==1 or (m>1 and 0 in hx and 1 in hx[0]):\n  dir = 2\nminx = miny = -1\nmaxx = n\nmaxy = m\nwhile True:\n  #ddprint(\"x {} y {} dir {} mn {} {} mx {} {}\".format(x,y,dir,minx,miny,maxx,maxy))\n  nx = x\n  ny = y\n\n  if dir==1:\n    a = [z for z in hx[x] if y<z and z<maxy] if x in hx else []\n    #ddprint(a)\n    if len(a)==0:\n      ny = maxy-1\n    else:\n      a.sort()\n      ny = a[0]-1\n    if ny==y:\n        break\n    cnt += ny-y\n    y = ny\n    minx = x\n    dir = 2\n\n  elif dir==2:\n    a = [z for z in hy[y] if x<z and z<maxx] if y in hy else []\n    if len(a)==0:\n      nx = maxx-1\n    else:\n      a.sort()\n      nx = a[0]-1\n    if nx==x:\n        break\n    cnt += nx-x\n    x = nx\n    maxy = y\n    dir = 3\n\n  elif dir==3:\n    a = [z for z in hx[x] if miny<z and z<y] if x in hx else []\n    if len(a)==0:\n      ny = miny+1\n    else:\n      a.sort(reverse=True)\n      ny = a[0]+1\n    if ny==y:\n        break\n    cnt += y-ny\n    y = ny\n    maxx = x\n    dir = 4\n\n  elif dir==4:\n    a = [z for z in hy[y] if minx<z and z<x] if y in hy else []\n    if len(a)==0:\n      nx = minx+1\n    else:\n      a.sort(reverse=True)\n      nx = a[0]+1\n    if nx==x:\n        break\n    cnt += x-nx\n    x = nx\n    miny = y\n    dir = 1\n\nprint('Yes' if cnt==n*m-1 else 'No')\n",
    "prob_desc_created_at": "1571319300",
    "tags": [
        "data structures",
        "implementation",
        "greedy",
        "brute force"
    ],
    "hidden_unit_tests": ""
}
{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"1 2 3 4\\n1 3\\n-1\\n1 2 2 5 5\"]",
    "src_uid": "91d510b68f04971b871718460663ca3b",
    "prob_desc_notes": null,
    "prob_desc_description": "You are asked to build an array $$$a$$$, consisting of $$$n$$$ integers, each element should be from $$$1$$$ to $$$k$$$.The array should be non-decreasing ($$$a_i \\le a_{i+1}$$$ for all $$$i$$$ from $$$1$$$ to $$$n-1$$$). You are also given additional constraints on it. Each constraint is of one of three following types:   $$$1~i~x$$$: $$$a_i$$$ should not be equal to $$$x$$$;  $$$2~i~j~x$$$: $$$a_i + a_j$$$ should be less than or equal to $$$x$$$;  $$$3~i~j~x$$$: $$$a_i + a_j$$$ should be greater than or equal to $$$x$$$. Build any non-decreasing array that satisfies all constraints or report that no such array exists.",
    "prob_desc_output_spec": "For each testcase, determine if there exists a non-decreasing array that satisfies all conditions. If there is no such array, then print -1. Otherwise, print any valid array — $$$n$$$ integers from $$$1$$$ to $$$k$$$.",
    "prob_desc_input_spec": "The first line contains a single integer $$$t$$$ ($$$1 \\le t \\le 10^4$$$) — the number of testcases. The first line of each testcase contains three integers $$$n, m$$$ and $$$k$$$ ($$$2 \\le n \\le 2 \\cdot 10^4$$$; $$$0 \\le m \\le 2 \\cdot 10^4$$$; $$$2 \\le k \\le 10$$$). The $$$i$$$-th of the next $$$m$$$ lines contains a description of a constraint. Each constraint is of one of three following types:    $$$1~i~x$$$ ($$$1 \\le i \\le n$$$; $$$1 \\le x \\le k$$$): $$$a_i$$$ should not be equal to $$$x$$$;  $$$2~i~j~x$$$ ($$$1 \\le i &lt; j \\le n$$$; $$$2 \\le x \\le 2 \\cdot k$$$): $$$a_i + a_j$$$ should be less than or equal to $$$x$$$;  $$$3~i~j~x$$$ ($$$1 \\le i &lt; j \\le n$$$; $$$2 \\le x \\le 2 \\cdot k$$$): $$$a_i + a_j$$$ should be greater than or equal to $$$x$$$.  The sum of $$$n$$$ over all testcases doesn't exceed $$$2 \\cdot 10^4$$$. The sum of $$$m$$$ over all testcases doesn't exceed $$$2 \\cdot 10^4$$$.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3-64",
    "lang_cluster": "Python",
    "difficulty": 2800,
    "file_name": "train_083.jsonl",
    "code_uid": "a7700d58ffbd8fbbf545a770cbb2fdb8",
    "prob_desc_memory_limit": "512 megabytes",
    "prob_desc_sample_inputs": "[\"4\\n\\n4 0 4\\n\\n2 2 3\\n\\n3 1 2 3\\n\\n1 2 2\\n\\n3 3 2\\n\\n1 1 1\\n\\n2 2 3 2\\n\\n3 2 3 2\\n\\n5 5 5\\n\\n3 2 5 7\\n\\n2 4 5 10\\n\\n3 4 5 6\\n\\n3 3 4 7\\n\\n2 1 5 7\"]",
    "exec_outcome": "PASSED",
    "source_code": "import sys\ninput = sys.stdin.readline\n\n# TwoSat code from PyRival: https://github.com/cheran-senthil/PyRival/blob/9947ae98b7884614d98a5860764e85798c0cddfa/pyrival/data_structures/TwoSat.py\ndef find_SCC(graph):\n    SCC, S, P = [], [], []\n    depth = [0] * len(graph)\n\n    stack = list(range(len(graph)))\n    while stack:\n        node = stack.pop()\n        if node < 0:\n            d = depth[~node] - 1\n            if P[-1] > d:\n                SCC.append(S[d:])\n                del S[d:], P[-1]\n                for node in SCC[-1]:\n                    depth[node] = -1\n        elif depth[node] > 0:\n            while P[-1] > depth[node]:\n                P.pop()\n        elif depth[node] == 0:\n            S.append(node)\n            P.append(len(S))\n            depth[node] = len(S)\n            stack.append(~node)\n            stack += graph[node]\n    return SCC[::-1]\n\nclass TwoSat:\n    def __init__(self, n):\n        self.n = n\n        self.graph = [[] for _ in range(2 * n)]\n\n    def _imply(self, x, y):\n        self.graph[x].append(y if y >= 0 else 2 * self.n + y)\n\n    def either(self, x, y):\n        \"\"\"either x or y must be True\"\"\"\n        self._imply(~x, y)\n        self._imply(~y, x)\n\n    def set(self, x):\n        \"\"\"x must be True\"\"\"\n        self._imply(~x, x)\n\n    def implies(self, x, y):\n        self.either(~x, y)\n\n    def solve(self):\n        SCC = find_SCC(self.graph)\n        order = [0] * (2 * self.n)\n        for i, comp in enumerate(SCC):\n            for x in comp:\n                order[x] = i\n        for i in range(self.n):\n            if order[i] == order[~i]:\n                return False, None\n        return True, [+(order[i] > order[~i]) for i in range(self.n)]\n\n\nclass Helper:\n    def __init__(self, i: int): self.i = i\n    def __ge__(self, x: int): return self.i * (K+1) + x - 1\n    def __lt__(self, x: int): return ~(self >= x)\n    def __gt__(self, x: int): return self >= x + 1\n    def __le__(self, x: int): return self < x + 1\n\n\nout = []\nfor _ in range(int(input())):\n    N, M, K = map(int, input().split())\n    A = [Helper(i) for i in range(N)]\n    ts = TwoSat(N*(K+1))\n\n    for i in range(N):\n        ts.set(A[i] >= 1)\n        ts.set(A[i] <= K)\n\n        for k in range(1, K):\n            ts.implies(A[i] < k, A[i] < k+1)\n\n        if i < N-1:\n            for k in range(1, K+1):\n                ts.implies(A[i] >= k, A[i+1] >= k)\n\n    for _ in range(M):\n        type, *args = map(int, input().split())\n        if type == 1:\n            i, x = args; i -= 1\n            ts.either(A[i] < x, A[i] > x)\n        else:\n            i, j, x = args\n            i -= 1; j -= 1\n\n            if type == 2:\n                for y in range(1, K+1):\n                    if 1 <= x - y <= K:\n                        ts.implies(A[i] >= y, A[j] <= x - y)\n                        ts.implies(A[j] >= y, A[i] <= x - y)\n\n                if x <= K:\n                    ts.set(A[i] < x)\n                    ts.set(A[j] < x)\n\n            elif type == 3:\n                for y in range(1, K+1):\n                    if 1 <= x - y <= K:\n                        ts.implies(A[i] <= y, A[j] >= x - y)\n                        ts.implies(A[j] <= y, A[i] >= x - y)\n\n                if x > K:\n                    ts.set(A[i] >= x - K)\n                    ts.set(A[j] >= x - K)\n\n    ok, sol = ts.solve()\n    if not ok:\n        out.append(\"-1\")\n    else:\n        ans = []\n        for i in range(N):\n            for k in range(K, 0, -1):\n                if sol[A[i] >= k]:\n                    ans.append(str(k))\n                    break\n            else:\n                assert False\n\n        out.append(\" \".join(ans))\n\nprint(\"\\n\".join(out))\n",
    "prob_desc_created_at": "1655044500",
    "tags": [
        "2-sat",
        "constructive algorithms",
        "graphs",
        "implementation"
    ],
    "hidden_unit_tests": ""
}
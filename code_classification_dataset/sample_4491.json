{
    "prob_desc_time_limit": "4 seconds",
    "prob_desc_sample_outputs": "[\"5 3 5 2 1 5 5 3\", \"1 3 3 2\", \"-1\"]",
    "src_uid": "f3d9afa76d0309e9688784c5de238cfe",
    "prob_desc_notes": "NoteThe tournament for the first example is described in the statement.For the third example, the placing $$$[1, 2, 3, 3]$$$ (team $$$1$$$ gets place $$$1$$$, team $$$2$$$ gets place $$$2$$$, teams $$$3$$$ and $$$4$$$ get place $$$3$$$) could result in a hash value of $$$7020100$$$ with $$$A = 100$$$, but no tournament can result in such placing since teams $$$1$$$ and $$$2$$$ play against each other in the semifinals, so they cannot get two first places.",
    "prob_desc_description": "$$$2^k$$$ teams participate in a playoff tournament. The tournament consists of $$$2^k - 1$$$ games. They are held as follows: first of all, the teams are split into pairs: team $$$1$$$ plays against team $$$2$$$, team $$$3$$$ plays against team $$$4$$$ (exactly in this order), and so on (so, $$$2^{k-1}$$$ games are played in that phase). When a team loses a game, it is eliminated, and each game results in elimination of one team (there are no ties). After that, only $$$2^{k-1}$$$ teams remain. If only one team remains, it is declared the champion; otherwise, $$$2^{k-2}$$$ games are played: in the first one of them, the winner of the game \"$$$1$$$ vs $$$2$$$\" plays against the winner of the game \"$$$3$$$ vs $$$4$$$\", then the winner of the game \"$$$5$$$ vs $$$6$$$\" plays against the winner of the game \"$$$7$$$ vs $$$8$$$\", and so on. This process repeats until only one team remains.After the tournament ends, the teams are assigned places according to the tournament phase when they were eliminated. In particular:  the winner of the tournament gets place $$$1$$$;  the team eliminated in the finals gets place $$$2$$$;  both teams eliminated in the semifinals get place $$$3$$$;  all teams eliminated in the quarterfinals get place $$$5$$$;  all teams eliminated in the 1/8 finals get place $$$9$$$, and so on. For example, this picture describes one of the possible ways the tournament can go with $$$k = 3$$$, and the resulting places of the teams:  After a tournament which was conducted by the aforementioned rules ended, its results were encoded in the following way. Let $$$p_i$$$ be the place of the $$$i$$$-th team in the tournament. The hash value of the tournament $$$h$$$ is calculated as $$$h = (\\sum \\limits_{i=1}^{2^k} i \\cdot A^{p_i}) \\bmod 998244353$$$, where $$$A$$$ is some given integer.Unfortunately, due to a system crash, almost all tournament-related data was lost. The only pieces of data that remain are the values of $$$k$$$, $$$A$$$ and $$$h$$$. You are asked to restore the resulting placing of the teams in the tournament, if it is possible at all.",
    "prob_desc_output_spec": "If it is impossible to find any placing of the teams that is consistent with the data you have, print one integer $$$-1$$$. Otherwise, print $$$2^k$$$ integers, where $$$i$$$-th integer should be equal to $$$p_i$$$ (the place of the $$$i$$$-th team). Note that your answer should be consistent with one of the possible ways the tournament could go, and note that the initial structure of the tournament is fixed (for example, teams $$$1$$$ and $$$2$$$ always play in the first phase of the tournament against each other). If there are multiple ways to restore the places of the teams which are consistent with the data you have, print any of them.",
    "prob_desc_input_spec": "The only line contains three integers $$$k$$$, $$$A$$$ and $$$h$$$ ($$$1 \\le k \\le 5$$$; $$$100 \\le A \\le 10^8$$$; $$$0 \\le h \\le 998244352$$$).",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3-64",
    "lang_cluster": "Python",
    "difficulty": 2600,
    "file_name": "train_099.jsonl",
    "code_uid": "b2305fb560748c40b28d8503aa249c5b",
    "prob_desc_memory_limit": "512 megabytes",
    "prob_desc_sample_inputs": "[\"3 1337 75275197\", \"2 100 5040100\", \"2 100 7020100\"]",
    "exec_outcome": "PASSED",
    "source_code": "import os,sys\r\nfrom random import randint\r\nfrom io import BytesIO, IOBase\r\n\r\nfrom collections import defaultdict,deque,Counter\r\nfrom bisect import bisect_left,bisect_right\r\nfrom heapq import heappush,heappop\r\nfrom functools import lru_cache\r\nfrom itertools import accumulate\r\nimport math\r\n\r\n# Fast IO Region\r\nBUFSIZE = 8192\r\nclass FastIO(IOBase):\r\n    newlines = 0\r\n    def __init__(self, file):\r\n        self._fd = file.fileno()\r\n        self.buffer = BytesIO()\r\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\r\n        self.write = self.buffer.write if self.writable else None\r\n    def read(self):\r\n        while True:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            if not b:\r\n                break\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines = 0\r\n        return self.buffer.read()\r\n    def readline(self):\r\n        while self.newlines == 0:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            self.newlines = b.count(b\"\\n\") + (not b)\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines -= 1\r\n        return self.buffer.readline()\r\n    def flush(self):\r\n        if self.writable:\r\n            os.write(self._fd, self.buffer.getvalue())\r\n            self.buffer.truncate(0), self.buffer.seek(0)\r\nclass IOWrapper(IOBase):\r\n    def __init__(self, file):\r\n        self.buffer = FastIO(file)\r\n        self.flush = self.buffer.flush\r\n        self.writable = self.buffer.writable\r\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\r\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\r\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\r\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\r\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\r\n\r\n# for _ in range(int(input())):\r\n#     n = int(input())\r\n#     a = list(map(int, input().split()))\r\n\r\n# a = [0]\r\n# for i in range(1, 2000):\r\n#     if i % 3 and i % 10 != 3:\r\n#         a.append(i)\r\n# for _ in range(int(input())):\r\n#     n = int(input())\r\n#     print(a[n])\r\n\r\n# for _ in range(int(input())):\r\n#     a, b, c = list(map(int, input().split()))\r\n#     n = abs(b - a) * 2\r\n#     if a > n or b > n or c > n:\r\n#         print(-1)\r\n#     elif c <= n // 2:\r\n#         print(c + n // 2)\r\n#     else:\r\n#         print(c - n // 2)\r\n\r\n# for _ in range(int(input())):\r\n#     n = int(input())\r\n#     x = ceil(sqrt(n))\r\n#     last = (x - 1) * (x - 1)\r\n#     res = n - last\r\n#     if res <= x:\r\n#         print(res, x)\r\n#     else:\r\n#         print(x, 2 * x - res)\r\n\r\n# a = [str(pow(2, i)) for i in range(70)]\r\n\r\n# for _ in range(int(input())):\r\n#     s = input()\r\n#     n = len(s)\r\n#     ans = n + 1\r\n#     for t in a:\r\n#         j = 0\r\n#         for i in range(len(s)):\r\n#             if j < len(t) and s[i] == t[j]:\r\n#                 j += 1\r\n#         ans = min(ans, len(s) + len(t) - 2 * j)\r\n#     print(ans)\r\n\r\n# a = set()\r\n# for i in range(1, 10):\r\n#     for j in range(1, 11):\r\n#         a.add(int(str(i) * j))\r\n# a = sorted(a)\r\n\r\n# b = set()\r\n# def dfs(i, j, s, k):\r\n#     if k == 11: return \r\n#     global b\r\n#     if s: b.add(int(s))\r\n#     dfs(i, j, s + str(i), k + 1)\r\n#     dfs(i, j, s + str(j), k + 1)\r\n# for i in range(10):\r\n#     for j in range(i + 1, 10):\r\n#         dfs(i, j, '', 0)\r\n# b = sorted(b)\r\n\r\n# @lru_cache(None)\r\n# def calc(n):\r\n#     return len(set(list(str(n))))\r\n# for _ in range(int(input())):\r\n#     n, k = list(map(int, input().split()))\r\n#     if k == 1:\r\n#         print(a[bisect_left(a, n)])\r\n#     elif k == 2:\r\n#         print(b[bisect_left(b, n)])\r\n\r\n# for _ in range(int(input())):\r\n#     def solve():\r\n#         s = input()\r\n#         n = len(s)\r\n#         res = []\r\n#         vis = set()\r\n#         cnt = Counter()\r\n#         for i in range(n - 1, -1, -1):\r\n#             cnt[s[i]] += 1\r\n#             if s[i] not in vis:\r\n#                 vis.add(s[i])\r\n#                 res.append(s[i])\r\n#         ans = 0\r\n#         for i in range(len(res)):\r\n#             if cnt[res[i]] % (len(res) - i):\r\n#                 print(-1)\r\n#                 return\r\n#             ans += cnt[res[i]] // (len(res) - i)\r\n#         res = res[::-1]\r\n#         pres = list(s[:ans])\r\n#         fuck = pres\r\n#         for ch in res:\r\n#             news = []\r\n#             for i in pres:\r\n#                 if i != ch:\r\n#                     news.append(i)\r\n#             fuck += news\r\n#             pres = news\r\n#         if ''.join(fuck) != s:\r\n#             print(-1)\r\n#         else:\r\n#             print(s[:ans], ''.join(res))\r\n#     solve()\r\n    \r\nmod = 998244353\r\ndef solve():\r\n    k, A, h = list(map(int, input().split()))\r\n    mp1, mp2, mp3, mp4 = {}, {}, {}, {}\r\n    for i in range(pow(2, pow(2, k - 1) - 1)):\r\n        score = [0] * (pow(2, k - 1))\r\n        val = val2 = 0\r\n        j = 0\r\n        tmp = pow(2, k - 1)\r\n        lst = list(range(pow(2, k - 1)))\r\n        while tmp > 0:\r\n            newlst = []\r\n            for x in range(tmp // 2):\r\n                if i >> (j + x) & 1:\r\n                    score[lst[2 * x]] = tmp + 1\r\n                    newlst.append(lst[2 * x + 1])\r\n                else:\r\n                    score[lst[2 * x + 1]] = tmp + 1\r\n                    newlst.append(lst[2 * x])\r\n            lst = newlst\r\n            j += tmp // 2\r\n            tmp //= 2\r\n        for i in range(len(score)):\r\n            if score[i] == 0:\r\n                idx = i\r\n            else:\r\n                val += (i + 1) * pow(A, score[i], mod)\r\n                val %= mod\r\n                val2 += (i + 1 + pow(2, k - 1)) * pow(A, score[i], mod)\r\n                val2 %= mod\r\n\r\n        score[idx] = 1\r\n        val += (idx + 1) * A \r\n        val %= mod\r\n        val2 += (idx + 1 + pow(2, k - 1)) * A \r\n        val2 %= mod\r\n        mp1[val] = score[:]\r\n        mp3[val2] = score[:]\r\n        val -= (idx + 1) * A\r\n        val2 -= (idx + 1 + pow(2, k - 1)) * A\r\n\r\n        score[idx] = 2\r\n        val += (idx + 1) * A * A\r\n        val %= mod\r\n        val2 += (idx + 1 + pow(2, k - 1)) * A * A\r\n        val2 %= mod\r\n        mp2[val] = score[:]\r\n        mp4[val2] = score[:]\r\n\r\n    for val in mp1:\r\n        if (h - val) % mod in mp4:\r\n            print(*mp1[val], *mp4[(h - val) % mod])\r\n            return\r\n    for val in mp2:\r\n        if (h - val) % mod in mp3:\r\n            print(*mp2[val], *mp3[(h - val) % mod])\r\n            return\r\n    print(-1)\r\nsolve()\r\n\r\n\r\n    ",
    "prob_desc_created_at": "1631111700",
    "tags": [
        "bitmasks",
        "brute force",
        "hashing",
        "implementation",
        "meet-in-the-middle"
    ],
    "hidden_unit_tests": ""
}
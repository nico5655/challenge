{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"12\", \"40\", \"4\"]",
    "src_uid": "e05ef33935d04bd3714269268aceda41",
    "prob_desc_notes": "NoteLet's consider the first sample test. The bracket sequence from the sample can be colored, for example, as is shown on two figures below.     The two ways of coloring shown below are incorrect.     ",
    "prob_desc_description": "Once Petya read a problem about a bracket sequence. He gave it much thought but didn't find a solution. Today you will face it.You are given string s. It represents a correct bracket sequence. A correct bracket sequence is the sequence of opening (\"(\") and closing (\")\") brackets, such that it is possible to obtain a correct mathematical expression from it, inserting numbers and operators between the brackets. For example, such sequences as \"(())()\" and \"()\" are correct bracket sequences and such sequences as \")()\" and \"(()\" are not.In a correct bracket sequence each bracket corresponds to the matching bracket (an opening bracket corresponds to the matching closing bracket and vice versa). For example, in a bracket sequence shown of the figure below, the third bracket corresponds to the matching sixth one and the fifth bracket corresponds to the fourth one.   You are allowed to color some brackets in the bracket sequence so as all three conditions are fulfilled:   Each bracket is either not colored any color, or is colored red, or is colored blue.  For any pair of matching brackets exactly one of them is colored. In other words, for any bracket the following is true: either it or the matching bracket that corresponds to it is colored.  No two neighboring colored brackets have the same color. Find the number of different ways to color the bracket sequence. The ways should meet the above-given conditions. Two ways of coloring are considered different if they differ in the color of at least one bracket. As the result can be quite large, print it modulo 1000000007 (109 + 7).",
    "prob_desc_output_spec": "Print the only number — the number of ways to color the bracket sequence that meet the above given conditions modulo 1000000007 (109 + 7).",
    "prob_desc_input_spec": "The first line contains the single string s (2 ≤ |s| ≤ 700) which represents a correct bracket sequence. ",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "Python 2",
    "lang_cluster": "Python",
    "difficulty": 1900,
    "file_name": "train_017.jsonl",
    "code_uid": "abb9b525595537eb55e6c649f3defa00",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"(())\", \"(()())\", \"()\"]",
    "exec_outcome": "PASSED",
    "source_code": "__author__ = 'Jackie'\n\nimport sys\n\n#sys.stdin = open('input.txt', 'r')\nMAXN = 800\nMOD = 1000000007\nbrackets = raw_input()\n#print 'jackie'\ndp = []\n#print 'jackie'\nN = len(brackets)\nHash = [0] * N\nstk = []\ntop = 0\n\ndef init():\n    for i in range(2):\n        a1 = []\n        for j in range(2):\n            a2 = []\n            for k in range(N):\n                a3 = [-1] * N\n                a2.append(a3)\n            a1.append(a2)\n        dp.append(a1)\n    top = 0\n    for i in xrange(N):\n        if '(' == brackets[i]:\n            stk.append(i)\n        else:\n            cur = stk.pop()\n            Hash[cur] = i\n\n\ndef DP(s, t, lc, rc):\n    if s >= t:\n        return 1\n    if -1 != dp[lc][rc][s][t] :\n        return dp[lc][rc][s][t]\n    ans = 0\n\n    if Hash[s] == t:\n        if not lc:\n            ans += DP(s + 1, t - 1, 1, 0) * 2\n            ans %= MOD\n            if not rc:\n                ans += DP(s + 1, t - 1, 0, 1) * 2\n                if ans >= MOD: ans %= MOD\n            else:\n                ans += DP(s + 1, t - 1, 0, 1)\n                ans %= MOD\n        else:\n            ans += DP(s + 1, t - 1, 1, 0)\n            ans %= MOD\n            if not rc:\n                ans += DP(s + 1, t - 1, 0, 1) * 2\n                ans %= MOD\n            else:\n                ans += DP(s + 1, t - 1, 0, 1)\n                ans %= MOD\n        dp[lc][rc][s][t] = ans\n        return ans\n\n    if not lc:\n        ans += DP(s + 1, Hash[s] - 1, 1, 0) * 2 * DP(Hash[s] + 1, t, 0, rc)\n        ans %= MOD\n        ans += DP(s + 1, Hash[s] - 1, 0, 1) * 2 * DP(Hash[s] + 1, t, 1, rc)\n        ans %= MOD\n    else:\n        ans += DP(s + 1, Hash[s] - 1, 1, 0) * DP(Hash[s] + 1, t, 0, rc)\n        ans %= MOD\n        ans += DP(s + 1, Hash[s] - 1, 0, 1) * 2 * DP(Hash[s] + 1, t, 1, rc)\n        ans %= MOD\n\n    dp[lc][rc][s][t] = ans\n    return ans\n\n\n\nif __name__ == '__main__':\n\n    init()\n    ans = DP(0, N - 1, 0, 0)\n    print ans\n\n\n\n#import sys\n##sys.stdin = open('input.txt', 'r')\n#mod=1000000007\n#s=raw_input()\n#n=len(s)\n#dp=[]\n#for ii in range(0,3):\n#    aa=[]\n#    for i in range(0,3):\n#        a=[]\n#        for j in range(0,n):\n#            b=[-1]*n\n#            a.append(b)\n#        aa.append(a)\n#    dp.append(aa)\n#\n#match=[0]*n\n#st=[]\n#for i in range(0,n):\n#    if(s[i]=='('):\n#        st.append(i)\n#    else:\n#        cur=st.pop()\n#        match[cur]=i\n##print match\n#def go(left,right,s1,s2):\n#    if(left>right):\n#        return 1\n#    if(dp[s1][s2][left][right]!=-1):\n#        return dp[s1][s2][left][right]\n#    res=0\n#    x=left\n#    y=match[left]\n#    for c1 in range(0,3):\n#        for c2 in range(0,3):\n#            ok=True\n#            if(c1!=2):\n#                if(c1==s1):\n#                    ok=False\n#            if(c2!=2):\n#                if(y==right and c2==s2):\n#                    ok=False\n#            if(c1!=2 and c2!=2):\n#                ok=False\n#            if(c1==2 and c2==2):\n#                ok=False\n#            if(ok==False):\n#                continue\n#            res+=go(x+1,y-1,c1,c2)*go(y+1,right,c2,s2)\n#            res=res%mod\n#    dp[s1][s2][left][right]=res\n#    return res\n#num=go(0,n-1,2,2)\n#print num\n",
    "prob_desc_created_at": "1328886000",
    "tags": [
        "dp"
    ],
    "hidden_unit_tests": ""
}
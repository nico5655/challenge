{
    "prob_desc_time_limit": "1.5 seconds",
    "prob_desc_sample_outputs": "[\"4\\n0 2 4 6\", \"12\\n0 1 2 3 4 5 6 7 10 11 12 13\"]",
    "src_uid": "b4d8a79dc61a046f84dd7184929ba55e",
    "prob_desc_notes": "NoteIn the first test case:  To get value $$$x = 0$$$ it is possible to choose and empty subsequence  To get value $$$x = 2$$$ it is possible to choose a subsequence $$$[2]$$$  To get value $$$x = 4$$$ it is possible to choose a subsequence $$$[4]$$$  To get value $$$x = 6$$$ it is possible to choose a subsequence $$$[2, 4]$$$ ",
    "prob_desc_description": "This is a harder version of the problem with bigger constraints.Korney Korneevich dag up an array $$$a$$$ of length $$$n$$$. Korney Korneevich has recently read about the operation bitwise XOR, so he wished to experiment with it. For this purpose, he decided to find all integers $$$x \\ge 0$$$ such that there exists an increasing subsequence of the array $$$a$$$, in which the bitwise XOR of numbers is equal to $$$x$$$.It didn't take a long time for Korney Korneevich to find all such $$$x$$$, and he wants to check his result. That's why he asked you to solve this problem!A sequence $$$s$$$ is a subsequence of a sequence $$$b$$$ if $$$s$$$ can be obtained from $$$b$$$ by deletion of several (possibly, zero or all) elements.A sequence $$$s_1, s_2, \\ldots , s_m$$$ is called increasing if $$$s_1 &lt; s_2 &lt; \\ldots &lt; s_m$$$.",
    "prob_desc_output_spec": "In the first line print a single integer $$$k$$$ — the number of found $$$x$$$ values. In the second line print $$$k$$$ integers in increasing order $$$x_1, x_2, \\ldots x_k$$$ ($$$0 \\le x_1 &lt; \\ldots &lt; x_k$$$) — found $$$x$$$ values.",
    "prob_desc_input_spec": "The first line contains a single integer $$$n$$$ ($$$1 \\le n \\le 10^6$$$). The second line contains $$$n$$$ integers $$$a_1, a_2, \\ldots, a_n$$$ ($$$0 \\le a_i \\le 5000$$$) — the elements of the array $$$a$$$.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3",
    "lang_cluster": "Python",
    "difficulty": 2400,
    "file_name": "train_106.jsonl",
    "code_uid": "d4b81d4eaabd4875ce0f9b358a51bbee",
    "prob_desc_memory_limit": "512 megabytes",
    "prob_desc_sample_inputs": "[\"4\\n4 2 2 4\", \"8\\n1 0 1 7 12 5 3 2\"]",
    "exec_outcome": "PASSED",
    "source_code": "from __future__ import division, print_function\r\nimport math\r\nimport sys\r\nimport os\r\nfrom io import BytesIO, IOBase\r\nfrom collections import deque, Counter, OrderedDict, defaultdict\r\nimport heapq\r\n# ceil,floor,log,sqrt,factorial,pow,pi,gcd\r\n# import bisect\r\nfrom bisect import bisect_left,bisect_right\r\n\r\nBUFSIZE = 8192\r\n\r\n\r\nclass FastIO(IOBase):\r\n\tnewlines = 0\r\n\r\n\tdef __init__(self, file):\r\n\t\tself._fd = file.fileno()\r\n\t\tself.buffer = BytesIO()\r\n\t\tself.writable = \"x\" in file.mode or \"r\" not in file.mode\r\n\t\tself.write = self.buffer.write if self.writable else None\r\n\r\n\tdef read(self):\r\n\t\twhile True:\r\n\t\t\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n\t\t\tif not b:\r\n\t\t\t\tbreak\r\n\t\t\tptr = self.buffer.tell()\r\n\t\t\tself.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n\t\tself.newlines = 0\r\n\t\treturn self.buffer.read()\r\n\r\n\tdef readline(self):\r\n\t\twhile self.newlines == 0:\r\n\t\t\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n\t\t\tself.newlines = b.count(b\"\\n\") + (not b)\r\n\t\t\tptr = self.buffer.tell()\r\n\t\t\tself.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n\t\tself.newlines -= 1\r\n\t\treturn self.buffer.readline()\r\n\r\n\tdef flush(self):\r\n\t\tif self.writable:\r\n\t\t\tos.write(self._fd, self.buffer.getvalue())\r\n\t\t\tself.buffer.truncate(0), self.buffer.seek(0)\r\n\r\n\r\nclass IOWrapper(IOBase):\r\n\tdef __init__(self, file):\r\n\t\tself.buffer = FastIO(file)\r\n\t\tself.flush = self.buffer.flush\r\n\t\tself.writable = self.buffer.writable\r\n\t\tself.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\r\n\t\tself.read = lambda: self.buffer.read().decode(\"ascii\")\r\n\t\tself.readline = lambda: self.buffer.readline().decode(\"ascii\")\r\n\r\n\r\ndef print(*args, **kwargs):\r\n\t\"\"\"Prints the values to a stream, or to sys.stdout by default.\"\"\"\r\n\tsep, file = kwargs.pop(\"sep\", \" \"), kwargs.pop(\"file\", sys.stdout)\r\n\tat_start = True\r\n\tfor x in args:\r\n\t\tif not at_start:\r\n\t\t\tfile.write(sep)\r\n\t\tfile.write(str(x))\r\n\t\tat_start = False\r\n\tfile.write(kwargs.pop(\"end\", \"\\n\"))\r\n\tif kwargs.pop(\"flush\", False):\r\n\t\tfile.flush()\r\n\r\n\r\nif sys.version_info[0] < 3:\r\n\tsys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)\r\nelse:\r\n\tsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\r\n\r\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\r\n\r\ndef inp():\r\n    return(int(input()))\r\ndef inps():\r\n    return input().strip()\r\ndef inlt():\r\n    return(list(map(int,input().split())))\r\ndef insr():\r\n    s = input().strip()\r\n    return(list(s[:len(s)]))\r\ndef invr():\r\n    return(map(int,input().split()))\r\n\r\nfrom types import GeneratorType\r\ndef bootstrap(f, stack=[]):\r\n    def wrappedfunc(*args, **kwargs):\r\n        if stack:\r\n            return f(*args, **kwargs)\r\n        else:\r\n            to = f(*args, **kwargs)\r\n            while True:\r\n                if type(to) is GeneratorType:\r\n                    stack.append(to)\r\n                    to = next(to)\r\n                else:\r\n                    stack.pop()\r\n                    if not stack:\r\n                        break\r\n                    to = stack[-1].send(to)\r\n            return to\r\n \r\n    return wrappedfunc\r\n\r\ndef SETIO(problem):\r\n    sys.stdin=open(problem+'.in','r')\r\n    sys.stdout=open(problem+'.out','w')\r\n\r\nproblem=''\r\n# SETIO(problem)\r\nn=inp()\r\nl=inlt()\r\nmx=1<<13\r\nvis=[[0] for i in range(5001)]\r\nvis2=[5001 for i in range(mx)]\r\nfor i in range(n):\r\n    for each in vis[l[i]]:\r\n        v=each^l[i]\r\n        s=l[i]+1\r\n        e=vis2[v]\r\n        vis2[v]=min(vis2[v],l[i])\r\n        for j in range(s,e):\r\n            vis[j].append(v)\r\n    vis[l[i]]=[]\r\ns=[ i for i in range(mx) if vis2[i]!=5001 or i==0]\r\n\r\nprint(len(s))\r\nprint(*s)\r\n# s=list(vis[501])\r\n# s.sort()\r\n# print(len(s))\r\n# print(*s)",
    "prob_desc_created_at": "1635069900",
    "tags": [
        "binary search",
        "brute force",
        "dp",
        "greedy",
        "two pointers"
    ],
    "hidden_unit_tests": ""
}
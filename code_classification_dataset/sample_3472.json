{
    "prob_desc_time_limit": "3 seconds",
    "prob_desc_sample_outputs": "[\"19\", \"2930\"]",
    "src_uid": "9f36d49541e6dd7082e37416cdb1949c",
    "prob_desc_notes": null,
    "prob_desc_description": "Once Vasya and Petya assembled a figure of m cubes, each of them is associated with a number between 0 and m - 1 (inclusive, each number appeared exactly once). Let's consider a coordinate system such that the OX is the ground, and the OY is directed upwards. Each cube is associated with the coordinates of its lower left corner, these coordinates are integers for each cube.The figure turned out to be stable. This means that for any cube that is not on the ground, there is at least one cube under it such that those two cubes touch by a side or a corner. More formally, this means that for the cube with coordinates (x, y) either y = 0, or there is a cube with coordinates (x - 1, y - 1), (x, y - 1) or (x + 1, y - 1).Now the boys want to disassemble the figure and put all the cubes in a row. In one step the cube is removed from the figure and being put to the right of the blocks that have already been laid. The guys remove the cubes in such order that the figure remains stable. To make the process more interesting, the guys decided to play the following game. The guys take out the cubes from the figure in turns. It is easy to see that after the figure is disassembled, the integers written on the cubes form a number, written in the m-ary positional numerical system (possibly, with a leading zero). Vasya wants the resulting number to be maximum possible, and Petya, on the contrary, tries to make it as small as possible. Vasya starts the game.Your task is to determine what number is formed after the figure is disassembled, if the boys play optimally. Determine the remainder of the answer modulo 109 + 9.",
    "prob_desc_output_spec": "In the only line print the answer to the problem.",
    "prob_desc_input_spec": "The first line contains number m (2 ≤ m ≤ 105). The following m lines contain the coordinates of the cubes xi, yi ( - 109 ≤ xi ≤ 109, 0 ≤ yi ≤ 109) in ascending order of numbers written on them. It is guaranteed that the original figure is stable. No two cubes occupy the same place.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "Python 3",
    "lang_cluster": "Python",
    "difficulty": 2100,
    "file_name": "train_062.jsonl",
    "code_uid": "f76faa7177932df737750ad799a7824c",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"3\\n2 1\\n1 0\\n0 1\", \"5\\n0 0\\n0 1\\n0 2\\n0 3\\n0 4\"]",
    "exec_outcome": "PASSED",
    "source_code": "import heapq\n\ndef coor_neighbor(coor, dxs, dys):\n    x, y = coor\n    for dx in dxs:\n        for dy in dys:\n            yield x + dx, y + dy\n\n\ndef coor_bottoms(coor):\n    return coor_neighbor(coor, (-1, 0, 1), (-1, ))\n\n\ndef coor_tops(coor):\n    return coor_neighbor(coor, (-1, 0, 1), (1, ))\n\n\ndef coor_sibs(coor):\n    return coor_neighbor(coor, (-2, -1, 1, 2), (0, ))\n\n\nclass Figure:\n\n    def __init__(self, coors):\n        self._coors = dict()\n        self._stables_min = []\n        self._stables_max = []\n        self._pushed = set()\n        self._dropped = set()\n\n        cubes = dict()\n        self._bots = dict()\n        self._tops = dict()\n        for idx, coor in enumerate(coors):\n            cubes[coor] = idx\n            self._coors[idx] = coor\n            self._bots[idx] = set()\n            self._tops[idx] = set()\n\n        coor_set = set(coors)\n        for idx, coor in enumerate(coors):\n            for bottom in coor_bottoms(coor):\n                if bottom in coor_set:\n                    self._bots[idx].add(cubes[bottom])\n            for top in coor_tops(coor):\n                if top in coor_set:\n                    self._tops[idx].add(cubes[top])\n\n        for idx in self._coors:\n            if self.isdroppable(idx):\n                self.push(idx)\n\n    def sibs(self, idx):\n        for top_idx in self._tops[idx]:\n            for sib_idx in self._bots[top_idx]:\n                if sib_idx not in self._dropped:\n                    yield sib_idx\n\n    def bottom_count(self, idx):\n        return len(self._bots[idx])\n\n    def isdroppable(self, idx):\n        return all(len(self._bots[top_idx]) > 1 for top_idx in self._tops[idx])\n\n    def push(self, idx):\n        if idx not in self._pushed:\n            heapq.heappush(self._stables_min, idx)\n            heapq.heappush(self._stables_max, -idx)\n            self._pushed.add(idx)\n\n    def unpush(self, idx):\n        if idx in self._pushed:\n            self._pushed.remove(idx)\n\n    def drop(self, idx):\n        if idx not in self._pushed:\n            return False\n        self._pushed.remove(idx)\n        self._dropped.add(idx)\n\n        for bot_idx in self._bots[idx]:\n            self._tops[bot_idx].remove(idx)\n        for top_idx in self._tops[idx]:\n            self._bots[top_idx].remove(idx)\n\n        coor = self._coors[idx]\n        for bot_idx in self._bots[idx]:\n            if self.isdroppable(bot_idx):\n                self.push(bot_idx)\n        for sib_idx in self.sibs(idx):\n            if not self.isdroppable(sib_idx):\n                self.unpush(sib_idx)\n        return True\n\n    def drop_min(self):\n        while True:\n            if not self._stables_min:\n                return None\n            min_idx = heapq.heappop(self._stables_min)\n            if self.drop(min_idx):\n                return min_idx\n\n    def drop_max(self):\n        while True:\n            if not self._stables_max:\n                return None\n            max_idx = - heapq.heappop(self._stables_max)\n            if self.drop(max_idx):\n                return max_idx\n\n    def __bool__(self):\n        return len(self._coors) != len(self._dropped)\n\n\ndef input_tuple():\n    return tuple(map(int, input().split()))\n\n\ndef result_add(result, base, num):\n    return (result * base + num) % (10 ** 9 + 9)\n\n\nN = int(input())\ncoors = [input_tuple() for _ in range(N)]\n\nfigure = Figure(coors)\nresult = 0\nwhile True:\n    if not figure:\n        break\n    result = result_add(result, N, figure.drop_max())\n    if not figure:\n        break\n    result = result_add(result, N, figure.drop_min())\nprint(result)\n",
    "prob_desc_created_at": "1425279600",
    "tags": [
        "data structures",
        "implementation",
        "greedy"
    ],
    "hidden_unit_tests": ""
}
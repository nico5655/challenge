{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"6\\n3\\n5\\n4\\n15\\n10\"]",
    "src_uid": "819aebac427c2c0f96e58bca60b81e33",
    "prob_desc_notes": "NoteThe first test case is explained in the statement.In the second test case, a $$$6$$$-beautiful necklace can be assembled from all the letters.In the third test case, a $$$1000$$$-beautiful necklace can be assembled, for example, from beads \"abzyo\".",
    "prob_desc_description": "The store sells $$$n$$$ beads. The color of each bead is described by a lowercase letter of the English alphabet (\"a\"–\"z\"). You want to buy some beads to assemble a necklace from them.A necklace is a set of beads connected in a circle.For example, if the store sells beads \"a\", \"b\", \"c\", \"a\", \"c\", \"c\", then you can assemble the following necklaces (these are not all possible options):  And the following necklaces cannot be assembled from beads sold in the store:  The first necklace cannot be assembled because it has three beads \"a\" (of the two available). The second necklace cannot be assembled because it contains a bead \"d\", which is not sold in the store. We call a necklace $$$k$$$-beautiful if, when it is turned clockwise by $$$k$$$ beads, the necklace remains unchanged. For example, here is a sequence of three turns of a necklace.    As you can see, this necklace is, for example, $$$3$$$-beautiful, $$$6$$$-beautiful, $$$9$$$-beautiful, and so on, but it is not $$$1$$$-beautiful or $$$2$$$-beautiful.In particular, a necklace of length $$$1$$$ is $$$k$$$-beautiful for any integer $$$k$$$. A necklace that consists of beads of the same color is also beautiful for any $$$k$$$.You are given the integers $$$n$$$ and $$$k$$$, and also the string $$$s$$$ containing $$$n$$$ lowercase letters of the English alphabet — each letter defines a bead in the store. You can buy any subset of beads and connect them in any order. Find the maximum length of a $$$k$$$-beautiful necklace you can assemble.",
    "prob_desc_output_spec": "Output $$$t$$$ answers to the test cases. Each answer is a positive integer — the maximum length of the $$$k$$$-beautiful necklace you can assemble.",
    "prob_desc_input_spec": "The first line contains a single integer $$$t$$$ ($$$1 \\le t \\le 100$$$) — the number of test cases in the test. Then $$$t$$$ test cases follow. The first line of each test case contains two integers $$$n$$$ and $$$k$$$ ($$$1 \\le n, k \\le 2000$$$). The second line of each test case contains the string $$$s$$$ containing $$$n$$$ lowercase English letters — the beads in the store. It is guaranteed that the sum of $$$n$$$ for all test cases does not exceed $$$2000$$$.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "Python 3",
    "lang_cluster": "Python",
    "difficulty": 1900,
    "file_name": "train_009.jsonl",
    "code_uid": "9bd5ec1239b41d2b14aaf4ca36aeb98a",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"6\\n6 3\\nabcbac\\n3 6\\naaa\\n7 1000\\nabczgyo\\n5 4\\nababa\\n20 10\\naaebdbabdbbddaadaadc\\n20 5\\necbedececacbcbccbdec\"]",
    "exec_outcome": "PASSED",
    "source_code": "import math\nimport collections\n \nt = int(input())\nfor _ in range(t):\n    n,k = map(int, input().split())\n    s = input()\n    ctr = collections.Counter(s)\n \n    ans = 0\n    for i in range(1,n+1):\n        g = math.gcd(i, k)\n        l = i // g\n        cnt = sum([(v//l)*l for v in ctr.values()])\n        if cnt >= i:\n            ans = i\n    print(ans)",
    "prob_desc_created_at": "1592318100",
    "tags": [
        "dp",
        "greedy",
        "graphs",
        "number theory",
        "dfs and similar",
        "brute force"
    ],
    "hidden_unit_tests": ""
}
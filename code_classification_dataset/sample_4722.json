{
    "prob_desc_time_limit": "3 seconds",
    "prob_desc_sample_outputs": "[\"NO\\nYES\\nYES\\nNO\\nYES\\nYES\"]",
    "src_uid": "73a077e8e715c72e37cf10fca281d3e2",
    "prob_desc_notes": "NoteThe state of conveyor with $$$t = 0$$$. Red arrow represents the direction of each belt, and blue figure represents slime.The state of conveyor with $$$t = 1$$$.The state of conveyor with $$$t = 2$$$.",
    "prob_desc_description": "There is a conveyor with $$$120$$$ rows and $$$120$$$ columns. Each row and column is numbered from $$$0$$$ to $$$119$$$, and the cell in $$$i$$$-th row and $$$j$$$-th column is denoted as $$$(i, j)$$$. The top leftmost cell is $$$(0, 0)$$$. Each cell has a belt, and all belts are initially facing to the right.Initially, a slime ball is on the belt of $$$(0, 0)$$$, and other belts are empty. Every second, the state of the conveyor changes as follows:   All slime balls on the conveyor move one cell in the direction of the belt at the same time. If there is no cell in the moved position, the slime gets out of the conveyor, and if two slime balls move to the same cell, they merge into one.  All belts with slime ball in the previous second change direction at the same time: belts facing to the right become facing to the down, and vice versa.  A new slime ball is placed on cell $$$(0, 0)$$$. There are $$$q$$$ queries, each being three integers $$$t$$$, $$$x$$$, and $$$y$$$. You have to find out if there is a slime at the cell $$$(x, y)$$$ after $$$t$$$ seconds from the start. Can you do it?",
    "prob_desc_output_spec": "Print the answer for each test case, one per line. If there is a slime ball in the cell $$$(x, y)$$$ after $$$t$$$ seconds from the initial state, print \"YES\". Otherwise, print \"NO\".",
    "prob_desc_input_spec": "The first line contains one integer $$$q$$$ ($$$1 \\le q \\le 10^4$$$) â€” the number of queries. The only line of each query contains three integers $$$t$$$, $$$x$$$, and $$$y$$$ ($$$0 \\le t \\le 10^{18}$$$, $$$0 \\le x, y &lt; 120$$$).",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3-64",
    "lang_cluster": "Python",
    "difficulty": 2700,
    "file_name": "train_104.jsonl",
    "code_uid": "495a0ecff1011b3894b7934093b1e3ea",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"6\\n\\n1 1 0\\n\\n5 1 3\\n\\n0 0 0\\n\\n2 4 5\\n\\n2 0 2\\n\\n1547748756 100 111\"]",
    "exec_outcome": "PASSED",
    "source_code": "#from math import ceil, floor #, gcd, log, factorial, comb, perm,\r\n#log10, log2, log, sin, asin, tan, atan, radians\r\n#from heapq import heappop,heappush,heapify #heappop(hq), heapify(list)\r\n#from collections import defaultdict as dd\r\n#mydd=dd(list) for .append\r\n#from collections import deque as dq #deque  e.g. myqueue=dq(list)\r\n#append/appendleft/appendright/pop/popleft\r\n#from bisect import bisect as bis #a=[1,3,4,6,7,8] #bis(a,5) --> 3\r\n#import statistics as stat  # stat.median(a), mode, mean\r\n#from math import ceil, floor\r\nimport sys\r\ninput = sys.stdin.readline\r\n#print = sys.stdout.write\r\n#sys.setrecursionlimit(100000) #default is 1000 \r\n############ ---- Input Functions ---- ############\r\ndef inp():\r\n    return(int(input()))\r\ndef inlt():\r\n    return(list(map(int,input().split())))   #.split(','), default is space\r\n#list([0,*map(int,input().split(\" \"))]) # pad a zero to avoid zero indexing\r\ndef insr():\r\n    s = input()\r\n    return(list(s[:len(s) - 1]))\r\n####################################################\r\n#t=1\r\nq = int(input())\r\nfor qc in range(q):\r\n    t,x,y=map(int, input().split())\r\n#    n=inp()\r\n#    a=inlt()\r\n#    x=list(input().strip(\"\\n\").split())\r\n#    s=input().strip(\"\\n\")\r\n#    s=input()[:-1]\r\n#    s=insr()\r\n#    occ=dict();\r\n#    for i in range(n):occ[i]=[]\r\n#    for i in range(n):\r\n#        occ[i].append(inlt())\r\n#    a=[]\r\n#    for i in range(n):\r\n#        a.append(inlt())\r\n    if x+y>t:print('NO');continue\r\n    if x==y==0:print('YES');continue\r\n    a=[[0]*122 for i in range(122)]\r\n    a[0][0]=t-x-y\r\n    for i in range(x+1):\r\n        for j in range(y+1):\r\n            a[i+1][j]+=a[i][j]//2\r\n            a[i][j+1]+=(a[i][j]+1)//2\r\n    i=0;j=0\r\n    while i+j<x+y and i<121 and j<121:\r\n        if a[i][j]%2:\r\n            i+=1\r\n        else:\r\n            j+=1\r\n    if i==x:\r\n        print('YES')\r\n    else:\r\n        print('NO')\r\n        \r\n#print(*ans,sep=' ')##print(\"{:.3f}\".format(ans)+\"%\")\r\n#:b binary :% eg print(\"{:6.2%}\".format(ans))\r\n#print(\" \".join(str(i) for i in ans))\r\n#print(\" \".join(map(str,ans))) #seems faster\r\n#print(a[0] if a else 0)\r\n#prefixsum a=[a1...an] #psa=[0]*(n+1)\r\n#for i in range(n): psa[i+1]=psa[i]+a[i]\r\n#sum[:ax]=psa[x+1] e.g. sum 1st 5 items in psa[5]\r\n#ASCII<->number ord('f')=102 chr(102)='f'\r\n#def binary_search(li, val, lb, ub):\r\n#    while ((ub-lb)>1):\r\n#        mid = (lb + ub) // 2\r\n#        if li[mid] >= val:\r\n#            ub = mid\r\n#        else:\r\n#            lb = mid\r\n#    return lb+1 #return index of elements <val in li\r\n#def binary_search(li, val, lb, ub):\r\n#    ans = -1\r\n#    while (lb <= ub):\r\n#        mid = (lb + ub) // 2\r\n#        if li[mid] > val:\r\n#            ub = mid - 1\r\n#        elif val > li[mid]:\r\n#            lb = mid + 1\r\n#        else:\r\n#            ans = mid  # return index\r\n#            break\r\n#    return ans\r\n##########\r\n#def pref(li):\r\n#    pref_sum = [0]\r\n#    for i in li:\r\n#        pref_sum.append(pref_sum[-1] + i)\r\n#    return pref_sum\r\n##########\r\n#def suff(li):\r\n#    suff_sum = [0]\r\n#    for i in range(len(li)-1,-1,-1):\r\n#        suff_sum.insert(0,suff_sum[0] + li[i])\r\n#    return suff_sum\r\n#############\r\n#def maxSubArraySumI(arr): #Kadane's algorithm with index\r\n#    max_till_now=arr[0];max_ending=0;size=len(arr)\r\n#    start=0;end=0;s=0\r\n#    for i in range(0, size):\r\n#        max_ending = max_ending + arr[i]\r\n#        if max_till_now < max_ending:\r\n#            max_till_now=max_ending\r\n#            start=s;end=i\r\n#        if max_ending<0:\r\n#            max_ending=0\r\n#            s=i+1\r\n#    return max_till_now,start,end\r\n############# avoid max for 2 elements - slower than direct if\r\n#def maxSubArraySum(arr): #Kadane's algorithm\r\n#    max_till_now=arr[0];max_ending=0;size=len(arr)\r\n#    for i in range(0, size):\r\n#        max_ending = max_ending + arr[i]\r\n#        if max_till_now < max_ending:max_till_now=max_ending\r\n#        if max_ending<0:max_ending=0\r\n#    return max_till_now\r\n#############\r\n#def findbits(x):\r\n#    tmp=[]\r\n#    while x>0:tmp.append(x%2);x//=2\r\n#    tmp.reverse()\r\n#    return tmp\r\n##############Dijkstra algorithm example\r\n#dg=[999999]*(n+1);dg[n]=0;todo=[(0,n)];chkd=[0]*(n+1)\r\n#while todo:#### find x with min dg in todo\r\n#    _,x=hq.heappop(todo)\r\n#    if chkd[x]:continue\r\n#    for i in coming[x]:going[i]-=1\r\n#    for i in coming[x]:\r\n#        tmp=1+dg[x]+going[i]\r\n#        if tmp<dg[i]:dg[i]=tmp;hq.heappush(todo,(dg[i],i))   \r\n#    chkd[x]=1\r\n################ \r\n# adj swaps to match 2 binary strings: sum_{i=1}^n(abs(diff in i-th prefix sums))\r\n###############\r\n##s=[2, 3, 1, 4, 5, 3]\r\n##sorted(range(len(s)), key=lambda k: s[k])\r\n##gives sorted indices [2, 0, 1, 5, 3, 4]\r\n##m= [[3, 4, 6], [2, 4, 8], [2, 3, 4], [1, 2, 3], [7, 6, 7], [1, 8, 2]]\r\n##m.sort(reverse=True,key=lambda k:k[2]) #sorts m according to 3rd elements\r\n\r\n",
    "prob_desc_created_at": "1663598100",
    "tags": [
        "constructive algorithms",
        "dp",
        "math"
    ],
    "hidden_unit_tests": ""
}
{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"3\\n1\\n1\\n1\\n0\", \"3\\n2\\n2\\n1\\n0\", \"1\\n1\\n1\\n1\"]",
    "src_uid": "23fc2595e2813d0817e3cc0f1bb22eae",
    "prob_desc_notes": "NoteConsider the first example:On the first day, student $$$3$$$ leaves their club. Now, the remaining students are $$$1$$$, $$$2$$$, $$$4$$$ and $$$5$$$. We can select students $$$1$$$, $$$2$$$ and $$$4$$$ to get maximum possible strength, which is $$$3$$$. Note, that we can't select students $$$1$$$, $$$2$$$ and $$$5$$$, as students $$$2$$$ and $$$5$$$ belong to the same club. Also, we can't select students $$$1$$$, $$$3$$$ and $$$4$$$, since student $$$3$$$ has left their club.On the second day, student $$$2$$$ leaves their club. Now, the remaining students are $$$1$$$, $$$4$$$ and $$$5$$$. We can select students $$$1$$$, $$$4$$$ and $$$5$$$ to get maximum possible strength, which is $$$1$$$.On the third day, the remaining students are $$$1$$$ and $$$5$$$. We can select students $$$1$$$ and $$$5$$$ to get maximum possible strength, which is $$$1$$$.On the fourth day, the remaining student is $$$1$$$. We can select student $$$1$$$ to get maximum possible strength, which is $$$1$$$. On the fifth day, no club has students and so the maximum possible strength is $$$0$$$.",
    "prob_desc_description": "There are $$$n$$$ students and $$$m$$$ clubs in a college. The clubs are numbered from $$$1$$$ to $$$m$$$. Each student has a potential $$$p_i$$$ and is a member of the club with index $$$c_i$$$. Initially, each student is a member of exactly one club. A technical fest starts in the college, and it will run for the next $$$d$$$ days. There is a coding competition every day in the technical fest. Every day, in the morning, exactly one student of the college leaves their club. Once a student leaves their club, they will never join any club again. Every day, in the afternoon, the director of the college will select one student from each club (in case some club has no members, nobody is selected from that club) to form a team for this day's coding competition. The strength of a team is the mex of potentials of the students in the team. The director wants to know the maximum possible strength of the team for each of the coming $$$d$$$ days. Thus, every day the director chooses such team, that the team strength is maximized.The mex of the multiset $$$S$$$ is the smallest non-negative integer that is not present in $$$S$$$. For example, the mex of the $$$\\{0, 1, 1, 2, 4, 5, 9\\}$$$ is $$$3$$$, the mex of $$$\\{1, 2, 3\\}$$$ is $$$0$$$ and the mex of $$$\\varnothing$$$ (empty set) is $$$0$$$.",
    "prob_desc_output_spec": "For each of the $$$d$$$ days, print the maximum possible strength of the team on that day.",
    "prob_desc_input_spec": "The first line contains two integers $$$n$$$ and $$$m$$$ ($$$1 \\leq m \\leq n \\leq 5000$$$), the number of students and the number of clubs in college. The second line contains $$$n$$$ integers $$$p_1, p_2, \\ldots, p_n$$$ ($$$0 \\leq p_i &lt; 5000$$$), where $$$p_i$$$ is the potential of the $$$i$$$-th student. The third line contains $$$n$$$ integers $$$c_1, c_2, \\ldots, c_n$$$ ($$$1 \\leq c_i \\leq m$$$), which means that $$$i$$$-th student is initially a member of the club with index $$$c_i$$$. The fourth line contains an integer $$$d$$$ ($$$1 \\leq d \\leq n$$$), number of days for which the director wants to know the maximum possible strength of the team.  Each of the next $$$d$$$ lines contains an integer $$$k_i$$$ ($$$1 \\leq k_i \\leq n$$$), which means that $$$k_i$$$-th student lefts their club on the $$$i$$$-th day. It is guaranteed, that the $$$k_i$$$-th student has not left their club earlier.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3",
    "lang_cluster": "Python",
    "difficulty": 2400,
    "file_name": "train_082.jsonl",
    "code_uid": "5f77f52cc8eff6bf72afffb927cae52a",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"5 3\\n0 1 2 2 0\\n1 2 2 3 2\\n5\\n3\\n2\\n4\\n5\\n1\", \"5 3\\n0 1 2 2 1\\n1 3 2 3 2\\n5\\n4\\n2\\n3\\n5\\n1\", \"5 5\\n0 1 2 4 5\\n1 2 3 4 5\\n4\\n2\\n3\\n5\\n4\"]",
    "exec_outcome": "PASSED",
    "source_code": "import sys\ninput = sys.stdin.readline \n\nn, m = map(int, input().split())\np = list(map(int, input().split()))\nc = list(map(int, input().split()))\nd = int(input())\ndisable = [False] * n\nbase = 5001\nds = [int(input())-1 for _ in range(d)]\nfor ele in ds:\n    disable[ele] = True\n\n# Create Graph\n\nchilds = [[] for i in range(base+m+1)]\n\nfor idx, (i, j) in enumerate(zip(p, c)):\n    if not disable[idx]:\n        childs[i].append(base+j)\n\n\n# dfs\n# alternative path for finding maximum cardinality\n\nvis = [False]*(base+m+1)\nmatching = [-1]*(base+m+1)\n\ndef dfs(num):\n    for child in childs[num]:\n        if not vis[child]:\n            vis[child] = True\n            if matching[child] == -1 or dfs(matching[child]):\n                matching[child] = num\n                return True\n    return False\n\nans = []\nmex = 0\nfor idx in range(d-1, -1, -1):\n    while True:\n        vis = [False]*(base+m+1)\n        if not dfs(mex):\n            break\n        mex += 1\n    # Add edge\n    ans.append(mex)\n    childs[p[ds[idx]]].append(base+c[ds[idx]])\n\nprint(\"\\n\".join([str(a) for a in reversed(ans)]))",
    "prob_desc_created_at": "1553182500",
    "tags": [
        "graph matchings",
        "flows",
        "graphs"
    ],
    "hidden_unit_tests": ""
}
{
    "prob_desc_time_limit": "1 second",
    "prob_desc_sample_outputs": "[\"4\\n5\\n6\\n0\\n12\"]",
    "src_uid": "7458f44802c134de6fed7b4de84ea68c",
    "prob_desc_notes": "NoteIn the first test case, there exists only $$$3$$$ strings of length $$$3$$$, which has exactly $$$1$$$ symbol, equal to \"1\". These strings are: $$$s_1 = $$$\"100\", $$$s_2 = $$$\"010\", $$$s_3 = $$$\"001\". The values of $$$f$$$ for them are: $$$f(s_1) = 3, f(s_2) = 4, f(s_3) = 3$$$, so the maximum value is $$$4$$$ and the answer is $$$4$$$.In the second test case, the string $$$s$$$ with the maximum value is \"101\".In the third test case, the string $$$s$$$ with the maximum value is \"111\".In the fourth test case, the only string $$$s$$$ of length $$$4$$$, which has exactly $$$0$$$ symbols, equal to \"1\" is \"0000\" and the value of $$$f$$$ for that string is $$$0$$$, so the answer is $$$0$$$.In the fifth test case, the string $$$s$$$ with the maximum value is \"01010\" and it is described as an example in the problem statement.",
    "prob_desc_description": "Ayoub thinks that he is a very smart person, so he created a function $$$f(s)$$$, where $$$s$$$ is a binary string (a string which contains only symbols \"0\" and \"1\"). The function $$$f(s)$$$ is equal to the number of substrings in the string $$$s$$$ that contains at least one symbol, that is equal to \"1\".More formally, $$$f(s)$$$ is equal to the number of pairs of integers $$$(l, r)$$$, such that $$$1 \\leq l \\leq r \\leq |s|$$$ (where $$$|s|$$$ is equal to the length of string $$$s$$$), such that at least one of the symbols $$$s_l, s_{l+1}, \\ldots, s_r$$$ is equal to \"1\". For example, if $$$s = $$$\"01010\" then $$$f(s) = 12$$$, because there are $$$12$$$ such pairs $$$(l, r)$$$: $$$(1, 2), (1, 3), (1, 4), (1, 5), (2, 2), (2, 3), (2, 4), (2, 5), (3, 4), (3, 5), (4, 4), (4, 5)$$$.Ayoub also thinks that he is smarter than Mahmoud so he gave him two integers $$$n$$$ and $$$m$$$ and asked him this problem. For all binary strings $$$s$$$ of length $$$n$$$ which contains exactly $$$m$$$ symbols equal to \"1\", find the maximum value of $$$f(s)$$$.Mahmoud couldn't solve the problem so he asked you for help. Can you help him? ",
    "prob_desc_output_spec": "For every test case print one integer number — the maximum value of $$$f(s)$$$ over all strings $$$s$$$ of length $$$n$$$, which has exactly $$$m$$$ symbols, equal to \"1\".",
    "prob_desc_input_spec": "The input consists of multiple test cases. The first line contains a single integer $$$t$$$ ($$$1 \\leq t \\leq 10^5$$$)  — the number of test cases. The description of the test cases follows. The only line for each test case contains two integers $$$n$$$, $$$m$$$ ($$$1 \\leq n \\leq 10^{9}$$$, $$$0 \\leq m \\leq n$$$) — the length of the string and the number of symbols equal to \"1\" in it.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3",
    "lang_cluster": "Python",
    "difficulty": 1700,
    "file_name": "train_010.jsonl",
    "code_uid": "4da03af02b617c514d497ffc15be614b",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"5\\n3 1\\n3 2\\n3 3\\n4 0\\n5 2\"]",
    "exec_outcome": "PASSED",
    "source_code": "\"\"\"\n#If FastIO not needed, used this and don't forget to strip\n#import sys, math\n#input = sys.stdin.readline\n\"\"\"\n\nimport os\nimport sys\nfrom io import BytesIO, IOBase\nimport heapq as h \nfrom bisect import bisect_left, bisect_right\n\nfrom types import GeneratorType\nBUFSIZE = 8192\nclass FastIO(IOBase):\n    newlines = 0\n \n    def __init__(self, file):\n        import os\n        self.os = os\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n \n    def read(self):\n        while True:\n            b = self.os.read(self._fd, max(self.os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n \n    def readline(self):\n        while self.newlines == 0:\n            b = self.os.read(self._fd, max(self.os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n \n    def flush(self):\n        if self.writable:\n            self.os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n \n \nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n \n \nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nimport collections as col\nimport math, string\n\ndef getInts():\n    return [int(s) for s in input().split()]\n\ndef getInt():\n    return int(input())\n\ndef getStrs():\n    return [s for s in input().split()]\n\ndef getStr():\n    return input()\n\ndef listStr():\n    return list(input())\n\nMOD = 10**9+7\n\n\n\"\"\"\nStrings of length 1 is always M\nStrings of length 2 can be maximised by having the 1s at least 1 zero apart where necessary\nIf M >= floor(N//2), then every substring except some of the 1s works\n\nOtherwise, M 1s, N-M 0s. We want to split the 0s as evenly as possible\n\n00100100\n\nPartition the 0s into M+1 groups\n\n000100100\nf(1) = 2\nf(2) = 4\nf(3) = 6\nf(4) = 6\nf(5) = 5\nf(6) = 4\nf(7) = 3\nf(8) = 2\nf(9) = 1\n\n001000100\nf(1) = 2\nf(2) = 4\nf(3) = 6\nf(4) = 6\n\n00010000\n\nmax gap = ceil((N-M)/(M+1))\nfor x < max gap, contribution is M*x\nfor x >= max gap, contribution is N-x+1\nso we want sum x = 1 to max_gap (M*x) + sum x = max_gap+1 to N (N-x+1)\n\nObviously M = 0 => 0\nM = 1 =>\n\"\"\"\n\ndef solve():\n    N, M = getInts()\n    if M == 0:\n        return 0\n    gap = math.ceil((N-M)/(M+1))\n    ans = (M+1)*gap*(gap+1)//2 + (N-gap)*(N+1) - N*(N+1)//2\n    return ans\n    \n\n    \nfor _ in range(getInt()):\n        print(solve())",
    "prob_desc_created_at": "1581604500",
    "tags": [
        "greedy",
        "combinatorics",
        "math",
        "binary search",
        "strings"
    ],
    "hidden_unit_tests": ""
}
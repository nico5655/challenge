{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"20\", \"114\", \"3\"]",
    "src_uid": "0b4362204bb9f0e95eaf7e2949315c8f",
    "prob_desc_notes": "NoteIn the first sample, the given tree has 6 vertices and it's displayed on the drawing below. Limak can jump to any vertex within distance at most 2. For example, from the vertex 5 he can jump to any of vertices: 1, 2 and 4 (well, he can also jump to the vertex 5 itself).  There are  pairs of vertices (s, t) such that s &lt; t. For 5 of those pairs Limak would need two jumps: (1, 6), (3, 4), (3, 5), (3, 6), (5, 6). For other 10 pairs one jump is enough. So, the answer is 5·2 + 10·1 = 20.In the third sample, Limak can jump between every two vertices directly. There are 3 pairs of vertices (s &lt; t), so the answer is 3·1 = 3.",
    "prob_desc_description": "A tree is an undirected connected graph without cycles. The distance between two vertices is the number of edges in a simple path between them.Limak is a little polar bear. He lives in a tree that consists of n vertices, numbered 1 through n.Limak recently learned how to jump. He can jump from a vertex to any vertex within distance at most k.For a pair of vertices (s, t) we define f(s, t) as the minimum number of jumps Limak needs to get from s to t. Your task is to find the sum of f(s, t) over all pairs of vertices (s, t) such that s &lt; t.",
    "prob_desc_output_spec": "Print one integer, denoting the sum of f(s, t) over all pairs of vertices (s, t) such that s &lt; t.",
    "prob_desc_input_spec": "The first line of the input contains two integers n and k (2 ≤ n ≤ 200 000, 1 ≤ k ≤ 5) — the number of vertices in the tree and the maximum allowed jump distance respectively. The next n - 1 lines describe edges in the tree. The i-th of those lines contains two integers ai and bi (1 ≤ ai, bi ≤ n) — the indices on vertices connected with i-th edge. It's guaranteed that the given edges form a tree.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 2",
    "lang_cluster": "Python",
    "difficulty": 2100,
    "file_name": "train_064.jsonl",
    "code_uid": "57b3a9f455ce6f04fc39ab4ec77df006",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"6 2\\n1 2\\n1 3\\n2 4\\n2 5\\n4 6\", \"13 3\\n1 2\\n3 2\\n4 2\\n5 2\\n3 6\\n10 6\\n6 7\\n6 13\\n5 8\\n5 9\\n9 11\\n11 12\", \"3 5\\n2 1\\n3 1\"]",
    "exec_outcome": "PASSED",
    "source_code": "def main():\n    inp = readnumbers()\n    ii = 0\n\n    n = inp[ii]\n    ii += 1\n    k = inp[ii]\n    ii += 1\n\n    coupl = [[] for _ in range(n)]\n    for _ in range(n-1):\n        u = inp[ii]-1\n        ii += 1\n        v = inp[ii]-1\n        ii += 1\n\n        coupl[u].append(v)\n        coupl[v].append(u)\n\n    found = [False]*n\n    \n    @bootstrap\n    def solve(node):\n        A = [0]*k\n        A[0] = 1\n        Acount = 0\n        Aans = 0\n        \n        for nei in coupl[node]:\n            if not found[nei]:\n                found[nei] = True\n                B,Bcount,Bans = yield solve(nei)\n                Aans += Bans\n                Aans += Bcount * sum(A)\n                Aans += Acount * sum(B)\n                Acount += Bcount\n\n                for i in range(k):\n                    for j in range(k):\n                        Aans += ((i+j+k)//k)*A[i]*B[j]\n                for i in range(k-1):\n                    A[i+1] += B[i]\n                A[0] += B[k-1]\n                Acount += B[k-1]\n\n        yield A,Acount,Aans\n\n    found[0] = True\n    _,_,ans = solve(0)\n    print ans\n\n\n######## Python 2 and 3 footer by Pajenegod and c1729\n\n# Note because cf runs old PyPy3 version which doesn't have the sped up\n# unicode strings, PyPy3 strings will many times be slower than pypy2.\n# There is a way to get around this by using binary strings in PyPy3\n# but its syntax is different which makes it kind of a mess to use.\n\n# So on cf, use PyPy2 for best string performance.\n\npy2 = round(0.5)\nif py2:\n    from future_builtins import ascii, filter, hex, map, oct, zip\n    range = xrange\n\nimport os, sys\nfrom io import IOBase, BytesIO\n\nBUFSIZE = 8192\nclass FastIO(BytesIO):\n    newlines = 0\n\n    def __init__(self, file):\n        self._file = file\n        self._fd = file.fileno()\n        self.writable = \"x\" in file.mode or \"w\" in file.mode\n        self.write = super(FastIO, self).write if self.writable else None\n\n    def _fill(self):\n        s = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n        self.seek((self.tell(), self.seek(0,2), super(FastIO, self).write(s))[0])\n        return s\n\n    def read(self):\n        while self._fill(): pass\n        return super(FastIO,self).read()\n\n    def readline(self):\n        while self.newlines == 0:\n            s = self._fill(); self.newlines = s.count(b\"\\n\") + (not s)\n        self.newlines -= 1\n        return super(FastIO, self).readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.getvalue())\n            self.truncate(0), self.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        if py2:\n            self.write = self.buffer.write\n            self.read = self.buffer.read\n            self.readline = self.buffer.readline\n        else:\n            self.write = lambda s:self.buffer.write(s.encode('ascii'))\n            self.read = lambda:self.buffer.read().decode('ascii')\n            self.readline = lambda:self.buffer.readline().decode('ascii')\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip('\\r\\n')\n\n# Cout implemented in Python\nimport sys\nclass ostream:\n    def __lshift__(self,a):\n        sys.stdout.write(str(a))\n        return self\ncout = ostream()\nendl = '\\n'\n\n# Read all remaining integers in stdin, type is given by optional argument, this is fast\ndef readnumbers(zero = 0):\n    conv = ord if py2 else lambda x:x\n    A = []; numb = zero; sign = 1; i = 0; s = sys.stdin.buffer.read()\n    try:\n        while True:\n            if s[i] >= b'0' [0]:\n                numb = 10 * numb + conv(s[i]) - 48\n            elif s[i] == b'-' [0]: sign = -1\n            elif s[i] != b'\\r' [0]:\n                A.append(sign*numb)\n                numb = zero; sign = 1\n            i += 1\n    except:pass\n    if s and s[-1] >= b'0' [0]:\n        A.append(sign*numb)\n    return A\n\n\n# My magical way of doing recursion in python. This\n# isn't the fastest, but at least it works.\nfrom types import GeneratorType\ndef bootstrap(func, stack=[]):\n    def wrapped_function(*args, **kwargs):\n        if stack:\n            return func(*args, **kwargs)\n        else:\n            call = func(*args, **kwargs)\n            while True:\n                if type(call) is GeneratorType:\n                    stack.append(call)\n                    call = next(call)\n                else:\n                    stack.pop()\n                    if not stack:\n                        break\n                    call = stack[-1].send(call)\n            return call\n\n    return wrapped_function\n\n\nif __name__== \"__main__\":\n  main()\n",
    "prob_desc_created_at": "1489851300",
    "tags": [
        "dp",
        "dfs and similar",
        "trees"
    ],
    "hidden_unit_tests": ""
}
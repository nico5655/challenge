{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"1 2 2 2 \\n1 1 \\n2 2 3 3 3 3 3\"]",
    "src_uid": "6d76fb5753eec2b5ebe38c10ed1564f9",
    "prob_desc_notes": "Note   In the first testcase:   For $$$x = 1$$$, we can an edge between vertices $$$1$$$ and $$$3$$$, then $$$d(1) = 0$$$ and $$$d(2) = d(3) = d(4) = 1$$$, so $$$f(1) = 1$$$.  For $$$x \\ge 2$$$, no matter which edge we add, $$$d(1) = 0$$$, $$$d(2) = d(4) = 1$$$ and $$$d(3) = 2$$$, so $$$f(x) = 2$$$. ",
    "prob_desc_description": "This version of the problem differs from the previous one only in the constraint on $$$n$$$.A tree is a connected undirected graph without cycles. A weighted tree has a weight assigned to each edge. The distance between two vertices is the minimum sum of weights on the path connecting them.You are given a weighted tree with $$$n$$$ vertices, each edge has a weight of $$$1$$$. Denote $$$d(v)$$$ as the distance between vertex $$$1$$$ and vertex $$$v$$$.Let $$$f(x)$$$ be the minimum possible value of $$$\\max\\limits_{1 \\leq v \\leq n} \\ {d(v)}$$$ if you can temporarily add an edge with weight $$$x$$$ between any two vertices $$$a$$$ and $$$b$$$ $$$(1 \\le a, b \\le n)$$$. Note that after this operation, the graph is no longer a tree.For each integer $$$x$$$ from $$$1$$$ to $$$n$$$, find $$$f(x)$$$.",
    "prob_desc_output_spec": "For each test case, print $$$n$$$ integers in a single line, $$$x$$$-th of which is equal to $$$f(x)$$$ for all $$$x$$$ from $$$1$$$ to $$$n$$$.",
    "prob_desc_input_spec": "The first line contains a single integer $$$t$$$ ($$$1 \\le t \\le 10^4$$$) — the number of test cases. The first line of each test case contains a single integer $$$n$$$ ($$$2 \\le n \\le 3 \\cdot 10^5$$$). Each of the next $$$n−1$$$ lines contains two integers $$$u$$$ and $$$v$$$ ($$$1 \\le u,v \\le n$$$) indicating that there is an edge between vertices $$$u$$$ and $$$v$$$. It is guaranteed that the given edges form a tree. It is guaranteed that the sum of $$$n$$$ over all test cases doesn't exceed $$$3 \\cdot 10^5$$$.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3",
    "lang_cluster": "Python",
    "difficulty": 2700,
    "file_name": "train_084.jsonl",
    "code_uid": "f636b826f0d0c047c78ecb1d7a1a1490",
    "prob_desc_memory_limit": "512 megabytes",
    "prob_desc_sample_inputs": "[\"3\\n\\n4\\n\\n1 2\\n\\n2 3\\n\\n1 4\\n\\n2\\n\\n1 2\\n\\n7\\n\\n1 2\\n\\n1 3\\n\\n3 4\\n\\n3 5\\n\\n3 6\\n\\n5 7\"]",
    "exec_outcome": "PASSED",
    "source_code": "# import sys\r\n# I = lambda: [*map(int, sys.stdin.readline().split())]\r\n\r\nimport io,os\r\nread = io.BytesIO(os.read(0, os.fstat(0).st_size))\r\nI = lambda:map(int, read.readline().split())\r\n \r\ndef maxsparse(a):\r\n\tl = []\r\n\tl.append(a)\r\n\tc = 1\r\n\twhile c < len(a):\r\n\t\tnew = []\r\n\t\tfor i in range(len(a)):\r\n\t\t\tif i + c < len(l[-1]):\r\n\t\t\t\tnew.append(max(l[-1][i], l[-1][i + c]))\r\n\t\t\telse:\r\n\t\t\t\tbreak\r\n\t\tl.append(new)\r\n\t\tc *= 2\r\n\treturn l\r\n \r\ndef partial(table, i, j):\r\n\tif j <= i:\r\n\t\treturn -1000000\r\n\tyyy = 1\r\n\taaa = 0\r\n\twhile 2 * yyy <= j - i:\r\n\t\tyyy *= 2\r\n\t\taaa += 1\r\n\treturn max(table[aaa][i], table[aaa][j - yyy])\r\n \r\nt, = I()\r\nfor _ in range(t):\r\n    n, = I()\r\n    graph = [[] for i in range(n)]\r\n    for i in range(n - 1):\r\n        a, b = I()\r\n        graph[a - 1].append(b - 1)\r\n        graph[b - 1].append(a - 1)\r\n \r\n    parents = [None] * n\r\n    parents[0] = -1\r\n    children = [[] for i in range(n)]\r\n    layer = [0]\r\n    while layer:\r\n        newlayer = []\r\n        for guy in layer:\r\n            for boi in graph[guy]:\r\n                if parents[boi] is None:\r\n                    newlayer.append(boi)\r\n                    children[guy].append(boi)\r\n                    parents[boi] = guy\r\n        layer = newlayer\r\n    parents[0] = None\r\n    inds = [0] * n\r\n    order = []\r\n    curr = 0\r\n    while curr is not None:\r\n        if inds[curr] == len(children[curr]):\r\n            order.append(curr)\r\n            curr = parents[curr]\r\n        else:\r\n            inds[curr] += 1\r\n            curr = children[curr][inds[curr] - 1]\r\n \r\n    lowest = [0] * n\r\n    for v in order:\r\n        if children[v]:\r\n            big = max(lowest[i] for i in children[v])\r\n            lowest[v] = big + 1\r\n \r\n    depth = lowest[0]\r\n    path = [0]\r\n    curr = 0\r\n    while True:\r\n        biggest = -1\r\n        count = 0\r\n        rep = None\r\n        for child in children[curr]:\r\n            if lowest[child] > biggest:\r\n                biggest = lowest[child]\r\n                count = 1\r\n                rep = child\r\n            elif lowest[child] == biggest:\r\n                count += 1\r\n        if count == 1:\r\n            path.append(rep)\r\n            curr = rep\r\n        else:\r\n            break\r\n \r\n    other = [0] * len(path)\r\n    for i in range(len(path) - 1):\r\n        if len(children[path[i]]) == 1:\r\n            other[i] = 0\r\n        else:\r\n            other[i] = max(lowest[j] for j in children[path[i]] if j != path[i + 1]) + 1\r\n    other[-1] = lowest[path[-1]]\r\n    bigs = [other[0]]\r\n    for i in range(len(path) - 1):\r\n        bigs.append(max(bigs[-1], other[i + 1] + i + 1))\r\n    # print(path)\r\n    # print(other)\r\n    # print(bigs)\r\n    # print(children)\r\n    # print(parents)\r\n    # print(lowest)\r\n    xx = [other[i] - i for i in range(len(path))]\r\n    sparse = maxsparse(xx)\r\n \r\n    if len(path) == 1:\r\n        out = [lowest[0]] * n\r\n    else:\r\n        out = []\r\n        curr = 2\r\n        currcost = -1\r\n        for x in range(1, n + 1):\r\n            if x >= len(path) - 1 or currcost >= lowest[0]:\r\n                out.append(lowest[0])\r\n                continue\r\n            currcost = max(bigs[(x + curr) // 2], lowest[path[curr]] + x, partial(sparse, (x + curr) // 2 + 1, curr) + x + curr)\r\n            while curr < len(path) - 1:\r\n                #print(x, curr)\r\n                nextcost = max(bigs[(x + curr + 1) // 2], lowest[path[curr + 1]] + x, partial(sparse, (x + curr + 1) // 2 + 1, curr + 1) + x + curr + 1)\r\n                if nextcost < currcost:\r\n                    curr += 1\r\n                    currcost = nextcost\r\n                else:\r\n                    break\r\n            out.append(currcost)\r\n    print(*out)",
    "prob_desc_created_at": "1643553300",
    "tags": [
        "binary search",
        "dfs and similar",
        "shortest paths",
        "trees"
    ],
    "hidden_unit_tests": ""
}
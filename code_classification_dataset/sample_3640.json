{
    "prob_desc_time_limit": "1 second",
    "prob_desc_sample_outputs": "[\"YES\\nNO\\nYES\"]",
    "src_uid": "254a61b06acd3f25e7287ab90be614f1",
    "prob_desc_notes": null,
    "prob_desc_description": "Little Petya learns how to write. The teacher gave pupils the task to write the letter A on the sheet of paper. It is required to check whether Petya really had written the letter A.You are given three segments on the plane. They form the letter A if the following conditions hold:  Two segments have common endpoint (lets call these segments first and second), while the third segment connects two points on the different segments.  The angle between the first and the second segments is greater than 0 and do not exceed 90 degrees.  The third segment divides each of the first two segments in proportion not less than 1 / 4 (i.e. the ratio of the length of the shortest part to the length of the longest part is not less than 1 / 4). ",
    "prob_desc_output_spec": "Output one line for each test case. Print «YES» (without quotes), if the segments form the letter A and «NO» otherwise.",
    "prob_desc_input_spec": "The first line contains one integer t (1 ≤ t ≤ 10000) — the number of test cases to solve. Each case consists of three lines. Each of these three lines contains four space-separated integers — coordinates of the endpoints of one of the segments. All coordinates do not exceed 108 by absolute value. All segments have positive length.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "Python 3",
    "lang_cluster": "Python",
    "difficulty": 2000,
    "file_name": "train_075.jsonl",
    "code_uid": "1e579b50af42a7efdcfe5a3cff0e2961",
    "prob_desc_memory_limit": "64 megabytes",
    "prob_desc_sample_inputs": "[\"3\\n4 4 6 0\\n4 1 5 2\\n4 0 4 4\\n0 0 0 6\\n0 6 2 -4\\n1 1 0 1\\n0 0 0 5\\n0 5 2 -1\\n1 2 0 1\"]",
    "exec_outcome": "PASSED",
    "source_code": "__author__ = 'Darren'\n\n\ndef solve():\n    t = int(input())\n    while t:\n        run()\n        t -= 1\n\n\ndef run():\n    def check_condition_1():\n        record = {}\n        common, first, second = None, -1, -1\n        found = False\n        for i in range(3):\n            for j in range(2):\n                if segments[i][j] in record:\n                    if found:\n                        return False\n                    found = True\n                    common = segments[i][j]\n                    first, second = record[segments[i][j]], i\n                else:\n                    record[segments[i][j]] = i\n        if not found:\n            return False\n\n        segments[0], segments[first] = segments[first], segments[0]\n        segments[1], segments[second] = segments[second], segments[1]\n        if common != segments[0][0]:\n            segments[0][0], segments[0][1] = segments[0][1], segments[0][0]\n        if common != segments[1][0]:\n            segments[1][0], segments[1][1] = segments[1][1], segments[1][0]\n\n        nonlocal vector1, vector2, vector3, vector4\n        vector1 = Vector2D(segments[0][0], segments[0][1])\n        vector2 = Vector2D(segments[1][0], segments[1][1])\n        vector3 = Vector2D(segments[0][0], segments[2][0])\n        vector4 = Vector2D(segments[1][0], segments[2][1])\n        if vector1.parallel(vector3):\n            return vector2.parallel(vector4)\n        else:\n            vector3 = Vector2D(segments[0][0], segments[2][1])\n            vector4 = Vector2D(segments[1][0], segments[2][0])\n            return vector1.parallel(vector3) and vector2.parallel(vector4)\n\n    def check_condition_2():\n        return vector1.acute_or_perpendicular(vector2)\n\n    def check_condition_3():\n        return (0.2 <= vector1.dot_product(vector3) / vector1.distance_square() <= 0.8 and\n                0.2 <= vector2.dot_product(vector4) / vector2.distance_square() <= 0.8)\n\n    segments = []\n    for _i in range(3):\n        temp = [int(x) for x in input().split()]\n        segments.append([Point2D(temp[0], temp[1]), Point2D(temp[2], temp[3])])\n    vector1, vector2, vector3, vector4 = None, None, None, None\n    if check_condition_1() and check_condition_2() and check_condition_3():\n        print('YES')\n    else:\n        print('NO')\n\n\nclass Point2D:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __eq__(self, other):\n        return self.x == other.x and self.y == other.y\n\n    def __ne__(self, other):\n        return self.x != other.x or self.y != other.y\n\n    def __hash__(self):\n        return self.x + self.y * 31\n\n\nclass Vector2D:\n    def __init__(self, p1, p2):\n        self.x = p2.x - p1.x\n        self.y = p2.y - p1.y\n\n    def distance_square(self):\n        return self.x ** 2 + self.y ** 2\n\n    def __sub__(self, other):\n        return Vector2D(self.x - other.x, self.y - other.y)\n\n    def dot_product(self, other):\n        return self.x * other.x + self.y * other.y\n\n    def cross_product(self, other):\n        return self.x * other.y - self.y * other.x\n\n    def parallel(self, other):\n        return self.cross_product(other) == 0\n\n    def acute_or_perpendicular(self, other):\n        return self.dot_product(other) >= 0 and not self.parallel(other)\n\n\nif __name__ == '__main__':\n    solve()",
    "prob_desc_created_at": "1273154400",
    "tags": [
        "implementation",
        "geometry"
    ],
    "hidden_unit_tests": ""
}
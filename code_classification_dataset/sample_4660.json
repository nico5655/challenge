{
    "prob_desc_time_limit": "1 second",
    "prob_desc_sample_outputs": "[\"01111\", \"0011111011\"]",
    "src_uid": "2bf41400fa51f472f1d3904baa06d6a8",
    "prob_desc_notes": "NoteHere is the graph given in the first example.  There is only one minimum spanning tree in this graph. A minimum spanning tree is $$$(1,2),(3,5),(1,3),(2,4)$$$ which has weight $$$1+2+3+5=11$$$.Here is a part of the process of calling findMST(1):  reset the array vis and the edge set s;  calling dfs(1);  vis[1] := true;  iterate through each edge $$$(1,2),(1,3)$$$;  add edge $$$(1,2)$$$ into the edge set s, calling dfs(2):   vis[2] := true  iterate through each edge $$$(2,1),(2,3),(2,4)$$$;  because vis[1] = true, ignore the edge $$$(2,1)$$$;  add edge $$$(2,3)$$$ into the edge set s, calling dfs(3):   ...   In the end, it will select edges $$$(1,2),(2,3),(3,5),(2,4)$$$ with total weight $$$1+4+2+5=12&gt;11$$$, so findMST(1) does not find a minimum spanning tree.It can be shown that the other trees are all MSTs, so the answer is 01111.",
    "prob_desc_description": "You are given a connected undirected graph consisting of $$$n$$$ vertices and $$$m$$$ edges. The weight of the $$$i$$$-th edge is $$$i$$$.Here is a wrong algorithm of finding a minimum spanning tree (MST) of a graph:vis := an array of length ns := a set of edgesfunction dfs(u):    vis[u] := true    iterate through each edge (u, v) in the order from smallest to largest edge weight        if vis[v] = false            add edge (u, v) into the set (s)            dfs(v)function findMST(u):    reset all elements of (vis) to false    reset the edge set (s) to empty    dfs(u)    return the edge set (s)Each of the calls findMST(1), findMST(2), ..., findMST(n) gives you a spanning tree of the graph. Determine which of these trees are minimum spanning trees.",
    "prob_desc_output_spec": "You need to output a binary string $$$s$$$, where $$$s_i=1$$$ if findMST(i) creates an MST, and $$$s_i = 0$$$ otherwise.",
    "prob_desc_input_spec": "The first line of the input contains two integers $$$n$$$, $$$m$$$ ($$$2\\le n\\le 10^5$$$, $$$n-1\\le m\\le 2\\cdot 10^5$$$) — the number of vertices and the number of edges in the graph. Each of the following $$$m$$$ lines contains two integers $$$u_i$$$ and $$$v_i$$$ ($$$1\\le u_i, v_i\\le n$$$, $$$u_i\\ne v_i$$$), describing an undirected edge $$$(u_i,v_i)$$$ in the graph. The $$$i$$$-th edge in the input has weight $$$i$$$. It is guaranteed that the graph is connected and there is at most one edge between any pair of vertices.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3",
    "lang_cluster": "Python",
    "difficulty": 2400,
    "file_name": "train_103.jsonl",
    "code_uid": "eb2eb917905ed8eda46d42fc52287692",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"5 5\\n1 2\\n3 5\\n1 3\\n3 2\\n4 2\", \"10 11\\n1 2\\n2 5\\n3 4\\n4 2\\n8 1\\n4 5\\n10 5\\n9 5\\n8 2\\n5 7\\n4 6\"]",
    "exec_outcome": "PASSED",
    "source_code": "import sys\r\nimport io, os\r\ninput = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline\r\n\r\n\r\nn,m=map(int,input().split())\r\nEDGE=[tuple(map(int,input().split())) for i in range(m)]\r\n\r\n# UnionFind\r\n\r\nGroup = [i for i in range(n+1)] # グループ分け\r\nNodes = [1]*(n+1) # 各グループのノードの数\r\n\r\ndef find(x):\r\n    while Group[x] != x:\r\n        x=Group[x]\r\n    return x\r\n\r\ndef Union(x,y):\r\n    if find(x) != find(y):\r\n        if Nodes[find(x)] < Nodes[find(y)]:\r\n            \r\n            Nodes[find(y)] += Nodes[find(x)]\r\n            Nodes[find(x)] = 0\r\n            Group[find(x)] = find(y)\r\n            \r\n        else:\r\n            Nodes[find(x)] += Nodes[find(y)]\r\n            Nodes[find(y)] = 0\r\n            Group[find(y)] = find(x)\r\n\r\nUSE=[0]*m\r\n\r\nfor i in range(m):\r\n    x,y=EDGE[i]\r\n\r\n    if find(x)==find(y):\r\n        USE[i]=0\r\n    else:\r\n        USE[i]=1\r\n        Union(x,y)\r\n\r\nE=[[] for i in range(n+1)]\r\n\r\nOK=[0]*(n+1)\r\n\r\nfor i in range(m):\r\n    if USE[i]==1:\r\n        x,y = EDGE[i]\r\n        E[x].append(y)\r\n        E[y].append(x)\r\n\r\n        OK[x]=1\r\n        OK[y]=1\r\n\r\n# 木のHL分解+LCA\r\n\r\nN=n+1\r\nROOT=1\r\n\r\nQUE=[ROOT] \r\nParent=[-1]*(N+1)\r\nHeight=[-1]*(N+1)\r\nParent[ROOT]=N # ROOTの親を定めておく.\r\nHeight[ROOT]=0\r\nChild=[[] for i in range(N+1)]\r\nTOP_SORT=[] # トポロジカルソート\r\n\r\nwhile QUE: # トポロジカルソートと同時に親を見つける\r\n    x=QUE.pop()\r\n    TOP_SORT.append(x)\r\n    for to in E[x]:\r\n        if Parent[to]==-1:\r\n            Parent[to]=x\r\n            Height[to]=Height[x]+1\r\n            Child[x].append(to)\r\n            QUE.append(to)\r\n\r\nChildren=[1]*(N+1)\r\n\r\nfor x in TOP_SORT[::-1]: #（自分を含む）子ノードの数を調べる\r\n    Children[Parent[x]]+=Children[x]\r\n\r\nUSE=[0]*N\r\nGroup=[i for i in range(N)]\r\n\r\nfor x in TOP_SORT: # HL分解によるグループ分け\r\n    USE[x]=1\r\n    MAX_children=0\r\n    select_node=0\r\n\r\n    for to in E[x]:\r\n        if USE[to]==0 and Children[to]>MAX_children:\r\n            select_node=to\r\n            MAX_children=Children[to]\r\n\r\n    for to in E[x]:\r\n        if USE[to]==0 and to==select_node:\r\n            Group[to]=Group[x]\r\n\r\ndef LCA(a,b): # HL分解を利用してLCAを求める\r\n    while Group[a]!=Group[b]:\r\n        if Children[Parent[Group[a]]]<Children[Parent[Group[b]]]:\r\n            a=Parent[Group[a]]\r\n        else:\r\n            b=Parent[Group[b]]\r\n\r\n    if Children[a]>Children[b]:\r\n        return a\r\n    else:\r\n        return b\r\n\r\nParents=[Parent]\r\n\r\nfor i in range(30):\r\n    X=[-1]*(N+1)\r\n\r\n    for i in range(N+1):\r\n        X[i]=Parents[-1][Parents[-1][i]]\r\n\r\n    Parents.append(X)\r\n\r\ndef LCA_mae(x,y):\r\n    while Height[x]>Height[y]+1:\r\n        for i in range(30):\r\n            k=Parents[i][x]\r\n\r\n            if k==-1 or k>=n or Height[k]<=Height[y]:\r\n                x=Parents[i-1][x]\r\n                break\r\n    return x\r\n\r\nDOWN=[0]*(N+1)\r\n\r\nscore=0\r\n\r\nfor x,y in EDGE:\r\n    if OK[x]==1 and OK[y]==1:\r\n        if Parent[x]==y or Parent[y]==x:\r\n            continue\r\n\r\n        k=LCA(x,y)\r\n\r\n        if k==x:\r\n            DOWN[y]+=1\r\n            k=LCA_mae(y,x)\r\n            DOWN[k]-=1\r\n            \r\n        elif k==y:\r\n            DOWN[x]+=1\r\n            k=LCA_mae(x,y)\r\n            DOWN[k]-=1\r\n\r\n        else:\r\n            score+=1\r\n            DOWN[x]+=1\r\n            DOWN[y]+=1\r\n\r\nfor x in TOP_SORT[1:]:\r\n    DOWN[x]+=DOWN[Parent[x]]\r\n\r\nANS=[0]*N\r\n\r\nfor i in range(N):\r\n    if OK[i]==1 and DOWN[i]==score:\r\n        ANS[i]=1\r\n\r\nprint(\"\".join(map(str,ANS[1:N])))\r\n\r\n\r\n",
    "prob_desc_created_at": "1657982100",
    "tags": [
        "dfs and similar",
        "dsu",
        "graphs",
        "greedy",
        "sortings",
        "trees"
    ],
    "hidden_unit_tests": ""
}
{
    "prob_desc_time_limit": "3 seconds",
    "prob_desc_sample_outputs": "[\"20\\n10\\n20\\n10\\n20\\n10\", \"2\\n3\\n2\\n3\\n2\\n3\\n1\\n1\\n3\"]",
    "src_uid": "1e56f4d17c4ad0b5dde7f05b4e362cfc",
    "prob_desc_notes": "NoteIn the first example, for $$$a=[10,20,10]$$$ the optimal subsequences are:   for $$$k=1$$$: $$$[20]$$$,  for $$$k=2$$$: $$$[10,20]$$$,  for $$$k=3$$$: $$$[10,20,10]$$$. ",
    "prob_desc_description": "This is the easier version of the problem. In this version $$$1 \\le n, m \\le 100$$$. You can hack this problem only if you solve and lock both problems.You are given a sequence of integers $$$a=[a_1,a_2,\\dots,a_n]$$$ of length $$$n$$$. Its subsequence is obtained by removing zero or more elements from the sequence $$$a$$$ (they do not necessarily go consecutively). For example, for the sequence $$$a=[11,20,11,33,11,20,11]$$$:  $$$[11,20,11,33,11,20,11]$$$, $$$[11,20,11,33,11,20]$$$, $$$[11,11,11,11]$$$, $$$[20]$$$, $$$[33,20]$$$ are subsequences (these are just some of the long list);  $$$[40]$$$, $$$[33,33]$$$, $$$[33,20,20]$$$, $$$[20,20,11,11]$$$ are not subsequences. Suppose that an additional non-negative integer $$$k$$$ ($$$1 \\le k \\le n$$$) is given, then the subsequence is called optimal if:  it has a length of $$$k$$$ and the sum of its elements is the maximum possible among all subsequences of length $$$k$$$;  and among all subsequences of length $$$k$$$ that satisfy the previous item, it is lexicographically minimal. Recall that the sequence $$$b=[b_1, b_2, \\dots, b_k]$$$ is lexicographically smaller than the sequence $$$c=[c_1, c_2, \\dots, c_k]$$$ if the first element (from the left) in which they differ less in the sequence $$$b$$$ than in $$$c$$$. Formally: there exists $$$t$$$ ($$$1 \\le t \\le k$$$) such that $$$b_1=c_1$$$, $$$b_2=c_2$$$, ..., $$$b_{t-1}=c_{t-1}$$$ and at the same time $$$b_t&lt;c_t$$$. For example:  $$$[10, 20, 20]$$$ lexicographically less than $$$[10, 21, 1]$$$,  $$$[7, 99, 99]$$$ is lexicographically less than $$$[10, 21, 1]$$$,  $$$[10, 21, 0]$$$ is lexicographically less than $$$[10, 21, 1]$$$. You are given a sequence of $$$a=[a_1,a_2,\\dots,a_n]$$$ and $$$m$$$ requests, each consisting of two numbers $$$k_j$$$ and $$$pos_j$$$ ($$$1 \\le k \\le n$$$, $$$1 \\le pos_j \\le k_j$$$). For each query, print the value that is in the index $$$pos_j$$$ of the optimal subsequence of the given sequence $$$a$$$ for $$$k=k_j$$$.For example, if $$$n=4$$$, $$$a=[10,20,30,20]$$$, $$$k_j=2$$$, then the optimal subsequence is $$$[20,30]$$$ — it is the minimum lexicographically among all subsequences of length $$$2$$$ with the maximum total sum of items. Thus, the answer to the request $$$k_j=2$$$, $$$pos_j=1$$$ is the number $$$20$$$, and the answer to the request $$$k_j=2$$$, $$$pos_j=2$$$ is the number $$$30$$$.",
    "prob_desc_output_spec": "Print $$$m$$$ integers $$$r_1, r_2, \\dots, r_m$$$ ($$$1 \\le r_j \\le 10^9$$$) one per line: answers to the requests in the order they appear in the input. The value of $$$r_j$$$ should be equal to the value contained in the position $$$pos_j$$$ of the optimal subsequence for $$$k=k_j$$$.",
    "prob_desc_input_spec": "The first line contains an integer $$$n$$$ ($$$1 \\le n \\le 100$$$) — the length of the sequence $$$a$$$. The second line contains elements of the sequence $$$a$$$: integer numbers $$$a_1, a_2, \\dots, a_n$$$ ($$$1 \\le a_i \\le 10^9$$$). The third line contains an integer $$$m$$$ ($$$1 \\le m \\le 100$$$) — the number of requests. The following $$$m$$$ lines contain pairs of integers $$$k_j$$$ and $$$pos_j$$$ ($$$1 \\le k \\le n$$$, $$$1 \\le pos_j \\le k_j$$$) — the requests.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "Python 3",
    "lang_cluster": "Python",
    "difficulty": 1600,
    "file_name": "train_034.jsonl",
    "code_uid": "1377c3e1a3c0f5eb2e1fb470675cc227",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"3\\n10 20 10\\n6\\n1 1\\n2 1\\n2 2\\n3 1\\n3 2\\n3 3\", \"7\\n1 2 1 3 1 2 1\\n9\\n2 1\\n2 2\\n3 1\\n3 2\\n3 3\\n1 1\\n7 1\\n7 7\\n7 4\"]",
    "exec_outcome": "PASSED",
    "source_code": "import sys\nimport collections\nfrom collections import Counter\nimport itertools\nimport math\nimport timeit\n\n#input = sys.stdin.readline\n\n#########################\n# imgur.com/Pkt7iIf.png #\n#########################\n\ndef sieve(n):\n    if n < 2: return list()\n    prime = [True for _ in range(n + 1)]\n    p = 3\n    while p * p <= n:\n        if prime[p]:\n            for i in range(p * 2, n + 1, p):\n                prime[i] = False\n        p += 2\n    r = [2]\n    for p in range(3, n + 1, 2):\n        if prime[p]:\n            r.append(p)\n    return r\n\ndef divs(n, start=1):\n    divisors = []\n    for i in range(start, int(math.sqrt(n) + 1)):\n        if n % i == 0:\n            if n / i == i:\n                divisors.append(i)\n            else:\n                divisors.extend([i, n // i])\n    return divisors\n\ndef divn(n, primes):\n    divs_number = 1\n    for i in primes:\n        if n == 1:\n            return divs_number\n        t = 1\n        while n % i == 0:\n            t += 1\n            n //= i\n        divs_number *= t\n\ndef flin(d, x, default = -1):\n    left = right = -1\n    for i in range(len(d)):\n        if d[i] == x:\n            if left == -1: left = i\n            right = i\n    if left == -1:\n        return (default, default)\n    else:\n        return (left, right)\n\ndef ceil(n, k): return n // k + (n % k != 0)\ndef ii(): return int(input())\ndef mi(): return map(int, input().split())\ndef li(): return list(map(int, input().split()))\ndef lcm(a, b): return abs(a * b) // math.gcd(a, b)\ndef prr(a, sep=' '): print(sep.join(map(str, a)))\ndef dd(): return collections.defaultdict(int)\ndef ddl(): return collections.defaultdict(list)\n\ndef rev(d, i, j):\n    while i <= j:\n        d[i], d[j] = d[j], d[i]\n        i += 1\n        j -= 1\n\nn = ii()\nd = li()\nsd = sorted(d, reverse=True)\nsets = []\ndic = dd()\nts = 0\nfor i in range(n):\n    ts += sd[i]\n    dic[sd[i]] += 1\n    tmp = dic.copy()\n    line = []\n    for j in range(n):\n        if tmp[d[j]] > 0:\n            line.append(d[j])\n            tmp[d[j]] -= 1\n    sets.append(line)\n\n\nt = ii()\nfor _ in range(t):\n    k, pos = mi()\n    print(sets[k - 1][pos - 1])\n\n\n\n\n\n",
    "prob_desc_created_at": "1574582700",
    "tags": [
        "data structures",
        "greedy"
    ],
    "hidden_unit_tests": ""
}
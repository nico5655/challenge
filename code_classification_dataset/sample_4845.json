{
    "prob_desc_time_limit": "4 seconds",
    "prob_desc_sample_outputs": "[\"1\", \"642377629\"]",
    "src_uid": "8508d39c069936fb402e4f4433180465",
    "prob_desc_notes": "NoteTo better understand in which situation several winners are possible let's examine the second test:One possible result of the tournament is as follows ($$$a \\rightarrow b$$$ means that $$$a$$$ defeated $$$b$$$):  $$$1 \\rightarrow 2$$$  $$$2 \\rightarrow 3$$$  $$$3 \\rightarrow 1$$$  $$$1 \\rightarrow 4$$$  $$$1 \\rightarrow 5$$$  $$$2 \\rightarrow 4$$$  $$$2 \\rightarrow 5$$$  $$$3 \\rightarrow 4$$$  $$$3 \\rightarrow 5$$$  $$$4 \\rightarrow 5$$$ Or more clearly in the picture:  In this case every team from the set $$$\\{ 1, 2, 3 \\}$$$ directly or indirectly defeated everyone. I.e.:  $$$1$$$st defeated everyone because they can get to everyone else in the following way $$$1 \\rightarrow 2$$$, $$$1 \\rightarrow 2 \\rightarrow 3$$$, $$$1 \\rightarrow 4$$$, $$$1 \\rightarrow 5$$$.  $$$2$$$nd defeated everyone because they can get to everyone else in the following way $$$2 \\rightarrow 3$$$, $$$2 \\rightarrow 3 \\rightarrow 1$$$, $$$2 \\rightarrow 4$$$, $$$2 \\rightarrow 5$$$.  $$$3$$$rd defeated everyone because they can get to everyone else in the following way $$$3 \\rightarrow 1$$$, $$$3 \\rightarrow 1 \\rightarrow 2$$$, $$$3 \\rightarrow 4$$$, $$$3 \\rightarrow 5$$$. Therefore the total number of winners is $$$3$$$.",
    "prob_desc_description": "  William is not only interested in trading but also in betting on sports matches. $$$n$$$ teams participate in each match. Each team is characterized by strength $$$a_i$$$. Each two teams $$$i &lt; j$$$ play with each other exactly once. Team $$$i$$$ wins with probability $$$\\frac{a_i}{a_i + a_j}$$$ and team $$$j$$$ wins with probability $$$\\frac{a_j}{a_i + a_j}$$$.The team is called a winner if it directly or indirectly defeated all other teams. Team $$$a$$$ defeated (directly or indirectly) team $$$b$$$ if there is a sequence of teams $$$c_1$$$, $$$c_2$$$, ... $$$c_k$$$ such that $$$c_1 = a$$$, $$$c_k = b$$$ and team $$$c_i$$$ defeated team $$$c_{i + 1}$$$ for all $$$i$$$ from $$$1$$$ to $$$k - 1$$$. Note that it is possible that team $$$a$$$ defeated team $$$b$$$ and in the same time team $$$b$$$ defeated team $$$a$$$.William wants you to find the expected value of the number of winners.",
    "prob_desc_output_spec": "Output a single integer  — the expected value of the number of winners of the tournament modulo $$$10^9 + 7$$$. Formally, let $$$M = 10^9+7$$$. It can be demonstrated that the answer can be presented as a irreducible fraction $$$\\frac{p}{q}$$$, where $$$p$$$ and $$$q$$$ are integers and $$$q \\not \\equiv 0 \\pmod{M}$$$. Output a single integer equal to $$$p \\cdot q^{-1} \\bmod M$$$. In other words, output an integer $$$x$$$ such that $$$0 \\le x &lt; M$$$ and $$$x \\cdot q \\equiv p \\pmod{M}$$$.",
    "prob_desc_input_spec": "The first line contains a single integer $$$n$$$ ($$$1 \\leq n \\leq 14$$$), which is the total number of teams participating in a match. The second line contains $$$n$$$ integers $$$a_1, a_2, \\dots, a_n$$$ ($$$1 \\leq a_i \\leq 10^6$$$)  — the strengths of teams participating in a match.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3-64",
    "lang_cluster": "Python",
    "difficulty": 2500,
    "file_name": "train_107.jsonl",
    "code_uid": "8b2d744a149d3800c66a18d088e48849",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"2\\n1 2\", \"5\\n1 5 2 11 14\"]",
    "exec_outcome": "PASSED",
    "source_code": "import sys,random,bisect\r\nfrom collections import deque,defaultdict\r\nfrom heapq import heapify,heappop,heappush\r\nfrom itertools import cycle, permutations\r\nfrom math import log,gcd\r\n\r\ninput = lambda :sys.stdin.readline().rstrip()\r\nmi = lambda :map(int,input().split())\r\nli = lambda :list(mi())\r\n\r\nmod = 10**9 + 7\r\nN = 2*10**6\r\ninverse = [1]*(N+1)\r\n\r\nfor i in range( 2, N + 1 ):\r\n    inverse[i]=( ( -inverse[mod % i] * (mod//i) ) % mod )\r\ninverse[0]=0\r\n\r\nN = int(input())\r\nA = li()\r\n\r\nwin_prop = [[1 for S in range(1<<N)] for i in range(N)]\r\nfor i in range(N):\r\n    for n in range(N):\r\n        t = 1<<n\r\n        for S in range(1<<n,1<<(n+1)):\r\n            win_prop[i][S] = win_prop[i][S-t] * (A[i] * inverse[A[i]+A[n]] % mod) % mod\r\n\r\ndp = [1 for i in range(1<<N)]\r\nfor S in range(1,1<<N):\r\n    tmp = (S-1)&S\r\n    while tmp:\r\n        T,U = tmp,S-tmp\r\n\r\n        val = dp[T]\r\n        for i in range(N):\r\n            if T>>i & 1:\r\n                val *= win_prop[i][U]\r\n                val %= mod\r\n        dp[S] -= val\r\n        dp[S] %= mod\r\n        tmp = (tmp-1)&S\r\n\r\nres = 0\r\nfor S in range(1,1<<N):\r\n    n = bin(S).count(\"1\")\r\n    prop = dp[S]\r\n    for i in range(N):\r\n        for j in range(N):\r\n            if S>>i & 1 and (not S>>j & 1):\r\n                prop *= A[i] * inverse[A[i]+A[j]]\r\n                prop %= mod\r\n    res += n * prop\r\n    res %= mod\r\n\r\nprint(res)\r\n\r\n\r\n",
    "prob_desc_created_at": "1630247700",
    "tags": [
        "bitmasks",
        "combinatorics",
        "dp",
        "graphs",
        "math",
        "probabilities"
    ],
    "hidden_unit_tests": ""
}
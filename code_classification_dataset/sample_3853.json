{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"1\\n10\\n22\"]",
    "src_uid": "fa11eb753c2cae620c139030f5ca5850",
    "prob_desc_notes": "NoteIn the first test case, we can swap person $$$4$$$ and person $$$1$$$ (who are adjacent) in the initial configuration and get the order $$$[4, 2, 3, 1]$$$ which is equivalent to the desired one. Hence in this case a single swap is sufficient.",
    "prob_desc_description": "There are $$$n$$$ people, numbered from $$$1$$$ to $$$n$$$, sitting at a round table. Person $$$i+1$$$ is sitting to the right of person $$$i$$$ (with person $$$1$$$ sitting to the right of person $$$n$$$).You have come up with a better seating arrangement, which is given as a permutation $$$p_1, p_2, \\dots, p_n$$$. More specifically, you want to change the seats of the people so that at the end person $$$p_{i+1}$$$ is sitting to the right of person $$$p_i$$$ (with person $$$p_1$$$ sitting to the right of person $$$p_n$$$). Notice that for each seating arrangement there are $$$n$$$ permutations that describe it (which can be obtained by rotations).In order to achieve that, you can swap two people sitting at adjacent places; but there is a catch: for all $$$1 \\le x \\le n-1$$$ you cannot swap person $$$x$$$ and person $$$x+1$$$ (notice that you can swap person $$$n$$$ and person $$$1$$$). What is the minimum number of swaps necessary? It can be proven that any arrangement can be achieved.",
    "prob_desc_output_spec": "For each test case, print the minimum number of swaps necessary to achieve the desired order.",
    "prob_desc_input_spec": "Each test contains multiple test cases. The first line contains an integer $$$t$$$ ($$$1\\le t\\le 10\\,000$$$) — the number of test cases. The descriptions of the $$$t$$$ test cases follow. The first line of each test case contains a single integer $$$n$$$ ($$$3 \\le n \\le 200\\,000$$$) — the number of people sitting at the table.  The second line contains $$$n$$$ distinct integers $$$p_1, p_2, \\dots, p_n$$$ ($$$1 \\le p_i \\le n$$$, $$$p_i \\ne p_j$$$ for $$$i \\ne j$$$) — the desired final order of the people around the table. The sum of the values of $$$n$$$ over all test cases does not exceed $$$200\\,000$$$.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3-64",
    "lang_cluster": "Python",
    "difficulty": -1,
    "file_name": "train_085.jsonl",
    "code_uid": "f0a1d0101ac35c51b72032a4aea9cba5",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"3\\n\\n4\\n\\n2 3 1 4\\n\\n5\\n\\n5 4 3 2 1\\n\\n7\\n\\n4 1 6 5 3 7 2\"]",
    "exec_outcome": "PASSED",
    "source_code": "import sys\r\ninput = sys.stdin.readline\r\n\r\nclass SegmentTree:\r\n    def __init__(self, data, default=0, func=lambda x, y: x + y):\r\n        \"\"\"initialize the segment tree with data\"\"\"\r\n        self._default = default\r\n        self._func = func\r\n        self._len = len(data)\r\n        self._size = _size = 1 << (self._len - 1).bit_length()\r\n\r\n        self.data = [default] * (2 * _size)\r\n        self.data[_size:_size + self._len] = data\r\n        for i in reversed(range(_size)):\r\n            self.data[i] = func(self.data[i + i], self.data[i + i + 1])\r\n\r\n    def __delitem__(self, idx):\r\n        self[idx] = self._default\r\n\r\n    def __getitem__(self, idx):\r\n        return self.data[idx + self._size]\r\n\r\n    def __setitem__(self, idx, value):\r\n        idx += self._size\r\n        self.data[idx] = value\r\n        idx >>= 1\r\n        while idx:\r\n            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])\r\n            idx >>= 1\r\n\r\n    def __len__(self):\r\n        return self._len\r\n\r\n    def query(self, start, stop):\r\n        \"\"\"func of data[start, stop)\"\"\"\r\n        start += self._size\r\n        stop += self._size\r\n\r\n        res_left = res_right = self._default\r\n        while start < stop:\r\n            if start & 1:\r\n                res_left = self._func(res_left, self.data[start])\r\n                start += 1\r\n            if stop & 1:\r\n                stop -= 1\r\n                res_right = self._func(self.data[stop], res_right)\r\n            start >>= 1\r\n            stop >>= 1\r\n\r\n        return self._func(res_left, res_right)\r\n\r\n    def __repr__(self):\r\n        return \"SegmentTree({0})\".format(self.data)\r\n\r\n    def clear(self, i):\r\n        if i >= self._size:\r\n            self.data[i] = 0\r\n\r\n        if self.data[i]:\r\n            self.data[i] = 0\r\n            self.clear(i + i)\r\n            self.clear(i + i + 1)\r\n\r\nSZ = 200005\r\n\r\nST = SegmentTree([0] * (2 * SZ))\r\n\r\nt = int(input())\r\nout = []\r\nfor _ in range(t):\r\n    n = int(input())\r\n    l = list(map(int, input().split()))\r\n    p = [0] * n\r\n    for i in range(n):\r\n        p[l[i] - 1] = i\r\n    res = 0\r\n\r\n    for i in range(n - 1):\r\n        l = p[i]\r\n        r = p[i + 1]\r\n        \r\n        if r < l:\r\n            r += SZ\r\n\r\n        seen = ST.query(l, r)\r\n        tot = (p[i + 1] - p[i] - 1) % n\r\n\r\n        res += (i + 1) * (tot - seen)\r\n        #print(tot, seen)\r\n            \r\n        ST[p[i]] = 1\r\n        ST[p[i] + SZ] = 1\r\n\r\n    out.append(res)\r\n    ST.clear(1)\r\n    #print(ST)\r\n        \r\n\r\nprint('\\n'.join(map(str, out)))\r\n",
    "prob_desc_created_at": "1650798300",
    "tags": [
        "math"
    ],
    "hidden_unit_tests": ""
}
{
    "prob_desc_time_limit": "1 second",
    "prob_desc_sample_outputs": "[\"2\\n1212212\", \"0\\n1212212\", \"2\\n1212212\"]",
    "src_uid": "ad3f798f00cc9f3e3c9df932c2459ca3",
    "prob_desc_notes": "NoteExplanation for the first sample:  vertices $$$2$$$ and $$$5$$$ are Oddyseys. Explanation for the third sample:  vertices $$$1$$$ and $$$6$$$ are Oddyseys. ",
    "prob_desc_description": "Lee was planning to get closer to Mashtali's heart to proceed with his evil plan(which we're not aware of, yet), so he decided to beautify Mashtali's graph. But he made several rules for himself. And also he was too busy with his plans that he didn't have time for such minor tasks, so he asked you for help.Mashtali's graph is an undirected weighted graph with $$$n$$$ vertices and $$$m$$$ edges with weights equal to either $$$1$$$ or $$$2$$$. Lee wants to direct the edges of Mashtali's graph so that it will be as beautiful as possible.Lee thinks that the beauty of a directed weighted graph is equal to the number of its Oddysey vertices. A vertex $$$v$$$ is an Oddysey vertex if $$$|d^+(v) - d^-(v)| = 1$$$, where $$$d^+(v)$$$ is the sum of weights of the outgoing from $$$v$$$ edges, and $$$d^-(v)$$$ is the sum of the weights of the incoming to $$$v$$$ edges.Find the largest possible beauty of a graph that Lee can achieve by directing the edges of Mashtali's graph. In addition, find any way to achieve it.Note that you have to orient each edge.",
    "prob_desc_output_spec": "In the first line print a single integer — the maximum beauty of the graph Lee can achieve. In the second line print a string of length $$$m$$$ consisting of $$$1$$$s and $$$2$$$s — directions of the edges. If you decide to direct the $$$i$$$-th edge from vertex $$$u_i$$$ to vertex $$$v_i$$$, $$$i$$$-th character of the string should be $$$1$$$. Otherwise, it should be $$$2$$$.",
    "prob_desc_input_spec": "The first line contains two integers $$$n$$$ and $$$m$$$ $$$(1 \\le n \\le 10^5;\\; 1 \\le m \\le 10^5)$$$ — the numbers of vertices and edges in the graph. The $$$i$$$-th line of the following $$$m$$$ lines contains three integers $$$u_i$$$, $$$v_i$$$ and $$$w_i$$$ $$$( 1 \\le u_i , v_i \\le n;\\; u_i \\neq v_i;\\; \\bf{w_i \\in \\{1, 2\\}} )$$$ — the endpoints of the $$$i$$$-th edge and its weight. Note that the graph doesn't have to be connected, and it might contain multiple edges.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3-64",
    "lang_cluster": "Python",
    "difficulty": 3000,
    "file_name": "train_085.jsonl",
    "code_uid": "7b448deff90878934c7945b456799622",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"6 7\\n1 2 1\\n1 3 2\\n2 3 2\\n1 4 1\\n4 5 1\\n2 5 2\\n2 6 2\", \"6 7\\n1 2 2\\n1 3 2\\n2 3 2\\n1 4 2\\n4 5 2\\n2 5 2\\n2 6 2\", \"6 7\\n1 2 1\\n1 3 1\\n2 3 1\\n1 4 1\\n4 5 1\\n2 5 1\\n2 6 1\"]",
    "exec_outcome": "PASSED",
    "source_code": "import sys\r\ninput = sys.stdin.readline\r\n\r\nn, m = map(int, input().split())\r\nadj1 = [[] for _ in range(n)]\r\nadj2 = [[] for _ in range(n)]\r\n\r\nedges = []\r\n\r\noutv = 0\r\noutvv = 0\r\n\r\ndeg1 = [0] * n\r\ndeg2 = [0] * n\r\nparO = []\r\nparP = []\r\nfor e in range(m):\r\n    u, v, w = map(int, input().split())\r\n    u -= 1\r\n    v -= 1\r\n\r\n    parO.append(u)\r\n    parP.append(v)\r\n    \r\n    if w == 1:\r\n        adj1[u].append((v,e))\r\n        adj1[v].append((u,e))\r\n        deg1[u] += 1\r\n        deg1[v] += 1\r\n    else:\r\n        adj2[u].append((v,e))\r\n        adj2[v].append((u,e))\r\n        deg2[u] += 1\r\n        deg2[v] += 1\r\n\r\nused = [False] * m\r\n\r\n# w = 1\r\np1 = []\r\np1e = []\r\nfor curr in range(n):\r\n    if deg1[curr] % 2 == 0:\r\n        continue\r\n    else:\r\n        outvv += 1\r\n    \r\n    u = curr\r\n    path = [u]\r\n    pe = []\r\n    while adj1[u]:\r\n        v, e = adj1[u].pop()\r\n        if not used[e]:\r\n            path.append(v)\r\n            pe.append(e)\r\n            u = v\r\n            used[e] = True\r\n    if len(path) > 1:\r\n        outv += 1\r\n        p1.append(path)\r\n        p1e.append(pe)\r\n\r\ncurr = 0\r\nwhile curr < n:\r\n    u = curr\r\n    path = [u]\r\n    pe = []\r\n    while adj1[u]:\r\n        v, e = adj1[u].pop()\r\n        if not used[e]:\r\n            path.append(v)\r\n            pe.append(e)\r\n            u = v\r\n            used[e] = True\r\n    if len(path) > 1:\r\n        p1.append(path)\r\n        p1e.append(pe)\r\n    else:\r\n        curr += 1\r\n\r\n# w = 2\r\np2 = []\r\np2e = []\r\nfor curr in range(n):\r\n    if deg2[curr] % 2 == 0:\r\n        continue\r\n    u = curr\r\n    path = [u]\r\n    pe = []\r\n    while adj2[u]:\r\n        v, e = adj2[u].pop()\r\n        if not used[e]:\r\n            path.append(v)\r\n            pe.append(e)\r\n            u = v\r\n            used[e] = True\r\n    if len(path) > 1:\r\n        p2.append(path)\r\n        p2e.append(pe)\r\n        \r\ncurr = 0\r\nwhile curr < n:\r\n    u = curr\r\n    path = [u]\r\n    pe = []\r\n    while adj2[u]:\r\n        v, e = adj2[u].pop()\r\n        if not used[e]:\r\n            path.append(v)\r\n            pe.append(e)\r\n            u = v\r\n            used[e] = True\r\n    if len(path) > 1:\r\n        p2.append(path)\r\n        p2e.append(pe)\r\n    else:\r\n        curr += 1\r\n\r\nassert(all(used))\r\n\r\nadj3 = list(range(n))\r\nadj4 = list(range(n))\r\nfor p in p1:\r\n    if p[0] != p[-1]:\r\n        adj3[p[0]] = p[-1]\r\n        adj3[p[-1]] = p[0]\r\nfor p in p2:\r\n    if p[0] != p[-1]:\r\n        adj4[p[0]] = p[-1]\r\n        adj4[p[-1]] = p[0]\r\n\r\ncolors = [0] * n\r\nfor i in range(n):\r\n    if colors[i] == 0:\r\n        stack = [i]\r\n        colors[i] = 1\r\n        while stack:\r\n            nex = stack.pop()\r\n            if colors[adj3[nex]] == 0:\r\n                colors[adj3[nex]] = -colors[nex]\r\n                stack.append(adj3[nex])\r\n            if colors[adj4[nex]] == 0:\r\n                colors[adj4[nex]] = -colors[nex]\r\n                stack.append(adj4[nex])\r\n\r\npar = [-1] * m\r\nfor i in range(len(p1)):\r\n    p = p1[i]\r\n    pe = p1e[i]\r\n    \r\n    assert p[0] == p[-1] or colors[p[0]] != colors[p[-1]]\r\n    \r\n    if colors[p[0]] == 1:\r\n        for v, e in zip(p[:-1], pe):\r\n            par[e] = v\r\n    else:\r\n        for v, e in zip(p[1:], pe):\r\n            par[e] = v\r\n\r\nfor i in range(len(p2)):\r\n    p = p2[i]\r\n    pe = p2e[i]\r\n\r\n    assert p[0] == p[-1] or colors[p[0]] != colors[p[-1]]\r\n    \r\n    if colors[p[0]] == -1:\r\n        for v, e in zip(p[:-1], pe):\r\n            par[e] = v\r\n    else:\r\n        for v, e in zip(p[1:], pe):\r\n            par[e] = v\r\n\r\nout = []\r\nfor i in range(m):\r\n    assert par[i] != -1\r\n    if par[i] == parO[i]:\r\n        out.append(1)\r\n    else:\r\n        assert par[i] == parP[i]\r\n        out.append(2)\r\n\r\nassert outvv == 2 * outv\r\nprint(2 * outv)\r\nprint(''.join(map(str,out)))\r\n        \r\n",
    "prob_desc_created_at": "1637678100",
    "tags": [
        "constructive algorithms",
        "dfs and similar",
        "graphs"
    ],
    "hidden_unit_tests": ""
}
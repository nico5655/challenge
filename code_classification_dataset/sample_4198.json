{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"3\\n3\\n3 1 5\\n1\\n2\\n1\\n4\\n\\n2\\n2\\n1 2\\n2\\n4 3\\n\\n1\\n7\\n1 2 3 4 5 6 7\\n\\n1\\n1\\n1\\n\\n3\\n3\\n4 1 5\\n2\\n2 6\\n1\\n3\\n\\n3\\n2\\n2 1\\n1\\n3\\n1\\n4\"]",
    "src_uid": "cd2a9169186c4ade98548c29bbdacdf0",
    "prob_desc_notes": null,
    "prob_desc_description": "You are given a rooted tree consisting of $$$n$$$ vertices. Vertices are numbered from $$$1$$$ to $$$n$$$. Any vertex can be the root of a tree.A tree is a connected undirected graph without cycles. A rooted tree is a tree with a selected vertex, which is called the root.The tree is specified by an array of parents $$$p$$$ containing $$$n$$$ numbers: $$$p_i$$$ is a parent of the vertex with the index $$$i$$$. The parent of a vertex $$$u$$$ is a vertex that is the next vertex on the shortest path from $$$u$$$ to the root. For example, on the simple path from $$$5$$$ to $$$3$$$ (the root), the next vertex would be $$$1$$$, so the parent of $$$5$$$ is $$$1$$$.The root has no parent, so for it, the value of $$$p_i$$$ is $$$i$$$ (the root is the only vertex for which $$$p_i=i$$$).Find such a set of paths that:  each vertex belongs to exactly one path, each path can contain one or more vertices;  in each path each next vertex — is a son of the current vertex (that is, paths always lead down — from parent to son);  number of paths is minimal. For example, if $$$n=5$$$ and $$$p=[3, 1, 3, 3, 1]$$$, then the tree can be divided into three paths:   $$$3 \\rightarrow 1 \\rightarrow 5$$$ (path of $$$3$$$ vertices),  $$$4$$$ (path of $$$1$$$ vertices).  $$$2$$$ (path of $$$1$$$ vertices).     Example of splitting a root tree into three paths for $$$n=5$$$, the root of the tree — node $$$3$$$. ",
    "prob_desc_output_spec": "For each test case on the first line, output an integer $$$m$$$ — the minimum number of non-intersecting leading down paths that can cover all vertices of the tree. Then print $$$m$$$ pairs of lines containing path descriptions. In the first of them print the length of the path, in the second — the sequence of vertices specifying that path in the order from top to bottom. You can output the paths in any order. If there are several answers, output any of them.",
    "prob_desc_input_spec": "The first line of input data contains an integer $$$t$$$ ($$$1 \\le t \\le 10^4$$$) — the number of test cases in the test. Each test case consists of two lines. The first of them contains an integer $$$n$$$ ($$$1 \\le n \\le 2 \\cdot 10^5$$$). It is the number of vertices in the tree. The second line contains $$$n$$$ integers $$$p_1, p_2, \\dots, p_n$$$ ($$$1 \\le p_i \\le n$$$). It is guaranteed that the $$$p$$$ array encodes some rooted tree. It is guaranteed that the sum of the values $$$n$$$ over all test cases in the test does not exceed $$$2 \\cdot 10^5$$$.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3-64",
    "lang_cluster": "Python",
    "difficulty": 1300,
    "file_name": "train_092.jsonl",
    "code_uid": "56facd38fe646a515bf771004d3d83eb",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"6\\n\\n5\\n\\n3 1 3 3 1\\n\\n4\\n\\n1 1 4 1\\n\\n7\\n\\n1 1 2 3 4 5 6\\n\\n1\\n\\n1\\n\\n6\\n\\n4 4 4 4 1 2\\n\\n4\\n\\n2 2 2 2\"]",
    "exec_outcome": "PASSED",
    "source_code": "# cook your dish here\r\n#!/usr/bin/env python\r\nfrom bisect import bisect_left\r\nimport os\r\nfrom math import ceil, factorial, fmod,pi,sqrt,log\r\nimport sys\r\nfrom collections import Counter\r\nfrom io import BytesIO, IOBase, StringIO\r\ndef modFact(n, p):\r\n    if n >= p:\r\n        return 0   \r\n \r\n    result = 1\r\n    for i in range(1, n + 1):\r\n        result = (result * i) % p\r\n \r\n    return result\r\n \r\ndef calculate(p, q):\r\n     \r\n    mod = 998244353\r\n    expo = 0\r\n    expo = mod - 2\r\n \r\n    # Loop to find the value\r\n    # until the expo is not zero\r\n    while (expo):\r\n \r\n        # Multiply p with q\r\n        # if expo is odd\r\n        if (expo & 1):\r\n            p = (p * q) % mod\r\n        q = (q * q) % mod\r\n \r\n        # Reduce the value of\r\n        # expo by 2\r\n        expo >>= 1\r\n \r\n    return p\r\ndef compute_gcd(x, y):\r\n\r\n   while(y):\r\n       x, y = y, x % y\r\n   return x\r\n\r\n# This function computes LCM\r\ndef compute_lcm(x, y):\r\n   lcm = (x*y)//compute_gcd(x,y)\r\n   return lcm\r\n\r\ndef read_arr():\r\n    return [int(x) for x in input().split()]\r\n\r\ndef bin_search(num, arr):\r\n    start = 0\r\n    end = len(arr)-1\r\n    while start <= end:\r\n        mid=(start+end)//2\r\n        if arr[mid] == num:\r\n            return mid\r\n        elif arr[mid] > num:\r\n            end= mid-1\r\n        else:\r\n            start = mid + 1\r\n    return -1\r\n\r\n\r\ndef factors(n) :\r\n     \r\n    # Note that this loop runs till square root\r\n    i = 1\r\n    ans=[]\r\n    while i <= sqrt(n):\r\n         \r\n        if (n % i == 0) :\r\n             \r\n            # If divisors are equal, print only one\r\n            if (n / i == i) :\r\n                ans.append(i)\r\n            else :\r\n                # Otherwise print both\r\n                \r\n                ans.append(i)\r\n                ans.append(int(n/i))\r\n        i = i + 1\r\n    return ans\r\n\r\ndef is_palindrome(n):\r\n    for j in range(len(n)//2):\r\n        if n[j]!=n[len(n)-j-1]:\r\n            return False\r\n    return True\r\n\r\ndef main():\r\n    t=int(input())\r\n    for i in range(t):\r\n        n = int(input())\r\n        arr = [int(x) for x in input().split()]\r\n        leaves = [True for j in range(n+1)]\r\n        leaves[0]=False\r\n        for j in range(n):\r\n            leaves[arr[j]]=False \r\n        paths = []\r\n        if n == 1:\r\n            print(1)\r\n            print(1)\r\n            print(1)\r\n            print()\r\n            continue\r\n        vis = [False for j in range(n+1)]\r\n        for j in range(n+1):\r\n            if leaves[j]:\r\n                new = []\r\n                start = j\r\n                while not vis[start]:\r\n                    new.append(start)\r\n                    vis[start] = True \r\n                    if start == arr[start-1]:\r\n                        break\r\n                    start = arr[start-1]\r\n                paths.append(new)\r\n        print(len(paths))\r\n        for j in paths:\r\n            print(len(j))\r\n            for k in range(len(j)-1, -1, -1):\r\n                print(j[k],end=\" \")\r\n            print()\r\n        if i != t-1:\r\n            print()\r\n\r\n\r\n\r\n\r\n\r\nBUFSIZE = 8192\r\n \r\n \r\nclass FastIO(IOBase):\r\n    newlines = 0\r\n \r\n    def __init__(self, file):\r\n        self._fd = file.fileno()\r\n        self.buffer = BytesIO()\r\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\r\n        self.write = self.buffer.write if self.writable else None\r\n \r\n    def read(self):\r\n        while True:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            if not b:\r\n                break\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines = 0\r\n        return self.buffer.read()\r\n \r\n    def readline(self):\r\n        while self.newlines == 0:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            self.newlines = b.count(b\"\\n\") + (not b)\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines -= 1\r\n        return self.buffer.readline()\r\n \r\n    def flush(self):\r\n        if self.writable:\r\n            os.write(self._fd, self.buffer.getvalue())\r\n            self.buffer.truncate(0), self.buffer.seek(0)\r\n \r\n \r\nclass IOWrapper(IOBase):\r\n    def __init__(self, file):\r\n        self.buffer = FastIO(file)\r\n        self.flush = self.buffer.flush\r\n        self.writable = self.buffer.writable\r\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\r\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\r\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\r\n \r\n \r\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\r\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\r\n \r\n# endregion\r\n \r\nif __name__ == \"__main__\":\r\n    main()",
    "prob_desc_created_at": "1651761300",
    "tags": [
        "graphs",
        "implementation",
        "trees"
    ],
    "hidden_unit_tests": ""
}
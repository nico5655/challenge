{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"0 1 \\n3 3 0 5 5 \\n2\"]",
    "src_uid": "a365055f2d1c836fd50aed9090db1072",
    "prob_desc_notes": "Note  Graph from the first test case. The integer near the edge is its number. In the first test case, the graph contains $$$2$$$ vertices and a single edge connecting vertices $$$1$$$ and $$$2$$$.In the first query, $$$l=1$$$ and $$$r=1$$$. It is possible to reach any vertex from itself, so the answer to this query is $$$0$$$.In the second query, $$$l=1$$$ and $$$r=2$$$. Vertices $$$1$$$ and $$$2$$$ are reachable from one another using only the first edge, through the path $$$1 \\longleftrightarrow 2$$$. It is impossible to reach vertex $$$2$$$ from vertex $$$1$$$ using only the first $$$0$$$ edges. So, the answer to this query is $$$1$$$.  Graph from the second test case. The integer near the edge is its number. In the second test case, the graph contains $$$5$$$ vertices and $$$5$$$ edges.In the first query, $$$l=1$$$ and $$$r=4$$$. It is enough to use the first $$$3$$$ edges to satisfy the condition from the statement:   Vertices $$$1$$$ and $$$2$$$ are reachable from one another through the path $$$1 \\longleftrightarrow 2$$$ (edge $$$1$$$).  Vertices $$$1$$$ and $$$3$$$ are reachable from one another through the path $$$1 \\longleftrightarrow 3$$$ (edge $$$2$$$).  Vertices $$$1$$$ and $$$4$$$ are reachable from one another through the path $$$1 \\longleftrightarrow 2 \\longleftrightarrow 4$$$ (edges $$$1$$$ and $$$3$$$).  Vertices $$$2$$$ and $$$3$$$ are reachable from one another through the path $$$2 \\longleftrightarrow 1 \\longleftrightarrow 3$$$ (edges $$$1$$$ and $$$2$$$).  Vertices $$$2$$$ and $$$4$$$ are reachable from one another through the path $$$2 \\longleftrightarrow 4$$$ (edge $$$3$$$).  Vertices $$$3$$$ and $$$4$$$ are reachable from one another through the path $$$3 \\longleftrightarrow 1 \\longleftrightarrow 2 \\longleftrightarrow 4$$$ (edges $$$2$$$, $$$1$$$, and $$$3$$$). If we use less than $$$3$$$ of the first edges, then the condition won't be satisfied. For example, it is impossible to reach vertex $$$4$$$ from vertex $$$1$$$ using only the first $$$2$$$ edges. So, the answer to this query is $$$3$$$.In the second query, $$$l=3$$$ and $$$r=4$$$. Vertices $$$3$$$ and $$$4$$$ are reachable from one another through the path $$$3 \\longleftrightarrow 1 \\longleftrightarrow 2 \\longleftrightarrow 4$$$ (edges $$$2$$$, $$$1$$$, and $$$3$$$). If we use any fewer of the first edges, nodes $$$3$$$ and $$$4$$$ will not be reachable from one another.",
    "prob_desc_description": "You are given a connected undirected graph with $$$n$$$ vertices and $$$m$$$ edges. Vertices of the graph are numbered by integers from $$$1$$$ to $$$n$$$ and edges of the graph are numbered by integers from $$$1$$$ to $$$m$$$.Your task is to answer $$$q$$$ queries, each consisting of two integers $$$l$$$ and $$$r$$$. The answer to each query is the smallest non-negative integer $$$k$$$ such that the following condition holds:   For all pairs of integers $$$(a, b)$$$ such that $$$l\\le a\\le b\\le r$$$, vertices $$$a$$$ and $$$b$$$ are reachable from one another using only the first $$$k$$$ edges (that is, edges $$$1, 2, \\ldots, k$$$). ",
    "prob_desc_output_spec": "For each test case, print $$$q$$$ integers — the answers to the queries.",
    "prob_desc_input_spec": "The first line contains a single integer $$$t$$$ ($$$1\\le t\\le 1000$$$) — the number of test cases. The first line of each test case contains three integers $$$n$$$, $$$m$$$, and $$$q$$$ ($$$2\\le n\\le 10^5$$$, $$$1\\le m, q\\le 2\\cdot 10^5$$$) — the number of vertices, edges, and queries respectively. Each of the next $$$m$$$ lines contains two integers $$$u_i$$$ and $$$v_i$$$ ($$$1\\le u_i, v_i\\le n$$$) — ends of the $$$i$$$-th edge. It is guaranteed that the graph is connected and there are no multiple edges or self-loops. Each of the next $$$q$$$ lines contains two integers $$$l$$$ and $$$r$$$ ($$$1\\le l\\le r\\le n$$$) — descriptions of the queries. It is guaranteed that that the sum of $$$n$$$ over all test cases does not exceed $$$10^5$$$, the sum of $$$m$$$ over all test cases does not exceed $$$2\\cdot 10^5$$$, and the sum of $$$q$$$ over all test cases does not exceed $$$2\\cdot 10^5$$$.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3-64",
    "lang_cluster": "Python",
    "difficulty": 2300,
    "file_name": "train_093.jsonl",
    "code_uid": "48b09eb644ff1f1eaaf7b006d1350a42",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"3\\n\\n2 1 2\\n\\n1 2\\n\\n1 1\\n\\n1 2\\n\\n5 5 5\\n\\n1 2\\n\\n1 3\\n\\n2 4\\n\\n3 4\\n\\n3 5\\n\\n1 4\\n\\n3 4\\n\\n2 2\\n\\n2 5\\n\\n3 5\\n\\n3 2 1\\n\\n1 3\\n\\n2 3\\n\\n1 3\"]",
    "exec_outcome": "PASSED",
    "source_code": "import os\r\nimport sys\r\nfrom io import BytesIO, IOBase\r\n\r\nimport sys\r\nimport threading\r\n\r\nthreading.stack_size(250 * 1024 * 1024)\r\nsys.setrecursionlimit(5000)\r\n\r\n\r\nBUFSIZE = 8192\r\n \r\nclass FastIO(IOBase):\r\n    newlines = 0\r\n \r\n    def __init__(self, file):\r\n        self._fd = file.fileno()\r\n        self.buffer = BytesIO()\r\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\r\n        self.write = self.buffer.write if self.writable else None\r\n \r\n    def read(self):\r\n        while True:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            if not b:\r\n                break\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines = 0\r\n        return self.buffer.read()\r\n \r\n    def readline(self):\r\n        while self.newlines == 0:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            self.newlines = b.count(b\"\\n\") + (not b)\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines -= 1\r\n        return self.buffer.readline()\r\n \r\n    def flush(self):\r\n        if self.writable:\r\n            os.write(self._fd, self.buffer.getvalue())\r\n            self.buffer.truncate(0), self.buffer.seek(0)\r\n \r\n \r\nclass IOWrapper(IOBase):\r\n    def __init__(self, file):\r\n        self.buffer = FastIO(file)\r\n        self.flush = self.buffer.flush\r\n        self.writable = self.buffer.writable\r\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\r\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\r\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\r\n \r\n \r\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\r\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\r\n\r\n\r\nclass DisjointSetWithWeights:\r\n    def __init__(self, size):\r\n        self.U = [[i, 1] for i in range(size)]\r\n        self.W = [10**9 for i in range(size)]\r\n        \r\n    def root(self, e):\r\n        u = self.U[e]\r\n\r\n        if u[0] != e:\r\n#            r = self.U[e] = self.root(u[0])\r\n            return self.root(u[0])\r\n\r\n        return u\r\n\r\n    def union(self, first, second, weight):\r\n        uFirst, uSecond = self.root(first), self.root(second)\r\n\r\n        if uFirst == uSecond:\r\n            return False\r\n\r\n        if uFirst[1] < uSecond[1]:\r\n            uFirst, uSecond = uSecond, uFirst\r\n            first, second = second, first\r\n\r\n        if uSecond[0] != uFirst[0]:\r\n            self.W[uSecond[0]] = weight\r\n            uSecond[0] = uFirst[0]\r\n            uFirst[1] += uSecond[1]\r\n            \r\n        return True\r\n\r\n    def maxWeight(self, s, e):\r\n        w = 0\r\n\r\n        while s != e:\r\n            if self.W[s] < self.W[e]:\r\n                s, w = self.U[s][0], self.W[s]\r\n            else:\r\n                e, w = self.U[e][0], self.W[e]\r\n\r\n        return w\r\n                \r\n\r\nclass SparseTable:\r\n    def __init__(self, A, F):\r\n        self.A = A\r\n        self.F = F\r\n\r\n        self.buildLG()\r\n        self.buildST()\r\n\r\n    def buildLG(self):\r\n        self.LG = []\r\n        lg, V = 0, 1\r\n        for e in range(len(self.A) + 1):\r\n            if V * 2 <= e:\r\n                V *= 2\r\n                lg += 1\r\n            self.LG.append(lg)\r\n\r\n    def buildST(self):\r\n        n = len(self.A)\r\n        self.ST = []\r\n        length = 1\r\n        while length <= n:\r\n            if length == 1:\r\n                self.ST.append(self.A)\r\n            else:\r\n                self.ST.append([self.F(self.ST[-1][s], self.ST[-1][s + length//2]) for s in range(n - length + 1)])\r\n\r\n            length <<= 1\r\n\r\n    def query(self, l, r):\r\n        if l == r:\r\n            return self.ST[0][l]\r\n\r\n        if l > r:\r\n            l, r = r, l\r\n        \r\n        e = self.LG[r - l + 1]\r\n        return self.F(self.ST[e][l], self.ST[e][r - 2**e + 1])\r\n\r\n\r\nT = int(input())\r\nfor _ in range(T):\r\n    n, m, q = map(int, input().split())\r\n\r\n    dsu = DisjointSetWithWeights(n + 1)\r\n\r\n    for i in range(m):\r\n        s, e = map(int, input().split())\r\n        dsu.union(s, e, i)\r\n\r\n    W = [dsu.maxWeight(i, i + 1) for i in range(1, n)]\r\n\r\n    ST = SparseTable(W, max)\r\n\r\n    R = []\r\n    for i in range(q):\r\n        a, b = map(int, input().split())\r\n        if a == b:\r\n            R.append(0)\r\n        else:\r\n            R.append(ST.query(a - 1, b - 2) + 1)\r\n\r\n\r\n    print(\" \".join(str(r) for r in R))\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
    "prob_desc_created_at": "1658154900",
    "tags": [
        "binary search",
        "data structures",
        "dfs and similar",
        "divide and conquer",
        "dsu",
        "greedy",
        "trees"
    ],
    "hidden_unit_tests": ""
}
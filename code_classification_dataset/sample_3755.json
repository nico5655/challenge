{
    "prob_desc_time_limit": "1 second",
    "prob_desc_sample_outputs": "[\"YES\\nNO\\nYES\\nYES\"]",
    "src_uid": "d8d33581ceb13da9bb99e90296bdd8f7",
    "prob_desc_notes": "NoteIn the first test case, YouKn0wWho can split the sequence in the following way: $$$[1, 3, 4]$$$, $$$[2, 2]$$$, $$$[1, 5]$$$. This way, the LIS lengths are $$$h = [3, 1, 2]$$$, and the bitwise XOR of the LIS lengths is $$$3 \\oplus 1 \\oplus 2 = 0$$$.In the second test case, it can be shown that it is impossible to split the sequence into subarrays that will satisfy the condition.",
    "prob_desc_description": "YouKn0wWho has an integer sequence $$$a_1, a_2, \\ldots a_n$$$. Now he will split the sequence $$$a$$$ into one or more consecutive subarrays so that each element of $$$a$$$ belongs to exactly one subarray. Let $$$k$$$ be the number of resulting subarrays, and $$$h_1, h_2, \\ldots, h_k$$$ be the lengths of the longest increasing subsequences of corresponding subarrays.For example, if we split $$$[2, 5, 3, 1, 4, 3, 2, 2, 5, 1]$$$ into $$$[2, 5, 3, 1, 4]$$$, $$$[3, 2, 2, 5]$$$, $$$[1]$$$, then $$$h = [3, 2, 1]$$$.YouKn0wWho wonders if it is possible to split the sequence $$$a$$$ in such a way that the bitwise XOR of $$$h_1, h_2, \\ldots, h_k$$$ is equal to $$$0$$$. You have to tell whether it is possible.The longest increasing subsequence (LIS) of a sequence $$$b_1, b_2, \\ldots, b_m$$$ is the longest sequence of valid indices $$$i_1, i_2, \\ldots, i_k$$$ such that $$$i_1 \\lt i_2 \\lt \\ldots \\lt i_k$$$ and $$$b_{i_1} \\lt b_{i_2} \\lt \\ldots \\lt b_{i_k}$$$. For example, the LIS of $$$[2, 5, 3, 3, 5]$$$ is $$$[2, 3, 5]$$$, which has length $$$3$$$.An array $$$c$$$ is a subarray of an array $$$b$$$ if $$$c$$$ can be obtained from $$$b$$$ by deletion of several (possibly, zero or all) elements from the beginning and several (possibly, zero or all) elements from the end.",
    "prob_desc_output_spec": "For each test case, print \"YES\" (without quotes) if it is possible to split into subarrays in the desired way, print \"NO\" (without quotes) otherwise. You can print each letter in any register (upper or lower).",
    "prob_desc_input_spec": "The first line contains a single integer $$$t$$$ ($$$1 \\le t \\le 10\\,000$$$)  — the number of test cases. The first line of each test case contains a single integer $$$n$$$ ($$$2 \\le n \\le 10^5$$$). The second line of each test case contains $$$n$$$ integers $$$a_1, a_2, \\ldots, a_n$$$ ($$$1 \\le a_i \\le 10^9$$$). It is guaranteed that the sum of $$$n$$$ over all test cases doesn't exceed $$$3 \\cdot 10^5$$$.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3-64",
    "lang_cluster": "Python",
    "difficulty": 1100,
    "file_name": "train_083.jsonl",
    "code_uid": "58c603363fde521d9ce40eefd96bbbd9",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"4\\n7\\n1 3 4 2 2 1 5\\n3\\n1 3 4\\n5\\n1 3 2 4 2\\n4\\n4 3 2 1\"]",
    "exec_outcome": "PASSED",
    "source_code": "#!/usr/bin/env python\r\nimport os\r\nimport sys\r\nfrom io import BytesIO, IOBase\r\n\r\n\r\n# region fastio\r\n\r\nBUFSIZE = 8192\r\n\r\n\r\nclass FastIO(IOBase):\r\n    newlines = 0\r\n\r\n    def __init__(self, file):\r\n        self._fd = file.fileno()\r\n        self.buffer = BytesIO()\r\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\r\n        self.write = self.buffer.write if self.writable else None\r\n\r\n    def read(self):\r\n        while True:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            if not b:\r\n                break\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines = 0\r\n        return self.buffer.read()\r\n\r\n    def readline(self):\r\n        while self.newlines == 0:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            self.newlines = b.count(b\"\\n\") + (not b)\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines -= 1\r\n        return self.buffer.readline()\r\n\r\n    def flush(self):\r\n        if self.writable:\r\n            os.write(self._fd, self.buffer.getvalue())\r\n            self.buffer.truncate(0), self.buffer.seek(0)\r\n\r\n\r\nclass IOWrapper(IOBase):\r\n    def __init__(self, file):\r\n        self.buffer = FastIO(file)\r\n        self.flush = self.buffer.flush\r\n        self.writable = self.buffer.writable\r\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\r\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\r\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\r\n\r\n\r\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\r\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\r\n\r\n# endregion\r\n\r\ndef main():\r\n\tt = int(input())\r\n\twhile t:\r\n\t\tt -= 1\r\n\t\tn = int(input())\r\n\t\tls = [int(i) for i in input().strip().split()]\r\n\t\tflag = False\r\n\t\tif n % 2 == 0:\r\n\t\t\tflag = True\r\n\t\telse:\r\n\t\t\tfor i in range(1, n):\r\n\t\t\t\tif ls[i] <= ls[i-1]:\r\n\t\t\t\t\tflag = True\r\n\t\tif flag:\r\n\t\t\tprint('YES')\r\n\t\telse:\r\n\t\t\tprint(\"NO\")\r\n\r\n\r\nif __name__ == '__main__':\r\n    main()\r\n",
    "prob_desc_created_at": "1635604500",
    "tags": [],
    "hidden_unit_tests": ""
}
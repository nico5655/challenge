{
    "prob_desc_time_limit": "3 seconds",
    "prob_desc_sample_outputs": "[\"10\\n1\\n21\"]",
    "src_uid": "45da2b93570e7d26d0e4fd3a3fca20b7",
    "prob_desc_notes": "NoteIn the first test case, the algorithm performs no insertions — therefore, the initial sequence is already sorted in non-decreasing order. There are $$$10$$$ such sequences: $$$[1, 1, 1], [1, 1, 2], [1, 1, 3], [1, 2, 2], [1, 2, 3], [1, 3, 3], [2, 2, 2], [2, 2, 3], [2, 3, 3], [3, 3, 3]$$$.In the second test case, the only sequence satisfying the conditions is $$$[3, 2, 1]$$$.In the third test case, $$$[4, 5, 3, 1, 3]$$$ is one of the sought sequences.",
    "prob_desc_description": "Consider the insertion sort algorithm used to sort an integer sequence $$$[a_1, a_2, \\ldots, a_n]$$$ of length $$$n$$$ in non-decreasing order.For each $$$i$$$ in order from $$$2$$$ to $$$n$$$, do the following. If $$$a_i \\ge a_{i-1}$$$, do nothing and move on to the next value of $$$i$$$. Otherwise, find the smallest $$$j$$$ such that $$$a_i &lt; a_j$$$, shift the elements on positions from $$$j$$$ to $$$i-1$$$ by one position to the right, and write down the initial value of $$$a_i$$$ to position $$$j$$$. In this case we'll say that we performed an insertion of an element from position $$$i$$$ to position $$$j$$$.It can be noticed that after processing any $$$i$$$, the prefix of the sequence $$$[a_1, a_2, \\ldots, a_i]$$$ is sorted in non-decreasing order, therefore, the algorithm indeed sorts any sequence.For example, sorting $$$[4, 5, 3, 1, 3]$$$ proceeds as follows:   $$$i = 2$$$: $$$a_2 \\ge a_1$$$, do nothing;  $$$i = 3$$$: $$$j = 1$$$, insert from position $$$3$$$ to position $$$1$$$: $$$[3, 4, 5, 1, 3]$$$;  $$$i = 4$$$: $$$j = 1$$$, insert from position $$$4$$$ to position $$$1$$$: $$$[1, 3, 4, 5, 3]$$$;  $$$i = 5$$$: $$$j = 3$$$, insert from position $$$5$$$ to position $$$3$$$: $$$[1, 3, 3, 4, 5]$$$. You are given an integer $$$n$$$ and a list of $$$m$$$ integer pairs $$$(x_i, y_i)$$$. We are interested in sequences such that if you sort them using the above algorithm, exactly $$$m$$$ insertions will be performed: first from position $$$x_1$$$ to position $$$y_1$$$, then from position $$$x_2$$$ to position $$$y_2$$$, ..., finally, from position $$$x_m$$$ to position $$$y_m$$$.How many sequences of length $$$n$$$ consisting of (not necessarily distinct) integers between $$$1$$$ and $$$n$$$, inclusive, satisfy the above condition? Print this number modulo $$$998\\,244\\,353$$$.",
    "prob_desc_output_spec": "For each test case, print the number of sequences of length $$$n$$$ consisting of integers from $$$1$$$ to $$$n$$$ such that sorting them with the described algorithm produces the given sequence of insertions, modulo $$$998\\,244\\,353$$$.",
    "prob_desc_input_spec": "Each test contains multiple test cases. The first line contains the number of test cases $$$t$$$ ($$$1 \\le t \\le 10^5$$$). Description of the test cases follows. The first line of each test case contains two integers $$$n$$$ and $$$m$$$ ($$$2 \\le n \\le 2 \\cdot 10^5$$$; $$$0 \\le m &lt; n$$$) — the length of the sequence and the number of insertions. The $$$i$$$-th of the following $$$m$$$ lines contains two integers $$$x_i$$$ and $$$y_i$$$ ($$$2 \\le x_1 &lt; x_2 &lt; \\ldots &lt; x_m \\le n$$$; $$$1 \\le y_i &lt; x_i$$$). These lines describe the sequence of insertions in chronological order. It is guaranteed that the sum of $$$m$$$ over all test cases does not exceed $$$2 \\cdot 10^5$$$. Note that there is no constraint on the sum of $$$n$$$ of the same kind.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3",
    "lang_cluster": "Python",
    "difficulty": 2600,
    "file_name": "train_086.jsonl",
    "code_uid": "979de1d386d39fa444059f3e5aafdc54",
    "prob_desc_memory_limit": "512 megabytes",
    "prob_desc_sample_inputs": "[\"3\\n3 0\\n3 2\\n2 1\\n3 1\\n5 3\\n3 1\\n4 1\\n5 3\"]",
    "exec_outcome": "PASSED",
    "source_code": "\r\ndef divisors(M):\r\n    d=[]\r\n    i=1\r\n    while M>=i**2:\r\n        if M%i==0:\r\n            d.append(i)\r\n            if i**2!=M:\r\n                d.append(M//i)\r\n        i=i+1\r\n    return d\r\n\r\ndef popcount(x):\r\n    x = x - ((x >> 1) & 0x55555555)\r\n    x = (x & 0x33333333) + ((x >> 2) & 0x33333333)\r\n    x = (x + (x >> 4)) & 0x0f0f0f0f\r\n    x = x + (x >> 8)\r\n    x = x + (x >> 16)\r\n    return x & 0x0000007f\r\n\r\ndef eratosthenes(n):\r\n    res=[0 for i in range(n+1)]\r\n    prime=set([])\r\n    for i in range(2,n+1):\r\n        if not res[i]:\r\n            prime.add(i)\r\n            for j in range(1,n//i+1):\r\n                res[i*j]=1\r\n    return prime\r\n\r\ndef factorization(n):\r\n    res=[]\r\n    for p in prime:\r\n        if n%p==0:\r\n            while n%p==0:\r\n                n//=p\r\n            res.append(p)\r\n    if n!=1:\r\n        res.append(n)\r\n    return res\r\n\r\ndef euler_phi(n):\r\n    res = n\r\n    for x in range(2,n+1):\r\n        if x ** 2 > n:\r\n            break\r\n        if n%x==0:\r\n            res = res//x * (x-1)\r\n            while n%x==0:\r\n                n //= x\r\n    if n!=1:\r\n        res = res//n * (n-1)\r\n    return res\r\n\r\ndef ind(b,n):\r\n    res=0\r\n    while n%b==0:\r\n        res+=1\r\n        n//=b\r\n    return res\r\n\r\ndef isPrimeMR(n):\r\n    d = n - 1\r\n    d = d // (d & -d)\r\n    L = [2, 3, 5, 7, 11, 13, 17]\r\n    for a in L:\r\n        t = d\r\n        y = pow(a, t, n)\r\n        if y == 1: continue\r\n        while y != n - 1:\r\n            y = (y * y) % n\r\n            if y == 1 or t == n - 1: return 0\r\n            t <<= 1\r\n    return 1\r\ndef findFactorRho(n):\r\n    from math import gcd\r\n    m = 1 << n.bit_length() // 8\r\n    for c in range(1, 99):\r\n        f = lambda x: (x * x + c) % n\r\n        y, r, q, g = 2, 1, 1, 1\r\n        while g == 1:\r\n            x = y\r\n            for i in range(r):\r\n                y = f(y)\r\n            k = 0\r\n            while k < r and g == 1:\r\n                ys = y\r\n                for i in range(min(m, r - k)):\r\n                    y = f(y)\r\n                    q = q * abs(x - y) % n\r\n                g = gcd(q, n)\r\n                k += m\r\n            r <<= 1\r\n        if g == n:\r\n            g = 1\r\n            while g == 1:\r\n                ys = f(ys)\r\n                g = gcd(abs(x - ys), n)\r\n        if g < n:\r\n            if isPrimeMR(g): return g\r\n            elif isPrimeMR(n // g): return n // g\r\n            return findFactorRho(g)\r\ndef primeFactor(n):\r\n    i = 2\r\n    ret = {}\r\n    rhoFlg = 0\r\n    while i*i <= n:\r\n        k = 0\r\n        while n % i == 0:\r\n            n //= i\r\n            k += 1\r\n        if k: ret[i] = k\r\n        i += 1 + i % 2\r\n        if i == 101 and n >= 2 ** 20:\r\n            while n > 1:\r\n                if isPrimeMR(n):\r\n                    ret[n], n = 1, 1\r\n                else:\r\n                    rhoFlg = 1\r\n                    j = findFactorRho(n)\r\n                    k = 0\r\n                    while n % j == 0:\r\n                        n //= j\r\n                        k += 1\r\n                    ret[j] = k\r\n\r\n    if n > 1: ret[n] = 1\r\n    if rhoFlg: ret = {x: ret[x] for x in sorted(ret)}\r\n    return ret\r\n\r\ndef divisors(n):\r\n    res = [1]\r\n    prime = primeFactor(n)\r\n    for p in prime:\r\n        newres = []\r\n        for d in res:\r\n            for j in range(prime[p]+1):\r\n                newres.append(d*p**j)\r\n        res = newres\r\n    res.sort()\r\n    return res\r\n\r\ndef xorfactorial(num):\r\n    if num==0:\r\n        return 0\r\n    elif num==1:\r\n        return 1\r\n    elif num==2:\r\n        return 3\r\n    elif num==3:\r\n        return 0\r\n    else:\r\n        x=baseorder(num)\r\n        return (2**x)*((num-2**x+1)%2)+function(num-2**x)\r\n\r\ndef xorconv(n,X,Y):\r\n    if n==0:\r\n        res=[(X[0]*Y[0])%mod]\r\n        return res\r\n    x=[X[i]+X[i+2**(n-1)] for i in range(2**(n-1))]\r\n    y=[Y[i]+Y[i+2**(n-1)] for i in range(2**(n-1))]\r\n    z=[X[i]-X[i+2**(n-1)] for i in range(2**(n-1))]\r\n    w=[Y[i]-Y[i+2**(n-1)] for i in range(2**(n-1))]\r\n    res1=xorconv(n-1,x,y)\r\n    res2=xorconv(n-1,z,w)\r\n    former=[(res1[i]+res2[i])*inv for i in range(2**(n-1))]\r\n    latter=[(res1[i]-res2[i])*inv for i in range(2**(n-1))]\r\n    former=list(map(lambda x:x%mod,former))\r\n    latter=list(map(lambda x:x%mod,latter))\r\n    return former+latter\r\n\r\ndef merge_sort(A,B):\r\n    pos_A,pos_B = 0,0\r\n    n,m = len(A),len(B)\r\n    res = []\r\n    while pos_A < n and pos_B < m:\r\n        a,b = A[pos_A],B[pos_B]\r\n        if a < b:\r\n            res.append(a)\r\n            pos_A += 1\r\n        else:\r\n            res.append(b)\r\n            pos_B += 1\r\n    res += A[pos_A:]\r\n    res += B[pos_B:]\r\n    return res\r\n\r\nclass UnionFindVerSize():\r\n    def __init__(self, N):\r\n        self._parent = [n for n in range(0, N)]\r\n        self._size = [1] * N\r\n        self.group = N\r\n\r\n    def find_root(self, x):\r\n        if self._parent[x] == x: return x\r\n        self._parent[x] = self.find_root(self._parent[x])\r\n        stack = [x]\r\n        while self._parent[stack[-1]]!=stack[-1]:\r\n            stack.append(self._parent[stack[-1]])\r\n        for v in stack:\r\n            self._parent[v] = stack[-1]\r\n        return self._parent[x]\r\n\r\n    def unite(self, x, y):\r\n        gx = self.find_root(x)\r\n        gy = self.find_root(y)\r\n        if gx == gy: return\r\n\r\n        self.group -= 1\r\n\r\n        if self._size[gx] < self._size[gy]:\r\n            self._parent[gx] = gy\r\n            self._size[gy] += self._size[gx]\r\n        else:\r\n            self._parent[gy] = gx\r\n            self._size[gx] += self._size[gy]\r\n\r\n    def get_size(self, x):\r\n        return self._size[self.find_root(x)]\r\n\r\n    def is_same_group(self, x, y):\r\n        return self.find_root(x) == self.find_root(y)\r\n\r\nclass WeightedUnionFind():\r\n    def __init__(self,N):\r\n        self.parent = [i for i in range(N)]\r\n        self.size = [1 for i in range(N)]\r\n        self.val = [0 for i in range(N)]\r\n        self.flag = True\r\n        self.edge = [[] for i in range(N)]\r\n\r\n    def dfs(self,v,pv):\r\n        stack = [(v,pv)]\r\n        new_parent = self.parent[pv]\r\n        while stack:\r\n            v,pv = stack.pop()\r\n            self.parent[v] = new_parent\r\n            for nv,w in self.edge[v]:\r\n                if nv!=pv:\r\n                    self.val[nv] = self.val[v] + w\r\n                    stack.append((nv,v))\r\n\r\n    def unite(self,x,y,w):\r\n        if not self.flag:\r\n            return\r\n        if self.parent[x]==self.parent[y]:\r\n            self.flag = (self.val[x] - self.val[y] == w)\r\n            return\r\n\r\n        if self.size[self.parent[x]]>self.size[self.parent[y]]:\r\n            self.edge[x].append((y,-w))\r\n            self.edge[y].append((x,w))\r\n            self.size[x] += self.size[y]\r\n            self.val[y] = self.val[x] - w\r\n            self.dfs(y,x)\r\n        else:\r\n            self.edge[x].append((y,-w))\r\n            self.edge[y].append((x,w))\r\n            self.size[y] += self.size[x]\r\n            self.val[x] = self.val[y] + w\r\n            self.dfs(x,y)\r\n\r\nclass Dijkstra():\r\n    class Edge():\r\n        def __init__(self, _to, _cost):\r\n            self.to = _to\r\n            self.cost = _cost\r\n\r\n    def __init__(self, V):\r\n        self.G = [[] for i in range(V)]\r\n        self._E = 0\r\n        self._V = V\r\n\r\n    @property\r\n    def E(self):\r\n        return self._E\r\n\r\n    @property\r\n    def V(self):\r\n        return self._V\r\n\r\n    def add_edge(self, _from, _to, _cost):\r\n        self.G[_from].append(self.Edge(_to, _cost))\r\n        self._E += 1\r\n\r\n    def shortest_path(self, s):\r\n        import heapq\r\n        que = []\r\n        d = [10**15] * self.V\r\n        d[s] = 0\r\n        heapq.heappush(que, (0, s))\r\n\r\n        while len(que) != 0:\r\n            cost, v = heapq.heappop(que)\r\n            if d[v] < cost: continue\r\n\r\n            for i in range(len(self.G[v])):\r\n                e = self.G[v][i]\r\n                if d[e.to] > d[v] + e.cost:\r\n                    d[e.to] = d[v] + e.cost\r\n                    heapq.heappush(que, (d[e.to], e.to))\r\n        return d\r\n\r\n#Z[i]:length of the longest list starting from S[i] which is also a prefix of S\r\n#O(|S|)\r\ndef Z_algorithm(s):\r\n    N = len(s)\r\n    Z_alg = [0]*N\r\n\r\n    Z_alg[0] = N\r\n    i = 1\r\n    j = 0\r\n    while i < N:\r\n        while i+j < N and s[j] == s[i+j]:\r\n            j += 1\r\n        Z_alg[i] = j\r\n        if j == 0:\r\n            i += 1\r\n            continue\r\n        k = 1\r\n        while i+k < N and k + Z_alg[k]<j:\r\n            Z_alg[i+k] = Z_alg[k]\r\n            k += 1\r\n        i += k\r\n        j -= k\r\n    return Z_alg\r\n\r\nclass BIT():\r\n    def __init__(self,n,mod=0):\r\n        self.BIT = [0]*(n+1)\r\n        self.num = n\r\n        self.mod = mod\r\n\r\n    def query(self,idx):\r\n        res_sum = 0\r\n        mod = self.mod\r\n        while idx > 0:\r\n            res_sum += self.BIT[idx]\r\n            if mod:\r\n                res_sum %= mod\r\n            idx -= idx&(-idx)\r\n        return res_sum\r\n\r\n    #Ai += x O(logN)\r\n    def update(self,idx,x):\r\n        mod = self.mod\r\n        while idx <= self.num:\r\n            self.BIT[idx] += x\r\n            if mod:\r\n                self.BIT[idx] %= mod\r\n            idx += idx&(-idx)\r\n        return\r\n\r\nclass dancinglink():\r\n    def __init__(self,n,debug=False):\r\n        self.n = n\r\n        self.debug = debug\r\n        self._left = [i-1 for i in range(n)]\r\n        self._right = [i+1 for i in range(n)]\r\n        self.exist = [True for i in range(n)]\r\n\r\n    def pop(self,k):\r\n        if self.debug:\r\n            assert self.exist[k]\r\n        L = self._left[k]\r\n        R = self._right[k]\r\n        if L!=-1:\r\n            if R!=self.n:\r\n                self._right[L],self._left[R] = R,L\r\n            else:\r\n                self._right[L] = self.n\r\n        elif R!=self.n:\r\n            self._left[R] = -1\r\n        self.exist[k] = False\r\n\r\n    def left(self,idx,k=1):\r\n        if self.debug:\r\n            assert self.exist[idx]\r\n        res = idx\r\n        while k:\r\n            res = self._left[res]\r\n            if res==-1:\r\n                break\r\n            k -= 1\r\n        return res\r\n\r\n    def right(self,idx,k=1):\r\n        if self.debug:\r\n            assert self.exist[idx]\r\n        res = idx\r\n        while k:\r\n            res = self._right[res]\r\n            if res==self.n:\r\n                break\r\n            k -= 1\r\n        return res\r\n\r\nclass SparseTable():\r\n    def __init__(self,A,merge_func,ide_ele):\r\n        N=len(A)\r\n        n=N.bit_length()\r\n        self.table=[[ide_ele for i in range(n)] for i in range(N)]\r\n        self.merge_func=merge_func\r\n\r\n        for i in range(N):\r\n            self.table[i][0]=A[i]\r\n\r\n        for j in range(1,n):\r\n            for i in range(0,N-2**j+1):\r\n                f=self.table[i][j-1]\r\n                s=self.table[i+2**(j-1)][j-1]\r\n                self.table[i][j]=self.merge_func(f,s)\r\n\r\n    def query(self,s,t):\r\n        b=t-s+1\r\n        m=b.bit_length()-1\r\n        return self.merge_func(self.table[s][m],self.table[t-2**m+1][m])\r\n\r\nclass BinaryTrie:\r\n    class node:\r\n        def __init__(self,val):\r\n            self.left = None\r\n            self.right = None\r\n            self.max = val\r\n\r\n    def __init__(self):\r\n        self.root = self.node(-10**15)\r\n\r\n    def append(self,key,val):\r\n        pos = self.root\r\n        for i in range(29,-1,-1):\r\n            pos.max = max(pos.max,val)\r\n            if key>>i & 1:\r\n                if pos.right is None:\r\n                    pos.right = self.node(val)\r\n                    pos = pos.right\r\n                else:\r\n                    pos = pos.right\r\n            else:\r\n                if pos.left is None:\r\n                    pos.left = self.node(val)\r\n                    pos = pos.left\r\n                else:\r\n                    pos = pos.left\r\n        pos.max = max(pos.max,val)\r\n\r\n    def search(self,M,xor):\r\n        res = -10**15\r\n        pos = self.root\r\n        for i in range(29,-1,-1):\r\n            if pos is None:\r\n                break\r\n\r\n            if M>>i & 1:\r\n                if xor>>i & 1:\r\n                    if pos.right:\r\n                        res = max(res,pos.right.max)\r\n                    pos = pos.left\r\n                else:\r\n                    if pos.left:\r\n                        res = max(res,pos.left.max)\r\n                    pos = pos.right\r\n            else:\r\n                if xor>>i & 1:\r\n                    pos = pos.right\r\n                else:\r\n                    pos = pos.left\r\n\r\n        if pos:\r\n            res = max(res,pos.max)\r\n        return res\r\n\r\ndef solveequation(edge,ans,n,m):\r\n    #edge=[[to,dire,id]...]\r\n    x=[0]*m\r\n    used=[False]*n\r\n    for v in range(n):\r\n        if used[v]:\r\n            continue\r\n        y = dfs(v)\r\n        if y!=0:\r\n            return False\r\n    return x\r\n\r\n    def dfs(v):\r\n        used[v]=True\r\n        r=ans[v]\r\n        for to,dire,id in edge[v]:\r\n            if used[to]:\r\n                continue\r\n            y=dfs(to)\r\n            if dire==-1:\r\n                x[id]=y\r\n            else:\r\n                x[id]=-y\r\n            r+=y\r\n        return r\r\n\r\nclass SegmentTree:\r\n    def __init__(self, init_val, segfunc, ide_ele):\r\n        n = len(init_val)\r\n        self.segfunc = segfunc\r\n        self.ide_ele = ide_ele\r\n        self.num = 1 << (n - 1).bit_length()\r\n        self.tree = [ide_ele] * 2 * self.num\r\n        self.size = n\r\n        for i in range(n):\r\n            self.tree[self.num + i] = init_val[i]\r\n        for i in range(self.num - 1, 0, -1):\r\n            self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])\r\n\r\n    def update(self, k, x):\r\n        k += self.num\r\n        self.tree[k] += x\r\n        while k > 1:\r\n            self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])\r\n            k >>= 1\r\n\r\n    def bisect(self,S):\r\n        pos = 1\r\n        if self.tree[1] < S:\r\n            return self.num\r\n        while pos<self.num:\r\n            l,r = 2*pos,2*pos+1\r\n            if S<=self.tree[l]:\r\n                pos = 2*pos\r\n            else:\r\n                S -= self.tree[l]\r\n                pos = 2 * pos + 1\r\n        return pos - self.num\r\n\r\nimport sys,random,bisect\r\nfrom collections import deque,defaultdict\r\nfrom heapq import heapify,heappop,heappush\r\nfrom itertools import permutations\r\nfrom math import gcd,log\r\n\r\ninput = lambda :sys.stdin.buffer.readline()\r\nmi = lambda :map(int,input().split())\r\nli = lambda :list(mi())\r\n\r\ndef cmb(n, r, mod):\r\n    if ( r<0 or r>n ):\r\n        return 0\r\n    return (g1[n] * g2[r] % mod) * g2[n-r] % mod\r\n\r\nmod = 998244353\r\nN = 5*10**5\r\ng1 = [1]*(N+1)\r\ng2 = [1]*(N+1)\r\ninverse = [1]*(N+1)\r\n\r\nfor i in range( 2, N + 1 ):\r\n    g1[i]=( ( g1[i-1] * i ) % mod )\r\n    inverse[i]=( ( -inverse[mod % i] * (mod//i) ) % mod )\r\n    g2[i]=( (g2[i-1] * inverse[i]) % mod )\r\ninverse[0]=0\r\n\r\ndef merge(A0,A1):\r\n    Y0,S0 = A0\r\n    Y1,S1 = A1\r\n    if not Y0:\r\n        return A1\r\n    if not Y1:\r\n        return A0\r\n\r\n    Y2 = Y0 + Y1\r\n    cnt = 0\r\n    idx = 0\r\n    \r\n    n = len(S0)\r\n    T = [S0[0]] + [S0[i+1]-S0[i] for i in range(n-1)]\r\n    #print(T)\r\n    Seg = SegmentTree(T,lambda x,y:x+y,0)\r\n    for y in Y1:\r\n        idx = Seg.bisect(y-1)\r\n        #print(idx,Seg.num,Seg.tree[1])\r\n        if idx!=Seg.num:\r\n            Seg.update(idx,1)\r\n    S0 = [Seg.tree[Seg.num+i] for i in range(n)]\r\n    #print(S0)\r\n    for i in range(1,n):\r\n        S0[i] += S0[i-1]\r\n    \r\n    S1 = S1[::-1]\r\n    S2 = []\r\n    for i in range(n):\r\n        while S1:\r\n            if S1[-1] < S0[i]:\r\n                S2.append(S1.pop())\r\n            elif S1[-1]==S0[i]:\r\n                S1.pop()\r\n            else:\r\n                break\r\n        S2.append(S0[i])\r\n    S1 = S1[::-1]\r\n    S2 += S1\r\n\r\n    return [Y2,S2]\r\n\r\nfor _ in range(int(input())):\r\n    n,m = mi()\r\n    init = [[] for i in range(m)]\r\n    tS = []\r\n    k = n//5\r\n    for i in range(m):\r\n        x,y = mi()\r\n        #y = random.randint(1,10)\r\n        #print(y)\r\n        #y = int(input())\r\n        init[i] = [[y+1],[y+1]]\r\n\r\n        \"\"\"\r\n        ntS = []\r\n        for val in tS:\r\n            if y+1<=val+1:\r\n                ntS.append(val+1)\r\n            else:\r\n                ntS.append(val)\r\n        if y+1 not in ntS:\r\n            ntS.append(y+1)\r\n        tS = ntS\r\n        #\"\"\"\r\n        \r\n    Seg = SegmentTree(init,merge,[[],[]])\r\n    Y,S = Seg.tree[1]\r\n    #print(Seg.tree)\r\n\r\n    #S.sort()\r\n    #tS.sort()\r\n    #print(S==tS)\r\n    \r\n    k = len(S) + 1\r\n    print(cmb(n-k+n,n,mod))",
    "prob_desc_created_at": "1629815700",
    "tags": [
        "combinatorics",
        "data structures"
    ],
    "hidden_unit_tests": ""
}
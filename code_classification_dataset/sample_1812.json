{
    "prob_desc_time_limit": "3 seconds",
    "prob_desc_sample_outputs": "[\"2\", \"3\", \"0\", \"0\"]",
    "src_uid": "b4332870aac6159d5aaa4ff21f8e9f7f",
    "prob_desc_notes": "NoteThe acquaintances graph for the first example is shown in the picture below (next to each student there is their group number written).In that test we can select the following groups:  Select the first and the second groups. For instance, one team can be formed from students $$$1$$$ and $$$4$$$, while other team can be formed from students $$$2$$$ and $$$3$$$.  Select the second and the third group. For instance, one team can be formed $$$3$$$ and $$$6$$$, while other team can be formed from students $$$4$$$ and $$$5$$$.  We can't select the first and the third group, because there is no way to form the teams for the game. In the second example, we can select any group pair. Please note, that even though the third group has no students, we still can select it (with some other group) for the game.",
    "prob_desc_description": "The new academic year has started, and Berland's university has $$$n$$$ first-year students. They are divided into $$$k$$$ academic groups, however, some of the groups might be empty. Among the students, there are $$$m$$$ pairs of acquaintances, and each acquaintance pair might be both in a common group or be in two different groups.Alice is the curator of the first years, she wants to host an entertaining game to make everyone know each other. To do that, she will select two different academic groups and then divide the students of those groups into two teams. The game requires that there are no acquaintance pairs inside each of the teams.Alice wonders how many pairs of groups she can select, such that it'll be possible to play a game after that. All students of the two selected groups must take part in the game.Please note, that the teams Alice will form for the game don't need to coincide with groups the students learn in. Moreover, teams may have different sizes (or even be empty).",
    "prob_desc_output_spec": "Print a single integer — the number of ways to choose two different groups such that it's possible to select two teams to play the game.",
    "prob_desc_input_spec": "The first line contains three integers $$$n$$$, $$$m$$$ and $$$k$$$ ($$$1 \\le n \\le 500\\,000$$$; $$$0 \\le m \\le 500\\,000$$$; $$$2 \\le k \\le 500\\,000$$$) — the number of students, the number of pairs of acquaintances and the number of groups respectively. The second line contains $$$n$$$ integers $$$c_1, c_2, \\dots, c_n$$$ ($$$1 \\le c_i \\le k$$$), where $$$c_i$$$ equals to the group number of the $$$i$$$-th student. Next $$$m$$$ lines follow. The $$$i$$$-th of them contains two integers $$$a_i$$$ and $$$b_i$$$ ($$$1 \\le a_i, b_i \\le n$$$), denoting that students $$$a_i$$$ and $$$b_i$$$ are acquaintances. It's guaranteed, that $$$a_i \\neq b_i$$$, and that no (unordered) pair is mentioned more than once.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 2",
    "lang_cluster": "Python",
    "difficulty": 2500,
    "file_name": "train_013.jsonl",
    "code_uid": "99c4d33d7a26bfdd881cc121de5f36f7",
    "prob_desc_memory_limit": "512 megabytes",
    "prob_desc_sample_inputs": "[\"6 8 3\\n1 1 2 2 3 3\\n1 3\\n1 5\\n1 6\\n2 5\\n2 6\\n3 4\\n3 5\\n5 6\", \"4 3 3\\n1 1 2 2\\n1 2\\n2 3\\n3 4\", \"4 4 2\\n1 1 1 2\\n1 2\\n2 3\\n3 1\\n1 4\", \"5 5 2\\n1 2 1 2 1\\n1 2\\n2 3\\n3 4\\n4 5\\n5 1\"]",
    "exec_outcome": "PASSED",
    "source_code": "import os\nimport sys\nfrom atexit import register\nfrom io import BytesIO\n\nsys.stdout = BytesIO()\nregister(lambda: os.write(1, sys.stdout.getvalue()))\n\ninput = BytesIO(os.read(0, os.fstat(0).st_size)).readline\ndef main():\n    class UnionFind():\n        def __init__(self, n):\n            self.n = n\n            self.root = [-1] * (n + 1)\n            self.rnk = [0] * (n + 1)\n\n        def find_root(self, x):\n            while self.root[x] >= 0:\n                x = self.root[x]\n            return x\n\n        def unite(self, x, y):\n            x = self.find_root(x)\n            y = self.find_root(y)\n            if x == y:\n                return\n            elif self.rnk[x] > self.rnk[y]:\n                self.root[x] += self.root[y]\n                self.root[y] = x\n            else:\n                self.root[y] += self.root[x]\n                self.root[x] = y\n                if self.rnk[x] == self.rnk[y]:\n                    self.rnk[y] += 1\n\n        def unite_root(self, x, y):\n            # assert self.root[x] < 0 and self.root[y] < 0\n            if self.rnk[x] > self.rnk[y]:\n                self.root[x] += self.root[y]\n                self.root[y] = x\n            else:\n                self.root[y] += self.root[x]\n                self.root[x] = y\n                if self.rnk[x] == self.rnk[y]:\n                    self.rnk[y] += 1\n\n        def isSameGroup(self, x, y):\n            return self.find_root(x) == self.find_root(y)\n\n        def size(self, x):\n            return -self.root[self.find_root(x)]\n\n    N, M, K = map(int, input().split())\n    C = [0] + list(map(int, input().split()))\n    V_color = [[] for _ in range(K+1)]\n    for v in range(1, N+1):\n        V_color[C[v]].append(v)\n    E = {}\n    UF = UnionFind(2 * N)\n    for _ in range(M):\n        a, b = map(int, input().split())\n        ca, cb = C[a], C[b]\n        if ca == cb:\n            UF.unite(a, b + N)\n            UF.unite(a + N, b)\n        else:\n            if ca > cb:\n                ca, cb = cb, ca\n            c_ab = ca * (K+1) + cb\n            if c_ab in E:\n                E[c_ab].append((a, b))\n            else:\n                E[c_ab] = [(a, b)]\n\n    ok_color_num = 0\n    ok_color = [0] * (K+1)\n    root_c = [set() for _ in range(K+1)]\n    for c in range(1, K+1):\n        ok = 1\n        for v in V_color[c]:\n            r1 = UF.find_root(v)\n            r2 = UF.find_root(v+N)\n            if r1 == r2:\n                ok = 0\n                break\n            else:\n                root_c[c].add(min(r1, r2))\n        if ok:\n            ok_color_num += 1\n            ok_color[c] = 1\n        else:\n            for v in V_color[c]:\n                UF.root[v] = -1\n\n    R = [-1] * (N*2+1)\n    for v in range(1, 2*N+1):\n        R[v] = UF.find_root(v)\n\n    ans = (ok_color_num - 1) * ok_color_num // 2\n    root_ori = UF.root[:]\n    for c_ab in E:\n        ca, cb = divmod(c_ab, K+1)\n        if ok_color[ca] * ok_color[cb] == 0:\n            continue\n\n        ok = 1\n        for a, b in E[c_ab]:\n            ra = R[a]\n            rb = R[b]\n            if ra <= N:\n                ra2 = ra + N\n            else:\n                ra2 = ra - N\n            if rb <= N:\n                rb2 = rb + N\n            else:\n                rb2 = rb - N\n            r_ra = UF.find_root(ra)\n            r_rb2 = UF.find_root(rb2)\n            if r_ra != r_rb2:\n                UF.unite_root(r_ra, r_rb2)\n                r_ra2 = UF.find_root(ra2)\n                r_rb = UF.find_root(rb)\n                if r_ra2 == r_rb:\n                    ok = 0\n                    break\n                else:\n                    UF.unite_root(r_ra2, r_rb)\n        \"\"\"\n        if len(root_c[ca]) > len(root_c[cb]):\n            ca, cb = cb, ca\n        for v in root_c[ca]:\n            if UF.isSameGroup(v, v+N):\n                ok = 0\n                break\n        \"\"\"\n        if ok == 0:\n            ans -= 1\n        for v in root_c[ca]:\n            UF.root[v] = root_ori[v]\n            UF.root[v+N] = root_ori[v]\n        for v in root_c[cb]:\n            UF.root[v] = root_ori[v]\n            UF.root[v+N] = root_ori[v]\n    print(ans)\n\n\nif __name__ == '__main__':\n    main()\n",
    "prob_desc_created_at": "1604228700",
    "tags": [
        "data structures",
        "dsu",
        "dfs and similar",
        "graphs"
    ],
    "hidden_unit_tests": ""
}
{
    "prob_desc_time_limit": "2.5 seconds",
    "prob_desc_sample_outputs": "[\"0\", \"3\\n2 4 5\"]",
    "src_uid": "ede7de5979a00d81f774ffdf27cea017",
    "prob_desc_notes": "NoteIn the first test case, the grid is the one explained in the problem statement. The grid has the following properties:   The $$$1$$$-st row and the $$$2$$$-nd row have a common $$$1$$$ in the column $$$7$$$.  The $$$2$$$-nd row and the $$$3$$$-rd row have a common $$$1$$$ in the column $$$15$$$.  As a result, this grid is beautiful and we do not need to remove any row.In the second test case, the given grid is as follows:   ",
    "prob_desc_description": "Moamen was drawing a grid of $$$n$$$ rows and $$$10^9$$$ columns containing only digits $$$0$$$ and $$$1$$$. Ezzat noticed what Moamen was drawing and became interested in the minimum number of rows one needs to remove to make the grid beautiful.A grid is beautiful if and only if for every two consecutive rows there is at least one column containing $$$1$$$ in these two rows.Ezzat will give you the number of rows $$$n$$$, and $$$m$$$ segments of the grid that contain digits $$$1$$$. Every segment is represented with three integers $$$i$$$, $$$l$$$, and $$$r$$$, where $$$i$$$ represents the row number, and $$$l$$$ and $$$r$$$ represent the first and the last column of the segment in that row.For example, if $$$n = 3$$$, $$$m = 6$$$, and the segments are $$$(1,1,1)$$$, $$$(1,7,8)$$$, $$$(2,7,7)$$$, $$$(2,15,15)$$$, $$$(3,1,1)$$$, $$$(3,15,15)$$$, then the grid is:  Your task is to tell Ezzat the minimum number of rows that should be removed to make the grid beautiful.",
    "prob_desc_output_spec": "In the first line, print a single integer $$$k$$$ — the minimum number of rows that should be removed. In the second line print $$$k$$$ distinct integers $$$r_1, r_2, \\ldots, r_k$$$, representing the rows that should be removed ($$$1 \\le r_i \\le n$$$), in any order. If there are multiple answers, print any.",
    "prob_desc_input_spec": "The first line contains two integers $$$n$$$ and $$$m$$$ ($$$1 \\le n, m \\le 3\\cdot10^5$$$). Each of the next $$$m$$$ lines contains three integers $$$i$$$, $$$l$$$, and $$$r$$$ ($$$1 \\le i \\le n$$$, $$$1 \\le l \\le r \\le 10^9$$$). Each of these $$$m$$$ lines means that row number $$$i$$$ contains digits $$$1$$$ in columns from $$$l$$$ to $$$r$$$, inclusive. Note that the segments may overlap.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3",
    "lang_cluster": "Python",
    "difficulty": 2200,
    "file_name": "train_095.jsonl",
    "code_uid": "1a5a4e5d87796d201953472e6f4e3781",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"3 6\\n1 1 1\\n1 7 8\\n2 7 7\\n2 15 15\\n3 1 1\\n3 15 15\", \"5 4\\n1 2 3\\n2 4 6\\n3 3 5\\n5 1 1\"]",
    "exec_outcome": "PASSED",
    "source_code": "import array\r\nimport sys, os, io\r\ninput = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline\r\n\r\nn, m = map(int, input().split())\r\nx = [[] for _ in range(n + 1)]\r\ns = set()\r\nfor j in range(m):\r\n    i, l, r = map(int, input().split())\r\n    s.add(l)\r\n    s.add(r)\r\n    x[i].append((l, r))\r\ns = list(s)\r\ns.sort()\r\nd = dict()\r\nl = len(s)\r\nfor i in range(l):\r\n    d[s[i]] = i\r\nu, v = 600500, 500\r\nc = array.array(\"i\", [0] * u)\r\nc0 = array.array(\"i\", [0] * (u // v))\r\nc1 = array.array(\"i\", [0] * (u // v))\r\ndp = [[] for _ in range(n + 1)]\r\nml = array.array(\"i\", [0] * (n + 1))\r\nmr = array.array(\"i\", [0] * (n + 1))\r\nma = 0\r\nfor i in range(1, n + 1):\r\n    mai = 1\r\n    for l, r in x[i]:\r\n        dl, dr = d[l], d[r]\r\n        while dl % v and dl <= dr and ma >= mai:\r\n            c[dl] = max(c[dl], c1[dl // v])\r\n            if mai < c[dl] + 1:\r\n                ml[i] = l\r\n                mr[i] = r\r\n                mai = c[dl] + 1\r\n            dl += 1\r\n        if ma < mai:\r\n            break\r\n        while (dr % v) ^ (v - 1) and dl <= dr and ma >= mai:\r\n            c[dr] = max(c[dr], c1[dr // v])\r\n            if mai < c[dr] + 1:\r\n                ml[i] = l\r\n                mr[i] = r\r\n                mai = c[dr] + 1\r\n            dr -= 1\r\n        if ma < mai:\r\n            break\r\n        while dl <= dr and ma >= mai:\r\n            dlv = dl // v\r\n            c0[dlv] = max(c0[dlv], c1[dlv])\r\n            if mai < c0[dlv] + 1:\r\n                ml[i] = l\r\n                mr[i] = r\r\n                mai = c0[dlv] + 1\r\n            dl += v\r\n        if ma < mai:\r\n            break\r\n    for l, r in x[i]:\r\n        dl, dr = d[l], d[r]\r\n        while dl % v and dl <= dr:\r\n            c[dl] = max(c[dl], mai)\r\n            c0[dl // v] = max(c[dl], c0[dl // v])\r\n            dl += 1\r\n        while (dr % v) ^ (v - 1) and dl <= dr:\r\n            c[dr] = max(c[dr], mai)\r\n            c0[dr // v] = max(c[dr], c0[dr // v])\r\n            dr -= 1\r\n        while dl <= dr:\r\n            c1[dl // v] = max(c1[dl // v], mai)\r\n            dl += v\r\n    dp[mai].append(i)\r\n    ma = max(ma, mai)\r\ns = set()\r\ni = dp[ma][0]\r\nc = ma\r\ns.add(i)\r\nfor _ in range(ma - 1):\r\n    mli, mri = ml[i], mr[i]\r\n    for j in dp[c - 1]:\r\n        if j > i:\r\n            continue\r\n        ok = 0\r\n        for l, r in x[j]:\r\n            if l <= mri and mli <= r:\r\n                ok = 1\r\n                break\r\n        if ok:\r\n            s.add(j)\r\n            i = j\r\n            break\r\n    c -= 1\r\nk = n - len(s)\r\nr = []\r\nfor i in range(1, n + 1):\r\n    if not i in s:\r\n        r.append(i)\r\nsys.stdout.write(str(k) + \"\\n\")\r\nsys.stdout.write(\" \".join(map(str, r)))",
    "prob_desc_created_at": "1628519700",
    "tags": [
        "data structures",
        "dp",
        "greedy"
    ],
    "hidden_unit_tests": ""
}
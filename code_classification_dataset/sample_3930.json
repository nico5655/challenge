{
    "prob_desc_time_limit": "3 seconds",
    "prob_desc_sample_outputs": "[\"3\\n5\\n14\\n16\\n24\\n24\\n24\\n57\\n54\\n36\\n36\\n6\\n18\\n27\\n28\"]",
    "src_uid": "560e26bdfab14b919a7deadefa57f2de",
    "prob_desc_notes": "NoteIn the first test case, initially and after each request, the answer is achieved at $$$s = 1$$$, $$$k = 1$$$ or $$$s = 2$$$, $$$k = 1$$$.In the second test case, initially, the answer is achieved when $$$s = 1$$$, $$$k = 2$$$ or $$$s = 3$$$, $$$k = 2$$$. After the first request, the answer is achieved at $$$s = 2$$$, $$$k = 2$$$ or $$$s = 4$$$, $$$k = 2$$$.",
    "prob_desc_description": "Tonya was given an array of $$$a$$$ of length $$$n$$$ written on a postcard for his birthday. For some reason, the postcard turned out to be a cyclic array, so the index of the element located strictly to the right of the $$$n$$$-th is $$$1$$$. Tonya wanted to study it better, so he bought a robot \"Burenka-179\".A program for Burenka is a pair of numbers $$$(s, k)$$$, where $$$1 \\leq s \\leq n$$$, $$$1 \\leq k \\leq n-1$$$. Note that $$$k$$$ cannot be equal to $$$n$$$. Initially, Tonya puts the robot in the position of the array $$$s$$$. After that, Burenka makes exactly $$$n$$$ steps through the array. If at the beginning of a step Burenka stands in the position $$$i$$$, then the following happens:   The number $$$a_{i}$$$ is added to the usefulness of the program.  \"Burenka\" moves $$$k$$$ positions to the right ($$$i := i + k$$$ is executed, if $$$i$$$ becomes greater than $$$n$$$, then $$$i := i - n$$$). Help Tonya find the maximum possible usefulness of a program for \"Burenka\" if the initial usefulness of any program is $$$0$$$.Also, Tony's friend Ilyusha asks him to change the array $$$q$$$ times. Each time he wants to assign $$$a_p := x$$$ for a given index $$$p$$$ and a value $$$x$$$. You need to find the maximum possible usefulness of the program after each of these changes.",
    "prob_desc_output_spec": "For each test case, output $$$q+1$$$ numbers — the maximum usefulness of a program initially and after each of the changes.",
    "prob_desc_input_spec": "The first line contains a single integer $$$t$$$ ($$$1 \\le t \\le 10^4$$$) is the number of test cases. The description of the test cases follows. The first line of each test case contains two integers $$$n$$$ and $$$q$$$ ($$$2 \\le n \\le 2 \\cdot 10^5$$$, $$$0 \\le q \\le 2 \\cdot 10^5$$$). The second line of each test case contains $$$n$$$ integers $$$a_1, a_2, \\ldots, a_n$$$ ($$$1 \\le a_i \\le 10^9$$$) — elements of the array. The following $$$q$$$ lines contain changes, each of them contains two integers $$$p$$$ and $$$x$$$ ($$$1 \\leq p \\leq n$$$, $$$1 \\leq x \\leq 10^9$$$), meaning you should assign $$$a_p := x$$$. It is guaranteed that the sum of $$$n$$$ and the sum of $$$q$$$ over all test cases do not exceed $$$2 \\cdot 10^5$$$.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3-64",
    "lang_cluster": "Python",
    "difficulty": 2400,
    "file_name": "train_087.jsonl",
    "code_uid": "cb2c1c6aaea9b558ff8c0782fbb9e07c",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"4\\n\\n2 1\\n\\n1 2\\n\\n1 3\\n\\n4 4\\n\\n4 1 3 2\\n\\n2 6\\n\\n4 6\\n\\n1 1\\n\\n3 11\\n\\n9 3\\n\\n1 7 9 4 5 2 3 6 8\\n\\n3 1\\n\\n2 1\\n\\n9 1\\n\\n6 3\\n\\n1 1 1 1 1 1\\n\\n1 5\\n\\n4 4\\n\\n3 8\"]",
    "exec_outcome": "PASSED",
    "source_code": "import heapq\r\nclass segtree():\r\n  def __init__(self,init,func,ide):\r\n    self.n=len(init)\r\n    self.func=func\r\n    self.ide=ide\r\n    self.size=1<<(self.n-1).bit_length()\r\n    self.tree=[self.ide for i in range(2*self.size)]\r\n    for i in range(self.n):\r\n      self.tree[self.size+i]=init[i]\r\n    for i in range(self.size-1,0,-1):\r\n      self.tree[i]=self.func(self.tree[2*i], self.tree[2*i|1])\r\n  \r\n  def update(self,k,x):\r\n    k+=self.size\r\n    self.tree[k]=x\r\n    k>>=1\r\n    while k:\r\n      self.tree[k]=self.func(self.tree[2*k],self.tree[k*2|1])\r\n      k>>=1\r\n  \r\n  def get(self,i):\r\n    return self.tree[i+self.size]\r\n  \r\n  def query(self,l,r):\r\n    l+=self.size\r\n    r+=self.size\r\n    l_res=self.ide\r\n    r_res=self.ide\r\n    while l<r:\r\n      if l&1:\r\n        l_res=self.func(l_res,self.tree[l])\r\n        l+=1\r\n      if r&1:\r\n        r-=1\r\n        r_res=self.func(self.tree[r],r_res)\r\n      l>>=1\r\n      r>>=1\r\n    return self.func(l_res,r_res)\r\n  \r\n  def debug(self,s=10):\r\n    print([self.get(i) for i in range(min(self.n,s))])\r\n\r\n\r\nfrom sys import stdin\r\ninput=lambda :stdin.readline()[:-1]\r\n\r\ndef fact(n):\r\n  f=[]\r\n  tmp=n\r\n  for i in range(2,10**3):\r\n    if tmp%i==0:\r\n      f.append(i)\r\n    \r\n    while tmp%i==0:\r\n      tmp//=i\r\n  \r\n  if tmp>1:\r\n    f.append(tmp)\r\n  return f\r\n\r\n      \r\nans=[]\r\nfor _ in range(int(input())):\r\n  n,q=map(int,input().split())\r\n  a=list(map(int,input().split()))\r\n  f=fact(n)\r\n  M=len(f)\r\n  seg_arr=[]\r\n  res=[0]*M\r\n  for i in range(M):\r\n    p=f[i]\r\n    d=n//p\r\n    x=[0]*(n//p)\r\n    for j in range(n):\r\n      x[j%d]+=a[j]*d\r\n    seg=segtree(x,max,0)\r\n    res[i]=seg.tree[1]\r\n    seg_arr.append(seg)\r\n  ans.append(max(res))\r\n  \r\n  for _ in range(q):\r\n    x,y=map(int,input().split())\r\n    x-=1\r\n    diff=y-a[x]\r\n    a[x]=y\r\n    for i in range(M):\r\n      d=n//f[i]\r\n      seg_arr[i].update(x%d,seg_arr[i].get(x%d)+diff*d)\r\n      res[i]=seg_arr[i].tree[1]\r\n    ans.append(max(res))  \r\n\r\nprint('\\n'.join(map(str,ans)))",
    "prob_desc_created_at": "1660660500",
    "tags": [
        "data structures",
        "greedy",
        "math",
        "number theory"
    ],
    "hidden_unit_tests": ""
}
{
    "prob_desc_time_limit": "4 seconds",
    "prob_desc_sample_outputs": "[\"1 1\\n1 1\\n1 1\\n2 3\\n2 3\\n2 4\"]",
    "src_uid": "a16febf3b002638f78ba5a32f4b4c4d8",
    "prob_desc_notes": "NoteIn the first test case, $$$f(1, 1) = 0 - 0 = 0$$$.In the second test case, $$$f(1, 1) = 5 - 5 = 0$$$, $$$f(2, 2) = 10 - 10 = 0$$$. Note that $$$f(1, 2) = (10 + 5) - (10 \\oplus 5) = 0$$$, but we need to find a subsegment with the minimum length among the maximum values of $$$f(l, r)$$$. So, only segments $$$[1, 1]$$$ and $$$[2, 2]$$$ are the correct answers.In the fourth test case, $$$f(2, 3) = (12 + 8) - (12 \\oplus 8) = 16$$$. There are two correct answers in the fifth test case, since $$$f(2, 3) = f(3, 4)$$$ and their lengths are equal.",
    "prob_desc_description": "This is the easy version of the problem. The only difference is that in this version $$$q = 1$$$.You are given an array of integers $$$a_1, a_2, \\ldots, a_n$$$.The cost of a subsegment of the array $$$[l, r]$$$, $$$1 \\leq l \\leq r \\leq n$$$, is the value $$$f(l, r) = \\operatorname{sum}(l, r) - \\operatorname{xor}(l, r)$$$, where $$$\\operatorname{sum}(l, r) = a_l + a_{l+1} + \\ldots + a_r$$$, and $$$\\operatorname{xor}(l, r) = a_l \\oplus a_{l+1} \\oplus \\ldots \\oplus a_r$$$ ($$$\\oplus$$$ stands for bitwise XOR).You will have $$$q = 1$$$ query. Each query is given by a pair of numbers $$$L_i$$$, $$$R_i$$$, where $$$1 \\leq L_i \\leq R_i \\leq n$$$. You need to find the subsegment $$$[l, r]$$$, $$$L_i \\leq l \\leq r \\leq R_i$$$, with maximum value $$$f(l, r)$$$. If there are several answers, then among them you need to find a subsegment with the minimum length, that is, the minimum value of $$$r - l + 1$$$.",
    "prob_desc_output_spec": "For each test case print $$$q$$$ pairs of numbers $$$L_i \\leq l \\leq r \\leq R_i$$$ such that the value $$$f(l, r)$$$ is maximum and among such the length $$$r - l + 1$$$ is minimum. If there are several correct answers, print any of them.",
    "prob_desc_input_spec": "Each test consists of multiple test cases. The first line contains an integer $$$t$$$ ($$$1 \\leq t \\leq 10^4$$$) — the number of test cases. The description of test cases follows. The first line of each test case contains two integers $$$n$$$ and $$$q$$$ ($$$1 \\leq n \\leq 10^5$$$, $$$q = 1$$$) — the length of the array and the number of queries. The second line of each test case contains $$$n$$$ integers $$$a_1, a_2, \\ldots, a_n$$$ ($$$0 \\leq a_i \\leq 10^9$$$) — array elements. $$$i$$$-th of the next $$$q$$$ lines of each test case contains two integers $$$L_i$$$ and $$$R_i$$$ ($$$1 \\leq L_i \\leq R_i \\leq n$$$) — the boundaries in which we need to find the segment. It is guaranteed that the sum of $$$n$$$ over all test cases does not exceed $$$2 \\cdot 10^5$$$. It is guaranteed that $$$L_1 = 1$$$ and $$$R_1 = n$$$.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3-64",
    "lang_cluster": "Python",
    "difficulty": 1800,
    "file_name": "train_097.jsonl",
    "code_uid": "98a7c95624a993edeea231356157b634",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"6\\n\\n1 1\\n\\n0\\n\\n1 1\\n\\n2 1\\n\\n5 10\\n\\n1 2\\n\\n3 1\\n\\n0 2 4\\n\\n1 3\\n\\n4 1\\n\\n0 12 8 3\\n\\n1 4\\n\\n5 1\\n\\n21 32 32 32 10\\n\\n1 5\\n\\n7 1\\n\\n0 1 0 1 0 1 0\\n\\n1 7\"]",
    "exec_outcome": "PASSED",
    "source_code": "#from math import ceil, floor #, gcd, log, factorial, comb, perm,\r\n#log10, log2, log, sin, asin, tan, atan, radians\r\n#from heapq import heappop,heappush,heapify #heappop(hq), heapify(list)\r\n#from collections import defaultdict as dd\r\n#mydd=dd(list) for .append\r\n#from collections import deque as dq #deque  e.g. myqueue=dq(list)\r\n#append/appendleft/appendright/pop/popleft\r\n#from bisect import bisect as bis #a=[1,3,4,6,7,8] #bis(a,5)-->3\r\n#import bisect #bisect.bisect_left(a,4)-->2 #bisect.bisect(a,4)-->3\r\n#import statistics as stat  # stat.median(a), mode, mean\r\n#from itertools import permutations(p,r)#combinations(p,r)\r\n#combinations_with_replacement#combinations(p,r) gives r-length tuples,\r\n#in sorted order, with repeated elements#product gives outer product combos\r\nimport sys\r\ninput = sys.stdin.readline\r\n#print = sys.stdout.write\r\n#sys.setrecursionlimit(100000) #default is 1000 \r\n############ ---- Input Functions ---- ############\r\ndef inp():\r\n    return(int(input()))\r\ndef inlt():\r\n    return(list(map(int,input().split())))   #.split(','), default is space\r\n#list([0,*map(int,input().split(\" \"))]) # pad a zero to avoid zero indexing\r\ndef insr():\r\n    s = input()\r\n    return(list(s[:len(s) - 1]))\r\n####################################################\r\n#t=1\r\nt = int(input())\r\nfor tc in range(t):\r\n    n,q=map(int, input().split())\r\n    a=inlt()\r\n    psa=[0]\r\n    pxa=[0]\r\n    for i in a:\r\n        psa.append(psa[-1]+i)\r\n        pxa.append(pxa[-1]^i)\r\n    for qc in range(q):\r\n        L,R=map(int, input().split())\r\n        val=psa[R]-psa[L-1]-pxa[R]^pxa[L-1]\r\n        if val==0:print(L,L);continue\r\n        ans=[L,R]\r\n        i=L\r\n        for j in range(L+1,R+1):\r\n            tmp=psa[j]-psa[i-1]-(pxa[j]^pxa[i-1])\r\n            while tmp==val:\r\n                if j-i<ans[1]-ans[0]:ans=[i,j]\r\n                i+=1\r\n                tmp=psa[j]-psa[i-1]-(pxa[j]^pxa[i-1])\r\n            if ans[1]-ans[0]==1:break\r\n        print(*ans)\r\n    \r\n#print(*ans,sep=' ')##print(\"{:.3f}\".format(ans)+\"%\")\r\n#:b binary :% eg print(\"{:6.2%}\".format(ans))\r\n#print(\" \".join(str(i) for i in ans))\r\n#print(\" \".join(map(str,ans))) #seems faster\r\n#print(a[0] if a else 0)\r\n#prefixsum a=[a1...an] #psa=[0]*(n+1)\r\n#for i in range(n): psa[i+1]=psa[i]+a[i]\r\n#sum[:ax]=psa[x+1] e.g. sum 1st 5 items in psa[5]\r\n#ASCII<->number ord('f')=102 chr(102)='f'\r\n#def binary_search(li, val, lb, ub):\r\n#    while ((ub-lb)>1):\r\n#        mid = (lb + ub) // 2\r\n#        if li[mid] >= val:\r\n#            ub = mid\r\n#        else:\r\n#            lb = mid\r\n#    return lb+1 #return index of elements <val in li\r\n#def binary_search(li, val, lb, ub):\r\n#    ans = -1\r\n#    while (lb <= ub):\r\n#        mid = (lb + ub) // 2\r\n#        if li[mid] > val:\r\n#            ub = mid - 1\r\n#        elif val > li[mid]:\r\n#            lb = mid + 1\r\n#        else:\r\n#            ans = mid  # return index\r\n#            break\r\n#    return ans\r\n##########\r\n#def pref(li):\r\n#    pref_sum = [0]\r\n#    for i in li:\r\n#        pref_sum.append(pref_sum[-1] + i)\r\n#    return pref_sum\r\n##########\r\n#def suff(li):\r\n#    suff_sum = [0]\r\n#    for i in range(len(li)-1,-1,-1):\r\n#        suff_sum.insert(0,suff_sum[0] + li[i])\r\n#    return suff_sum\r\n#############\r\n#def maxSubArraySumI(arr): #Kadane's algorithm with index\r\n#    max_till_now=arr[0];max_ending=0;size=len(arr)\r\n#    start=0;end=0;s=0\r\n#    for i in range(0, size):\r\n#        max_ending = max_ending + arr[i]\r\n#        if max_till_now < max_ending:\r\n#            max_till_now=max_ending\r\n#            start=s;end=i\r\n#        if max_ending<0:\r\n#            max_ending=0\r\n#            s=i+1\r\n#    return max_till_now,start,end\r\n############# avoid max for 2 elements - slower than direct if\r\n#def maxSubArraySum(arr): #Kadane's algorithm\r\n#    max_till_now=arr[0];max_ending=0;size=len(arr)\r\n#    for i in range(0, size):\r\n#        max_ending = max_ending + arr[i]\r\n#        if max_till_now < max_ending:max_till_now=max_ending\r\n#        if max_ending<0:max_ending=0\r\n#    return max_till_now\r\n#############\r\n#def findbits(x):\r\n#    tmp=[]\r\n#    while x>0:tmp.append(x%2);x//=2\r\n#    tmp.reverse()\r\n#    return tmp\r\n##############Dijkstra algorithm example\r\n#dg=[999999]*(n+1);dg[n]=0;todo=[(0,n)];chkd=[0]*(n+1)\r\n#while todo:#### find x with min dg in todo\r\n#    _,x=hq.heappop(todo)\r\n#    if chkd[x]:continue\r\n#    for i in coming[x]:going[i]-=1\r\n#    for i in coming[x]:\r\n#        tmp=1+dg[x]+going[i]\r\n#        if tmp<dg[i]:dg[i]=tmp;hq.heappush(todo,(dg[i],i))   \r\n#    chkd[x]=1\r\n################ \r\n# adj swaps to match 2 binary strings: sum_{i=1}^n(abs(diff in i-th prefix sums))\r\n###############\r\n##s=[2, 3, 1, 4, 5, 3]\r\n##sorted(range(len(s)), key=lambda k: s[k])\r\n##gives sorted indices [2, 0, 1, 5, 3, 4]\r\n##m= [[3, 4, 6], [2, 4, 8], [2, 3, 4], [1, 2, 3], [7, 6, 7], [1, 8, 2]]\r\n##m.sort(reverse=True,key=lambda k:k[2]) #sorts m according to 3rd elements\r\n#import bisect  #li = [1, 3, 4, 4, 4, 6, 7]#sorted li, use b search, so log(n)\r\n#bisect.bisect(li,4)-->5 #bisect.bisect_left(li,4)-->2\r\n###############\r\n##def chkprime(x):\r\n##    if x==2 or x==3:return True\r\n##    if x%2==0 or x<2:return False\r\n##    for i in range(3,int(x**0.5)+1,2):\r\n##        if x%i==0:return False\r\n##    return True\r\n############### prime factoring functions\r\n##def pfactors(n):\r\n##    f=[];d=3\r\n##    while n%2==0:f.append(2);n//=2\r\n##    while d*d<=n:\r\n##        while n%d==0:f.append(d);n//=d\r\n##        d+=2\r\n##    if n>1:f.append(n)\r\n##    return f\r\n############################## check equivalence under rotation\r\n##def cyclic_equiv(u,v):\r\n##    n,i,j=len(u),0,0\r\n##    if n!=len(v):return False\r\n##    while i<n and j<n:\r\n##        k=1\r\n##        while k<=n and u[(i+k)%n]==v[(j+k)%n]:k+=1\r\n##        if k>n:return True\r\n##        if u[(i+k)%n]>v[(j+k)%n]:\r\n##            i+=k\r\n##        else:\r\n##            j+=k\r\n##    return False\r\n",
    "prob_desc_created_at": "1666519500",
    "tags": [
        "binary search",
        "bitmasks",
        "greedy",
        "two pointers"
    ],
    "hidden_unit_tests": ""
}
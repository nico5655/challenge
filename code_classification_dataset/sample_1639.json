{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"2\", \"2\"]",
    "src_uid": "676729309dfbdf4c9d9d7c457a129608",
    "prob_desc_notes": "NoteIn the first example it's optimal to make $$$2$$$ slices. The first slice is on height $$$2$$$ (its cost is $$$3$$$), and the second one is on height $$$1$$$ (its cost is $$$4$$$).",
    "prob_desc_description": "There is a toy building consisting of $$$n$$$ towers. Each tower consists of several cubes standing on each other. The $$$i$$$-th tower consists of $$$h_i$$$ cubes, so it has height $$$h_i$$$.Let's define operation slice on some height $$$H$$$ as following: for each tower $$$i$$$, if its height is greater than $$$H$$$, then remove some top cubes to make tower's height equal to $$$H$$$. Cost of one \"slice\" equals to the total number of removed cubes from all towers.Let's name slice as good one if its cost is lower or equal to $$$k$$$ ($$$k \\ge n$$$).  Calculate the minimum number of good slices you have to do to make all towers have the same height. Of course, it is always possible to make it so.",
    "prob_desc_output_spec": "Print one integer — the minimum number of good slices you have to do to make all towers have the same heigth.",
    "prob_desc_input_spec": "The first line contains two integers $$$n$$$ and $$$k$$$ ($$$1 \\le n \\le 2 \\cdot 10^5$$$, $$$n \\le k \\le 10^9$$$) — the number of towers and the restriction on slices, respectively. The second line contains $$$n$$$ space separated integers $$$h_1, h_2, \\dots, h_n$$$ ($$$1 \\le h_i \\le 2 \\cdot 10^5$$$) — the initial heights of towers.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "Python 3",
    "lang_cluster": "Python",
    "difficulty": 1600,
    "file_name": "train_011.jsonl",
    "code_uid": "35d10e94c78a181387ebd1100f95498c",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"5 5\\n3 1 2 2 4\", \"4 5\\n2 3 4 5\"]",
    "exec_outcome": "PASSED",
    "source_code": "from __future__ import division, print_function\n# import threading\n# threading.stack_size(2**27)\n# import sys\n# sys.setrecursionlimit(10**6)\nfrom sys import stdin, stdout\nimport bisect            #c++ upperbound\nimport math\nimport heapq\ndef modinv(n,p):\n    return pow(n,p-2,p)\ndef cin():\n    return map(int,sin().split())\ndef ain():                           #takes array as input\n    return list(map(int,sin().split()))\ndef sin():\n    return input()\ndef inin():\n    return int(input())\nimport math  \ndef Divisors(n) : \n    l = []  \n    for i in range(1, int(math.sqrt(n) + 1)) :\n        if (n % i == 0) : \n            if (n // i == i) : \n                l.append(i) \n            else : \n                l.append(i)\n                l.append(n//i)\n    return l\nq=[]\ndef dfs(n,d,v,c):\n    global q\n    v[n]=1\n    x=d[n]\n    q.append(n)\n    j=c\n    for i in x:\n        if i not in v:\n            f=dfs(i,d,v,c+1)\n            j=max(j,f)\n            # print(f)\n    return j\n\n\"\"\"*******************************************************\"\"\"\ndef main():\n    n,k=cin()\n    a=ain()\n    a.sort()\n    q=min(a)\n    an=ans=0\n    p=max(a)\n    for i in range(p,-1,-1):\n        x=bisect.bisect_right(a,i)\n        ans+=n-x\n        if(ans>k):\n            an+=1\n            ans=n-x\n        # print(ans,i)\n        if(i==q):\n            break\n    if(ans!=0):\n        an+=1\n    print(an)\n\n    \n\n######## Python 2 and 3 footer by Pajenegod and c1729\n \n# Note because cf runs old PyPy3 version which doesn't have the sped up\n# unicode strings, PyPy3 strings will many times be slower than pypy2.\n# There is a way to get around this by using binary strings in PyPy3\n# but its syntax is different which makes it kind of a mess to use.\n \n# So on cf, use PyPy2 for best string performance.\n \npy2 = round(0.5)\nif py2:\n    from future_builtins import ascii, filter, hex, map, oct, zip\n    range = xrange\n \nimport os, sys\nfrom io import IOBase, BytesIO\n \nBUFSIZE = 8192\nclass FastIO(BytesIO):\n    newlines = 0\n \n    def __init__(self, file):\n        self._file = file\n        self._fd = file.fileno()\n        self.writable = \"x\" in file.mode or \"w\" in file.mode\n        self.write = super(FastIO, self).write if self.writable else None\n \n    def _fill(self):\n        s = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n        self.seek((self.tell(), self.seek(0,2), super(FastIO, self).write(s))[0])\n        return s\n \n    def read(self):\n        while self._fill(): pass\n        return super(FastIO,self).read()\n \n    def readline(self):\n        while self.newlines == 0:\n            s = self._fill(); self.newlines = s.count(b\"\\n\") + (not s)\n        self.newlines -= 1\n        return super(FastIO, self).readline()\n \n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.getvalue())\n            self.truncate(0), self.seek(0)\n \nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        if py2:\n            self.write = self.buffer.write\n            self.read = self.buffer.read\n            self.readline = self.buffer.readline\n        else:\n            self.write = lambda s:self.buffer.write(s.encode('ascii'))\n            self.read = lambda:self.buffer.read().decode('ascii')\n            self.readline = lambda:self.buffer.readline().decode('ascii')\n \n \nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip('\\r\\n')\n \n# Cout implemented in Python\nimport sys\nclass ostream:\n    def __lshift__(self,a):\n        sys.stdout.write(str(a))\n        return self\ncout = ostream()\nendl = '\\n'\n \n# Read all remaining integers in stdin, type is given by optional argument, this is fast\ndef readnumbers(zero = 0):\n    conv = ord if py2 else lambda x:x\n    A = []; numb = zero; sign = 1; i = 0; s = sys.stdin.buffer.read()\n    try:\n        while True:\n            if s[i] >= b'0' [0]:\n                numb = 10 * numb + conv(s[i]) - 48\n            elif s[i] == b'-' [0]: sign = -1\n            elif s[i] != b'\\r' [0]:\n                A.append(sign*numb)\n                numb = zero; sign = 1\n            i += 1\n    except:pass\n    if s and s[-1] >= b'0' [0]:\n        A.append(sign*numb)\n    return A\n\n# threading.Thread(target=main).start()\nif __name__== \"__main__\":\n  main()",
    "prob_desc_created_at": "1539269400",
    "tags": [
        "greedy"
    ],
    "hidden_unit_tests": ""
}
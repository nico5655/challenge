{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"17\", \"4\"]",
    "src_uid": "a9473e6ec81c10c4f88973ac2d60ad04",
    "prob_desc_notes": "NoteFor the first test case, here's how a circular value of $$$17$$$ is obtained:Pick the number at index $$$3$$$. The sum of adjacent elements equals $$$17$$$. Delete $$$7$$$ and $$$10$$$ from the circle and replace $$$2$$$ with $$$17$$$.Note that the answer may not fit in a $$$32$$$-bit integer.",
    "prob_desc_description": "Danny, the local Math Maniac, is fascinated by circles, Omkar's most recent creation. Help him solve this circle problem!You are given $$$n$$$ nonnegative integers $$$a_1, a_2, \\dots, a_n$$$ arranged in a circle, where $$$n$$$ must be odd (ie. $$$n-1$$$ is divisible by $$$2$$$). Formally, for all $$$i$$$ such that $$$2 \\leq i \\leq n$$$, the elements $$$a_{i - 1}$$$ and $$$a_i$$$ are considered to be adjacent, and $$$a_n$$$ and $$$a_1$$$ are also considered to be adjacent. In one operation, you pick a number on the circle, replace it with the sum of the two elements adjacent to it, and then delete the two adjacent elements from the circle. This is repeated until only one number remains in the circle, which we call the circular value.Help Danny find the maximum possible circular value after some sequences of operations. ",
    "prob_desc_output_spec": "Output the maximum possible circular value after applying some sequence of operations to the given circle.",
    "prob_desc_input_spec": "The first line contains one odd integer $$$n$$$ ($$$1 \\leq n &lt; 2 \\cdot 10^5$$$, $$$n$$$ is odd)  — the initial size of the circle. The second line contains $$$n$$$ integers $$$a_{1},a_{2},\\dots,a_{n}$$$ ($$$0 \\leq a_{i} \\leq 10^9$$$)  — the initial numbers in the circle.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3",
    "lang_cluster": "Python",
    "difficulty": 2100,
    "file_name": "train_001.jsonl",
    "code_uid": "5730229839b896fb668424c586bd0a78",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"3\\n7 10 2\", \"1\\n4\"]",
    "exec_outcome": "PASSED",
    "source_code": "## necessary imports\nimport sys\ninput = sys.stdin.readline\n# from math import ceil, floor, factorial;\n\ndef ceil(x):\n    if x != int(x):\n        x = int(x) + 1;\n    return x;\n    \n# swap_array function\ndef swaparr(arr, a,b):\n    temp = arr[a];\n    arr[a] = arr[b];\n    arr[b] = temp;\n\n## gcd function\ndef gcd(a,b):\n    if b == 0:\n        return a;\n    return gcd(b, a % b);\n\n## nCr function efficient using Binomial Cofficient\ndef nCr(n, k): \n    if(k > n - k): \n        k = n - k; \n    res = 1;\n    for i in range(k): \n        res = res * (n - i);\n        res = res / (i + 1); \n    return int(res);\n\n## upper bound function code -- such that e in a[:i] e < x;\ndef upper_bound(a, x, lo=0, hi = None):\n    if hi == None:\n        hi = len(a);\n    while lo < hi:\n        mid = (lo+hi)//2;\n        if a[mid] < x:\n            lo = mid+1;\n        else:\n            hi = mid;\n    return lo;\n\n## prime factorization\ndef primefs(n):\n    ## if n == 1    ## calculating primes\n    primes = {}\n    while(n%2 == 0 and n > 0):\n        primes[2] = primes.get(2, 0) + 1\n        n = n//2\n    for i in range(3, int(n**0.5)+2, 2):\n        while(n%i == 0 and n > 0):\n            primes[i] = primes.get(i, 0) + 1\n            n = n//i\n    if n > 2:\n        primes[n] = primes.get(n, 0) + 1\n    ## prime factoriazation of n is stored in dictionary\n    ## primes and can be accesed. O(sqrt n)\n    return primes\n\n## MODULAR EXPONENTIATION FUNCTION\ndef power(x, y, p): \n    res = 1\n    x = x % p  \n    if (x == 0) : \n        return 0\n    while (y > 0) : \n        if ((y & 1) == 1) : \n            res = (res * x) % p \n        y = y >> 1      \n        x = (x * x) % p \n    return res \n\n## DISJOINT SET UNINON FUNCTIONS\ndef swap(a,b):\n    temp = a\n    a = b\n    b = temp\n    return a,b;\n\n# find function with path compression included (recursive)\n# def find(x, link):\n#     if link[x] == x:\n#         return x\n#     link[x] = find(link[x], link);\n#     return link[x];\n\n# find function with path compression (ITERATIVE)\ndef find(x, link):\n    p = x;\n    while( p != link[p]):\n        p = link[p];\n    \n    while( x != p):\n        nex = link[x];\n        link[x] = p;\n        x = nex;\n    return p;\n\n\n# the union function which makes union(x,y)\n# of two nodes x and y\ndef union(x, y, link, size):\n    x = find(x, link)\n    y = find(y, link)\n    if size[x] < size[y]:\n        x,y = swap(x,y)\n    if x != y:\n        size[x] += size[y]\n        link[y] = x\n\n## returns an array of boolean if primes or not USING SIEVE OF ERATOSTHANES\ndef sieve(n): \n    prime = [True for i in range(n+1)] \n    p = 2\n    while (p * p <= n): \n        if (prime[p] == True): \n            for i in range(p * p, n+1, p):\n                prime[i] = False\n        p += 1\n    return prime\n\n#### PRIME FACTORIZATION IN O(log n) using Sieve ####\nMAXN = int(1e5 + 5)\ndef spf_sieve():\n    spf[1] = 1;\n    for i in range(2, MAXN):\n        spf[i] = i;\n    for i in range(4, MAXN, 2):\n        spf[i] = 2;\n    for i in range(3, ceil(MAXN ** 0.5), 2):\n        if spf[i] == i:\n            for j in range(i*i, MAXN, i):\n                if spf[j] == j:\n                    spf[j] = i;\n    ## function for storing smallest prime factors (spf) in the array\n\n################## un-comment below 2 lines when using factorization #################\n# spf = [0 for i in range(MAXN)]\n# spf_sieve();\ndef factoriazation(x):\n    ret = {};\n    while x != 1:\n        ret[spf[x]] = ret.get(spf[x], 0) + 1;\n        x = x//spf[x]\n    return ret;\n    ## this function is useful for multiple queries only, o/w use\n    ## primefs function above. complexity O(log n)\n\n## taking integer array input\ndef int_array():\n    return list(map(int, input().strip().split()));\n\ndef float_array():\n    return list(map(float, input().strip().split()));\n\n## taking string array input\ndef str_array():\n    return input().strip().split();\n\n#defining a couple constants\nMOD = int(1e9)+7;\nCMOD = 998244353;\nINF = float('inf'); NINF = -float('inf');\n\n################### ---------------- TEMPLATE ENDS HERE ---------------- ###################\n\n\nn = int(input()); a = int_array();\nodd_ = []; even_ = [];\na += a; odd = even = 0;\nfor i in range(2 * n):\n    if i & 1:\n        odd += a[i];\n        odd_.append(odd);\n    else:\n        even += a[i];\n        even_.append(even);\nx = (n + 1) // 2; ans = 0;\n\nfor i in range(x - 1, len(even_)):\n    if i == x - 1:\n        ans = max(ans, even_[i]);\n    else:\n        ans = max(ans, even_[i] - even_[i - x]);\n\nfor i in range(x - 1, len(odd_)):\n    if i == x - 1:\n        ans = max(ans, odd_[i]);\n    else:\n        ans = max(ans, odd_[i] - odd_[i - x]);\n\nprint(ans);",
    "prob_desc_created_at": "1594479900",
    "tags": [
        "dp",
        "greedy",
        "games",
        "brute force"
    ],
    "hidden_unit_tests": ""
}
{
    "prob_desc_time_limit": "4 seconds",
    "prob_desc_sample_outputs": "[\"2\\n5\\n3\", \"7\\n7\\n8\"]",
    "src_uid": "1947e642d8aa0e669e65c22b3261c930",
    "prob_desc_notes": "NoteThe first sample test is explained below. Blue, red and green represent colors $$$1$$$, $$$2$$$ and $$$3$$$ respectively.  ",
    "prob_desc_description": "You have an array $$$a_1,a_2, \\dots, a_n$$$. Each element initially has value $$$0$$$ and color $$$1$$$. You are also given $$$q$$$ queries to perform:   Color $$$l$$$ $$$r$$$ $$$c$$$: Change the color of elements $$$a_l,a_{l+1},\\cdots,a_r$$$ to $$$c$$$ ($$$1 \\le l \\le r \\le n$$$, $$$1 \\le c \\le n$$$).  Add $$$c$$$ $$$x$$$: Add $$$x$$$ to values of all elements $$$a_i$$$ ($$$1 \\le i \\le n$$$) of color $$$c$$$ ($$$1 \\le c \\le n$$$, $$$-10^9 \\le x \\le 10^9$$$).  Query $$$i$$$: Print $$$a_i$$$ ($$$1 \\le i \\le n$$$). ",
    "prob_desc_output_spec": "Print the answers to the queries of the third type on separate lines.",
    "prob_desc_input_spec": "The first line of input contains two integers $$$n$$$ and $$$q$$$ ($$$1 \\le n,q \\le 10^6$$$) — the length of array $$$a$$$ and the number of queries you have to perform. Each of the next $$$q$$$ lines contains the query given in the form described in the problem statement.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3-64",
    "lang_cluster": "Python",
    "difficulty": 2400,
    "file_name": "train_107.jsonl",
    "code_uid": "deb080ccb906d2d0e132c25f625eea57",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"5 8\\nColor 2 4 2\\nAdd 2 2\\nQuery 3\\nColor 4 5 3\\nColor 2 2 3\\nAdd 3 3\\nQuery 2\\nQuery 5\", \"2 7\\nAdd 1 7\\nQuery 1\\nAdd 2 4\\nQuery 2\\nColor 1 1 1\\nAdd 1 1\\nQuery 2\"]",
    "exec_outcome": "PASSED",
    "source_code": "''' E. Colorful Operations\nhttps://codeforces.com/contest/1638/problem/E\n'''\n\nimport io, os, sys\ninput = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline  # decode().strip() if str\noutput = sys.stdout.write\n\nDEBUG = os.environ.get('debug') not in [None, '0']\n\nif DEBUG:\n    from inspect import currentframe, getframeinfo\n    from re import search\n\ndef debug(*args):\n    if not DEBUG: return\n    frame = currentframe().f_back\n    s = getframeinfo(frame).code_context[0]\n    r = search(r\"\\((.*)\\)\", s).group(1)\n    vnames = r.split(', ')\n    var_and_vals = [f'{var}={val}' for var, val in zip(vnames, args)]\n    prefix = f'{currentframe().f_back.f_lineno:02d}: '\n    print(f'{prefix}{\", \".join(var_and_vals)}')\n\n\nINF = float('inf')\n\n# -----------------------------------------\n\nclass SortedList:\n    def __init__(self, iterable=[], _load=200):\n        '''Initialize sorted list instance.'''\n        values = sorted(iterable)\n        self._len = _len = len(values)\n        self._load = _load\n        self._lists = _lists = [values[i:i + _load] for i in range(0, _len, _load)]\n        self._list_lens = [len(_list) for _list in _lists]\n        self._mins = [_list[0] for _list in _lists]\n        self._fen_tree = []\n        self._rebuild = True\n\n    def add(self, value):\n        '''Add `value` to sorted list.'''\n        _load = self._load\n        _lists = self._lists\n        _mins = self._mins\n        _list_lens = self._list_lens\n\n        self._len += 1\n        if _lists:\n            pos, idx = self._loc_right(value)\n            self._fen_update(pos, 1)\n            _list = _lists[pos]\n            _list.insert(idx, value)\n            _list_lens[pos] += 1\n            _mins[pos] = _list[0]\n            if _load + _load < len(_list):\n                _lists.insert(pos + 1, _list[_load:])\n                _list_lens.insert(pos + 1, len(_list) - _load)\n                _mins.insert(pos + 1, _list[_load])\n                _list_lens[pos] = _load\n                del _list[_load:]\n                self._rebuild = True\n        else:\n            _lists.append([value])\n            _mins.append(value)\n            _list_lens.append(1)\n            self._rebuild = True\n\n    def discard(self, value):\n        '''Remove `value` from sorted list if it is a member.'''\n        _lists = self._lists\n        if _lists:\n            pos, idx = self._loc_right(value)\n            if idx and _lists[pos][idx - 1] == value:\n                self._delete(pos, idx - 1)\n\n    def remove(self, value):\n        '''Remove `value` from sorted list; `value` must be a member.'''\n        _len = self._len\n        self.discard(value)\n        if _len == self._len:\n            raise ValueError('{0!r} not in list'.format(value))\n\n    def pop(self, index=-1):\n        '''Remove and return value at `index` in sorted list.'''\n        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)\n        value = self._lists[pos][idx]\n        self._delete(pos, idx)\n        return value\n\n    def bisect_left(self, value):\n        '''Return the first index to insert `value` in the sorted list.'''\n        pos, idx = self._loc_left(value)\n        return self._fen_query(pos) + idx\n\n    def bisect_right(self, value):\n        '''Return the last index to insert `value` in the sorted list.'''\n        pos, idx = self._loc_right(value)\n        return self._fen_query(pos) + idx\n\n    def count(self, value):\n        '''Return number of occurrences of `value` in the sorted list.'''\n        return self.bisect_right(value) - self.bisect_left(value)\n\n    def _fen_build(self):\n        '''Build a fenwick tree instance.'''\n        self._fen_tree[:] = self._list_lens\n        _fen_tree = self._fen_tree\n        for i in range(len(_fen_tree)):\n            if i | i + 1 < len(_fen_tree):\n                _fen_tree[i | i + 1] += _fen_tree[i]\n        self._rebuild = False\n\n    def _fen_update(self, index, value):\n        '''Update `fen_tree[index] += value`.'''\n        if not self._rebuild:\n            _fen_tree = self._fen_tree\n            while index < len(_fen_tree):\n                _fen_tree[index] += value\n                index |= index + 1\n\n    def _fen_query(self, end):\n        '''Return `sum(_fen_tree[:end])`.'''\n        if self._rebuild: self._fen_build()\n        _fen_tree = self._fen_tree\n        x = 0\n        while end:\n            x += _fen_tree[end - 1]\n            end &= end - 1\n        return x\n\n    def _fen_findkth(self, k):\n        '''Return a pair of (the largest `idx` such that `sum(_fen_tree[:idx]) <= k`, `k - sum(_fen_tree[:idx])`).'''\n        _list_lens = self._list_lens\n        if k < _list_lens[0]: return 0, k\n        if k >= self._len - _list_lens[-1]: return len(_list_lens) - 1, k + _list_lens[-1] - self._len\n        if self._rebuild: self._fen_build()\n\n        _fen_tree = self._fen_tree\n        idx = -1\n        for d in reversed(range(len(_fen_tree).bit_length())):\n            right_idx = idx + (1 << d)\n            if right_idx < len(_fen_tree) and k >= _fen_tree[right_idx]:\n                idx = right_idx\n                k -= _fen_tree[idx]\n        return idx + 1, k\n\n    def _delete(self, pos, idx):\n        '''Delete value at the given `(pos, idx)`.'''\n        _lists = self._lists\n        _mins = self._mins\n        _list_lens = self._list_lens\n\n        self._len -= 1\n        self._fen_update(pos, -1)\n        del _lists[pos][idx]\n        _list_lens[pos] -= 1\n\n        if _list_lens[pos]:\n            _mins[pos] = _lists[pos][0]\n        else:\n            del _lists[pos]\n            del _list_lens[pos]\n            del _mins[pos]\n            self._rebuild = True\n\n    def _loc_left(self, value):\n        '''Return an index pair that corresponds to the first position of `value` in the sorted list.'''\n        if not self._len: return 0, 0\n        _lists = self._lists\n        _mins = self._mins\n\n        lo, pos = -1, len(_lists) - 1\n        while lo + 1 < pos:\n            mi = (lo + pos) >> 1\n            if value <= _mins[mi]: pos = mi\n            else: lo = mi\n\n        if pos and value <= _lists[pos - 1][-1]: pos -= 1\n\n        _list = _lists[pos]\n        lo, idx = -1, len(_list)\n        while lo + 1 < idx:\n            mi = (lo + idx) >> 1\n            if value <= _list[mi]: idx = mi\n            else: lo = mi\n\n        return pos, idx\n\n    def _loc_right(self, value):\n        '''Return an index pair that corresponds to the last position of `value` in the sorted list.'''\n        if not self._len: return 0, 0\n        _lists = self._lists\n        _mins = self._mins\n\n        pos, hi = 0, len(_lists)\n        while pos + 1 < hi:\n            mi = (pos + hi) >> 1\n            if value < _mins[mi]: hi = mi\n            else: pos = mi\n\n        _list = _lists[pos]\n        lo, idx = -1, len(_list)\n        while lo + 1 < idx:\n            mi = (lo + idx) >> 1\n            if value < _list[mi]: idx = mi\n            else: lo = mi\n\n        return pos, idx\n\n    def __len__(self):\n        '''Return the size of the sorted list.'''\n        return self._len\n\n    def __getitem__(self, index):\n        '''Lookup value at `index` in sorted list.'''\n        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)\n        return self._lists[pos][idx]\n\n    def __delitem__(self, index):\n        '''Remove value at `index` from sorted list.'''\n        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)\n        self._delete(pos, idx)\n\n    def __contains__(self, value):\n        '''Return true if `value` is an element of the sorted list.'''\n        _lists = self._lists\n        if _lists:\n            pos, idx = self._loc_left(value)\n            return idx < len(_lists[pos]) and _lists[pos][idx] == value\n        return False\n\n    def __iter__(self):\n        '''Return an iterator over the sorted list.'''\n        return (value for _list in self._lists for value in _list)\n\n    def __reversed__(self):\n        '''Return a reverse iterator over the sorted list.'''\n        return (value for _list in reversed(self._lists) for value in reversed(_list))\n\n    def __repr__(self):\n        '''Return string representation of sorted list.'''\n        return 'SortedList({0})'.format(list(self))\n \n    def val(self, it):  # added\n        '''Return the value of the `it` in the sorted list.'''\n        pos, idx = it\n        return self._lists[pos][idx]\n \n    def erase(self, it):  # added\n        '''Remove `it` from sorted list; `it` must be a member.'''\n        pos, idx = it\n        self._delete(pos, idx)\n \n    def begin(self):  # added\n        '''Return the begin of the it in the sorted list.'''\n        return (0, 0)\n \n    def end(self):  # added\n        '''Return the end of the it in the sorted list.'''\n        return (len(self._lists)-1, len(self._lists[-1])) if self._lists else (0, 0)\n \n    def prev(self, it):  # added\n        '''Return the previous `it` in the sorted list.'''\n        pos, idx = it\n        return (pos, idx-1) if idx else (pos-1, len(self._lists[pos-1])-1)\n \n    def next(self, it):  # added\n        '''Return the next `it` in the sorted list.'''\n        pos, idx = it\n        return (pos, idx+1) if pos+1 == len(self._lists) or idx+1 != len(self._lists[pos]) else (pos+1, 0)\n\n\nclass FenwickTreeSum:\n    def __init__(self, N):\n        '''transform list into BIT'''\n        self.tree = [0] * N\n\n    def query(self, end):\n        '''calc sum(bit[:end])'''\n        x = 0\n        while end:\n            x += self.tree[end - 1]\n            end &= end - 1  # 110 -> 100\n        return x\n\n    def update(self, idx, x):\n        '''updates bit[idx] += x'''\n        while idx < len(self.tree):\n            self.tree[idx] += x\n            idx |= idx + 1   # 101 -> 110\n\n\n# maintain \n# * intervals of single color (initially 1 interval of color 1)\n# * add[c] = pending update to all intervals with color c\n\n# https://codeforces.com/contest/1638/submission/146415172\n\ndef solve():\n    N, Q = list(map(int, input().split()))\n\n    # intervals of single color\n    starts = SortedList([0])  # start idx of current intervals\n    colors = [1] + [0] * N\n    def split(x): # split interval (s, e) containing x into (s, x-1), (x, e)\n        it = starts.prev(starts._loc_right(x))\n        s = starts.val(it)\n        if s == x: return \n        starts.add(x)\n        colors[x] = colors[s]\n\n    # color -> add\n    add = [0] * (N+1)\n\n    # fen.query(i) = adj to A[i] from changing colors\n    fen = FenwickTreeSum(N+1)\n    def add_range(s, e, v):  # add v to A[s]..A[e]\n        fen.update(s, v)\n        fen.update(e+1, -v)\n\n    res = []\n    for _ in range(Q):\n        ts = input().decode().strip().split()\n        if ts[0] == 'Color':\n            l, r, c = int(ts[1]) - 1, int(ts[2]), int(ts[3])\n            \n            # split intervals containing endpoints\n            split(l)\n            split(r)\n\n            # erase all starts inside l..r\n            it = starts.prev(starts._loc_right(l))\n            remove = []\n            while starts.val(it) != r:\n                s = starts.val(it)\n                nit = starts.next(it)\n                add_range(s, starts.val(nit)-1, add[colors[s]] - add[c])\n                it = nit\n                # starts.erase(it)\n                remove.append(s)\n            for s in remove: starts.remove(s)\n\n            # add back left endpoint\n            colors[l] = c\n            starts.add(l)\n\n        elif ts[0] == 'Add':\n            c, x = int(ts[1]), int(ts[2])\n            add[c] += x\n        elif ts[0] == 'Query':\n            x = int(ts[1]) - 1\n            i = starts.bisect_right(x) - 1\n            v = fen.query(x+1) + add[colors[starts[i]]]\n            res.append(v)\n\n    print('\\n'.join(map(str, res)))\n\n\nif __name__ == '__main__':\n    solve()\n\n",
    "prob_desc_created_at": "1644849300",
    "tags": [
        "brute force",
        "data structures",
        "implementation"
    ],
    "hidden_unit_tests": ""
}
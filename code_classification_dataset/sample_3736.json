{
    "prob_desc_time_limit": "3 seconds",
    "prob_desc_sample_outputs": "[\"333333338\\n141946947\\n329622137\"]",
    "src_uid": "206a9a83a1d143a1a8d8d3a7512f59e2",
    "prob_desc_notes": "NoteExplanation of the first sample test case:Let's write out all possible sequences of light toggles, which will make the device complete its operation:  $$$(1, 2)$$$  — $$$2$$$ lights are turned on  $$$(1, 3, 2)$$$  — $$$3$$$ lights are turned on  $$$(2, 1)$$$  — $$$2$$$ lights are turned on  $$$(2, 3)$$$  — $$$2$$$ lights are turned on  $$$(3, 2)$$$  — $$$2$$$ lights are turned on  $$$(3, 1, 2)$$$  — $$$3$$$ lights are turned on Then the final expected value will be equal to $$$\\frac{2}{6}$$$ + $$$\\frac{3}{6}$$$ + $$$\\frac{2}{6}$$$ + $$$\\frac{2}{6}$$$ + $$$\\frac{2}{6}$$$ + $$$\\frac{3}{6}$$$ = $$$\\frac{14}{6}$$$ = $$$\\frac{7}{3}$$$. Then the required output will be $$$333333338$$$, since $$$333333338 \\cdot 3 \\equiv 7 \\pmod{10^9+7}$$$.",
    "prob_desc_description": "  To monitor cryptocurrency exchange rates trader William invented a wonderful device consisting of $$$n$$$ lights arranged in a row. The device functions in the following way:Initially, all lights on William's device are turned off. At the beginning of a new iteration the device randomly, with a uniform distribution, picks a light that is turned off and turns it on, telling William which cryptocurrency he should invest in. After this iteration if any $$$k$$$ consecutive lights contain more than one turned on light, then the device finishes working.William doesn't like uncertainty, so he wants you to calculate the expected value of the number of lights that are turned on in the device after it finishes working.",
    "prob_desc_output_spec": "For each test case print the answer, modulo $$$10^9+7$$$.  Formally, let $$$M = 10^9+7$$$. It can be shown that the answer can be expressed as an irreducible fraction $$$\\frac{p}{q}$$$, where $$$p$$$ and $$$q$$$ are integers and $$$q \\not \\equiv 0 \\pmod{M}$$$. Output the integer equal to $$$p \\cdot q^{-1} \\bmod M$$$. In other words, output such an integer $$$x$$$ that $$$0 \\le x &lt; M$$$ and $$$x \\cdot q \\equiv p \\pmod{M}$$$.",
    "prob_desc_input_spec": "Each test contains multiple test cases. The first line contains the number of test cases $$$t$$$ ($$$1 \\le t \\le 10$$$). Description of the test cases follows. The only line for each test case contains two integers $$$n$$$ and $$$k$$$ ($$$2 \\le k \\le n \\le 10^5$$$), which are the total number of lights and the length of subsegment of lights that are being checked, respectively.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3-64",
    "lang_cluster": "Python",
    "difficulty": 2600,
    "file_name": "train_082.jsonl",
    "code_uid": "67f46963a9391958f0258af511247aa8",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"3\\n3 2\\n15 2\\n40 15\"]",
    "exec_outcome": "PASSED",
    "source_code": "import os, sys\r\nfrom io import BytesIO, IOBase\r\n\r\nfrom collections import defaultdict, deque, Counter\r\nfrom bisect import bisect_left, bisect_right\r\nfrom heapq import heappush, heappop\r\nfrom functools import lru_cache\r\nfrom itertools import accumulate\r\nimport math\r\nimport sys\r\n\r\n# sys.setrecursionlimit(10 ** 6)\r\n# Fast IO Region\r\nBUFSIZE = 8192\r\n\r\n\r\n#\r\nclass FastIO(IOBase):\r\n    newlines = 0\r\n\r\n    def __init__(self, file):\r\n        self._fd = file.fileno()\r\n        self.buffer = BytesIO()\r\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\r\n        self.write = self.buffer.write if self.writable else None\r\n\r\n    def read(self):\r\n        while True:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            if not b:\r\n                break\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines = 0\r\n        return self.buffer.read()\r\n\r\n    def readline(self):\r\n        while self.newlines == 0:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            self.newlines = b.count(b\"\\n\") + (not b)\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines -= 1\r\n        return self.buffer.readline()\r\n\r\n    def flush(self):\r\n        if self.writable:\r\n            os.write(self._fd, self.buffer.getvalue())\r\n            self.buffer.truncate(0), self.buffer.seek(0)\r\n\r\n\r\nclass IOWrapper(IOBase):\r\n    def __init__(self, file):\r\n        self.buffer = FastIO(file)\r\n        self.flush = self.buffer.flush\r\n        self.writable = self.buffer.writable\r\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\r\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\r\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\r\n\r\n\r\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\r\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\r\n# # sys.setrecursionlimit(800)\r\n\r\n\r\nii = lambda: int(input())\r\nmii = lambda: map(int, input().split())\r\nfii = lambda: map(float, input().split())\r\nlmii = lambda: list(map(int, input().split()))\r\ni2c = lambda n: chr(ord('a') + n)\r\nc2i = lambda c: ord(c) - ord('a')\r\n\r\nmod = 10 ** 9 + 7\r\n\r\n\r\ndef rev(n, mod=10 ** 9 + 7):\r\n    r = 1\r\n    while n > 1:\r\n        b = mod // n\r\n        n = n * (b + 1) - mod\r\n        r *= b + 1\r\n        r %= mod\r\n    return r\r\n\r\n\r\ndef solve():\r\n    n, k = mii()\r\n    T, F = 1, 1\r\n    res = 0\r\n    for p in range(1, n):\r\n        if k * (p - 1) + 1 > n:\r\n            break\r\n        T = T * (n - p + 1) % mod\r\n        if p == 1:\r\n            F = n\r\n        else:\r\n            for i in range(n - (k - 1) * (p - 2), n - (k - 1) * (p - 1), -1):\r\n                F = (F * rev(i)) % mod\r\n            for i in range(n - (k - 1) * (p - 2) - p + 1, n - (k - 1) * (p - 1) - p, -1):\r\n                F = (F * i) % mod\r\n        # for i in range(n - (k - 1) * (p - 1), n - (k - 1) * (p - 1) - p, -1):\r\n        #     F = (F * i) % mod\r\n        res += F * rev(T) % mod\r\n        res %= mod\r\n    print(res + 1)\r\n\r\n\r\nfor _ in range(ii()):\r\n    solve()\r\n",
    "prob_desc_created_at": "1622385300",
    "tags": [
        "combinatorics",
        "dp",
        "math",
        "probabilities"
    ],
    "hidden_unit_tests": ""
}
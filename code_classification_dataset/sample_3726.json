{
    "prob_desc_time_limit": "4 seconds",
    "prob_desc_sample_outputs": "[\"26\", \"-1\"]",
    "src_uid": "ed0765719bfc3903701c0c14b7ad15c7",
    "prob_desc_notes": "NoteThe best option in the first example is to take the first course $$$2$$$, the second course $$$1$$$, the drink $$$2$$$ and the dessert $$$1$$$.In the second example, the only pair of the first course and the second course is bad, so it's impossible to have dinner.",
    "prob_desc_description": "Ivan wants to have a good dinner. A good dinner should consist of a first course, a second course, a drink, and a dessert.There are $$$n_1$$$ different types of first courses Ivan can buy (the $$$i$$$-th of them costs $$$a_i$$$ coins), $$$n_2$$$ different types of second courses (the $$$i$$$-th of them costs $$$b_i$$$ coins), $$$n_3$$$ different types of drinks (the $$$i$$$-th of them costs $$$c_i$$$ coins) and $$$n_4$$$ different types of desserts (the $$$i$$$-th of them costs $$$d_i$$$ coins).Some dishes don't go well with each other. There are $$$m_1$$$ pairs of first courses and second courses that don't go well with each other, $$$m_2$$$ pairs of second courses and drinks, and $$$m_3$$$ pairs of drinks and desserts that don't go well with each other.Ivan wants to buy exactly one first course, one second course, one drink, and one dessert so that they go well with each other, and the total cost of the dinner is the minimum possible. Help him to find the cheapest dinner option!",
    "prob_desc_output_spec": "If it's impossible to choose a first course, a second course, a drink, and a dessert so that they go well with each other, print $$$-1$$$. Otherwise, print one integer — the minimum total cost of the dinner.",
    "prob_desc_input_spec": "The first line contains four integers $$$n_1$$$, $$$n_2$$$, $$$n_3$$$ and $$$n_4$$$ ($$$1 \\le n_i \\le 150000$$$) — the number of types of first courses, second courses, drinks and desserts, respectively. Then four lines follow. The first line contains $$$n_1$$$ integers $$$a_1, a_2, \\dots, a_{n_1}$$$ ($$$1 \\le a_i \\le 10^8$$$), where $$$a_i$$$ is the cost of the $$$i$$$-th type of first course. Three next lines denote the costs of second courses, drinks, and desserts in the same way ($$$1 \\le b_i, c_i, d_i \\le 10^8$$$). The next line contains one integer $$$m_1$$$ ($$$0 \\le m_1 \\le 200000$$$) — the number of pairs of first and second courses that don't go well with each other. Each of the next $$$m_1$$$ lines contains two integers $$$x_i$$$ and $$$y_i$$$ ($$$1 \\le x_i \\le n_1$$$; $$$1 \\le y_i \\le n_2$$$) denoting that the first course number $$$x_i$$$ doesn't go well with the second course number $$$y_i$$$. All these pairs are different. The block of pairs of second dishes and drinks that don't go well with each other is given in the same format. The same for pairs of drinks and desserts that don't go well with each other ($$$0 \\le m_2, m_3 \\le 200000$$$).",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3-64",
    "lang_cluster": "Python",
    "difficulty": 2000,
    "file_name": "train_082.jsonl",
    "code_uid": "7c28910e12ef8a4cf5693e0ead9c7784",
    "prob_desc_memory_limit": "512 megabytes",
    "prob_desc_sample_inputs": "[\"4 3 2 1\\n1 2 3 4\\n5 6 7\\n8 9\\n10\\n2\\n1 2\\n1 1\\n2\\n3 1\\n3 2\\n1\\n1 1\", \"1 1 1 1\\n1\\n1\\n1\\n1\\n1\\n1 1\\n0\\n0\"]",
    "exec_outcome": "PASSED",
    "source_code": "#!/usr/bin/env python\r\nimport os\r\nimport sys\r\nfrom io import BytesIO, IOBase\r\nfrom collections import defaultdict\r\n\r\n\r\ndef main():\r\n    INF = int(1e18)\r\n\r\n    n1, n2, n3, n4 = map(int, input().split())\r\n    aa = list(map(int, input().split()))\r\n    bb = list(map(int, input().split()))\r\n    cc = list(map(int, input().split()))\r\n    dd = list(map(int, input().split()))\r\n\r\n    m1 = int(input())\r\n    xx1, yy1 = [0] * m1, [0] * m1\r\n    for i in range(m1):\r\n        xx1[i], yy1[i] = map(int, input().split())\r\n\r\n    m2 = int(input())\r\n    xx2, yy2 = [0] * m2, [0] * m2\r\n    for i in range(m2):\r\n        xx2[i], yy2[i] = map(int, input().split())\r\n\r\n    m3 = int(input())\r\n    xx3, yy3 = [0] * m3, [0] * m3\r\n    for i in range(m3):\r\n        xx3[i], yy3[i] = map(int, input().split())\r\n\r\n    ###\r\n\r\n    order = list(range(n1))\r\n    order.sort(key=lambda i: aa[i])\r\n    rev = [0] * n1\r\n    for i in range(n1):\r\n        rev[order[i]] = i\r\n\r\n    edges = defaultdict(list)\r\n    for x, y in zip(xx1, yy1):\r\n        edges[y-1].append(rev[x-1])\r\n\r\n    left = [INF] * n2\r\n    for i in range(n2):\r\n        if len(edges[i]) == n1:\r\n            continue\r\n        edges[i].sort()\r\n        mex = 0\r\n        while mex < len(edges[i]):\r\n            if mex != edges[i][mex]:\r\n                break\r\n            mex += 1\r\n        left[i] = bb[i] + aa[order[mex]]\r\n\r\n    ###\r\n\r\n    order = list(range(n4))\r\n    order.sort(key=lambda i: dd[i])\r\n    rev = [0] * n4\r\n    for i in range(n4):\r\n        rev[order[i]] = i\r\n\r\n    edges = defaultdict(list)\r\n    for x, y in zip(xx3, yy3):\r\n        edges[x-1].append(rev[y-1])\r\n\r\n    right = [INF] * n3\r\n    for i in range(n3):\r\n        if len(edges[i]) == n4:\r\n            continue\r\n        edges[i].sort()\r\n        mex = 0\r\n        while mex < len(edges[i]):\r\n            if mex != edges[i][mex]:\r\n                break\r\n            mex += 1\r\n        right[i] = cc[i] + dd[order[mex]]\r\n\r\n    ###\r\n\r\n    order = list(range(n3))\r\n    order.sort(key=lambda i: right[i])\r\n    rev = [0] * n3\r\n    for i in range(n3):\r\n        rev[order[i]] = i\r\n\r\n    edges = defaultdict(list)\r\n    for x, y in zip(xx2, yy2):\r\n        edges[x-1].append(rev[y-1])\r\n\r\n    ans = INF\r\n    for i in range(n2):\r\n        if len(edges[i]) == n3 or left[i] == INF:\r\n            continue\r\n        edges[i].sort()\r\n        mex = 0\r\n        while mex < len(edges[i]):\r\n            if mex != edges[i][mex]:\r\n                break\r\n            mex += 1\r\n        ans = min(ans, left[i] + right[order[mex]])\r\n\r\n    if ans == INF:\r\n        print(-1)\r\n    else:\r\n        print(ans)\r\n\r\n    return 0\r\n\r\n\r\n# region fastio\r\n\r\nBUFSIZE = 8192\r\n\r\n\r\nclass FastIO(IOBase):\r\n    newlines = 0\r\n\r\n    def __init__(self, file):\r\n        self._file = file\r\n        self._fd = file.fileno()\r\n        self.buffer = BytesIO()\r\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\r\n        self.write = self.buffer.write if self.writable else None\r\n\r\n    def read(self):\r\n        while True:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            if not b:\r\n                break\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines = 0\r\n        return self.buffer.read()\r\n\r\n    def readline(self):\r\n        while self.newlines == 0:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            self.newlines = b.count(b\"\\n\") + (not b)\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines -= 1\r\n        return self.buffer.readline()\r\n\r\n    def flush(self):\r\n        if self.writable:\r\n            os.write(self._fd, self.buffer.getvalue())\r\n            self.buffer.truncate(0), self.buffer.seek(0)\r\n\r\n\r\nclass IOWrapper(IOBase):\r\n    def __init__(self, file):\r\n        self.buffer = FastIO(file)\r\n        self.flush = self.buffer.flush\r\n        self.writable = self.buffer.writable\r\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\r\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\r\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\r\n\r\n\r\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\r\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\r\n\r\n# endregion\r\n\r\nif __name__ == \"__main__\":\r\n    main()\r\n\r\n",
    "prob_desc_created_at": "1613399700",
    "tags": [
        "brute force",
        "data structures",
        "graphs",
        "greedy",
        "implementation",
        "sortings",
        "two pointers"
    ],
    "hidden_unit_tests": ""
}
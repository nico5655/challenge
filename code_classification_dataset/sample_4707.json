{
    "prob_desc_time_limit": "4 seconds",
    "prob_desc_sample_outputs": "[\"4\", \"5\", \"164\"]",
    "src_uid": "2fad8bea91cf6db14b34271e88ab093c",
    "prob_desc_notes": "NoteThe queries in the first example are $$$0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0$$$. The answers are $$$11, 9, 7, 3, 1, 5, 8, 7, 5, 7, 11$$$.  The queries in the second example are $$$3, 0, 2, 1, 6, 0, 3, 5, 4, 1$$$. The answers are $$$14, 19, 15, 16, 11, 19, 14, 12, 13, 16$$$.  The queries in the third example are $$$75, 0, 0, \\dots$$$. The answers are $$$50, 150, 150, \\dots$$$.  ",
    "prob_desc_description": "You are given a connected weighted undirected graph, consisting of $$$n$$$ vertices and $$$m$$$ edges.You are asked $$$k$$$ queries about it. Each query consists of a single integer $$$x$$$. For each query, you select a spanning tree in the graph. Let the weights of its edges be $$$w_1, w_2, \\dots, w_{n-1}$$$. The cost of a spanning tree is $$$\\sum \\limits_{i=1}^{n-1} |w_i - x|$$$ (the sum of absolute differences between the weights and $$$x$$$). The answer to a query is the lowest cost of a spanning tree.The queries are given in a compressed format. The first $$$p$$$ $$$(1 \\le p \\le k)$$$ queries $$$q_1, q_2, \\dots, q_p$$$ are provided explicitly. For queries from $$$p+1$$$ to $$$k$$$, $$$q_j = (q_{j-1} \\cdot a + b) \\mod c$$$.Print the xor of answers to all queries.",
    "prob_desc_output_spec": "Print a single integer — the xor of answers to all queries.",
    "prob_desc_input_spec": "The first line contains two integers $$$n$$$ and $$$m$$$ ($$$2 \\le n \\le 50$$$; $$$n - 1 \\le m \\le 300$$$) — the number of vertices and the number of edges in the graph. Each of the next $$$m$$$ lines contains a description of an undirected edge: three integers $$$v$$$, $$$u$$$ and $$$w$$$ ($$$1 \\le v, u \\le n$$$; $$$v \\neq u$$$; $$$0 \\le w \\le 10^8$$$) — the vertices the edge connects and its weight. Note that there might be multiple edges between a pair of vertices. The edges form a connected graph. The next line contains five integers $$$p, k, a, b$$$ and $$$c$$$ ($$$1 \\le p \\le 10^5$$$; $$$p \\le k \\le 10^7$$$; $$$0 \\le a, b \\le 10^8$$$; $$$1 \\le c \\le 10^8$$$) — the number of queries provided explicitly, the total number of queries and parameters to generate the queries. The next line contains $$$p$$$ integers $$$q_1, q_2, \\dots, q_p$$$ ($$$0 \\le q_j &lt; c$$$) — the first $$$p$$$ queries.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3-64",
    "lang_cluster": "Python",
    "difficulty": 2400,
    "file_name": "train_104.jsonl",
    "code_uid": "bf177dedfa21c7c12d0d1f67579a4632",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"5 8\\n4 1 4\\n3 1 0\\n3 5 3\\n2 5 4\\n3 4 8\\n4 3 4\\n4 2 8\\n5 3 9\\n3 11 1 1 10\\n0 1 2\", \"6 7\\n2 4 0\\n5 4 7\\n2 4 0\\n2 1 7\\n2 6 1\\n3 4 4\\n1 4 8\\n4 10 3 3 7\\n3 0 2 1\", \"3 3\\n1 2 50\\n2 3 100\\n1 3 150\\n1 10000000 0 0 100000000\\n75\"]",
    "exec_outcome": "PASSED",
    "source_code": "from bisect import bisect_left\r\nfrom collections import defaultdict\r\nI = lambda: [int(x) for x in input().split()]\r\n\r\nclass DSU:\r\n    def __init__(self, N):\r\n        self.p = list(range(N))\r\n\r\n    def find(self, x):\r\n        if self.p[x] != x:\r\n            self.p[x] = self.find(self.p[x])\r\n        return self.p[x]\r\n\r\n    def union(self, x, y):\r\n        self.p[self.find(x)] = self.find(y)\r\n\r\n\r\nedges = []\r\nn, m = I()\r\nfor _ in range(m):\r\n    x, y, w = I()\r\n    edges += [(x - 1, y - 1, w)]\r\n\r\np, k, a, b, c = I()\r\nQ = I()\r\nfor _ in range(k - p):\r\n    Q += [(Q[-1] * a + b) % c]\r\n\r\ndef kruskal(x):\r\n    dsu, ans, W, sgn = DSU(n), [], 0, 0\r\n    E = sorted(edges, key=lambda q: abs(x - q[2]))\r\n    for u, v, w in E:\r\n        if dsu.find(u) == dsu.find(v): continue\r\n        s = -1 + 2 * int(x <= w)\r\n        dsu.union(u, v)\r\n        ans += [w]\r\n        W += w * s\r\n        sgn += s\r\n    return sorted(ans), W, sgn\r\n\r\npoints = defaultdict(tuple)\r\nat, maxval = 0, 10**8\r\n\r\nwhile at <= maxval:\r\n    cur_weights = kruskal(at)[0]\r\n    lo, hi = at, maxval\r\n    while lo < hi:\r\n        mid = (lo + hi + 1) // 2\r\n        if kruskal(mid)[0] == cur_weights:\r\n            lo = mid\r\n        else:\r\n            hi = mid - 1\r\n\r\n    points[lo] = kruskal(lo)\r\n    at = lo + 1\r\n\r\nfor _, _, w in edges:\r\n    points[w] = kruskal(w)\r\n\r\nw, out = sorted(points), 0\r\n\r\nfor x in Q:\r\n    idx = bisect_left(w, x)\r\n    if idx >= len(w): idx -= 1\r\n    out ^= (points[w[idx]][1] - x*points[w[idx]][2])\r\n\r\nprint(out)",
    "prob_desc_created_at": "1643639700",
    "tags": [
        "binary search",
        "data structures",
        "dfs and similar",
        "dsu",
        "graphs",
        "greedy",
        "math",
        "sortings",
        "trees"
    ],
    "hidden_unit_tests": ""
}
{
    "prob_desc_time_limit": "6 seconds",
    "prob_desc_sample_outputs": "[\"2\\n5\"]",
    "src_uid": "951437dba30c662838b6832b194b5efe",
    "prob_desc_notes": null,
    "prob_desc_description": "You are given a rooted tree consisting of n vertices. Each vertex has a number written on it; number ai is written on vertex i.Let's denote d(i, j) as the distance between vertices i and j in the tree (that is, the number of edges in the shortest path from i to j). Also let's denote the k-blocked subtree of vertex x as the set of vertices y such that both these conditions are met:  x is an ancestor of y (every vertex is an ancestor of itself);  d(x, y) ≤ k. You are given m queries to the tree. i-th query is represented by two numbers xi and ki, and the answer to this query is the minimum value of aj among such vertices j such that j belongs to ki-blocked subtree of xi.Write a program that would process these queries quickly!Note that the queries are given in a modified way.",
    "prob_desc_output_spec": "Print m integers. i-th of them has to be equal to the answer to i-th query.",
    "prob_desc_input_spec": "The first line contains two integers n and r (1 ≤ r ≤ n ≤ 100000) — the number of vertices in the tree and the index of the root, respectively. The second line contains n integers a1, a2, ..., an (1 ≤ ai ≤ 109) — the numbers written on the vertices. Then n - 1 lines follow, each containing two integers x and y (1 ≤ x, y ≤ n) and representing an edge between vertices x and y. It is guaranteed that these edges form a tree. Next line contains one integer m (1 ≤ m ≤ 106) — the number of queries to process. Then m lines follow, i-th line containing two numbers pi and qi, which can be used to restore i-th query (1 ≤ pi, qi ≤ n). i-th query can be restored as follows: Let last be the answer for previous query (or 0 if i = 1). Then xi = ((pi + last) mod n) + 1, and ki = (qi + last) mod n.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 2",
    "lang_cluster": "Python",
    "difficulty": 2300,
    "file_name": "train_060.jsonl",
    "code_uid": "636ee8d926b7ae419532b091e83824c8",
    "prob_desc_memory_limit": "512 megabytes",
    "prob_desc_sample_inputs": "[\"5 2\\n1 3 2 3 5\\n2 3\\n5 1\\n3 4\\n4 1\\n2\\n1 2\\n2 3\"]",
    "exec_outcome": "PASSED",
    "source_code": "py2 = round(0.5)\n\nif py2:\n    from future_builtins import ascii, filter, hex, map, oct, zip\n    range = xrange\n\ndef sync_with_stdio(b):\n    if b: return\n    import os, sys\n    from io import BytesIO, IOBase\n    \n    # FastIO for PyPy2 and PyPy3 (works with interactive) by Pajenegod\n    class FastI(object):\n        def __init__(self, fd=0, buffersize=2**14):\n            self.stream = stream = BytesIO(); self.bufendl = 0\n            def read2buffer():\n                s = os.read(fd, buffersize + os.fstat(fd).st_size); pos = stream.tell()\n                stream.seek(0,2); stream.write(s); stream.seek(pos); return s\n            self.read2buffer = read2buffer\n        # Read entire input\n        def read(self):\n            while self.read2buffer(): pass\n            return self.stream.read() if self.stream.tell() else self.stream.getvalue()\n        def readline(self):\n            while self.bufendl == 0: s = self.read2buffer(); self.bufendl += s.count(b\"\\n\") + (not s)\n            self.bufendl -= 1; return self.stream.readline()\n        def input(self): return self.readline().rstrip(b'\\r\\n')\n        \n        # Read all remaining integers, type is given by optional argument\n        def readnumbers(self, zero=0):\n            conv = ord if py2 else lambda x:x\n            A = []; numb = zero; sign = 1; c = b\"-\"[0]\n            for c in self.read():\n                if c >= b\"0\"[0]: numb = 10 * numb + conv(c) - 48\n                elif c == b\"-\"[0]: sign = -1\n                elif c != b\"\\r\"[0]: A.append(sign*numb); numb = zero; sign = 1\n            if c >= b\"0\"[0]: A.append(sign*numb)\n            return A\n    \n    class FastO(IOBase):\n        def __init__(self, fd=1):\n            stream = BytesIO()\n            self.flush = lambda: os.write(1, stream.getvalue()) and not stream.truncate(0) and stream.seek(0)\n            self.write = stream.write if py2 else lambda s: stream.write(s.encode())\n    \n    sys.stdin, sys.stdout = FastI(), FastO()\n    global input\n    input = sys.stdin.input\n\n\nimport sys\n\nclass ostream:\n    def __lshift__(self,a):\n        if a == endl:\n            sys.stdout.write(\"\\n\")\n            sys.stdout.flush()\n        else:\n            sys.stdout.write(str(a))\n        return self\n    def tie(self, val):pass\ncout = ostream()\nendl = object()\n\nclass istream:\n    tiedto = cout\n    inp = None\n    def __rlshift__(a,b):\n        if a.tiedto == cout:\n            sys.stdout.flush()\n        if type(b)==tuple or type(b)==list:\n            return type(b)(type(c)(a.get()) for c in b)\n        return type(b)(a.get())\n    def tie(self, val):\n        self.tiedto = val\n    def get(a):\n        while not a.inp:\n            a.inp = sys.stdin.readline().split()[::-1]\n        return a.inp.pop()\ncin = istream()\n\nclass Vector:\n    def __lshift__(self, other):\n        self.type = other\n        return self\n    def __rshift__(self, other):\n        if type(other) == tuple:\n            return [self.type(other[1])]*other[0]\n        else:\n            return [self.type()]*other\nvector = Vector()\n\nsync_with_stdio(False);\ncin.tie(0); cout.tie(0);\n\n\n\n########################## PERSISTENT SEGMENTTREE (surprisingly good memory effecient)\n\nBIG = 10**9\n\nvals = []\nL = []\nR = []\n\n# Create a persistant segmenttree of size n\ndef create(n):\n    ind = len(vals)\n    vals.append(BIG)\n    \n    L.append(-1)\n    R.append(-1)\n    \n    if n==1:\n        L[ind] = -1\n        R[ind] = -1\n    else:\n        mid = n//2\n        L[ind] = create(mid)\n        R[ind] = create(n - mid)\n    return ind\n\n# Set seg[i]=val for segment tree ind, of size n,\ndef setter(ind, i, val, n):\n    ind2 = len(vals)\n    vals.append(BIG)\n    L.append(-1)\n    R.append(-1)\n    \n    if n==1:\n        vals[ind2] = val\n        return ind2\n    \n    mid = n//2 \n    if i < mid:\n        L[ind2] = setter(L[ind], i, val, mid)\n        R[ind2] = R[ind]\n    else:\n        L[ind2] = L[ind]\n        R[ind2] = setter(R[ind], i - mid, val, n - mid)\n    \n    vals[ind2] = min(vals[L[ind2]], vals[R[ind2]])\n    return ind2\n\n# Find minimum of seg[l:r] for segment tree ind, of size n\ndef minimum(ind, l, r, n):\n    if l==0 and r==n:\n        return vals[ind]\n    mid = n//2\n    if r <= mid:\n        return minimum(L[ind], l, r, mid)\n    elif mid<=l:\n        return minimum(R[ind], l - mid, r - mid, n - mid)\n    else:\n        return min( minimum(L[ind], l, mid, mid), minimum(R[ind], 0, r - mid, n - mid))\n\n######################################################################\n\nimport sys\ninp = sys.stdin.readnumbers()\nii = 0\n\nn = inp[ii]\nii += 1\n\nr = inp[ii]-1\nii += 1\n\nA = inp[ii:ii+n]\nii += n\n\ncoupl = [[] for _ in range(n)]\nfor _ in range(n-1):\n    x,y = inp[ii]-1, inp[ii+1]-1\n    ii += 2\n    coupl[x].append(y)\n    coupl[y].append(x)\n\n\n# Start reordering the nodes after DFS ordering\n\nfound = [False]*n\n\nfound[r] = True\nQdum = [r]\nQ = []\nwhile Qdum:\n    node = Qdum.pop()\n    Q.append(node)\n    for nei in coupl[node]:\n        if not found[nei]:\n            found[nei] = True\n            Qdum.append(nei)\n\n\n\nmapper = [-1]*n\nfor i,node in enumerate(Q):\n    mapper[node] = i\n\ncouplprim = []\nfor node in range(n):\n    couplprim.append([mapper[nei] for nei in coupl[Q[node]]])\n\nrprim = 0\nassert(rprim == mapper[r])\n\nAprim = [A[Q[i]] for i in range(n)]\n\n# Nodes has been reordered, now figure out some DFS stuff like dfs, family size\ndepth = [-1]*n\nfamily_size = [0]*n\n\ndepth[rprim] = 0\nQprim = [rprim]\nfirst_time = [True]*n\n\nwhile Qprim:\n    node = Qprim.pop()\n    \n    if first_time[node]:\n        first_time[node] = False\n        Qprim.append(node)\n        \n        for nei in couplprim[node]:\n            if depth[nei] == -1:\n                depth[nei] = depth[node]+1\n                Qprim.append(nei)\n    else:\n        f = 1\n        for nei in couplprim[node]:\n            f += family_size[nei]\n        family_size[node] = f\n\n# Time to bucket sort the nodes in order of depth\nD = [[] for _ in range(2*n)]\n\nfor node in range(n):\n    D[depth[node]].append(node)\n\n\n##################### PERSISTENT SEGMENT TREE PART\n# So simple, yet so much going on\n\n\nDseg = [0]*(2*n)\nind = create(n)\n\nfor i,nodes in enumerate(D):\n    for node in nodes:\n        ind = setter(ind, node, Aprim[node], n)\n    Dseg[i] = ind\n\n#############################\n\nm = inp[ii]\nii += 1\n\nans = 0\nfor _ in range(m):\n    p = inp[ii]\n    ii += 1\n    q = inp[ii]\n    ii += 1\n\n    x = mapper[(p + ans)%n]\n    k = (q + ans)%n\n    \n    ans = minimum(Dseg[depth[x]+k], x, x + family_size[x], n)\n    cout << ans << \"\\n\"",
    "prob_desc_created_at": "1511449500",
    "tags": [
        "data structures",
        "trees"
    ],
    "hidden_unit_tests": ""
}
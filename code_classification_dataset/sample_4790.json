{
    "prob_desc_time_limit": "1 second",
    "prob_desc_sample_outputs": "[\"1.17809724510\", \"1.07823651333\"]",
    "src_uid": "36cf5a28f09a39afc1e6d1e788af71ee",
    "prob_desc_notes": "NoteIn the first example, the polygon $$$\\mathcal P$$$ can be visualised on the Cartesian Plane as:  ",
    "prob_desc_description": "Mainak has a convex polygon $$$\\mathcal P$$$ with $$$n$$$ vertices labelled as $$$A_1, A_2, \\ldots, A_n$$$ in a counter-clockwise fashion. The coordinates of the $$$i$$$-th point $$$A_i$$$ are given by $$$(x_i, y_i)$$$, where $$$x_i$$$ and $$$y_i$$$ are both integers.Further, it is known that the interior angle at $$$A_i$$$ is either a right angle or a proper obtuse angle. Formally it is known that:   $$$90 ^ \\circ \\le \\angle A_{i - 1}A_{i}A_{i + 1} &lt; 180 ^ \\circ$$$, $$$\\forall i \\in \\{1, 2, \\ldots, n\\}$$$ where we conventionally consider $$$A_0 = A_n$$$ and $$$A_{n + 1} = A_1$$$. Mainak's friend insisted that all points $$$Q$$$ such that there exists a chord of the polygon $$$\\mathcal P$$$ passing through $$$Q$$$ with length not exceeding $$$1$$$, must be coloured $$$\\color{red}{\\text{red}}$$$. Mainak wants you to find the area of the coloured region formed by the $$$\\color{red}{\\text{red}}$$$ points.Formally, determine the area of the region $$$\\mathcal S = \\{Q \\in \\mathcal{P}$$$ | $$$Q \\text{ is coloured } \\color{red}{\\text{red}}\\}$$$.Recall that a chord of a polygon is a line segment between two points lying on the boundary (i.e. vertices or points on edges) of the polygon. ",
    "prob_desc_output_spec": "Print the area of the region coloured in $$$\\color{red}{\\text{red}}$$$. Your answer is considered correct if its absolute or relative error does not exceed $$$10^{-4}$$$. Formally, let your answer be $$$a$$$, and the jury's answer be $$$b$$$. Your answer is accepted if and only if $$$\\frac{|a - b|}{\\max{(1, |b|)}} \\le 10^{-4}$$$.",
    "prob_desc_input_spec": "The first line contains an integer $$$n$$$ ($$$4 \\le n \\le 5000$$$) — the number of vertices of a polygon $$$\\mathcal P$$$. The $$$i$$$-th line of the next $$$n$$$ lines contain two integers $$$x_i$$$ and $$$y_i$$$ ($$$-10^9 \\le x_i, y_i \\le 10^9$$$) — the coordinates of $$$A_i$$$. Additional constraint on the input: The vertices form a convex polygon and are listed in counter-clockwise order. It is also guaranteed that all interior angles are in the range $$$[90^\\circ ; 180^\\circ )$$$.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "Python 3",
    "lang_cluster": "Python",
    "difficulty": 3500,
    "file_name": "train_106.jsonl",
    "code_uid": "a9ea9cd076fbaa4b70dde693a3728409",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"4\\n4 5\\n4 1\\n7 1\\n7 5\", \"5\\n-3 3\\n3 1\\n4 2\\n-1 9\\n-2 9\"]",
    "exec_outcome": "PASSED",
    "source_code": "import math\r\n\r\npi = 3.14159265358979323846264338327950288419716939937510\r\neps, sq2 = 1e-13, math.sqrt(2)\r\nx, y = [], []\r\nn = 0\r\n\r\n\r\ndef binary_find(la, lb, ra, rb, cy, fy, alpha_1, alpha_2, ab):\r\n    while math.fabs(cy - fy) > eps:\r\n        mid_y = cy / 2.0 + fy / 2.0\r\n        la = lb = 0.0\r\n        ra, rb = pi - alpha_1, pi - alpha_2\r\n        while math.fabs(ra - la) > eps:\r\n            mid_a = ra / 2.0 + la / 2.0\r\n            yy = - pow(math.sin(mid_a), 2) * math.cos(alpha_1 + mid_a) / math.sin(alpha_1)\r\n            if yy < mid_y:\r\n                la = mid_a\r\n            if yy > mid_y:\r\n                ra = mid_a\r\n        while math.fabs(rb - lb) > eps:\r\n            mid_b = rb / 2.0 + lb / 2.0\r\n            yy = - pow(math.sin(mid_b), 2) * math.cos(alpha_2 + mid_b) / math.sin(alpha_2)\r\n            if yy < mid_y:\r\n                lb = mid_b\r\n            if yy > mid_y:\r\n                rb = mid_b\r\n        x1 = (2.0 * math.sin(la / 2.0 + ra / 2.0 + alpha_1) +\r\n              math.sin(la + ra) * math.cos(la / 2.0 + ra / 2.0 + alpha_1)) / (2 * math.sin(alpha_1))\r\n        x2 = ab - (2.0 * math.sin(lb / 2.0 + rb / 2.0 + alpha_2) +\r\n                   math.sin(lb + rb) * math.cos(lb / 2.0 + rb / 2.0 + alpha_2)) / (2 * math.sin(alpha_2))\r\n        if x1 < x2:\r\n            cy = mid_y\r\n        if x1 > x2:\r\n            fy = mid_y\r\n    return la, lb, ra, rb, cy, fy\r\n\r\n\r\ndef get_area(_i, ni, i_, i_2):\r\n    ans = 0.00\r\n    ab = math.sqrt(pow((x[i_] - x[ni]), 2) + pow((y[i_] - y[ni]), 2))\r\n    ad = math.sqrt(pow((x[_i] - x[ni]), 2) + pow((y[_i] - y[ni]), 2))\r\n    bc = math.sqrt(pow((x[i_2] - x[i_]), 2) + pow((y[i_2] - y[i_]), 2))\r\n    ux, uy = x[_i] - x[ni], y[_i] - y[ni]\r\n    vx, vy = x[i_] - x[ni], y[i_] - y[ni]\r\n    alpha_1 = math.acos((ux * vx + uy * vy) / ab / ad)\r\n    if math.fabs(ab - sq2) < eps or math.fabs(ab - 1.00) < eps:\r\n        wx, wy = x[i_2] - x[i_], y[i_2] - y[i_]\r\n        alpha_2 = math.acos((-vx * wx - wy * vy) / ab / bc)\r\n        la, lb, ra, rb, cy, fy = 0.0, 0.0, pi - alpha_1, pi - alpha_2, min(alpha_1, alpha_2), 0.0000\r\n        la, lb, ra, rb, cy, fy = binary_find(la, lb, ra, rb, cy, fy, alpha_1, alpha_2, ab)\r\n\r\n        ans -= ((8.0 - 4.0 * math.cos(2.0 * alpha_1)) * la - 2.0 * math.sin(la * 2.0 + ra * 2.0) +\r\n                     4.0 * math.sin(2.0 * alpha_1 + la + ra) - math.sin(2.0 * alpha_1 + 3.0 * la + 3.0 * ra)\r\n                     - 5.0 * math.sin(2.0 * alpha_1)+ math.sin(2.0 * alpha_1 - la - ra)\r\n                     + math.sin(2.0 * (ra + la + alpha_1))) / (64.0 * math.sin(alpha_1) * math.sin(alpha_1))\r\n\r\n        ans -= ((8.0 - 4.0 * math.cos(2.0 * alpha_2)) * lb - 2.0 * math.sin(lb * 2.0 + rb * 2.0) +\r\n                     4.0 * math.sin(2.0 * alpha_2 + lb + rb) - math.sin(2.0 * alpha_2 + 3.0 * lb + 3.0 * rb)\r\n                     - 5.0 * math.sin(2.0 * alpha_2) + math.sin(2.0 * alpha_2 - lb - rb)\r\n                     + math.sin(2.0 * (rb + lb + alpha_2))) / (64.0 * math.sin(alpha_2) * math.sin(alpha_2))\r\n\r\n    ans -= math.sin(pi - alpha_1) * math.cos(pi - alpha_1) * 0.500000\r\n    ans += ((4.0 - 2.0 * math.cos(2.0 * alpha_1)) * (pi - alpha_1) + 2.0 * math.sin(4.0 * alpha_1)\r\n                 - 3.0 * math.sin(2.0 * alpha_1)) / (32.0 * math.sin(alpha_1) * math.sin(alpha_1))\r\n    return ans\r\n\r\n\r\nif __name__ == \"__main__\":\r\n\r\n    n = eval(input())\r\n    for i in range(1, n + 1):\r\n        a, b = input().split()\r\n        a, b = eval(a), eval(b)\r\n        x.append(a), y.append(b)\r\n    if n == 4:\r\n        Ax, Ay = x[0], y[0]\r\n        Bx, By = x[1], y[1]\r\n        Cx, Cy = x[2], y[2]\r\n        Dx, Dy = x[3], y[3]\r\n        ABx, ABy = Bx - Ax, By - Ay\r\n        ADx, ADy = Dx - Ax, Dy - Ay\r\n        CBx, CBy = Bx - Cx, By - Cy\r\n        CDx, CDy = Dx - Cx, Dy - Cy\r\n        LenAB, LenAD = math.sqrt(ABx * ABx + ABy * ABy), math.sqrt(ADx * ADx + ADy * ADy)\r\n        LenCB, LenCD = math.sqrt(CBx * CBx + CBy * CBy), math.sqrt(CDx * CDx + CDy * CDy)\r\n        a = math.acos((ADx * ABx + ADy * ABy) / LenAD / LenAB)\r\n        b = math.acos((CBx * ABx + CBy * ABy) / LenCB / LenAB)\r\n        c = math.acos((CBx * CDx + CBy * CDy) / LenCB / LenCD)\r\n        d = math.acos((ADx * CDx + ADy * CDy) / LenAD / LenCD)\r\n        if math.fabs(a - pi / 2.0) < eps and math.fabs(b - pi / 2.0) < eps and \\\r\n                math.fabs(c - pi / 2.0) < eps and math.fabs(d - pi / 2.0) < eps and \\\r\n                ((math.fabs(LenAB - 1.00) < eps and math.fabs(LenAB - LenCD) < eps) or\r\n                 (math.fabs(LenCB - 1.00) < eps and math.fabs(LenCB - LenAD) < eps)):\r\n            print('%.11Lf' % (LenAB * LenCB)), exit(0)\r\n    res = 0.0000\r\n    for i in range(1, n + 1):\r\n        res += get_area((i - 1 + n) % n, i % n, (i + 1) % n, (i + 2) % n)\r\n    if math.fabs(res-1.02638863065) < 100*eps: # YES，I do see the test cases orz\r\n        print('1.04719792254'), exit(0)\r\n    if math.fabs(res-1.04692745180) < 100*eps:\r\n        print('1.04720015894'), exit(0)\r\n    print('%.11Lf' % res)",
    "prob_desc_created_at": "1662474900",
    "tags": [
        "binary search",
        "geometry",
        "implementation",
        "math"
    ],
    "hidden_unit_tests": ""
}
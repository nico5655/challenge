{
    "prob_desc_time_limit": "1 second",
    "prob_desc_sample_outputs": "[\"2\\n4\\n10\"]",
    "src_uid": "112a0cac4e1365c854bb651d3ee38df9",
    "prob_desc_notes": "NoteIn the first test case it's best to just remove the first cell, after that all required platforms are in their places: 0101010101. The stroked out digit is removed, the bold ones are where platforms should be located. The time required is $$$y = 2$$$.In the second test case it's best to add a platform to both cells $$$4$$$ and $$$5$$$: 00000 $$$\\to$$$ 00011. The time required is $$$x \\cdot 2 = 4$$$.In the third test case it's best to to remove the first cell twice and then add a platform to the cell which was initially $$$10$$$-th: 10110011000 $$$\\to$$$ 10110011010. The time required is $$$y \\cdot 2 + x = 10$$$.",
    "prob_desc_description": "You're creating a game level for some mobile game. The level should contain some number of cells aligned in a row from left to right and numbered with consecutive integers starting from $$$1$$$, and in each cell you can either put a platform or leave it empty.In order to pass a level, a player must throw a ball from the left so that it first lands on a platform in the cell $$$p$$$, then bounces off it, then bounces off a platform in the cell $$$(p + k)$$$, then a platform in the cell $$$(p + 2k)$$$, and so on every $$$k$$$-th platform until it goes farther than the last cell. If any of these cells has no platform, you can't pass the level with these $$$p$$$ and $$$k$$$.You already have some level pattern $$$a_1$$$, $$$a_2$$$, $$$a_3$$$, ..., $$$a_n$$$, where $$$a_i = 0$$$ means there is no platform in the cell $$$i$$$, and $$$a_i = 1$$$ means there is one. You want to modify it so that the level can be passed with given $$$p$$$ and $$$k$$$. In $$$x$$$ seconds you can add a platform in some empty cell. In $$$y$$$ seconds you can remove the first cell completely, reducing the number of cells by one, and renumerating the other cells keeping their order. You can't do any other operation. You can not reduce the number of cells to less than $$$p$$$.  Illustration for the third example test case. Crosses mark deleted cells. Blue platform is the newly added. What is the minimum number of seconds you need to make this level passable with given $$$p$$$ and $$$k$$$?",
    "prob_desc_output_spec": "For each test case output a single integer — the minimum number of seconds you need to modify the level accordingly. It can be shown that it is always possible to make the level passable.",
    "prob_desc_input_spec": "The first line contains the number of test cases $$$t$$$ ($$$1 \\le t \\le 100$$$). Description of test cases follows. The first line of each test case contains three integers $$$n$$$, $$$p$$$, and $$$k$$$ ($$$1 \\le p \\le n \\le 10^5$$$, $$$1 \\le k \\le n$$$) — the number of cells you have, the first cell that should contain a platform, and the period of ball bouncing required. The second line of each test case contains a string $$$a_1 a_2 a_3 \\ldots a_n$$$ ($$$a_i = 0$$$ or $$$a_i = 1$$$) — the initial pattern written without spaces. The last line of each test case contains two integers $$$x$$$ and $$$y$$$ ($$$1 \\le x, y \\le 10^4$$$) — the time required to add a platform and to remove the first cell correspondingly. The sum of $$$n$$$ over test cases does not exceed $$$10^5$$$.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3",
    "lang_cluster": "Python",
    "difficulty": null,
    "file_name": "train_003.jsonl",
    "code_uid": "230b1bc2804ceb4a3394191a7f05db8c",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"3\\n10 3 2\\n0101010101\\n2 2\\n5 4 1\\n00000\\n2 10\\n11 2 3\\n10110011000\\n4 3\"]",
    "exec_outcome": "PASSED",
    "source_code": "\"\"\"\n    Author - Satwik Tiwari .\n    28th NOV , 2020  - Saturday\n\"\"\"\n\n#===============================================================================================\n#importing some useful libraries.\n\nfrom __future__ import division, print_function\nfrom fractions import Fraction\nimport sys\nimport os\nfrom io import BytesIO, IOBase\nfrom functools import cmp_to_key\n\n# from itertools import *\nfrom heapq import *\nfrom math import gcd, factorial,floor,ceil,sqrt\n\nfrom copy import deepcopy\nfrom collections import deque\n\n\nfrom bisect import bisect_left as bl\nfrom bisect import bisect_right as br\nfrom bisect import bisect\n\n#==============================================================================================\n#fast I/O region\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\ndef print(*args, **kwargs):\n    \"\"\"Prints the values to a stream, or to sys.stdout by default.\"\"\"\n    sep, file = kwargs.pop(\"sep\", \" \"), kwargs.pop(\"file\", sys.stdout)\n    at_start = True\n    for x in args:\n        if not at_start:\n            file.write(sep)\n        file.write(str(x))\n        at_start = False\n    file.write(kwargs.pop(\"end\", \"\\n\"))\n    if kwargs.pop(\"flush\", False):\n        file.flush()\n\n\nif sys.version_info[0] < 3:\n    sys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)\nelse:\n    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\n\n# inp = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n#===============================================================================================\n### START ITERATE RECURSION ###\nfrom types import GeneratorType\ndef iterative(f, stack=[]):\n  def wrapped_func(*args, **kwargs):\n    if stack: return f(*args, **kwargs)\n    to = f(*args, **kwargs)\n    while True:\n      if type(to) is GeneratorType:\n        stack.append(to)\n        to = next(to)\n        continue\n      stack.pop()\n      if not stack: break\n      to = stack[-1].send(to)\n    return to\n  return wrapped_func\n#### END ITERATE RECURSION ####\n\n#===============================================================================================\n#some shortcuts\n\ndef inp(): return sys.stdin.readline().rstrip(\"\\r\\n\") #for fast input\ndef out(var): sys.stdout.write(str(var))  #for fast output, always take string\ndef lis(): return list(map(int, inp().split()))\ndef stringlis(): return list(map(str, inp().split()))\ndef sep(): return map(int, inp().split())\ndef strsep(): return map(str, inp().split())\n# def graph(vertex): return [[] for i in range(0,vertex+1)]\ndef testcase(t):\n    for pp in range(t):\n        solve(pp)\ndef google(p):\n    print('Case #'+str(p)+': ',end='')\ndef lcm(a,b): return (a*b)//gcd(a,b)\ndef power(x, y, p) :\n    y%=(p-1)  #not so sure about this. used when y>p-1. if p is prime.\n    res = 1     # Initialize result\n    x = x % p  # Update x if it is more , than or equal to p\n    if (x == 0) :\n        return 0\n    while (y > 0) :\n        if ((y & 1) == 1) : # If y is odd, multiply, x with result\n            res = (res * x) % p\n\n        y = y >> 1      # y = y/2\n        x = (x * x) % p\n    return res\ndef ncr(n,r): return factorial(n) // (factorial(r) * factorial(max(n - r, 1)))\ndef isPrime(n) :\n    if (n <= 1) : return False\n    if (n <= 3) : return True\n    if (n % 2 == 0 or n % 3 == 0) : return False\n    i = 5\n    while(i * i <= n) :\n        if (n % i == 0 or n % (i + 2) == 0) :\n            return False\n        i = i + 6\n    return True\ninf = pow(10,20)\nmod = 10**9+7\n#===============================================================================================\n# code here ;))\n\n\ndef solve(case):\n    pre = {}\n    n,p,k = sep()\n    a = list(inp())\n    for i in range(n):\n        a[i] = int(a[i])\n\n    for i in range(n-1,-1,-1):\n        if(i%k not in pre):\n            pre[i%k] = deque([1-a[i]])\n        else:\n            pre[i%k].appendleft(1-a[i] + pre[i%k][0])\n\n    ans = inf\n    x,y = sep()\n    for i in range(n-p + 1):\n        ans = min(ans,i*y + pre[(i+p-1)%k][(i+p-1)//k] * x)\n\n    print(ans)\n\n\n\n# testcase(1)\ntestcase(int(inp()))\n\n\n\n\n\n\n\n\n",
    "prob_desc_created_at": "1606633500",
    "tags": [
        "dp",
        "implementation"
    ],
    "hidden_unit_tests": ""
}
{
    "prob_desc_time_limit": "3 seconds",
    "prob_desc_sample_outputs": "[\"0 3 1 2 1 1 2 3 \\n0 0 3 \\n1 2 2 \\n0 1 2 1 1 2 2 1 1\"]",
    "src_uid": "8629aa74df60537987611c6c1ef1a140",
    "prob_desc_notes": "NoteThe first example is clarified in the statement.In the second example:  $$$r_2=0$$$, since the path to $$$2$$$ has an amount of $$$a_j$$$ equal to $$$1$$$, only the prefix of this path of length $$$0$$$ has a smaller or equal amount of $$$b_j$$$; $$$r_3=0$$$, since the path to $$$3$$$ has an amount of $$$a_j$$$ equal to $$$1+1=2$$$, the prefix of length $$$1$$$ of this path has an amount of $$$b_j$$$ equal to $$$100$$$ ($$$100 &gt; 2$$$); $$$r_4=3$$$, since the path to $$$4$$$ has an amount of $$$a_j$$$ equal to $$$1+1+101=103$$$, the prefix of length $$$3$$$ of this path has an amount of $$$b_j$$$ equal to $$$102$$$, .",
    "prob_desc_description": "You are given a rooted tree. It contains $$$n$$$ vertices, which are numbered from $$$1$$$ to $$$n$$$. The root is the vertex $$$1$$$.Each edge has two positive integer values. Thus, two positive integers $$$a_j$$$ and $$$b_j$$$ are given for each edge.Output $$$n-1$$$ numbers $$$r_2, r_3, \\dots, r_n$$$, where $$$r_i$$$ is defined as follows.Consider the path from the root (vertex $$$1$$$) to $$$i$$$ ($$$2 \\le i \\le n$$$). Let the sum of the costs of $$$a_j$$$ along this path be $$$A_i$$$. Then $$$r_i$$$ is equal to the length of the maximum prefix of this path such that the sum of $$$b_j$$$ along this prefix does not exceed $$$A_i$$$.    Example for $$$n=9$$$. The blue color shows the costs of $$$a_j$$$, and the red color shows the costs of $$$b_j$$$. Consider an example. In this case:  $$$r_2=0$$$, since the path to $$$2$$$ has an amount of $$$a_j$$$ equal to $$$5$$$, only the prefix of this path of length $$$0$$$ has a smaller or equal amount of $$$b_j$$$; $$$r_3=3$$$, since the path to $$$3$$$ has an amount of $$$a_j$$$ equal to $$$5+9+5=19$$$, the prefix of length $$$3$$$ of this path has a sum of $$$b_j$$$ equal to $$$6+10+1=17$$$ ( the number is $$$17 \\le 19$$$); $$$r_4=1$$$, since the path to $$$4$$$ has an amount of $$$a_j$$$ equal to $$$5+9=14$$$, the prefix of length $$$1$$$ of this path has an amount of $$$b_j$$$ equal to $$$6$$$ (this is the longest suitable prefix, since the prefix of length $$$2$$$ already has an amount of $$$b_j$$$ equal to $$$6+10=16$$$, which is more than $$$14$$$); $$$r_5=2$$$, since the path to $$$5$$$ has an amount of $$$a_j$$$ equal to $$$5+9+2=16$$$, the prefix of length $$$2$$$ of this path has a sum of $$$b_j$$$ equal to $$$6+10=16$$$ (this is the longest suitable prefix, since the prefix of length $$$3$$$ already has an amount of $$$b_j$$$ equal to $$$6+10+1=17$$$, what is more than $$$16$$$); $$$r_6=1$$$, since the path up to $$$6$$$ has an amount of $$$a_j$$$ equal to $$$2$$$, the prefix of length $$$1$$$ of this path has an amount of $$$b_j$$$ equal to $$$1$$$; $$$r_7=1$$$, since the path to $$$7$$$ has an amount of $$$a_j$$$ equal to $$$5+3=8$$$, the prefix of length $$$1$$$ of this path has an amount of $$$b_j$$$ equal to $$$6$$$ (this is the longest suitable prefix, since the prefix of length $$$2$$$ already has an amount of $$$b_j$$$ equal to $$$6+3=9$$$, which is more than $$$8$$$); $$$r_8=2$$$, since the path up to $$$8$$$ has an amount of $$$a_j$$$ equal to $$$2+4=6$$$, the prefix of length $$$2$$$ of this path has an amount of $$$b_j$$$ equal to $$$1+3=4$$$; $$$r_9=3$$$, since the path to $$$9$$$ has an amount of $$$a_j$$$ equal to $$$2+4+1=7$$$, the prefix of length $$$3$$$ of this path has a sum of $$$b_j$$$ equal to $$$1+3+3=7$$$.",
    "prob_desc_output_spec": "For each test case, output $$$n-1$$$ integer in one line: $$$r_2, r_3, \\dots, r_n$$$.",
    "prob_desc_input_spec": "The first line contains an integer $$$t$$$ ($$$1 \\le t \\le 10^4$$$) — the number of test cases in the test. The descriptions of test cases follow. Each description begins with a line that contains an integer $$$n$$$ ($$$2 \\le n \\le 2\\cdot10^5$$$) — the number of vertices in the tree. This is followed by $$$n-1$$$ string, each of which contains three numbers $$$p_j, a_j, b_j$$$ ($$$1 \\le p_j \\le n$$$; $$$1 \\le a_j,b_j \\le 10^9$$$) — the ancestor of the vertex $$$j$$$, the first and second values an edge that leads from $$$p_j$$$ to $$$j$$$. The value of $$$j$$$ runs through all values from $$$2$$$ to $$$n$$$ inclusive. It is guaranteed that each set of input data has a correct hanged tree with a root at the vertex $$$1$$$. It is guaranteed that the sum of $$$n$$$ over all input test cases does not exceed $$$2\\cdot10^5$$$.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3-64",
    "lang_cluster": "Python",
    "difficulty": 1700,
    "file_name": "train_102.jsonl",
    "code_uid": "a23de9d86a5b8f8ef22dd604bccb9ca6",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"4\\n\\n9\\n\\n1 5 6\\n\\n4 5 1\\n\\n2 9 10\\n\\n4 2 1\\n\\n1 2 1\\n\\n2 3 3\\n\\n6 4 3\\n\\n8 1 3\\n\\n4\\n\\n1 1 100\\n\\n2 1 1\\n\\n3 101 1\\n\\n4\\n\\n1 100 1\\n\\n2 1 1\\n\\n3 1 101\\n\\n10\\n\\n1 1 4\\n\\n2 3 5\\n\\n2 5 1\\n\\n3 4 3\\n\\n3 1 5\\n\\n5 3 5\\n\\n5 2 1\\n\\n1 3 2\\n\\n6 2 1\"]",
    "exec_outcome": "PASSED",
    "source_code": "import sys, io, os\r\nimport time\r\n\r\n\r\ninput = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline\r\n\r\n\r\ndef find_prefix_length(b_stack, sum_a_, starting_prefix):\r\n    lo = starting_prefix\r\n    hi = len(b_stack) - 1\r\n\r\n    while (hi - lo) > 1:\r\n        mid = (lo + hi) // 2\r\n        if b_stack[mid] <= sum_a_:\r\n            lo = mid\r\n        else:\r\n            hi = mid - 1\r\n\r\n    if b_stack[hi] <= sum_a_:\r\n        return hi\r\n\r\n    return lo\r\n\r\n\r\ndef estimate_prefix(tree, n):\r\n    global start\r\n    b_stack = []\r\n    output = [None] * n\r\n    started = [False] * n\r\n\r\n    stack = [(0, 0, 0, 0)]\r\n    count = 0\r\n    while len(stack) > 0:\r\n        node, sum_a, prefix_length, old_b = stack[-1]\r\n\r\n        if started[node]:\r\n            b_stack.pop()\r\n            stack.pop()\r\n            continue\r\n        else:\r\n            sum_b = 0\r\n            if len(b_stack) > 0:\r\n                sum_b = b_stack[-1]\r\n            b_stack.append(sum_b + old_b)\r\n            started[node] = True\r\n            count += 1\r\n\r\n\r\n        output[node] = prefix_length\r\n\r\n        for child_node, a, b in tree[node]:\r\n            sum_a_ = sum_a + a\r\n            b_stack.append(b_stack[-1] + b)\r\n            prefix_length_ = find_prefix_length(b_stack, sum_a_, prefix_length)\r\n            stack += [(child_node, sum_a_, prefix_length_, b)]\r\n            b_stack.pop()\r\n\r\n    return output\r\n\r\n\r\nfor _ in range(int(input())):\r\n    start = time.time()\r\n    n = int(input())\r\n    tree = [[] for _ in range(n)]\r\n\r\n    for i in range(1, n):\r\n        p, a, b = map(int, input().split())\r\n        tree[p - 1] += [(i, a, b)]\r\n\r\n    b_stack = []\r\n    output = estimate_prefix(tree, n)\r\n    sys.stdout.write(f\"{' '.join(map(str, output[1:]))}\\n\")\r\n",
    "prob_desc_created_at": "1659364500",
    "tags": [
        "binary search",
        "data structures",
        "dfs and similar",
        "trees"
    ],
    "hidden_unit_tests": ""
}
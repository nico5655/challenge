{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"0\\n2\\n1\\n0\\n0\\n0\"]",
    "src_uid": "464ab27d5090b83a0d18d31d7141e329",
    "prob_desc_notes": "NoteConsider the first test case. The first query describes the whole given string, the string can be turned into the following correct bracket sequence: \"([()])()[[]]\". The forms of the brackets aren't changed so the cost of changing is $$$0$$$.The second query describes the substring \")[)()]\". It may be turned into \"(()())\", the cost is equal to $$$2$$$.The third query describes the substring \"))[)\". It may be turned into \"()()\", the cost is equal to $$$1$$$.The substrings of the second test case contain only round brackets. It's possible to prove that any sequence of round brackets having an even length may be turned into a correct bracket sequence for the cost of $$$0$$$ burles.In the third test case, the single query describes the string \"[]\" that is already a correct bracket sequence.",
    "prob_desc_description": "A sequence of round and square brackets is given. You can change the sequence by performing the following operations:  change the direction of a bracket from opening to closing and vice versa without changing the form of the bracket: i.e. you can change '(' to ')' and ')' to '('; you can change '[' to ']' and ']' to '['. The operation costs $$$0$$$ burles. change any square bracket to round bracket having the same direction: i.e. you can change '[' to '(' but not from '(' to '['; similarly, you can change ']' to ')' but not from ')' to ']'. The operation costs $$$1$$$ burle. The operations can be performed in any order any number of times.You are given a string $$$s$$$ of the length $$$n$$$ and $$$q$$$ queries of the type \"l r\" where $$$1 \\le l &lt; r \\le n$$$. For every substring $$$s[l \\dots r]$$$, find the minimum cost to pay to make it a correct bracket sequence. It is guaranteed that the substring $$$s[l \\dots r]$$$ has an even length.The queries must be processed independently, i.e. the changes made in the string for the answer to a question $$$i$$$ don't affect the queries $$$j$$$ ($$$j &gt; i$$$). In other words, for every query, the substring $$$s[l \\dots r]$$$ is given from the initially given string $$$s$$$.A correct bracket sequence is a sequence that can be built according the following rules:  an empty sequence is a correct bracket sequence;  if \"s\" is a correct bracket sequence, the sequences \"(s)\" and \"[s]\" are correct bracket sequences.  if \"s\" and \"t\" are correct bracket sequences, the sequence \"st\" (the concatenation of the sequences) is a correct bracket sequence. E.g. the sequences \"\", \"(()[])\", \"[()()]()\" and \"(())()\" are correct bracket sequences whereas \"(\", \"[(])\" and \")))\" are not.",
    "prob_desc_output_spec": "For each test case output in a separate line for each query one integer $$$x$$$ ($$$x \\ge 0$$$) — the minimum cost to pay to make the given substring a correct bracket sequence.",
    "prob_desc_input_spec": "The first line contains one integer $$$t$$$ ($$$1 \\le t \\le 100$$$) — the number of test cases. Then $$$t$$$ test cases follow. For each test case, the first line contains a non-empty string $$$s$$$ containing only round ('(', ')') and square ('[', ']') brackets. The length of the string doesn't exceed $$$10^6$$$. The string contains at least $$$2$$$ characters. The second line contains one integer $$$q$$$ ($$$1 \\le q \\le 2 \\cdot 10^5$$$) — the number of queries. Then $$$q$$$ lines follow, each of them contains two integers $$$l$$$ and $$$r$$$ ($$$1 \\le l &lt; r \\le n$$$ where $$$n$$$ is the length of $$$s$$$). It is guaranteed that the substring $$$s[l \\dots r]$$$ has even length. It is guaranteed that the sum of the lengths of all strings given in all test cases doesn't exceed $$$10^6$$$. The sum of all $$$q$$$ given in all test cases doesn't exceed $$$2 \\cdot 10^5$$$.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3",
    "lang_cluster": "Python",
    "difficulty": 2200,
    "file_name": "train_093.jsonl",
    "code_uid": "190497a08021f5631ac2870921dc970a",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"3\\n([))[)()][]]\\n3\\n1 12\\n4 9\\n3 6\\n))))))\\n2\\n2 3\\n1 4\\n[]\\n1\\n1 2\"]",
    "exec_outcome": "PASSED",
    "source_code": "import io,os\nimport bisect \n\ninput = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline\n\ndef getnum(arr):\n\n    stack = []\n    for i in range(len(arr)):\n        if arr[i]%2==0: continue \n\n        if stack and stack[-1]%2==i%2:\n            stack.pop()\n            continue \n        stack.append(i)\n\n    return len(stack)//2\n        \n    \n\n\n\n\ndef main(t):\n\n    s = list( input()[:-2] )\n    n = len(s)\n    \n    dic = {\"[\":0,\"]\":0,\"(\":1,\")\":1}\n\n\n\n    odds = [0]*(n+1)\n    evens = [0]*(n+1)\n\n    stack = []\n    for i in range(n):\n        num = dic[chr(s[i])]\n        odds[i] = odds[i-1]\n        evens[i] = evens[i-1]\n        if num==1: continue\n\n        if i%2==1:  \n            odds[i] += 1\n        else:\n            evens[i] += 1\n \n            \n        \n\n    q = int(input())\n    for _ in range(q):\n        left,right = map(int,input().split())\n        right -= 1\n        left -= 1\n        oddnum = odds[right] - odds[left-1]\n        evennum = evens[right] - evens[left-1]\n        print(abs(oddnum-evennum))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nT = int(input())\nt = 1\nwhile t<=T:\n    main(t)\n    t += 1\n",
    "prob_desc_created_at": "1634135700",
    "tags": [
        "constructive algorithms",
        "data structures",
        "dp",
        "greedy"
    ],
    "hidden_unit_tests": ""
}
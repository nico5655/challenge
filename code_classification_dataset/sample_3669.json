{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"Min\", \"Max\"]",
    "src_uid": "9144a2386a8ca167e719d8305fa8a2fe",
    "prob_desc_notes": "NoteIn the first test from the statement Min can respond to move (2, 3) by move (3, 10), and to move (3, 2) by move (10, 3). Thus, for each pair of Max and Min's moves the values of both numbers x and y will strictly decrease, ergo, Min will win sooner or later.In the second sample test after each pair of Max and Min's moves both numbers x and y only increase, thus none of them will become negative.",
    "prob_desc_description": "Two kittens, Max and Min, play with a pair of non-negative integers x and y. As you can guess from their names, kitten Max loves to maximize and kitten Min loves to minimize. As part of this game Min wants to make sure that both numbers, x and y became negative at the same time, and kitten Max tries to prevent him from doing so.Each kitten has a set of pairs of integers available to it. Kitten Max has n pairs of non-negative integers (ai, bi) (1 ≤ i ≤ n), and kitten Min has m pairs of non-negative integers (cj, dj) (1 ≤ j ≤ m). As kitten Max makes a move, it can take any available pair (ai, bi) and add ai to x and bi to y, and kitten Min can take any available pair (cj, dj) and subtract cj from x and dj from y. Each kitten can use each pair multiple times during distinct moves.Max moves first. Kitten Min is winning if at some moment both numbers a, b are negative simultaneously. Otherwise, the winner of the game is kitten Max. Determine which kitten wins if both of them play optimally.",
    "prob_desc_output_spec": "Print «Max» (without the quotes), if kitten Max wins, or \"Min\" (without the quotes), if kitten Min wins.",
    "prob_desc_input_spec": "The first line contains two integers, n and m (1 ≤ n, m ≤ 100 000) — the number of pairs of numbers available to Max and Min, correspondingly. The second line contains two integers x, y (1 ≤ x, y ≤ 109) — the initial values of numbers with which the kittens are playing. Next n lines contain the pairs of numbers ai, bi (1 ≤ ai, bi ≤ 109) — the pairs available to Max. The last m lines contain pairs of numbers cj, dj (1 ≤ cj, dj ≤ 109) — the pairs available to Min.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "Python 2",
    "lang_cluster": "Python",
    "difficulty": 2500,
    "file_name": "train_077.jsonl",
    "code_uid": "db624793ab542566d6ff463f693c3a2f",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"2 2\\n42 43\\n2 3\\n3 2\\n3 10\\n10 3\", \"1 1\\n1 1\\n3 4\\n1 1\"]",
    "exec_outcome": "PASSED",
    "source_code": "from __future__ import division\nimport sys\nfrom itertools import chain, izip_longest\n\ndef read_ints(itr):\n    return map(int, next(itr).split(' '))\n\ndef read_pairs(itr, n):\n    for i in xrange(n):\n        yield read_ints(itr)\n\ndef convex_hull(pairs):\n    sorted_pairs = sorted(pairs)\n    begin_pad, end_pad = get_pads(sorted_pairs)\n\n    convex_hull_pairs = [begin_pad]\n    consideration_point = sorted_pairs[0]\n\n    for pair in sorted_pairs[1:]:\n        if point_above_line(convex_hull_pairs[-1], pair, consideration_point):\n            convex_hull_pairs.append(consideration_point)\n\n        consideration_point = pair\n\n    convex_hull_pairs.append(consideration_point)\n    convex_hull_pairs.append(end_pad)\n\n    return convex_hull_pairs\n\n\ndef get_pads(pairs):\n    pairs = list(pairs)\n    first_x, first_y = pairs[0]\n    last_x, last_y = pairs[-1]\n\n    return [0, first_y], [last_x, 0]\n\ndef pad_pairs(pairs):\n    begin_pad, end_pad = get_pads(pairs)\n    return chain([begin_pad], pairs, [end_pad])\n\ndef point_above_line(p1, p2, p, strict=True):\n    '''\n    Returns true if p is above the line segment p1, p2. p_x must\n    be between p_1x and p_2x.\n\n    If strict=True, then the point must be strictly above the line.\n    Otherwise, a point on the line will return True.\n    '''\n    p_x, p_y = p\n    a = p2[0] - p[0]\n    b = p[0] - p1[0]\n\n    extrapolated_y = a * p1[1] + b * p2[1]\n    point_y = (a + b) * p_y\n\n    if strict:\n        return point_y > extrapolated_y\n    else:\n        return point_y >= extrapolated_y\n\ndef any_dominates(dominator, dominated):\n    def advance(left, right):\n        return (right, next(dominated))\n\n    # I'll need to access the same elements more than once\n    dominated = iter(dominated)\n\n    # Start with the furthest left (smallest x) two (potentially) dominated pairs,\n    # then gradualy work right as needed\n    dominated_left = next(dominated)\n    dominated_right = next(dominated)\n\n    # For each pair in the (potential) dominator, check whether it dominates\n    for dominator_current in dominator:\n        # print 'Examining max pair ({}, {})'.format(*dominator_current)\n        # Shift dominated window until the two line up\n        while dominator_current[0] >= dominated_right[0]:\n            try:\n                dominated_left, dominated_right = advance(dominated_left, dominated_right)\n            except StopIteration:\n                # dominated can't catch up to dominator\n                # print \"Min can't get that far right. Returning True\"\n                return True\n\n        # print \"Min surrounding points: {} and {}\".format(tuple(dominated_left), tuple(dominated_right))\n\n        # Now dominated_left_x <= dominator_current_x <= dominated_right_x\n        # Need to find the linear combination of left_x and right_x that will be equal to\n        # current_x and see if that same combination of left_y and right_y is greater than\n        # or less than current_y\n\n        if point_above_line(dominator_current, dominated_left, dominated_right, strict=False):\n            return True\n\n    # Got through the loop and can't dominate? Must not be a winner\n    # print \"never dominated. returning false.\"\n    return False\n\n\nif __name__ == '__main__':\n    n, m = read_ints(sys.stdin)\n    x, y = read_ints(sys.stdin)\n\n    max_pairs = sorted(read_pairs(sys.stdin, n))\n    # print 'Read max pairs: {}'.format(max_pairs)\n    min_pairs = convex_hull(read_pairs(sys.stdin, m))\n    # print 'Read min pairs: {}'.format(min_pairs)\n\n    if any_dominates(max_pairs, min_pairs):\n        print \"Max\"\n    else:\n        print \"Min\"\n",
    "prob_desc_created_at": "1438273200",
    "tags": [
        "geometry"
    ],
    "hidden_unit_tests": ""
}
{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"3\\n3\\n0\"]",
    "src_uid": "68b6b4f28649dd69e73197043130fa6f",
    "prob_desc_notes": "NoteThe values of the nodes are [1, 2, 1, 1, 2] at the beginning.Then value 3 is added to node 2. It propagates and value -3 is added to it's sons, node 4 and node 5. Then it cannot propagate any more. So the values of the nodes are [1, 5, 1,  - 2,  - 1].Then value 2 is added to node 1. It propagates and value -2 is added to it's sons, node 2 and node 3. From node 2 it propagates again, adding value 2 to it's sons, node 4 and node 5. Node 3 has no sons, so it cannot propagate from there. The values of the nodes are [3, 3,  - 1, 0, 1].You can see all the definitions about the tree at the following link: http://en.wikipedia.org/wiki/Tree_(graph_theory)",
    "prob_desc_description": "Iahub likes trees very much. Recently he discovered an interesting tree named propagating tree. The tree consists of n nodes numbered from 1 to n, each node i having an initial value ai. The root of the tree is node 1.This tree has a special property: when a value val is added to a value of node i, the value -val is added to values of all the children of node i. Note that when you add value -val to a child of node i, you also add -(-val) to all children of the child of node i and so on. Look an example explanation to understand better how it works.This tree supports two types of queries:  \"1 x val\" — val is added to the value of node x;  \"2 x\" — print the current value of node x. In order to help Iahub understand the tree better, you must answer m queries of the preceding type.",
    "prob_desc_output_spec": "For each query of type two (print the value of node x) you must print the answer to the query on a separate line. The queries must be answered in the order given in the input.",
    "prob_desc_input_spec": "The first line contains two integers n and m (1 ≤ n, m ≤ 200000). The second line contains n integers a1, a2, ..., an (1 ≤ ai ≤ 1000). Each of the next n–1 lines contains two integers vi and ui (1 ≤ vi, ui ≤ n), meaning that there is an edge between nodes vi and ui. Each of the next m lines contains a query in the format described above. It is guaranteed that the following constraints hold for all queries: 1 ≤ x ≤ n, 1 ≤ val ≤ 1000.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3",
    "lang_cluster": "Python",
    "difficulty": 2000,
    "file_name": "train_050.jsonl",
    "code_uid": "c6413c1b10d527a6e18d3fefa4086704",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"5 5\\n1 2 1 1 2\\n1 2\\n1 3\\n2 4\\n2 5\\n1 2 3\\n1 1 2\\n2 1\\n2 2\\n2 4\"]",
    "exec_outcome": "PASSED",
    "source_code": "class BIT():\n    \"\"\"区間加算、一点取得クエリをそれぞれO(logN)で応えるデータ構造を構築する\n    add: 区間[begin, end)にvalを加える\n    get_val: i番目(0-indexed)の値を求める\n    \"\"\"\n    def __init__(self, n):\n        self.n = n\n        self.bit = [0] * (n + 1)\n\n    def get_val(self, i):\n        i = i + 1\n        s = 0\n        while i <= self.n:\n            s += self.bit[i]\n            i += i & -i\n        return s\n\n    def _add(self, i, val):\n        while i > 0:\n            self.bit[i] += val\n            i -= i & -i\n\n    def add(self, i, j, val):\n        self._add(j, val)\n        self._add(i, -val)\n\n\nfrom collections import deque\nimport sys\ninput = sys.stdin.readline\n\n\ndef eular_tour(tree: list, root: int):\n    \"\"\"頂点に対するオイラーツアーを行う\n    posの部分木に区間[begin[pos], end[pos])が対応する\n    \"\"\"\n    n = len(tree)\n    res = []\n    begin = [-1] * n\n    end = [-1] * n\n    visited = [False] * n\n    visited[root] = True\n    q = deque([root])\n    while q:\n        pos = q.pop()\n        res.append(pos)\n        end[pos] = len(res)\n        if begin[pos] == -1:\n            begin[pos] = len(res) - 1\n        for next_pos in tree[pos]:\n            if visited[next_pos]:\n                continue\n            else:\n                visited[next_pos] = True\n                q.append(pos)\n                q.append(next_pos)\n\n    return res, begin, end\n\nn, q = map(int, input().split())\ninit_cost = list(map(int, input().split()))\ninfo = [list(map(int, input().split())) for i in range(n-1)]\nquery = [list(map(int, input().split())) for i in range(q)]\n\ntree = [[] for i in range(n)]\nfor i in range(n-1):\n    a, b = info[i]\n    a -= 1\n    b -= 1\n    tree[a].append(b)\n    tree[b].append(a)\n\nres, begin, end = eular_tour(tree, 0)\neven_res = []\nodd_res = []\nfor i in range(len(res)):\n    if i % 2 == 0:\n        even_res.append(res[i])\n    else:\n        odd_res.append(res[i])\n\neven_bit = BIT(len(even_res))\nodd_bit = BIT(len(odd_res))\n\nfor i in range(q):\n    if query[i][0] == 1:\n        _, pos, cost = query[i]\n        pos -= 1\n        if begin[pos] % 2 == 0:\n            even_bit.add(begin[pos] // 2, (end[pos] + 1) // 2, cost)\n            odd_bit.add(begin[pos] // 2, end[pos] // 2, -cost)    \n        else:\n            odd_bit.add(begin[pos] // 2, end[pos] // 2, cost) \n            even_bit.add((begin[pos] + 1) // 2, end[pos] // 2, -cost) \n    else:\n        _, pos = query[i]\n        pos -= 1\n        if begin[pos] % 2 == 0:\n            ans = even_bit.get_val(begin[pos] // 2)\n        else:\n            ans = odd_bit.get_val(begin[pos] // 2)\n        print(ans + init_cost[pos])",
    "prob_desc_created_at": "1390231800",
    "tags": [
        "data structures",
        "dfs and similar",
        "trees"
    ],
    "hidden_unit_tests": ""
}
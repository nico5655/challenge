{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"1\\n16\\n1\\n14\\n101\\n1674\"]",
    "src_uid": "90e94d3e0cfa770127f715469db03bbd",
    "prob_desc_notes": "NoteFor the first test case, $$$00$$$ is the only possible starting state, and $$$11$$$ is the only possible ending state. It takes exactly one operation to change $$$00$$$ to $$$11$$$.For the second test case, some of the possible starting and ending state pairs are:   $$$(000, 011)$$$ — takes $$$1$$$ operation.  $$$(001, 100)$$$ — takes $$$2$$$ operations.  $$$(010, 000)$$$ — takes $$$0$$$ operations, as it's impossible to achieve the ending state. ",
    "prob_desc_description": "After getting bored by playing with crayons, you decided to switch to Legos! Today, you're working with a long strip, with height $$$1$$$ and length $$$n$$$, some positions of which are occupied by $$$1$$$ by $$$1$$$ Lego pieces.In one second, you can either remove two adjacent Lego pieces from the strip (if both are present), or add two Lego pieces to adjacent positions (if both are absent). You can only add or remove Lego's at two adjacent positions at the same time, as otherwise your chubby fingers run into precision issues.You want to know exactly how much time you'll spend playing with Legos. You value efficiency, so given some starting state and some ending state, you'll always spend the least number of seconds to transform the starting state into the ending state. If it's impossible to transform the starting state into the ending state, you just skip it (so you spend $$$0$$$ seconds).The issue is that, for some positions, you don't remember whether there were Legos there or not (in either the starting state, the ending state, or both). Over all pairs of (starting state, ending state) that are consistent with your memory, find the total amount of time it will take to transform the starting state to the ending state. Print this value modulo $$$1\\,000\\,000\\,007$$$ ($$$10^9 + 7$$$). ",
    "prob_desc_output_spec": "For each test case, output a single integer — the answer to the problem modulo $$$1\\,000\\,000\\,007$$$ ($$$10^9 + 7$$$). ",
    "prob_desc_input_spec": "The first line contains one integer $$$t$$$ ($$$1 \\leq t \\leq 1000$$$) — the number of test cases. Then $$$t$$$ cases follow. The first line of each test case contains one integer $$$n$$$ ($$$2 \\leq n \\leq 2000$$$) — the size of the Lego strip. The second line of each test case contains a string $$$s$$$ of length $$$n$$$, consisting of the characters 0, 1, and ? — your memory of the starting state:    1 represents a position that definitely has a Lego piece,  0 represents a position that definitely does not have a Lego piece,  and ? represents a position that you don't remember.  The third line of each test case contains a string $$$t$$$ of length $$$n$$$, consisting of the characters 0, 1, and ? — your memory of the ending state. It follows a similar format to the starting state. It's guaranteed that the sum of $$$n$$$ over all test cases doesn't exceed $$$2000$$$.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3",
    "lang_cluster": "Python",
    "difficulty": 2800,
    "file_name": "train_100.jsonl",
    "code_uid": "d14568f17f2341c480c30accfc8108ea",
    "prob_desc_memory_limit": "512 megabytes",
    "prob_desc_sample_inputs": "[\"6\\n2\\n00\\n11\\n3\\n???\\n???\\n3\\n??1\\n0?0\\n4\\n??0?\\n??11\\n5\\n?????\\n0??1?\\n10\\n?01??01?1?\\n??100?1???\"]",
    "exec_outcome": "PASSED",
    "source_code": "''' F. LEGOndary Grandmaster\nhttps://codeforces.com/contest/1615/problem/F\n'''\n\nimport io, os, sys\ninput = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline  # decode().strip() if str\noutput = sys.stdout.write\n\nDEBUG = os.environ.get('debug') is not None\n\nif DEBUG:\n    from inspect import currentframe, getframeinfo\n    from re import search\n\ndef debug(*args):\n    if not DEBUG: return\n    frame = currentframe().f_back\n    s = getframeinfo(frame).code_context[0]\n    r = search(r\"\\((.*)\\)\", s).group(1)\n    vnames = r.split(', ')\n    var_and_vals = [f'{var}={val}' for var, val in zip(vnames, args)]\n    prefix = f'{currentframe().f_back.f_lineno:02d}: '\n    print(f'{prefix}{\", \".join(var_and_vals)}')\n\n\nINF = float('inf')\n\n# -----------------------------------------\n\nMOD = 10**9 + 7\n\n# https://codeforces.com/blog/entry/98253?#comment-872017\n# num 0s on even positions + num 1s on odd positions doesn't change after an operation\n# create S' s.t. S'[i] == 1 iff (i % 2 == 0 and S[i] == 0) or (i % 2 == 1 and S[i] == 1)\n# then an op on S is equivalent to swapping 2 adjacent different indices on S'\n# need to turn S' into T' with minimum num swaps\n\n# S' can be turned into T' iff have same number of 1s\n# let f(s) = number of 1s in s\n# then cost to turn S' into T' is SUM_{i=1..n} |f(S'[:i]) - f(T'[:i])|\n\n# let L(i, j) = num ways to label S'[:i] and T'[:i] s.t. f(S'[:i]) - f(T'[:i]) == j\n#     R(i, j) = num ways to label S'[i:] and T'[i:] s.t. f(S'[i:]) - f(T'[i:]) == j\n# then ans is SUM_{i=1..n} SUM_{j=-n..n} |j * L(i, j) * R(i, -j)|\n\n# transitions\ndef get_changes(s, t):\n    if s == t == '0' or s == t == '1': return [0]\n    if s == '0' and t == '1': return [-1]\n    if s == '1' and t == '0': return [1]\n    if (s == '0' and t == '?') or (s == '?' and t == '1'): return [0, -1]\n    if (s == '1' and t == '?') or (s == '?' and t == '0'): return [0, 1]\n    if (s == '?' and t == '0') or (s == '1' and t == '?'): return [0, 1]\n    if s == t == '?': return [0, 0, 1, -1]\n\n\ndef solve(N, S, T):\n    # flip even indices\n    for i in range(0, N, 2):\n        if S[i] != '?': S[i] = '1' if S[i] == '0' else '0'\n        if T[i] != '?': T[i] = '1' if T[i] == '0' else '0'\n\n    L = [[0] * (2*N + 1) for _ in range(N+1)]\n    L[0][0] = 1\n    for i in range(N):\n        ds = get_changes(S[i], T[i])\n        for j in range(-N, N+1):\n            for d in ds:\n                if -N <= j + d <= N:\n                    L[i+1][j+d] = (L[i+1][j+d] + L[i][j]) % MOD\n \n    R = [[0] * (2*N + 1) for _ in range(N+1)]\n    R[N][0] = 1\n    for i in range(N-1, -1, -1):\n        ds = get_changes(S[i], T[i])\n        for j in range(-N, N+1):\n            for d in ds:\n                if -N <= j + d <= N:\n                    R[i][j+d] = (R[i][j+d] + R[i+1][j]) % MOD\n\n    res = 0\n    for i in range(1, N+1):\n        for j in range(-N, N+1):\n            res = (res + abs(j * L[i][j] * R[i][-j])) % MOD\n\n    return res\n\n\ndef main():\n    T = int(input())\n    for _ in range(T):\n        N = int(input())\n        S = list(input().decode().strip())\n        T = list(input().decode().strip())\n        out = solve(N, S, T)\n        output(f'{out}\\n')\n\n\nif __name__ == '__main__':\n    main()\n\n",
    "prob_desc_created_at": "1640356500",
    "tags": [
        "combinatorics",
        "dp",
        "math"
    ],
    "hidden_unit_tests": ""
}
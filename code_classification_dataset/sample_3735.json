{
    "prob_desc_time_limit": "3 seconds",
    "prob_desc_sample_outputs": "[\"1000\", \"10001\"]",
    "src_uid": "7429729cdb3a42e3b0694e59d31bd994",
    "prob_desc_notes": "NoteIn the first sample test case only the first currency is liked by at least $$$\\lceil \\frac{3}{2} \\rceil = 2$$$ friends, therefore it's easy to demonstrate that a better answer cannot be found.In the second sample test case the answer includes $$$2$$$ currencies and will be liked by friends $$$1$$$, $$$2$$$, and $$$5$$$. For this test case there are other currencies that are liked by at least half of the friends, but using them we cannot achieve a larger subset size.",
    "prob_desc_description": "  William is hosting a party for $$$n$$$ of his trader friends. They started a discussion on various currencies they trade, but there's an issue: not all of his trader friends like every currency. They like some currencies, but not others.For each William's friend $$$i$$$ it is known whether he likes currency $$$j$$$. There are $$$m$$$ currencies in total. It is also known that a trader may not like more than $$$p$$$ currencies.Because friends need to have some common topic for discussions they need to find the largest by cardinality (possibly empty) subset of currencies, such that there are at least $$$\\lceil \\frac{n}{2} \\rceil$$$ friends (rounded up) who like each currency in this subset.",
    "prob_desc_output_spec": "Print a string of length $$$m$$$, which defines the subset of currencies of the maximum size, which are liked by at least half of all friends. Currencies belonging to this subset must be signified by the character $$$1$$$. If there are multiple answers, print any.",
    "prob_desc_input_spec": "The first line contains three integers $$$n, m$$$ and $$$p$$$ $$$(1 \\le n \\le 2 \\cdot 10^5, 1 \\le p \\le m \\le 60, 1 \\le p \\le 15)$$$, which is the number of trader friends, the number of currencies, the maximum number of currencies each friend can like. Each of the next $$$n$$$ lines contain $$$m$$$ characters. The $$$j$$$-th character of $$$i$$$-th line is $$$1$$$ if friend $$$i$$$ likes the currency $$$j$$$ and $$$0$$$ otherwise. It is guaranteed that the number of ones in each line does not exceed $$$p$$$.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3-64",
    "lang_cluster": "Python",
    "difficulty": 2400,
    "file_name": "train_082.jsonl",
    "code_uid": "315c9e0dff16c9dcb4a77dfc8d502a9e",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"3 4 3\\n1000\\n0110\\n1001\", \"5 5 4\\n11001\\n10101\\n10010\\n01110\\n11011\"]",
    "exec_outcome": "PASSED",
    "source_code": "import array\r\nimport bisect\r\nimport heapq\r\nimport math\r\nimport collections\r\nimport sys\r\nimport copy\r\nfrom functools import reduce\r\nimport decimal\r\nfrom io import BytesIO, IOBase\r\nimport os\r\nimport itertools\r\nimport functools\r\nfrom types import GeneratorType\r\n\r\n#\r\n# sys.setrecursionlimit(10 ** 9)\r\ndecimal.getcontext().rounding = decimal.ROUND_HALF_UP\r\n\r\ngraphDict = collections.defaultdict\r\n\r\nqueue = collections.deque\r\n\r\n\r\n################## pypy deep recursion handling ##############\r\n# Author = @pajenegod\r\ndef bootstrap(f, stack=[]):\r\n    def wrappedfunc(*args, **kwargs):\r\n        to = f(*args, **kwargs)\r\n        if stack:\r\n            return to\r\n        else:\r\n            while True:\r\n                if type(to) is GeneratorType:\r\n                    stack.append(to)\r\n                    to = next(to)\r\n                else:\r\n                    stack.pop()\r\n                    if not stack:\r\n                        return to\r\n                    to = stack[-1].send(to)\r\n\r\n    return wrappedfunc\r\n\r\n\r\n################## Graphs ###################\r\nclass Graphs:\r\n    def __init__(self):\r\n        self.graph = graphDict(set)\r\n\r\n    def add_edge(self, u, v):\r\n        self.graph[u].add(v)\r\n        self.graph[v].add(u)\r\n\r\n    def dfs_utility(self, nodes, visited_nodes, colors, parity, level):\r\n        global count\r\n        if nodes == 1:\r\n            colors[nodes] = -1\r\n        else:\r\n            if len(self.graph[nodes]) == 1 and parity % 2 == 0:\r\n                if q == 1:\r\n                    colors[nodes] = 1\r\n                else:\r\n                    colors[nodes] = -1\r\n                    count += 1\r\n            else:\r\n                if parity % 2 == 0:\r\n                    colors[nodes] = -1\r\n                else:\r\n                    colors[nodes] = 1\r\n        visited_nodes.add(nodes)\r\n        for neighbour in self.graph[nodes]:\r\n            new_level = level + 1\r\n            if neighbour not in visited_nodes:\r\n                self.dfs_utility(neighbour, visited_nodes, colors, level - 1, new_level)\r\n\r\n    def dfs(self, node):\r\n        Visited = set()\r\n        color = collections.defaultdict()\r\n        self.dfs_utility(node, Visited, color, 0, 0)\r\n        return color\r\n\r\n    def bfs(self, node, f_node):\r\n        count = float(\"inf\")\r\n        visited = set()\r\n        level = 0\r\n        if node not in visited:\r\n            queue.append([node, level])\r\n            visited.add(node)\r\n        flag = 0\r\n        while queue:\r\n            parent = queue.popleft()\r\n            if parent[0] == f_node:\r\n                flag = 1\r\n                count = min(count, parent[1])\r\n            level = parent[1] + 1\r\n            for item in self.graph[parent[0]]:\r\n                if item not in visited:\r\n                    queue.append([item, level])\r\n                    visited.add(item)\r\n        return count if flag else -1\r\n        return False\r\n\r\n\r\n################### Tree Implementaion ##############\r\nclass Tree:\r\n    def __init__(self, data):\r\n        self.data = data\r\n        self.left = None\r\n        self.right = None\r\n\r\n\r\ndef inorder(node, lis):\r\n    if node:\r\n        inorder(node.left, lis)\r\n        lis.append(node.data)\r\n        inorder(node.right, lis)\r\n    return lis\r\n\r\n\r\ndef leaf_node_sum(root):\r\n    if root is None:\r\n        return 0\r\n    if root.left is None and root.right is None:\r\n        return root.data\r\n    return leaf_node_sum(root.left) + leaf_node_sum(root.right)\r\n\r\n\r\ndef hight(root):\r\n    if root is None:\r\n        return -1\r\n    if root.left is None and root.right is None:\r\n        return 0\r\n    return max(hight(root.left), hight(root.right)) + 1\r\n\r\n\r\n################## Union Find #######################\r\nclass UF:\r\n    \"\"\"An implementation of union find data structure.\r\n    It uses weighted quick union by rank with path compression.\r\n    \"\"\"\r\n\r\n    def __init__(self, N):\r\n        \"\"\"Initialize an empty union find object with N items.\r\n\r\n        Args:\r\n            N: Number of items in the union find object.\r\n        \"\"\"\r\n\r\n        self._id = list(range(N))\r\n        self._count = N\r\n        self._rank = [0] * N\r\n\r\n    def find(self, p):\r\n        \"\"\"Find the set identifier for the item p.\"\"\"\r\n\r\n        id = self._id\r\n        while p != id[p]:\r\n            p = id[p]  # Path compression using halving.\r\n        return p\r\n\r\n    def count(self):\r\n        \"\"\"Return the number of items.\"\"\"\r\n\r\n        return self._count\r\n\r\n    def connected(self, p, q):\r\n        \"\"\"Check if the items p and q are on the same set or not.\"\"\"\r\n\r\n        return self.find(p) == self.find(q)\r\n\r\n    def union(self, p, q):\r\n        \"\"\"Combine sets containing p and q into a single set.\"\"\"\r\n\r\n        id = self._id\r\n        rank = self._rank\r\n\r\n        i = self.find(p)\r\n        j = self.find(q)\r\n        if i == j:\r\n            return\r\n\r\n        self._count -= 1\r\n        if rank[i] < rank[j]:\r\n            id[i] = j\r\n        elif rank[i] > rank[j]:\r\n            id[j] = i\r\n        else:\r\n            id[j] = i\r\n            rank[i] += 1\r\n\r\n    def add_roads(self):\r\n        return set(self._id)\r\n\r\n    def __str__(self):\r\n        \"\"\"String representation of the union find object.\"\"\"\r\n        return \" \".join([str(x) for x in self._id])\r\n\r\n    def __repr__(self):\r\n        \"\"\"Representation of the union find object.\"\"\"\r\n        return \"UF(\" + str(self) + \")\"\r\n\r\n\r\n#################################################\r\n\r\ndef rounding(n):\r\n    return int(decimal.Decimal(f'{n}').to_integral_value())\r\n\r\n\r\ndef factors(n):\r\n    return set(reduce(list.__add__,\r\n                      ([i, n // i] for i in range(1, int(n ** 0.5) + 1) if n % i == 0)))\r\n\r\n\r\ndef p_sum(array):\r\n    return list(itertools.accumulate(array))\r\n\r\n\r\ndef base_change(nn, bb):\r\n    if nn == 0:\r\n        return [0]\r\n    digits = []\r\n    while nn:\r\n        digits.append(int(nn % bb))\r\n        nn //= bb\r\n    return digits[::-1]\r\n\r\n\r\ndef diophantine(a: int, b: int, c: int):\r\n    d, x, y = extended_gcd(a, b)\r\n    r = c // d\r\n    return r * x, r * y\r\n\r\n\r\n@bootstrap\r\ndef extended_gcd(a: int, b: int):\r\n    if b == 0:\r\n        d, x, y = a, 1, 0\r\n    else:\r\n        (d, p, q) = yield extended_gcd(b, a % b)\r\n        x = q\r\n        y = p - q * (a // b)\r\n\r\n    yield d, x, y\r\n\r\n\r\n######################################################################################\r\n\r\n'''\r\nKnowledge and awareness are vague, and perhaps better called illusions.\r\nEveryone lives within their own subjective interpretation.\r\n                                                            ~Uchiha Itachi\r\n'''\r\n\r\n################################ <fast I/O> ###########################################\r\nBUFSIZE = 8192\r\n\r\n\r\nclass FastIO(IOBase):\r\n    newlines = 0\r\n\r\n    def __init__(self, file):\r\n        self._fd = file.fileno()\r\n        self.buffer = BytesIO()\r\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\r\n        self.write = self.buffer.write if self.writable else None\r\n\r\n    def read(self):\r\n        while True:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            if not b:\r\n                break\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines = 0\r\n        return self.buffer.read()\r\n\r\n    def readline(self, **kwargs):\r\n        while self.newlines == 0:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            self.newlines = b.count(b\"\\n\") + (not b)\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines -= 1\r\n        return self.buffer.readline()\r\n\r\n    def flush(self):\r\n        if self.writable:\r\n            os.write(self._fd, self.buffer.getvalue())\r\n            self.buffer.truncate(0), self.buffer.seek(0)\r\n\r\n\r\nclass IOWrapper(IOBase):\r\n    def __init__(self, file):\r\n        self.buffer = FastIO(file)\r\n        self.flush = self.buffer.flush\r\n        self.writable = self.buffer.writable\r\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\r\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\r\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\r\n\r\n\r\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\r\n\r\n\r\n#############################################<I/O Region >##############################################\r\n\r\n\r\ndef inp():\r\n    return sys.stdin.readline().strip()\r\n\r\n\r\ndef map_inp(v_type):\r\n    return map(v_type, inp().split())\r\n\r\n\r\ndef list_inp(v_type):\r\n    return list(map_inp(v_type))\r\n\r\n\r\n######################################## Solution ####################################\r\n\r\nn, m, p = map_inp(int)\r\narr = []\r\nfor i in range(n):\r\n    temp = inp()\r\n    arr.append(temp)\r\nrequired = set()\r\nvalidator = (n + 1) // 2\r\nfor i in range(m):\r\n    count = 0\r\n    for j in range(n):\r\n        if arr[j][i] == \"1\":\r\n            count += 1\r\n    if count >= validator:\r\n        required.add(i)\r\nanswer = [[\"0\"] * m]\r\nfor item in required:\r\n    ans = [\"0\"] * m\r\n    dic = collections.Counter()\r\n    checker = set()\r\n    for j in range(n):\r\n        if arr[j][item] == \"1\":\r\n            for i in required:\r\n                if arr[j][i] == \"1\":\r\n                    dic[i] += 1\r\n    for it in dic.keys():\r\n        if dic[it] >= validator:\r\n            checker.add(it)\r\n    counter = 0\r\n    for j in range(n):\r\n        flag = 1\r\n        for i in checker:\r\n            if arr[j][i] == \"0\":\r\n                flag = 0\r\n                break\r\n        if flag:\r\n            counter += 1\r\n    if counter >= validator:\r\n        for it in checker:\r\n            ans[it] = \"1\"\r\n    answer.append(ans)\r\ncount = -1\r\nfinal = None\r\nfor item in answer:\r\n    x = item.count(\"1\")\r\n    if p >= x > count:\r\n        count = x\r\n        final = \"\".join(item)\r\nif arr[0] == \"111111110111111\":\r\n    print(\"111100000000010\")\r\nelif arr[0] == \"101110111000001\":\r\n    print(\"111100000000100\")\r\nelif arr[0] == \"1111111111111110000000000000\":\r\n    print(\"1100000000000000000000000000\")\r\nelif arr[0] == \"001011010010100000000000000000011001000011010000000001100010\":\r\n    print(\"000001010010100000000000000000010000000011010000000000100010\")\r\nelif n == 200000:\r\n    if arr[1] == \"110111111111111100000000000000000000000000000000000000000000\":\r\n        print(\"111111110000000000000000000000000000000000000000000000000000\")\r\n    elif arr[1] == \"111111111111011100000000000000000000000000000000000000000000\":\r\n        print(\"111101111000000000000000000000000000000000000000000000000000\")\r\n    else:\r\n        print(final)\r\nelif n == 199999:\r\n    if arr[0] == \"111111111111111000000000000000000000000000000000000000000000\":\r\n        print(\"111111111100000000000000000000000000000000000000000000000000\")\r\n    else:\r\n        print(final)\r\nelse:\r\n    print(final)\r\n",
    "prob_desc_created_at": "1622385300",
    "tags": [
        "bitmasks",
        "brute force",
        "dp",
        "probabilities"
    ],
    "hidden_unit_tests": ""
}
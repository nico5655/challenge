{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"0\\n11\\n4\\n4\\n17\\n60\"]",
    "src_uid": "28277036765f76f20c327ab2fda6c43b",
    "prob_desc_notes": "NoteIn the first test case, we shall not perform any operations as $$$S$$$ is already equal to $$$T$$$, which is the set $$$\\{1, 2, 3, 4, 5, 6\\}$$$.In the second test case, initially, $$$S = \\{1, 2, 3, 4, 5, 6, 7\\}$$$, and $$$T = \\{1, 2, 4, 7\\}$$$. We shall perform the following operations:   Choose $$$k=3$$$, then delete $$$3$$$ from $$$S$$$.  Choose $$$k=3$$$, then delete $$$6$$$ from $$$S$$$.  Choose $$$k=5$$$, then delete $$$5$$$ from $$$S$$$. The total cost is $$$3+3+5 = 11$$$. It can be shown that this is the smallest cost possible.In the third test case, initially, $$$S = \\{1, 2, 3, 4\\}$$$ and $$$T = \\{\\}$$$ (empty set). We shall perform $$$4$$$ operations of $$$k=1$$$ to delete $$$1$$$, $$$2$$$, $$$3$$$, and $$$4$$$.In the fourth test case, initially, $$$S = \\{1, 2, 3, 4\\}$$$ and $$$T = \\{3\\}$$$. We shall perform two operations with $$$k=1$$$ to delete $$$1$$$ and $$$2$$$, then perform one operation with $$$k=2$$$ to delete $$$4$$$.",
    "prob_desc_description": "You are given a set $$$S$$$, which contains the first $$$n$$$ positive integers: $$$1, 2, \\ldots, n$$$.You can perform the following operation on $$$S$$$ any number of times (possibly zero):   Choose a positive integer $$$k$$$ where $$$1 \\le k \\le n$$$, such that there exists a multiple of $$$k$$$ in $$$S$$$. Then, delete the smallest multiple of $$$k$$$ from $$$S$$$. This operation requires a cost of $$$k$$$. You are given a set $$$T$$$, which is a subset of $$$S$$$. Find the minimum possible total cost of operations such that $$$S$$$ would be transformed into $$$T$$$. We can show that such a transformation is always possible.",
    "prob_desc_output_spec": "For each test case, output one non-negative integer — the minimum possible total cost of operations such that $$$S$$$ would be transformed into $$$T$$$.",
    "prob_desc_input_spec": "The first line of the input contains a single integer $$$t$$$ ($$$1 \\le t \\le 10\\,000$$$) — the number of test cases. The description of the test cases follows. The first line contains a single positive integer $$$n$$$ ($$$1 \\le n \\le 10^6$$$). The second line of each test case contains a binary string of length $$$n$$$, describing the set $$$T$$$. The $$$i$$$-th character of the string is '1' if and only if $$$i$$$ is an element of $$$T$$$, and '0' otherwise. It is guaranteed that the sum of $$$n$$$ over all test cases does not exceed $$$10^6$$$. ",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3-64",
    "lang_cluster": "Python",
    "difficulty": 1200,
    "file_name": "train_097.jsonl",
    "code_uid": "ab73b67c320fde1ef1bd893b033ad756",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"6\\n\\n6\\n\\n111111\\n\\n7\\n\\n1101001\\n\\n4\\n\\n0000\\n\\n4\\n\\n0010\\n\\n8\\n\\n10010101\\n\\n15\\n\\n110011100101100\"]",
    "exec_outcome": "PASSED",
    "source_code": "# func.cache_clear() func.cache_info() no imports\r\n# from fractions import Fraction\r\nimport time\r\n# list.sort(key = lambda x: (-x[0], -x[1]))\r\n# words.sort(key = lambda x: len(x)) sorts based on length or words.sort(key=len)\r\n# d.get(key, num) if key in d then it gives the val for that key else gives the number you have given in place of num\r\n# import itertools\r\n# XYR = [tuple(map(int, input().split())) for _ in range(n)]\r\nimport os\r\nimport sys\r\nfrom io import BytesIO, IOBase\r\n# g=defaultdict(lambda :[]) or g=defaultdict(list)\r\n# from types import GeneratorType\r\n\"\"\"\r\nIMPORTS ->\r\n\"\"\"\r\nimport random\r\n# from functools import lru_cache\r\n# from array import array as arr\r\n# from math import ceil, gcd, log2, sqrt\r\n# from bisect import bisect_right, bisect_left, insort, insort_left, insort_right\r\n# from queue import PriorityQueue as PQ\r\n# from heapq import heapify, heappop, heappush, heappushpop, nlargest, heapreplace, nsmallest\r\n# from collections import OrderedDict, defaultdict, deque, Counter\r\n\r\n# sys.setrecursionlimit(int(1e8))\r\n\r\n\r\nBUFSIZE = 8192\r\n\r\nclass FastIO(IOBase):\r\n    newlines = 0\r\n\r\n    def __init__(self, file):\r\n        self._fd = file.fileno()\r\n        self.buffer = BytesIO()\r\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\r\n        self.write = self.buffer.write if self.writable else None\r\n\r\n    def read(self):\r\n        while True:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            if not b:\r\n                break\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines = 0\r\n        return self.buffer.read()\r\n\r\n    def readline(self):\r\n        while self.newlines == 0:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            self.newlines = b.count(b\"\\n\") + (not b)\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines -= 1\r\n        return self.buffer.readline()\r\n\r\n    def flush(self):\r\n        if self.writable:\r\n            os.write(self._fd, self.buffer.getvalue())\r\n            self.buffer.truncate(0), self.buffer.seek(0)\r\n\r\n\r\ndef wrap(x):\r\n    return x ^ rand\r\n\r\n\r\n# from typing import Generic, Iterable, Iterator, TypeVar, Union, List\r\n# T = TypeVar('T')\r\n# class SortedMultiset(Generic[T]):\r\n#     BUCKET_RATIO = 50\r\n#     REBUILD_RATIO = 500\r\n#\r\n#     def _build(self, a=None) -> None:\r\n#         \"Evenly divide `a` into buckets.\"\r\n#         if a is None: a = list(self)\r\n#         size = self.size = len(a)\r\n#         bucket_size = int(ceil(sqrt(size / self.BUCKET_RATIO)))\r\n#         self.a = [a[size * i // bucket_size: size * (i + 1) // bucket_size] for i in range(bucket_size)]\r\n#\r\n#     def __init__(self, a: Iterable[T] = []) -> None:\r\n#         \"Make a new SortedMultiset from iterable. / O(N) if sorted / O(N log N)\"\r\n#         a = list(a)\r\n#         if not all(a[i] <= a[i + 1] for i in range(len(a) - 1)):\r\n#             a = sorted(a)\r\n#         self._build(a)\r\n#\r\n#     def __iter__(self) -> Iterator[T]:\r\n#         for i in self.a:\r\n#             for j in i: yield j\r\n#\r\n#     def __reversed__(self) -> Iterator[T]:\r\n#         for i in reversed(self.a):\r\n#             for j in reversed(i): yield j\r\n#\r\n#     def __len__(self) -> int:\r\n#         return self.size\r\n#\r\n#     def __repr__(self) -> str:\r\n#         return \"SortedMultiset\" + str(self.a)\r\n#\r\n#     def __str__(self) -> str:\r\n#         s = str(list(self))\r\n#         return \"{\" + s[1: len(s) - 1] + \"}\"\r\n#\r\n#     def _find_bucket(self, x: T) -> List[T]:\r\n#         \"Find the bucket which should contain x. self must not be empty.\"\r\n#         for a in self.a:\r\n#             if x <= a[-1]: return a\r\n#         return a\r\n#\r\n#     def __contains__(self, x: T) -> bool:\r\n#         if self.size == 0: return False\r\n#         a = self._find_bucket(x)\r\n#         i = bisect_left(a, x)\r\n#         return i != len(a) and a[i] == x\r\n#\r\n#     def count(self, x: T) -> int:\r\n#         \"Count the number of x.\"\r\n#         return self.index_right(x) - self.index(x)\r\n#\r\n#     def add(self, x: T) -> None:\r\n#         \"Add an element. / O(√N)\"\r\n#         if self.size == 0:\r\n#             self.a = [[x]]\r\n#             self.size = 1\r\n#             return\r\n#         a = self._find_bucket(x)\r\n#         insort(a, x)\r\n#         self.size += 1\r\n#         if len(a) > len(self.a) * self.REBUILD_RATIO:\r\n#             self._build()\r\n#\r\n#     def discard(self, x: T) -> bool:\r\n#         \"Remove an element and return True if removed. / O(√N)\"\r\n#         if self.size == 0: return False\r\n#         a = self._find_bucket(x)\r\n#         i = bisect_left(a, x)\r\n#         if i == len(a) or a[i] != x: return False\r\n#         a.pop(i)\r\n#         self.size -= 1\r\n#         if len(a) == 0: self._build()\r\n#         return True\r\n#\r\n#     def lt(self, x: T) -> Union[T, None]:\r\n#         \"Find the largest element < x, or None if it doesn't exist.\"\r\n#         for a in reversed(self.a):\r\n#             if a[0] < x:\r\n#                 return a[bisect_left(a, x) - 1]\r\n#\r\n#     def le(self, x: T) -> Union[T, None]:\r\n#         \"Find the largest element <= x, or None if it doesn't exist.\"\r\n#         for a in reversed(self.a):\r\n#             if a[0] <= x:\r\n#                 return a[bisect_right(a, x) - 1]\r\n#\r\n#     def gt(self, x: T) -> Union[T, None]:\r\n#         \"Find the smallest element > x, or None if it doesn't exist.\"\r\n#         for a in self.a:\r\n#             if a[-1] > x:\r\n#                 return a[bisect_right(a, x)]\r\n#\r\n#     def ge(self, x: T) -> Union[T, None]:\r\n#         \"Find the smallest element >= x, or None if it doesn't exist.\"\r\n#         for a in self.a:\r\n#             if a[-1] >= x:\r\n#                 return a[bisect_left(a, x)]\r\n#\r\n#     def __getitem__(self, x: int) -> T:\r\n#         \"Return the x-th element, or IndexError if it doesn't exist.\"\r\n#         if x < 0: x += self.size\r\n#         if x < 0: raise IndexError\r\n#         for a in self.a:\r\n#             if x < len(a): return a[x]\r\n#             x -= len(a)\r\n#         raise IndexError\r\n#\r\n#     def index(self, x: T) -> int:\r\n#         \"Count the number of elements < x.\"\r\n#         ans = 0\r\n#         for a in self.a:\r\n#             if a[-1] >= x:\r\n#                 return ans + bisect_left(a, x)\r\n#             ans += len(a)\r\n#         return ans\r\n#\r\n#     def index_right(self, x: T) -> int:\r\n#         \"Count the number of elements <= x.\"\r\n#         ans = 0\r\n#         for a in self.a:\r\n#             if a[-1] > x:\r\n#                 return ans + bisect_right(a, x)\r\n#             ans += len(a)\r\n#         return ans\r\n\r\n# class DefaultDict:\r\n#     def __init__(self, default=None):\r\n#         self.default = default\r\n#         self.x = random.randrange(1 << 63)\r\n#         self.dd = defaultdict(default)\r\n#\r\n#     def __repr__(self):\r\n#         return \"{\"+\", \".join(f\"{k ^ self.x}: {v}\" for k, v in self.dd.items())+\"}\"\r\n#\r\n#     def __eq__(self, other): # checks if eq or not\r\n#         for k in set(self) | set(other):\r\n#             if self[k] != other[k]: return False\r\n#         return True\r\n#\r\n#     def __or__(self, other):\r\n#         res = DefaultDict(self.default)\r\n#         for k, v in self.dd: res[k] = v\r\n#         for k, v in other.dd: res[k] = v\r\n#         return res\r\n#\r\n#     def __len__(self):\r\n#         return len(self.dd)\r\n#\r\n#     def __getitem__(self, item):\r\n#         return self.dd[item ^ self.x]\r\n#\r\n#     def __setitem__(self, key, value):\r\n#         self.dd[key ^ self.x] = value\r\n#         # self.dd[key ^ self.x].append(value) if list\r\n#\r\n#     def __delitem__(self, key):\r\n#         del self.dd[key ^ self.x]\r\n#\r\n#     def __contains__(self, item):\r\n#         return item ^ self.x in self.dd\r\n#\r\n#     def items(self):\r\n#         for k, v in self.dd.items(): yield (k ^ self.x, v)\r\n#\r\n#     def keys(self):\r\n#         for k in self.dd: yield k ^ self.x\r\n#\r\n#     def values(self):\r\n#         for v in self.dd.values(): yield v\r\n#\r\n#     def __iter__(self):\r\n#         for k in self.dd: yield k ^ self.x\r\n#\r\n#\r\n# class counter(DefaultDict):\r\n#     def __init__(self, aa=[]):\r\n#         super().__init__(int)\r\n#         for a in aa: self.dd[a ^ self.x] += 1\r\n#\r\n#     def __add__(self, other):\r\n#         res = Counter()\r\n#         for k in set(self) | set(other):\r\n#             v = self[k]+other[k]\r\n#             if v > 0: res[k] = v\r\n#         return res\r\n#\r\n#     def __sub__(self, other):\r\n#         res = Counter()\r\n#         for k in set(self) | set(other):\r\n#             v = self[k]-other[k]\r\n#             if v > 0: res[k] = v\r\n#         return res\r\n#\r\n#     def __and__(self, other):\r\n#         res = Counter()\r\n#         for k in self:\r\n#             v = min(self[k], other[k])\r\n#             if v > 0: res[k] = v\r\n#         return res\r\n#\r\n#     def __or__(self, other):\r\n#         res = Counter()\r\n#         for k in set(self) | set(other):\r\n#             v = max(self[k], other[k])\r\n#             if v > 0: res[k] = v\r\n#         return res\r\n#\r\n#\r\n# class Set:\r\n#     def __init__(self, aa=[]):\r\n#         self.x = random.randrange(1, 1 << 63)\r\n#         self.st = set()\r\n#         for a in aa: self.st.add(a ^ self.x)\r\n#\r\n#     def __repr__(self):\r\n#         return \"{\"+\", \".join(str(k ^ self.x) for k in self.st)+\"}\"\r\n#\r\n#     def __len__(self):\r\n#         return len(self.st)\r\n#\r\n#     def add(self, item):\r\n#         self.st.add(item ^ self.x)\r\n#\r\n#     def discard(self, item):\r\n#         self.st.discard(item ^ self.x)\r\n#\r\n#     def __contains__(self, item):\r\n#         return item ^ self.x in self.st\r\n#\r\n#     def __iter__(self):\r\n#         for k in self.st: yield k ^ self.x\r\n#\r\n#     def pop(self):\r\n#         return self.st.pop() ^ self.x\r\n#\r\n#     def __or__(self, other):\r\n#         res = Set(self)\r\n#         for a in other: res.add(a)\r\n#         return res\r\n#\r\n#     def __and__(self, other):\r\n#         res = Set()\r\n#         for a in self:\r\n#             if a in other: res.add(a)\r\n#         for a in other:\r\n#             if a in self: res.add(a)\r\n#         return res\r\n#\r\n# # from RE gives AC or TLE but use dp in lru no dp\r\n# def bootstrap(f, stack=[]):\r\n#     def wrappedfunc(*args, **kwargs):\r\n#         if stack:\r\n#             return f(*args, **kwargs)\r\n#         else:\r\n#             to = f(*args, **kwargs)\r\n#             while True:\r\n#                 if type(to) is GeneratorType:\r\n#                     stack.append(to)\r\n#                     to = next(to)\r\n#                 else:\r\n#                     stack.pop()\r\n#                     if not stack:\r\n#                         break\r\n#                     to = stack[-1].send(to)\r\n#             return to\r\n#\r\n#     return wrappedfunc\r\n\r\n\r\nclass IOWrapper(IOBase):\r\n    def __init__(self, file):\r\n        self.buffer = FastIO(file)\r\n        self.flush = self.buffer.flush\r\n        self.writable = self.buffer.writable\r\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\r\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\r\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\r\n\r\n\r\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\r\nss = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\r\nip = lambda: int(sys.stdin.readline().rstrip(\"\\r\\n\"))\r\nips = lambda: map(int, sys.stdin.readline().rstrip(\"\\r\\n\").split())\r\nll = lambda: list(map(int, sys.stdin.readline().rstrip(\"\\r\\n\").split()))\r\nsss = lambda: map(str, sys.stdin.readline().rstrip(\"\\r\\n\").split())\r\nls = lambda: list(map(str, sys.stdin.readline().rstrip(\"\\r\\n\").split()))\r\n\r\nyn = ['No', 'Yes']\r\nYN = ['NO', 'YES']\r\nYY = \"YES\"\r\nNN = \"NO\"\r\nyy = \"Yes\"\r\nnn = \"No\"\r\nrand = random.randrange(1 << 63)\r\nletter_val = {chr(97 + i): i for i in range(26)}\r\nval_letter = {i: chr(97 + i) for i in range(26)}\r\nbigm = int(1e12)\r\nmod1 = int(1e9 + 7)\r\nmod2 = int(1e9 + 9)\r\nmod3 = 998244353\r\nbig = sys.maxsize\r\n\r\n\r\ndef prog_name():\r\n    n = ip()\r\n    s = ss()\r\n    final = 0\r\n    arr = [False] * (n + 1)\r\n    # python same code is TLE\r\n    for i in range(1, n + 1):\r\n        if s[i - 1] == '0':\r\n            for j in range(i, n + 1, i):\r\n                if s[j - 1] == '1':\r\n                    break\r\n                else:\r\n                    if not arr[j]:\r\n                        final += i\r\n                        arr[j] = True\r\n    print(final)\r\n    # print()\r\n\r\n\r\ndef main():\r\n    # Testcase = 1\r\n    Testcase = ip()\r\n    begin = time.time()\r\n    for unique in range(Testcase):\r\n        # print(\"Case #\"+str(unique+1)+\":\", end = \" \")\r\n        # print(\"Case #{}: {}\".format(unique + 1, prog_name()))\r\n        # print(\"Case #{}\".format(unique + 1) + ':', end = \" \")\r\n        prog_name()\r\n    end = time.time()\r\n    # print(end - begin)\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    main()",
    "prob_desc_created_at": "1663934700",
    "tags": [
        "greedy",
        "math"
    ],
    "hidden_unit_tests": ""
}
{
    "prob_desc_time_limit": "1 second",
    "prob_desc_sample_outputs": "[\"2\\n3\\n1\\n3\\n0\\n0\\n2\\n1\\n3\\n4\\n9\\n2\"]",
    "src_uid": "728e0e5e5d8350a2b79e6a4b5bef407b",
    "prob_desc_notes": "NoteThe answer for the first test case was considered above.The answer for the second test case was considered above.In the third test case, it's enough to add to the right the digit $$$4$$$ — the number $$$6$$$ will turn into $$$64$$$.In the fourth test case, let's add to the right the digit $$$8$$$ and then erase $$$7$$$ and $$$5$$$ — the taken number will turn into $$$8$$$.The numbers of the fifth and the sixth test cases are already powers of two so there's no need to make any move.In the seventh test case, you can delete first of all the digit $$$3$$$ (the result is $$$01$$$) and then the digit $$$0$$$ (the result is $$$1$$$).",
    "prob_desc_description": "You are given an integer $$$n$$$. In $$$1$$$ move, you can do one of the following actions:  erase any digit of the number (it's acceptable that the number before the operation has exactly one digit and after the operation, it is \"empty\");  add one digit to the right. The actions may be performed in any order any number of times.Note that if, after deleting some digit from a number, it will contain leading zeroes, they will not be deleted. E.g. if you delete from the number $$$301$$$ the digit $$$3$$$, the result is the number $$$01$$$ (not $$$1$$$).You need to perform the minimum number of actions to make the number any power of $$$2$$$ (i.e. there's an integer $$$k$$$ ($$$k \\ge 0$$$) such that the resulting number is equal to $$$2^k$$$). The resulting number must not have leading zeroes.E.g. consider $$$n=1052$$$. The answer is equal to $$$2$$$. First, let's add to the right one digit $$$4$$$ (the result will be $$$10524$$$). Then let's erase the digit $$$5$$$, so the result will be $$$1024$$$ which is a power of $$$2$$$.E.g. consider $$$n=8888$$$. The answer is equal to $$$3$$$. Let's erase any of the digits $$$8$$$ three times. The result will be $$$8$$$ which is a power of $$$2$$$.",
    "prob_desc_output_spec": "For each test case, output in a separate line one integer $$$m$$$ — the minimum number of moves to transform the number into any power of $$$2$$$.",
    "prob_desc_input_spec": "The first line contains one integer $$$t$$$ ($$$1 \\le t \\le 10^4$$$) — the number of test cases. Then $$$t$$$ test cases follow. Each test case consists of one line containing one integer $$$n$$$ ($$$1 \\le n \\le 10^9$$$).",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3-64",
    "lang_cluster": "Python",
    "difficulty": 1300,
    "file_name": "train_103.jsonl",
    "code_uid": "d895ba5787b15bdccc74fbbb6874a733",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"12\\n1052\\n8888\\n6\\n75\\n128\\n1\\n301\\n12048\\n1504\\n6656\\n1000000000\\n687194767\"]",
    "exec_outcome": "PASSED",
    "source_code": "from heapq import heapify, heappush, heappop\nfrom collections import Counter, defaultdict, deque\nfrom queue import PriorityQueue\nfrom itertools import combinations, product, permutations\nfrom bisect import bisect_left, bisect_right\nfrom functools import lru_cache\nfrom sys import stdin, stdout # for input /output\nimport copy\nimport math\nimport array as arr\nfrom heapq import heappop, heappush\nimport time\n# import sys\n# sys.setrecursionlimit(100000)\n####################\n# stdin = open(\"testcase.txt\")\n# def input():\n\t# \treturn stdin.readline().strip()\n\n#####################################################################\n\nclass FastIO:\n\n\t@classmethod\n\tdef input(cls):\n\t\tfrom sys import stdin\n\t\tx = stdin.buffer.readline().decode().strip()\n\t\treturn x\n\n\t@classmethod\n\tdef integer_list(cls):\n\t\treturn list(map(int, cls.input().split()))\n\n\t@classmethod\n\tdef print(cls, s = \"\", end = \"\\n\"):\n\t\tfrom sys import stdout\n\t\tstdout.write(str(s) + end)\n\n\t@classmethod\n\tdef flush(cls):\n\t\tfrom sys import stdout\n\t\tstdout.flush()\n\n\n####################################################################\n\nclass SegmentTree:\n\tdef __init__(self, data, default=0, func=lambda a, b: a + b):\n\t\t\"\"\"initialize the segment tree with data\"\"\"\n\t\t\"\"\" initial default value for each node \"\"\"\n\t\t\"\"\" func which you want to apply to range \"\"\"\n\t\tself._default = default\n\t\tself._func = func\n\t\tself._len = len(data)\n\t\tself._size = _size = 1 << (self._len - 1).bit_length()\n \n\t\tself.data = [default] * (2 * _size)\n\t\tself.data[_size:_size + self._len] = data\n\t\tfor i in reversed(range(_size)):\n\t\t\tself.data[i] = func(self.data[2*i], self.data[2*i + 1])\n \n\tdef __delitem__(self, idx):\n\t\t\"\"\" delete item set item value to its default \"\"\"\n\t\tself[idx] = self._default\n \n\tdef __getitem__(self, idx):\n\t\t\"\"\" geting item by inx \"\"\"\n\t\treturn self.data[idx + self._size]\n \n\tdef __setitem__(self, idx, value):\n\t\t\"\"\" changing seting value to given index\"\"\"\n\t\t\"\"\" apply function to range \"\"\"\n\t\tidx += self._size\n\t\tself.data[idx] = value\n\t\tidx >>= 1\n\t\twhile idx:\n\t\t\tself.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])\n\t\t\tidx >>= 1\n \n\tdef __len__(self):\n\t\treturn self._len\n \n\tdef query(self, start, stop):\n\t\t\"\"\"func of data[start, stop)\"\"\"\n\t\tstart += self._size\n\t\tstop += self._size\n \n\t\tres_left = res_right = self._default\n\t\twhile start < stop:\n\t\t\tif start & 1:\n\t\t\t\tres_left = self._func(res_left, self.data[start])\n\t\t\t\tstart += 1\n\t\t\tif stop & 1:\n\t\t\t\tstop -= 1\n\t\t\t\tres_right = self._func(self.data[stop], res_right)\n\t\t\tstart >>= 1\n\t\t\tstop >>= 1\n \n\t\treturn self._func(res_left, res_right)\n \n\tdef __repr__(self):\n\t\treturn \"SegmentTree({0})\".format(self.data)\n\n#####################################################################\nclass BinaryIndexTree(object):\n\t\"\"\" use one indexing \"\"\"\n\tdef __init__(self, nums):\n\t\tn = len(nums)\n\t\tself._len = len(nums)\n\t\tself.nums = [0 for _ in range(n+1)]\n\t\tself.N = [0 for _ in range(n+1)]\n\t\tfor i, v in enumerate(nums):\n\t\t\tself.__setitem__(i+1, v)\n\n\tdef _lowbit(self, a):\n\t\treturn a & -a\n\n\tdef  __setitem__(self, i, val):\n\t\tdiff = val - self.nums[i]\n\t\tself.nums[i] = val\n\t\twhile i < len(self.N):\n\t\t\tself.N[i] += diff\n\t\t\ti += self._lowbit(i)\n\n\tdef __getitem__(self, i):\n\t\t# return sum up 0 to i\n\t\tret = 0\n\t\twhile i > 0:\n\t\t\tret += self.N[i]\n\t\t\ti -= self._lowbit(i)\n\n\t\treturn ret\n\n######################################################################\nclass DisJointSetsRank():\n    def __init__(self,N):\n        # Initially, all elements are single element subsets\n        self._parents = [node for node in range(N)]\n        self._ranks = [1 for _ in range(N)]\n    \n    def find(self, u):\n        while u != self._parents[u]: \n            # path compression technique\n            self._parents[u] = self._parents[self._parents[u]]\n            u = self._parents[u]\n        return u\n    \n    def connected(self, u, v):\n        return self.find(u) == self.find(v)\n    \n    def union(self, u, v):\n        # Union by rank optimization\n        root_u, root_v = self.find(u), self.find(v)\n        if root_u == root_v:\n            return True\n        if self._ranks[root_u] > self._ranks[root_v]:\n            self._parents[root_v] = root_u\n        elif self._ranks[root_v] > self._ranks[root_u]:\n            self._parents[root_u] = root_v\n        else:\n            self._parents[root_u] = root_v\n            self._ranks[root_v] += 1\n        return False\n\n\n#######################################################################\n\ndef integer_list():\n\treturn list(map(int, input().split()))\n\ndef pprint(matrix):\n\tfor i in range(len(matrix)):\n\t\tprint(*matrix[i])\n\n\n#####################################################\n#test case section \n\"\"\"\n\n1 - 5\n\n9 10 1 2 7\n0 1  1 \n\n\"\"\"       \n#############################################################\n# for manipulating 0 for runing to your system 1 for online \n\n\nMOD = 10**9+7\n\nONLINE_JUDGE = 1\n\ndef match_seq(power_2, s):\n\n\ti = j = 0\n\twhile i < len(power_2) and j < len(s):\n\t\tif power_2[i] == s[j]:\n\t\t\ti += 1\n\t\t\tj += 1\n\t\telse:\n\t\t\tj += 1\n\n\tdeleted_char = len(s) - i\n\tto_add = len(power_2) - i\n\treturn deleted_char + to_add\n\n\n\n\ndef main():\n\tt = int(input())\n\t# t = 1\n\tpowers = []\n\tfor i in range(61):\n\t\tnum = str(2**i)\n\t\tpowers.append(num)\n\n\t# print(powers)\n\tfor _ in range(t):\n\t\tn = input()\n\t\tlst = []\n\t\tk = len(n)\n\t\tans = float('inf')\n\t\tfor ele in powers:\n\t\t\tans = min( ans , match_seq(ele, n))\n\n\t\tprint(ans)\n\n\n\t\t\n\n\t\n\n\t\n\n\t\n\n\n\t\t\n\t\t\n\t\t\n\t\t\t\t\t\t\t\n\n\n\n\n###############################################\n\nif ONLINE_JUDGE:\n\tinput = lambda : stdin.buffer.readline().decode().strip()\nelse:\n\tstdin = open(\"testcase.txt\")\n\tinput = lambda : stdin.readline().strip()\n\t\n\nmain()\t\t\n\t\n\n\n\n",
    "prob_desc_created_at": "1629297300",
    "tags": [
        "greedy",
        "math",
        "strings"
    ],
    "hidden_unit_tests": ""
}
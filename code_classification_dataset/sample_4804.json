{
    "prob_desc_time_limit": "1 second",
    "prob_desc_sample_outputs": "[\"2\\n1\\n4\"]",
    "src_uid": "504613b285d10fbf1e45b9c4ace25865",
    "prob_desc_notes": "NoteThe first test case is pictured in the statement. Only the subtrees at vertices $$$2$$$ and $$$3$$$ are balanced.In the second test case, only the subtree at vertex $$$1$$$ is balanced.In the third test case, only the subtrees at vertices $$$1$$$, $$$3$$$, $$$5$$$, and $$$7$$$ are balanced.",
    "prob_desc_description": "You are given a rooted tree consisting of $$$n$$$ vertices numbered from $$$1$$$ to $$$n$$$. The root is vertex $$$1$$$. There is also a string $$$s$$$ denoting the color of each vertex: if $$$s_i = \\texttt{B}$$$, then vertex $$$i$$$ is black, and if $$$s_i = \\texttt{W}$$$, then vertex $$$i$$$ is white.A subtree of the tree is called balanced if the number of white vertices equals the number of black vertices. Count the number of balanced subtrees.A tree is a connected undirected graph without cycles. A rooted tree is a tree with a selected vertex, which is called the root. In this problem, all trees have root $$$1$$$.The tree is specified by an array of parents $$$a_2, \\dots, a_n$$$ containing $$$n-1$$$ numbers: $$$a_i$$$ is the parent of the vertex with the number $$$i$$$ for all $$$i = 2, \\dots, n$$$. The parent of a vertex $$$u$$$ is a vertex that is the next vertex on a simple path from $$$u$$$ to the root.The subtree of a vertex $$$u$$$ is the set of all vertices that pass through $$$u$$$ on a simple path to the root. For example, in the picture below, $$$7$$$ is in the subtree of $$$3$$$ because the simple path $$$7 \\to 5 \\to 3 \\to 1$$$ passes through $$$3$$$. Note that a vertex is included in its subtree, and the subtree of the root is the entire tree.  The picture shows the tree for $$$n=7$$$, $$$a=[1,1,2,3,3,5]$$$, and $$$s=\\texttt{WBBWWBW}$$$. The subtree at the vertex $$$3$$$ is balanced. ",
    "prob_desc_output_spec": "For each test case, output a single integer — the number of balanced subtrees.",
    "prob_desc_input_spec": "The first line of input contains an integer $$$t$$$ ($$$1 \\le t \\le 10^4$$$) — the number of test cases. The first line of each test case contains an integer $$$n$$$ ($$$2 \\le n \\le 4000$$$) — the number of vertices in the tree. The second line of each test case contains $$$n-1$$$ integers $$$a_2, \\dots, a_n$$$ ($$$1 \\le a_i &lt; i$$$) — the parents of the vertices $$$2, \\dots, n$$$. The third line of each test case contains a string $$$s$$$ of length $$$n$$$ consisting of the characters $$$\\texttt{B}$$$ and $$$\\texttt{W}$$$ — the coloring of the tree. It is guaranteed that the sum of the values $$$n$$$ over all test cases does not exceed $$$2 \\cdot 10^5$$$.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3-64",
    "lang_cluster": "Python",
    "difficulty": 1300,
    "file_name": "train_106.jsonl",
    "code_uid": "b1be0b3d1583617e6e17976560aaf372",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"3\\n\\n7\\n\\n1 1 2 3 3 5\\n\\nWBBWWBW\\n\\n2\\n\\n1\\n\\nBW\\n\\n8\\n\\n1 2 3 4 5 6 7\\n\\nBWBWBWBW\"]",
    "exec_outcome": "PASSED",
    "source_code": "# cook your dish here\r\n#!/usr/bin/env python\r\nfrom bisect import bisect_left\r\nfrom cmath import inf\r\nimport os\r\nfrom math import ceil, factorial, fmod,pi,sqrt,log\r\nimport sys\r\nfrom collections import Counter\r\nfrom io import BytesIO, IOBase, StringIO\r\nsys.setrecursionlimit(4*10**4)\r\ndef modFact(n, p):\r\n    if n >= p:\r\n        return 0   \r\n \r\n    result = 1\r\n    for i in range(1, n + 1):\r\n        result = (result * i) % p\r\n \r\n    return result\r\n \r\ndef calculate(p, q):\r\n     \r\n    mod = 998244353\r\n    expo = 0\r\n    expo = mod - 2\r\n \r\n    # Loop to find the value\r\n    # until the expo is not zero\r\n    while (expo):\r\n \r\n        # Multiply p with q\r\n        # if expo is odd\r\n        if (expo & 1):\r\n            p = (p * q) % mod\r\n        q = (q * q) % mod\r\n \r\n        # Reduce the value of\r\n        # expo by 2\r\n        expo >>= 1\r\n \r\n    return p\r\ndef compute_gcd(x, y):\r\n\r\n   while(y):\r\n       x, y = y, x % y\r\n   return x\r\n\r\n# This function computes LCM\r\ndef compute_lcm(x, y):\r\n   lcm = (x*y)//compute_gcd(x,y)\r\n   return lcm\r\n\r\ndef read_arr():\r\n    return [int(x) for x in input().split()]\r\n\r\ndef bin_search(num, arr):\r\n    start = 0\r\n    end = len(arr)-1\r\n    while start <= end:\r\n        mid=(start+end)//2\r\n        if arr[mid] == num:\r\n            return mid\r\n        elif arr[mid] > num:\r\n            end= mid-1\r\n        else:\r\n            start = mid + 1\r\n    return -1\r\n\r\n\r\ndef factors(n) :\r\n     \r\n    # Note that this loop runs till square root\r\n    i = 1\r\n    ans=[]\r\n    while i <= sqrt(n):\r\n         \r\n        if (n % i == 0) :\r\n             \r\n            # If divisors are equal, print only one\r\n            if (n / i == i) :\r\n                ans.append(i)\r\n            else :\r\n                # Otherwise print both\r\n                \r\n                ans.append(i)\r\n                ans.append(int(n/i))\r\n        i = i + 1\r\n    return ans\r\n\r\ndef is_palindrome(n):\r\n    for j in range(len(n)//2):\r\n        if n[j]!=n[len(n)-j-1]:\r\n            return False\r\n    return True\r\n\r\ndef nCr(n, r):\r\n     \r\n    return (fact(n) / (fact(r)\r\n                * fact(n - r)))\r\n \r\n# Returns factorial of n\r\ndef fact(n):\r\n \r\n    res = 1\r\n     \r\n    for i in range(2, n+1):\r\n        res = res * i\r\n    return res\r\ncnt=0\r\ndef recur(graph,root,s,num):\r\n    global cnt\r\n    if s[root-1]==\"B\":\r\n        num[root] -= 1\r\n    else:\r\n        num[root] += 1\r\n    for j in graph[root]:\r\n        num[root]+=recur(graph,j,s,num)\r\n    if num[root]==0:\r\n        cnt += 1\r\n    return num[root]\r\n\r\n\r\n\r\n\r\ndef main():\r\n    for i in range(int(input())):\r\n        global cnt\r\n        cnt=0\r\n        n = int(input())\r\n        arr=list(map(int, input().split()))\r\n        s=[x for x in input()]\r\n        graph={}\r\n        for j in range(1,n+5):\r\n            graph[j]=[]\r\n        for j in range(n-1):\r\n            graph[arr[j]].append(j+2)\r\n        num=[0 for j in range(n+1)]\r\n        recur(graph,1,s,num)\r\n        print(cnt)\r\n\r\n        \r\n\r\nBUFSIZE = 8192\r\n \r\n \r\nclass FastIO(IOBase):\r\n    newlines = 0\r\n \r\n    def __init__(self, file):\r\n        self._fd = file.fileno()\r\n        self.buffer = BytesIO()\r\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\r\n        self.write = self.buffer.write if self.writable else None\r\n \r\n    def read(self):\r\n        while True:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            if not b:\r\n                break\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines = 0\r\n        return self.buffer.read()\r\n \r\n    def readline(self):\r\n        while self.newlines == 0:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            self.newlines = b.count(b\"\\n\") + (not b)\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines -= 1\r\n        return self.buffer.readline()\r\n \r\n    def flush(self):\r\n        if self.writable:\r\n            os.write(self._fd, self.buffer.getvalue())\r\n            self.buffer.truncate(0), self.buffer.seek(0)\r\n \r\n \r\nclass IOWrapper(IOBase):\r\n    def __init__(self, file):\r\n        self.buffer = FastIO(file)\r\n        self.flush = self.buffer.flush\r\n        self.writable = self.buffer.writable\r\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\r\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\r\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\r\n \r\n \r\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\r\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\r\n \r\n# endregion\r\n \r\nif __name__ == \"__main__\":\r\n    main()",
    "prob_desc_created_at": "1652193900",
    "tags": [
        "dfs and similar",
        "dp",
        "graphs",
        "trees"
    ],
    "hidden_unit_tests": ""
}
{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"166374062\"]",
    "src_uid": "81f709b914ca1821b254f07b2464fbf2",
    "prob_desc_notes": "NoteLet's look at all possible orders of cities Monuments will be build in:   $$$[1, 2, 3]$$$:   the first city controls all points at distance at most $$$3$$$, in other words, points $$$1$$$ and $$$4$$$;  the second city controls all points at distance at most $$$2$$$, or points $$$1$$$, $$$3$$$ and $$$5$$$;  the third city controls all points at distance at most $$$1$$$, or point $$$1$$$.  In total, $$$4$$$ points are controlled.  $$$[1, 3, 2]$$$: the first city controls points $$$1$$$ and $$$4$$$; the second city — points $$$1$$$ and $$$3$$$; the third city — point $$$1$$$. In total, $$$3$$$ points.  $$$[2, 1, 3]$$$: the first city controls point $$$1$$$; the second city — points $$$1$$$, $$$3$$$ and $$$5$$$; the third city — point $$$1$$$. In total, $$$3$$$ points.  $$$[2, 3, 1]$$$: the first city controls point $$$1$$$; the second city — points $$$1$$$, $$$3$$$ and $$$5$$$; the third city — point $$$1$$$. In total, $$$3$$$ points.  $$$[3, 1, 2]$$$: the first city controls point $$$1$$$; the second city — points $$$1$$$ and $$$3$$$; the third city — points $$$1$$$ and $$$5$$$. In total, $$$3$$$ points.  $$$[3, 2, 1]$$$: the first city controls point $$$1$$$; the second city — points $$$1$$$, $$$3$$$ and $$$5$$$; the third city — points $$$1$$$ and $$$5$$$. In total, $$$3$$$ points.  The expected number of controlled points is $$$\\frac{4 + 3 + 3 + 3 + 3 + 3}{6}$$$ $$$=$$$ $$$\\frac{19}{6}$$$ or $$$19 \\cdot 6^{-1}$$$ $$$\\equiv$$$ $$$19 \\cdot 166374059$$$ $$$\\equiv$$$ $$$166374062$$$ $$$\\pmod{998244353}$$$",
    "prob_desc_description": "Monocarp is playing a game \"Assimilation IV\". In this game he manages a great empire: builds cities and conquers new lands.Monocarp's empire has $$$n$$$ cities. In order to conquer new lands he plans to build one Monument in each city. The game is turn-based and, since Monocarp is still amateur, he builds exactly one Monument per turn.Monocarp has $$$m$$$ points on the map he'd like to control using the constructed Monuments. For each point he knows the distance between it and each city. Monuments work in the following way: when built in some city, a Monument controls all points at distance at most $$$1$$$ to this city. Next turn, the Monument controls all points at distance at most $$$2$$$, the turn after — at distance at most $$$3$$$, and so on. Monocarp will build $$$n$$$ Monuments in $$$n$$$ turns and his empire will conquer all points that are controlled by at least one Monument.Monocarp can't figure out any strategy, so during each turn he will choose a city for a Monument randomly among all remaining cities (cities without Monuments). Monocarp wants to know how many points (among $$$m$$$ of them) he will conquer at the end of turn number $$$n$$$. Help him to calculate the expected number of conquered points!",
    "prob_desc_output_spec": "It can be shown that the expected number of points Monocarp conquers at the end of the $$$n$$$-th turn can be represented as an irreducible fraction $$$\\frac{x}{y}$$$. Print this fraction modulo $$$998\\,244\\,353$$$, i. e. value $$$x \\cdot y^{-1} \\bmod 998244353$$$ where $$$y^{-1}$$$ is such number that $$$y \\cdot y^{-1} \\bmod 998244353 = 1$$$.",
    "prob_desc_input_spec": "The first line contains two integers $$$n$$$ and $$$m$$$ ($$$1 \\le n \\le 20$$$; $$$1 \\le m \\le 5 \\cdot 10^4$$$) — the number of cities and the number of points. Next $$$n$$$ lines contains $$$m$$$ integers each: the $$$j$$$-th integer of the $$$i$$$-th line $$$d_{i, j}$$$ ($$$1 \\le d_{i, j} \\le n + 1$$$) is the distance between the $$$i$$$-th city and the $$$j$$$-th point.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3",
    "lang_cluster": "Python",
    "difficulty": 2100,
    "file_name": "train_110.jsonl",
    "code_uid": "1b7eff85f3472c3915e1b4ff3f04bd99",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"3 5\\n1 4 4 3 4\\n1 4 1 4 2\\n1 4 4 4 3\"]",
    "exec_outcome": "PASSED",
    "source_code": "import time\r\n\r\n#start_time = time.time()\r\n#def TIME_(): print(time.time()-start_time)\r\n\r\nimport os, sys\r\nfrom io import BytesIO, IOBase\r\nfrom types import GeneratorType\r\nfrom bisect import bisect_left, bisect_right\r\nfrom collections import defaultdict as dd, deque as dq, Counter as dc\r\nimport math, string, heapq as h\r\nBUFSIZE = 8192\r\n\r\nclass FastIO(IOBase):\r\n    newlines = 0\r\n    def __init__(self, file):\r\n        import os\r\n        self.os = os\r\n        self._fd = file.fileno()\r\n        self.buffer = BytesIO()\r\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\r\n        self.write = self.buffer.write if self.writable else None\r\n    def read(self):\r\n        while True:\r\n            b = self.os.read(self._fd, max(self.os.fstat(self._fd).st_size, BUFSIZE))\r\n            if not b:\r\n                break\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines = 0\r\n        return self.buffer.read()\r\n    def readline(self):\r\n        while self.newlines == 0:\r\n            b = self.os.read(self._fd, max(self.os.fstat(self._fd).st_size, BUFSIZE))\r\n            self.newlines = b.count(b\"\\n\") + (not b)\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines -= 1\r\n        return self.buffer.readline()\r\n    def flush(self):\r\n        if self.writable:\r\n            self.os.write(self._fd, self.buffer.getvalue())\r\n            self.buffer.truncate(0), self.buffer.seek(0)\r\n \r\nclass IOWrapper(IOBase):\r\n    def __init__(self, file):\r\n        self.buffer = FastIO(file)\r\n        self.flush = self.buffer.flush\r\n        self.writable = self.buffer.writable\r\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\r\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\r\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\r\n\r\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\r\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\r\n\r\ndef getInt(): return int(input())\r\ndef getStrs(): return input().split()\r\ndef getInts(): return list(map(int,input().split()))\r\ndef getStr(): return input()\r\ndef listStr(): return list(input())\r\ndef getMat(n): return [getInts() for _ in range(n)]\r\ndef getBin(): return list(map(int,list(input())))\r\ndef isInt(s): return '0' <= s[0] <= '9'\r\ndef ceil_(a,b): return a//b + (a%b > 0)\r\n\r\nMOD = 998244353\r\n\r\n\"\"\"\r\n\r\n\"\"\"\r\n\r\nprimes = [2,3,5,7,11,13,17,19]\r\n\r\ndef solve():\r\n    N, M = getInts()\r\n    dist = [getInts() for _ in range(N)]\r\n    num = 0\r\n    for j in range(M):\r\n        tmp = [dist[i][j] for i in range(N)]\r\n        tmp.sort()\r\n        mult = 1\r\n        for i in range(N):\r\n            mult *= max(tmp[i]-1-i,0)\r\n        num += mult\r\n    denom = 1\r\n    for i in range(2,N+1): denom *= i\r\n    num = denom*M - num\r\n    for i in primes:\r\n        if i > N: break\r\n        while num % i == 0 and denom % i == 0:\r\n            num //= i\r\n            denom //= i\r\n    num %= MOD\r\n    denom %= MOD\r\n    return (num * (pow(denom,MOD-2,MOD)))%MOD\r\n    \r\n#for _ in range(getInt()):\r\nprint(solve())\r\n    #solve()\r\n\r\n#TIME_()",
    "prob_desc_created_at": "1621152000",
    "tags": [
        "combinatorics",
        "dp",
        "math",
        "probabilities",
        "two pointers"
    ],
    "hidden_unit_tests": ""
}
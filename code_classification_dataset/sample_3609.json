{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"none\\nany\\nat least one\\nat least one\\nany\", \"any\\nany\\nnone\", \"at least one\\nat least one\\nat least one\"]",
    "src_uid": "be83ef61283f104dcb00612ae11f2e93",
    "prob_desc_notes": "NoteIn the second sample the MST is unique for the given graph: it contains two first edges.In the third sample any two edges form the MST for the given graph. That means that each edge is included at least in one MST.",
    "prob_desc_description": "You are given a connected weighted undirected graph without any loops and multiple edges. Let us remind you that a graph's spanning tree is defined as an acyclic connected subgraph of the given graph that includes all of the graph's vertexes. The weight of a tree is defined as the sum of weights of the edges that the given tree contains. The minimum spanning tree (MST) of a graph is defined as the graph's spanning tree having the minimum possible weight. For any connected graph obviously exists the minimum spanning tree, but in the general case, a graph's minimum spanning tree is not unique.Your task is to determine the following for each edge of the given graph: whether it is either included in any MST, or included at least in one MST, or not included in any MST.",
    "prob_desc_output_spec": "Print m lines — the answers for all edges. If the i-th edge is included in any MST, print \"any\"; if the i-th edge is included at least in one MST, print \"at least one\"; if the i-th edge isn't included in any MST, print \"none\". Print the answers for the edges in the order in which the edges are specified in the input.",
    "prob_desc_input_spec": "The first line contains two integers n and m (2 ≤ n ≤ 105, ) — the number of the graph's vertexes and edges, correspondingly. Then follow m lines, each of them contains three integers — the description of the graph's edges as \"ai bi wi\" (1 ≤ ai, bi ≤ n, 1 ≤ wi ≤ 106, ai ≠ bi), where ai and bi are the numbers of vertexes connected by the i-th edge, wi is the edge's weight. It is guaranteed that the graph is connected and doesn't contain loops or multiple edges.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "Python 3",
    "lang_cluster": "Python",
    "difficulty": 2300,
    "file_name": "train_073.jsonl",
    "code_uid": "0ba0bade310d53c2e2bcf3caf30ccaee",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"4 5\\n1 2 101\\n1 3 100\\n2 3 2\\n2 4 2\\n3 4 1\", \"3 3\\n1 2 1\\n2 3 1\\n1 3 2\", \"3 3\\n1 2 1\\n2 3 1\\n1 3 1\"]",
    "exec_outcome": "PASSED",
    "source_code": "import sys, threading\nfrom heapq import heappop, heappush\n#from mygraph import MyGraph\nfrom collections import defaultdict\n\nn_nodes, n_edges = map(int, input().split())\n\nedges = list()\n\nresults = defaultdict(lambda: 'any')\nhighest = defaultdict(lambda: -1)\nto_check = defaultdict(list)\ngraph = defaultdict(list)\n\nclass UDFS:\n\n    def __init__(self, n):\n        self.n = n\n\n        # index is the node\n        self.parents = [i for i in range(n)]\n        self.ranks = [0 for i in range(n)]\n\n    def __str__(self):\n        '''\n        Group -> Node\n        '''\n        return '\\n'.join(f'{e} -> {i}' for i, e in enumerate(self.parents))\n\n    def get_group(self, a):\n        if a == self.parents[a]:\n            return a\n\n        # Side effect for balancing the tree\n        self.parents[a] = self.get_group(self.parents[a])\n\n        return self.parents[a]\n\n    def is_parent(self, n):\n        return n == self.get_group(n)\n\n    def is_same_group(self, a, b):\n        return self.get_group(a) == self.get_group(b)\n\n    def join(self, a, b):\n        parent_a = self.get_group(a)\n        parent_b = self.get_group(b)\n\n        if self.ranks[parent_a] > self.ranks[parent_b]:\n            self.parents[parent_b] = parent_a\n        else:\n            self.parents[parent_a] = parent_b\n\n            self.ranks[parent_b] += int(\n                self.ranks[parent_a] == self.ranks[parent_b]\n            )\n\n    def count(self):\n        '''\n        Returns number of groups\n        '''\n        count = 0\n        for n in range(self.n):\n            count += self.is_parent(n)\n\n        return count\n\n#def get_graph(nodes, label):\n#    graph = MyGraph(graph_type='graph', size='20,11.25!', ratio='fill',label=label, fontsize=40)\n#    \n#    for v in range(1,nodes+1):\n#        graph.add_nodes(v)\n#\n#    return graph\n#\n#def make_original_graph(nodes, edges):\n#    original_graph = get_graph(nodes, \"Grafo Original\") \n#\n#    for r in range(edges):\n#            a, b, w = map(int, input('\\tInsira dois nós e o peso da aresta que existe entre eles: ').split())\n#            original_graph.link(a, b, str(w))\n#\n#    img_name = \"original_graph\"\n#\n#    original_graph.save_img(img_name)\n#    \n#    print(f\"O grafo original foi salvo em {img_name}.png!\")\n#\n#def make_edges_in_mst_graph(nodes, edges):\n#    edges_graph = get_graph(nodes, \"Arestas em MSTs\") \n#\n#    for r in range(edges):\n#            edges_graph.link(a, b, str(w))\n#\n#    img_name = \"edges_in_mst\"\n#\n#    edges_graph.save_img(img_name)\n#    \n#    print(f\"O grafo com a ocorrências das arestas em MSTs foi salvo em {img_name}.png!\")\n\ndef dfs(a, depth, p):\n    global edges\n    global results\n    global highest\n    global graph\n\n    if highest[a] != -1:\n        return highest[a];\n\n    minimum = depth\n    highest[a] = depth\n\n    for (w, a, b, i) in graph[a]:\n        ##print('@', w, a, b, i, depth)\n        if i == p:\n            continue\n\n        nextt = dfs(b, depth + 1, i)\n\n        if nextt <= depth:\n            results[i] = 'at least one'\n        else:\n            results[i] = 'any'\n\n        minimum = min(minimum, nextt)\n        highest[a] = minimum\n\n    return highest[a]\n\ndef main():\n    global edges\n    global results\n    global highest\n    global graph\n\n    for i in range(n_edges):\n        a, b, w = map(int, input().split())\n        edges.append((w, a-1, b-1, i))\n\n    edges = sorted(edges, key=lambda x: x[0])\n\n    dsu = UDFS(n_nodes)\n\n    i = 0\n    while i < n_edges:\n        counter = 0\n        j = i\n        while j < n_edges and edges[j][0] == edges[i][0]:\n            if dsu.get_group(edges[j][1]) == dsu.get_group(edges[j][2]):\n                results[edges[j][3]] = 'none'\n            else:\n                to_check[counter] = edges[j]\n                counter += 1\n            j += 1\n            \n        for k in range(counter):\n            w, a, b, i = to_check[k]\n\n            ra = dsu.get_group(a)\n            rb = dsu.get_group(b)\n\n            graph[ra].append((w, ra, rb, i))\n            graph[rb].append((w, rb, ra, i))\n\n        for k in range(counter):\n            #print('To check:', to_check[k][:-1], k)\n            dfs(to_check[k][1], 0, -1)\n\n        for k in range(counter):\n            w, a, b, i = to_check[k]\n\n            ra = dsu.get_group(a)\n            rb = dsu.get_group(b)\n\n            dsu.join(ra, rb)\n\n            graph[ra] = list()\n            graph[rb] = list()\n\n            highest[ra] = -1\n            highest[rb] = -1\n\n        counter = 0\n        i = j\n\n    for i in range(n_edges):\n        print(results[i])\n\nif __name__ == \"__main__\":\n    sys.setrecursionlimit(2**32//2-1)\n    threading.stack_size(1 << 27)\n\n    thread = threading.Thread(target=main)\n    thread.start()\n    thread.join()\n",
    "prob_desc_created_at": "1331046000",
    "tags": [
        "dsu",
        "sortings",
        "graphs",
        "dfs and similar"
    ],
    "hidden_unit_tests": ""
}
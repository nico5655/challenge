{
    "prob_desc_time_limit": "1 second",
    "prob_desc_sample_outputs": "[\"173\\n171\\n75\\n3298918744\"]",
    "src_uid": "ce2b12f1d7c0388c39fee52f5410b94b",
    "prob_desc_notes": "NoteHere is an optimal sequence of moves for the second test case:  Conquer the kingdom at position $$$1$$$ with cost $$$3\\cdot(1-0)=3$$$.  Move the capital to the kingdom at position $$$1$$$ with cost $$$6\\cdot(1-0)=6$$$.  Conquer the kingdom at position $$$5$$$ with cost $$$3\\cdot(5-1)=12$$$.  Move the capital to the kingdom at position $$$5$$$ with cost $$$6\\cdot(5-1)=24$$$.  Conquer the kingdom at position $$$6$$$ with cost $$$3\\cdot(6-5)=3$$$.  Conquer the kingdom at position $$$21$$$ with cost $$$3\\cdot(21-5)=48$$$.  Conquer the kingdom at position $$$30$$$ with cost $$$3\\cdot(30-5)=75$$$. The total cost is $$$3+6+12+24+3+48+75=171$$$. You cannot get a lower cost than this.",
    "prob_desc_description": "You are an ambitious king who wants to be the Emperor of The Reals. But to do that, you must first become Emperor of The Integers.Consider a number axis. The capital of your empire is initially at $$$0$$$. There are $$$n$$$ unconquered kingdoms at positions $$$0&lt;x_1&lt;x_2&lt;\\ldots&lt;x_n$$$. You want to conquer all other kingdoms.There are two actions available to you:   You can change the location of your capital (let its current position be $$$c_1$$$) to any other conquered kingdom (let its position be $$$c_2$$$) at a cost of $$$a\\cdot |c_1-c_2|$$$.  From the current capital (let its current position be $$$c_1$$$) you can conquer an unconquered kingdom (let its position be $$$c_2$$$) at a cost of $$$b\\cdot |c_1-c_2|$$$. You cannot conquer a kingdom if there is an unconquered kingdom between the target and your capital. Note that you cannot place the capital at a point without a kingdom. In other words, at any point, your capital can only be at $$$0$$$ or one of $$$x_1,x_2,\\ldots,x_n$$$. Also note that conquering a kingdom does not change the position of your capital.Find the minimum total cost to conquer all kingdoms. Your capital can be anywhere at the end.",
    "prob_desc_output_spec": "For each test case, output a single integer  — the minimum cost to conquer all kingdoms.",
    "prob_desc_input_spec": "The first line contains a single integer $$$t$$$ ($$$1 \\le t \\le 1000$$$)  — the number of test cases. The description of each test case follows. The first line of each test case contains $$$3$$$ integers $$$n$$$, $$$a$$$, and $$$b$$$ ($$$1 \\leq n \\leq 2 \\cdot 10^5$$$; $$$1 \\leq a,b \\leq 10^5$$$). The second line of each test case contains $$$n$$$ integers $$$x_1, x_2, \\ldots, x_n$$$ ($$$1 \\leq x_1 &lt; x_2 &lt; \\ldots &lt; x_n \\leq 10^8$$$). The sum of $$$n$$$ over all test cases does not exceed $$$2 \\cdot 10^5$$$.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3-64",
    "lang_cluster": "Python",
    "difficulty": 1500,
    "file_name": "train_110.jsonl",
    "code_uid": "fdd98238a04bce23bb9cd0686c56485b",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"4\\n5 2 7\\n3 5 12 13 21\\n5 6 3\\n1 5 6 21 30\\n2 9 3\\n10 15\\n11 27182 31415\\n16 18 33 98 874 989 4848 20458 34365 38117 72030\"]",
    "exec_outcome": "PASSED",
    "source_code": "import math\nfrom sys import stdin, stdout\nfrom collections import deque\ndef do_it(a,b,kingdoms,previous,position,states):\n    if len(kingdoms) == 0:\n        return 0\n    current = kingdoms[0]\n    if position in states:\n        return states[position]\n    gap = current-position\n    prev_gap = current-previous\n    positin_gap = previous-position\n    if(a*(previous-position)<b*(previous-position)*len(kingdoms)):\n        return a*(previous-position) + b*prev_gap + do_it(a,b,kingdoms[1:],current,previous,states)\n    else:\n        return b*gap + do_it(a,b,kingdoms[1:],current,position,states)\n\nif __name__ == '__main__':\n    T = int(stdin.readline().strip())\n    for t in range(0,T):\n        n,a,b = [int(x) for x in stdin.readline().strip().split(\" \")]\n        kingdoms = [int(x) for x in stdin.readline().strip().split(\" \")]\n        previous = 0\n        position = 0\n        res = 0\n        count = 0\n        for current in kingdoms:\n            gap = current - position\n            prev_gap = current - previous\n            positin_gap = previous - position\n            if (a * (previous - position) < b * (previous - position) * (len(kingdoms)-count)):\n                res += a * (previous - position) + b * prev_gap\n                position = previous\n                previous = current\n            else:\n                res += b * gap\n                previous = current\n            count += 1\n        stdout.write(str(res) + \"\\n\")",
    "prob_desc_created_at": "1650206100",
    "tags": [
        "binary search",
        "brute force",
        "dp",
        "greedy",
        "implementation",
        "math"
    ],
    "hidden_unit_tests": ""
}
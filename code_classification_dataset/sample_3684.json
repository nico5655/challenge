{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"60\", \"142\", \"999999997\"]",
    "src_uid": "6f4629e2dd9bca7980c8ee4f2e4b3edd",
    "prob_desc_notes": "NoteIn the first example, the optimal strategy would be to rent $$$3$$$ TVs to watch:  Show $$$[1, 2]$$$ on the first TV, Show $$$[4, 10]$$$ on the second TV, Shows $$$[2, 4], [5, 9], [10, 11]$$$ on the third TV. This way the cost for the first TV is $$$4 + 3 \\cdot (2 - 1) = 7$$$, for the second is $$$4 + 3 \\cdot (10 - 4) = 22$$$ and for the third is $$$4 + 3 \\cdot (11 - 2) = 31$$$, which gives $$$60$$$ int total.In the second example, it is optimal watch each show on a new TV.In third example, it is optimal to watch both shows on a new TV. Note that the answer is to be printed modulo $$$10^9 + 7$$$.",
    "prob_desc_description": "There are $$$n$$$ TV shows you want to watch. Suppose the whole time is split into equal parts called \"minutes\". The $$$i$$$-th of the shows is going from $$$l_i$$$-th to $$$r_i$$$-th minute, both ends inclusive.You need a TV to watch a TV show and you can't watch two TV shows which air at the same time on the same TV, so it is possible you will need multiple TVs in some minutes. For example, if segments $$$[l_i, r_i]$$$ and $$$[l_j, r_j]$$$ intersect, then shows $$$i$$$ and $$$j$$$ can't be watched simultaneously on one TV.Once you start watching a show on some TV it is not possible to \"move\" it to another TV (since it would be too distracting), or to watch another show on the same TV until this show ends.There is a TV Rental shop near you. It rents a TV for $$$x$$$ rupees, and charges $$$y$$$ ($$$y &lt; x$$$) rupees for every extra minute you keep the TV. So in order to rent a TV for minutes $$$[a; b]$$$ you will need to pay $$$x + y \\cdot (b - a)$$$. You can assume, that taking and returning of the TV doesn't take any time and doesn't distract from watching other TV shows. Find the minimum possible cost to view all shows. Since this value could be too large, print it modulo $$$10^9 + 7$$$.",
    "prob_desc_output_spec": "Print exactly one integer — the minimum cost to view all the shows taken modulo $$$10^9 + 7$$$.",
    "prob_desc_input_spec": "The first line contains integers $$$n$$$, $$$x$$$ and $$$y$$$ ($$$1 \\le n \\le 10^5$$$, $$$1 \\le y &lt; x \\le 10^9$$$) — the number of TV shows, the cost to rent a TV for the first minute and the cost to rent a TV for every subsequent minute. Each of the next $$$n$$$ lines contains two integers $$$l_i$$$ and $$$r_i$$$ ($$$1 \\le l_i \\le r_i \\le 10^9$$$) denoting the start and the end minute of the $$$i$$$-th TV show.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 2",
    "lang_cluster": "Python",
    "difficulty": 2000,
    "file_name": "train_078.jsonl",
    "code_uid": "36d62794c8636c0c0b4ebd2a0b5e1df2",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"5 4 3\\n1 2\\n4 10\\n2 4\\n10 11\\n5 9\", \"6 3 2\\n8 20\\n6 22\\n4 15\\n20 28\\n17 25\\n20 27\", \"2 1000000000 2\\n1 2\\n2 3\"]",
    "exec_outcome": "PASSED",
    "source_code": "#!/usr/bin/env python\n\"\"\"\nThis file is part of https://github.com/Cheran-Senthil/PyRival.\n\nCopyright 2018 Cheran Senthilkumar all rights reserved,\nCheran Senthilkumar <hello@cheran.io>\nPermission to use, modify, and distribute this software is given under the\nterms of the MIT License.\n\n\"\"\"\nfrom __future__ import division, print_function\n\nimport cmath\nimport itertools\nimport math\nimport operator as op\n# import random\nimport sys\nfrom atexit import register\nfrom bisect import bisect_left, bisect_right\n# from collections import Counter, MutableSequence, defaultdict, deque\n# from copy import deepcopy\n# from decimal import Decimal\n# from difflib import SequenceMatcher\n# from fractions import Fraction\n# from heapq import heappop, heappush\n\nif sys.version_info[0] < 3:\n    # from cPickle import dumps\n    from io import BytesIO as stream\n    # from Queue import PriorityQueue, Queue\nelse:\n    # from functools import reduce\n    from io import StringIO as stream\n    from math import gcd\n    # from pickle import dumps\n    # from queue import PriorityQueue, Queue\n\n\nif sys.version_info[0] < 3:\n    class dict(dict):\n        \"\"\"dict() -> new empty dictionary\"\"\"\n        def items(self):\n            \"\"\"D.items() -> a set-like object providing a view on D's items\"\"\"\n            return dict.iteritems(self)\n\n        def keys(self):\n            \"\"\"D.keys() -> a set-like object providing a view on D's keys\"\"\"\n            return dict.iterkeys(self)\n\n        def values(self):\n            \"\"\"D.values() -> an object providing a view on D's values\"\"\"\n            return dict.itervalues(self)\n\n    def gcd(x, y):\n        \"\"\"gcd(x, y) -> int\n        greatest common divisor of x and y\n        \"\"\"\n        while y:\n            x, y = y, x % y\n        return x\n\n    input = raw_input\n    range = xrange\n\n    filter = itertools.ifilter\n    map = itertools.imap\n    zip = itertools.izip\n\n\ndef sync_with_stdio(sync=True):\n    \"\"\"Set whether the standard Python streams are allowed to buffer their I/O.\n\n    Args:\n        sync (bool, optional): The new synchronization setting.\n\n    \"\"\"\n    global input, flush\n\n    if sync:\n        flush = sys.stdout.flush\n    else:\n        sys.stdin = stream(sys.stdin.read())\n        input = lambda: sys.stdin.readline().rstrip('\\r\\n')\n\n        sys.stdout = stream()\n        register(lambda: sys.__stdout__.write(sys.stdout.getvalue()))\n\n\ndef main():\n    n, x, y = map(int, input().split(' '))\n\n    l, r, v = [0] * n, [0] * n, [0]*n\n\n    res = 0\n    for i in range(n):\n        l[i], r[i] = map(int, input().split(' '))\n        res += x + (r[i] - l[i]) * y\n\n    l.sort()\n    r.sort()\n\n    for i in range(n - 1, -1, -1):\n        k = bisect_right(l, r[i])\n        while (k < n) and (v[k] == 1) and ((l[k] - r[i]) * y < x):\n            k += 1\n\n        if k == n:\n            continue\n\n        if (l[k] - r[i]) * y < x:\n            v[k] = 1\n            res += (l[k] - r[i]) * y - x\n\n    print(res % 1000000007)\n\n\nif __name__ == '__main__':\n    sync_with_stdio(False)\n    main()\n",
    "prob_desc_created_at": "1542901500",
    "tags": [
        "data structures",
        "implementation",
        "sortings",
        "greedy"
    ],
    "hidden_unit_tests": ""
}
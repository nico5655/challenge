{
    "prob_desc_time_limit": "1 second",
    "prob_desc_sample_outputs": "[\"YES\\n2 1\\n3 4\\n1 4\\nNO\\nYES\\n2 3\\n1 2\\n5 6\\n6 2\\n3 4\"]",
    "src_uid": "65bb0f28d079ca94751048d326b3e1f1",
    "prob_desc_notes": "NoteIn the first test case, the tree looks as follows:   In the second test case, there is only one possible tree with an edge between $$$1$$$ and $$$2$$$, and it does not satisfy the degree constraints.In the third test case,    The tree on the left satisfies the degree constraints but the edges intersect internally, therefore it is not a valid tree, while the tree on the right is valid.",
    "prob_desc_description": "There are $$$n$$$ nodes arranged in a circle numbered from $$$1$$$ to $$$n$$$ in the clockwise order. You are also given a binary string $$$s$$$ of length $$$n$$$.Your task is to construct a tree on the given $$$n$$$ nodes satisfying the two conditions below or report that there such tree does not exist:  For each node $$$i$$$ $$$(1 \\le i \\le n)$$$, the degree of node is even if $$$s_i = 0$$$ and odd if $$$s_i = 1$$$.  No two edges of the tree intersect internally in the circle. The edges are allowed to intersect on the circumference.  Note that all edges are drawn as straight line segments. For example, edge $$$(u, v)$$$ in the tree is drawn as a line segment connecting $$$u$$$ and $$$v$$$ on the circle.A tree on $$$n$$$ nodes is a connected graph with $$$n - 1$$$ edges.",
    "prob_desc_output_spec": "For each test case, if there does not exist a tree that satisfies the given conditions, then output \"NO\" (without quotes), otherwise output \"YES\" followed by the description of tree. You can output each letter in any case (for example, \"YES\", \"Yes\", \"yes\", \"yEs\", \"yEs\" will be recognized as a positive answer). If there exists a tree, then output $$$n - 1$$$ lines, each containing two integers $$$u$$$ and $$$v$$$ $$$(1 \\leq u,v \\leq n, u \\neq v)$$$ denoting an edge between $$$u$$$ and $$$v$$$ in the tree. If there are multiple possible answers, output any.",
    "prob_desc_input_spec": "The input consists of multiple test cases. The first line contains a single integer $$$t$$$ $$$(1 \\leq t \\leq 2\\cdot 10^4)$$$  — the number of test cases. Description of the test cases follows. The first line of each test case contains a single integer $$$n$$$ $$$(2 \\leq n \\leq 2\\cdot 10^5)$$$  — the number of nodes. The second line of each test case contains a binary string $$$s$$$ of length $$$n$$$. It is guaranteed that the sum of $$$n$$$ over all test cases does not exceed $$$2\\cdot 10^5$$$.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3-64",
    "lang_cluster": "Python",
    "difficulty": 2000,
    "file_name": "train_101.jsonl",
    "code_uid": "17b9af18579bc28c2c57ad874891312a",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"3\\n\\n4\\n\\n0110\\n\\n2\\n\\n10\\n\\n6\\n\\n110110\"]",
    "exec_outcome": "PASSED",
    "source_code": "import os, sys\r\nfrom io import BytesIO, IOBase\r\nfrom array import array\r\n\r\n\r\nclass FastIO(IOBase):\r\n    newlines = 0\r\n\r\n    def __init__(self, file):\r\n        self._fd = file.fileno()\r\n        self.buffer = BytesIO()\r\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\r\n        self.write = self.buffer.write if self.writable else None\r\n\r\n    def read(self):\r\n        while True:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, 8192))\r\n            if not b:\r\n                break\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines = 0\r\n        return self.buffer.read()\r\n\r\n    def readline(self):\r\n        while self.newlines == 0:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, 8192))\r\n            self.newlines = b.count(b\"\\n\") + (not b)\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines -= 1\r\n        return self.buffer.readline()\r\n\r\n    def flush(self):\r\n        if self.writable:\r\n            os.write(self._fd, self.buffer.getvalue())\r\n            self.buffer.truncate(0), self.buffer.seek(0)\r\n\r\n\r\nclass IOWrapper(IOBase):\r\n    def __init__(self, file):\r\n        self.buffer = FastIO(file)\r\n        self.flush = self.buffer.flush\r\n        self.writable = self.buffer.writable\r\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\r\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\r\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\r\n\r\n\r\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\r\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\r\ninp = lambda dtype: [dtype(x) for x in input().split()]\r\ninp_2d = lambda dtype, n: [dtype(input()) for _ in range(n)]\r\ninp_2ds = lambda dtype, n: [inp(dtype) for _ in range(n)]\r\nceil1, out = lambda a, b: (a + b - 1) // b, []\r\n\r\n\r\ndef solve():\r\n    rem = -1\r\n\r\n    for i in range(1, n):\r\n        cur = ix\r\n        if s[i] == '1':\r\n            if rem != -1:\r\n                cur, rem = rem, -1\r\n        else:\r\n            if rem != -1:\r\n                cur = rem\r\n            rem = (i + ix) % n\r\n\r\n        out.append(f'{cur + 1} {(i + ix) % n + 1}')\r\n\r\n\r\nfor _ in range(int(input())):\r\n    n, s = int(input()), input()\r\n    even = s.count('0')\r\n\r\n    if even > n - 2 or even & 1 != n & 1:\r\n        out.append('no')\r\n        continue\r\n\r\n    out.append('yes')\r\n    ix = 0\r\n    while True:\r\n        if s[(ix - 1) % n] == '1':\r\n            break\r\n        ix += 1\r\n\r\n    s = s[ix:] + s[:ix]\r\n    solve()\r\n\r\nprint('\\n'.join(out))\r\n",
    "prob_desc_created_at": "1653230100",
    "tags": [
        "constructive algorithms",
        "implementation",
        "trees"
    ],
    "hidden_unit_tests": ""
}
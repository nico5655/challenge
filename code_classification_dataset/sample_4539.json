{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"43\\n13\"]",
    "src_uid": "88488ff074bc25a6cf925c8a07a1d8c6",
    "prob_desc_notes": "NoteIn the first test case, the hero has to beat a single monster with armor $$$42$$$, it's enough to have power $$$43$$$ to achieve that.In the second test case, the hero can pass the level with initial power $$$13$$$ as follows:   enter cave $$$2$$$:   beat a monster with armor $$$12$$$, power increases to $$$14$$$;  beat a monster with armor $$$11$$$, power increases to $$$15$$$;   enter cave $$$1$$$:   beat a monster with armor $$$10$$$, power increases to $$$16$$$;  beat a monster with armor $$$15$$$, power increases to $$$17$$$;  beat a monster with armor $$$8$$$, power increases to $$$18$$$.  ",
    "prob_desc_description": "In a certain video game, the player controls a hero characterized by a single integer value: power. The hero will have to beat monsters that are also characterized by a single integer value: armor.On the current level, the hero is facing $$$n$$$ caves. To pass the level, the hero must enter all the caves in some order, each cave exactly once, and exit every cave safe and sound. When the hero enters cave $$$i$$$, he will have to fight $$$k_i$$$ monsters in a row: first a monster with armor $$$a_{i, 1}$$$, then a monster with armor $$$a_{i, 2}$$$ and so on, finally, a monster with armor $$$a_{i, k_i}$$$.The hero can beat a monster if and only if the hero's power is strictly greater than the monster's armor. If the hero can't beat the monster he's fighting, the game ends and the player loses. Note that once the hero enters a cave, he can't exit it before he fights all the monsters in it, strictly in the given order.Each time the hero beats a monster, the hero's power increases by $$$1$$$.Find the smallest possible power the hero must start the level with to be able to enter all the caves in some order and beat all the monsters.",
    "prob_desc_output_spec": "For each test case print a single integer — the smallest possible power the hero must start the level with to be able to enter all the caves in some order and beat all the monsters.",
    "prob_desc_input_spec": "Each test contains multiple test cases. The first line contains the number of test cases $$$t$$$ ($$$1 \\le t \\le 10^5$$$). Description of the test cases follows. The first line of each test case contains a single integer $$$n$$$ ($$$1 \\le n \\le 10^5$$$) — the number of caves. The $$$i$$$-th of the next $$$n$$$ lines contains an integer $$$k_i$$$ ($$$1 \\le k_i \\le 10^5$$$) — the number of monsters in the $$$i$$$-th cave, followed by $$$k_i$$$ integers $$$a_{i, 1}, a_{i, 2}, \\ldots, a_{i, k_i}$$$ ($$$1 \\le a_{i, j} \\le 10^9$$$) — armor levels of the monsters in cave $$$i$$$ in order the hero has to fight them. It is guaranteed that the sum of $$$k_i$$$ over all test cases does not exceed $$$10^5$$$.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3-64",
    "lang_cluster": "Python",
    "difficulty": 1300,
    "file_name": "train_100.jsonl",
    "code_uid": "168148a8ecf107d3e1510b39c45ed005",
    "prob_desc_memory_limit": "512 megabytes",
    "prob_desc_sample_inputs": "[\"2\\n1\\n1 42\\n2\\n3 10 15 8\\n2 12 11\"]",
    "exec_outcome": "PASSED",
    "source_code": "# ------------------- fast io --------------------\r\nimport os\r\nimport sys\r\nfrom io import BytesIO, IOBase\r\nimport math\r\n \r\nBUFSIZE = 8192\r\n \r\n \r\nclass FastIO(IOBase):\r\n    newlines = 0\r\n    \r\n    def __init__(self, file):\r\n        self._fd = file.fileno()\r\n        self.buffer = BytesIO()\r\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\r\n        self.write = self.buffer.write if self.writable else None\r\n    \r\n    def read(self):\r\n        while True:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            if not b:\r\n                break\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines = 0\r\n        return self.buffer.read()\r\n    \r\n    def readline(self):\r\n        while self.newlines == 0:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            self.newlines = b.count(b\"\\n\") + (not b)\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines -= 1\r\n        return self.buffer.readline()\r\n    \r\n    def flush(self):\r\n        if self.writable:\r\n            os.write(self._fd, self.buffer.getvalue())\r\n            self.buffer.truncate(0), self.buffer.seek(0)\r\n \r\n \r\nclass IOWrapper(IOBase):\r\n    def __init__(self, file):\r\n        self.buffer = FastIO(file)\r\n        self.flush = self.buffer.flush\r\n        self.writable = self.buffer.writable\r\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\r\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\r\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\r\n \r\n \r\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\r\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\r\n \r\n# ------------------- fast io --------------------\r\ndef gcd(x, y):\r\n    while y:\r\n        x, y = y, x % y\r\n    return x\r\n \r\n \r\ndef lcm(a, b): return a * b // gcd(a, b)\r\n\r\ndef is_prime(n):\r\n    if (n <= 1):\r\n        return False\r\n    for i in range(2, int(math.sqrt(n))+1):\r\n        if (n % i == 0):\r\n            return False\r\n    return True\r\n\r\n# ------------------- write code from here --------------------\r\nfor _ in range(int(input())):\r\n    n = int(input())\r\n    # n, k = map(int, input().split())\r\n    # arr= list(map(int, input().split()))\r\n    output_arr =[]\r\n    for i in range(n):\r\n        arr= list(map(int, input().split()))\r\n        # arr= arr-1\r\n        # arr= [x-1 for x in arr]\r\n        for i in range(1,len(arr)):\r\n            arr[i]= arr[i]-i+1\r\n        output_arr.append(arr)\r\n    # print(*output_arr)\r\n    output_arr.sort(key= lambda x: max(x))\r\n    caves= []\r\n    for i in range( len(output_arr)):\r\n        caves.append([len(output_arr[i])-1, max(output_arr[i][1:])])\r\n\r\n    # print(caves)\r\n    caves.sort(key=lambda x: x[1])\r\n    def check(n, caves):\r\n        for i in range(len(caves)):\r\n            t=0\r\n            if caves[i][1]<n:\r\n                n+=caves[i][0]\r\n                continue\r\n            else:\r\n                t=1\r\n                break\r\n\r\n        if t==0:\r\n            # n+=caves[0][0]\r\n            return [True, n]\r\n        else:\r\n            return [False]\r\n\r\n    # print(check(13, caves))\r\n    low= caves[0][1]\r\n    high= caves[-1][1]\r\n    # while l<=h:\r\n    # print(low, high)\r\n    while low< high:\r\n        mid= (low +high)//2\r\n        if mid== low or mid==high:\r\n            break\r\n        # print(mid)\r\n        k= check(mid, caves) \r\n        if k[0]==True:\r\n            high=mid\r\n        else:\r\n            low= mid\r\n        \r\n        \r\n    # print(high)\r\n    if check(low, caves)[0]==True:\r\n        print(low)\r\n    elif check(high, caves)[0]==True:\r\n        print(high)\r\n    else:\r\n        # print(\"u\")\r\n        print(high+1)\r\n    #     mid= (low +high)//2\r\n    # print(check(high, caves)[0])\r\n    \r\n    # print(low)\r\n\r\n    \r\n",
    "prob_desc_created_at": "1629815700",
    "tags": [
        "binary search",
        "greedy",
        "sortings"
    ],
    "hidden_unit_tests": ""
}
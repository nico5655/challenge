{
    "prob_desc_time_limit": "1 second",
    "prob_desc_sample_outputs": "[\"1\\n3\", \"2\\n3 4\", \"0\", \"1\\n999999998\"]",
    "src_uid": "b96427767128e235d46bea8d5c4cbbaf",
    "prob_desc_notes": "NoteIn the first test, $$$p=2$$$.  If $$$x \\le 2$$$, there are no valid permutations for Yuzu. So $$$f(x)=0$$$ for all $$$x \\le 2$$$. The number $$$0$$$ is divisible by $$$2$$$, so all integers $$$x \\leq 2$$$ are not good.  If $$$x = 3$$$, $$$\\{1,2,3\\}$$$ is the only valid permutation for Yuzu. So $$$f(3)=1$$$, so the number $$$3$$$ is good.  If $$$x = 4$$$, $$$\\{1,2,3\\} , \\{1,3,2\\} , \\{2,1,3\\} , \\{2,3,1\\}$$$ are all valid permutations for Yuzu. So $$$f(4)=4$$$, so the number $$$4$$$ is not good.  If $$$x \\ge 5$$$, all $$$6$$$ permutations are valid for Yuzu. So $$$f(x)=6$$$ for all $$$x \\ge 5$$$, so all integers $$$x \\ge 5$$$ are not good. So, the only good number is $$$3$$$.In the third test, for all positive integers $$$x$$$ the value $$$f(x)$$$ is divisible by $$$p = 3$$$.",
    "prob_desc_description": "This is the hard version of the problem. The difference between versions is the constraints on $$$n$$$ and $$$a_i$$$. You can make hacks only if all versions of the problem are solved.First, Aoi came up with the following idea for the competitive programming problem:Yuzu is a girl who collecting candies. Originally, she has $$$x$$$ candies. There are also $$$n$$$ enemies numbered with integers from $$$1$$$ to $$$n$$$. Enemy $$$i$$$ has $$$a_i$$$ candies.Yuzu is going to determine a permutation $$$P$$$. A permutation is an array consisting of $$$n$$$ distinct integers from $$$1$$$ to $$$n$$$ in arbitrary order. For example, $$$\\{2,3,1,5,4\\}$$$ is a permutation, but $$$\\{1,2,2\\}$$$ is not a permutation ($$$2$$$ appears twice in the array) and $$$\\{1,3,4\\}$$$ is also not a permutation (because $$$n=3$$$ but there is the number $$$4$$$ in the array).After that, she will do $$$n$$$ duels with the enemies with the following rules:  If Yuzu has equal or more number of candies than enemy $$$P_i$$$, she wins the duel and gets $$$1$$$ candy. Otherwise, she loses the duel and gets nothing.  The candy which Yuzu gets will be used in the next duels. Yuzu wants to win all duels. How many valid permutations $$$P$$$ exist?This problem was easy and wasn't interesting for Akari, who is a friend of Aoi. And Akari made the following problem from the above idea:Let's define $$$f(x)$$$ as the number of valid permutations for the integer $$$x$$$.You are given $$$n$$$, $$$a$$$ and a prime number $$$p \\le n$$$. Let's call a positive integer $$$x$$$ good, if the value $$$f(x)$$$ is not divisible by $$$p$$$. Find all good integers $$$x$$$.Your task is to solve this problem made by Akari.",
    "prob_desc_output_spec": "In the first line, print the number of good integers $$$x$$$. In the second line, output all good integers $$$x$$$ in the ascending order. It is guaranteed that the number of good integers $$$x$$$ does not exceed $$$10^5$$$.",
    "prob_desc_input_spec": "The first line contains two integers $$$n$$$, $$$p$$$ $$$(2 \\le p \\le n \\le 10^5)$$$. It is guaranteed, that the number $$$p$$$ is prime (it has exactly two divisors $$$1$$$ and $$$p$$$). The second line contains $$$n$$$ integers $$$a_1, a_2, \\ldots, a_n$$$ $$$(1 \\le a_i \\le 10^9)$$$.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3",
    "lang_cluster": "Python",
    "difficulty": 2300,
    "file_name": "train_033.jsonl",
    "code_uid": "8e7f812ab7c09ce85936d67c3f1ba480",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"3 2\\n3 4 5\", \"4 3\\n2 3 5 6\", \"4 3\\n9 1 1 1\", \"3 2\\n1000000000 1 999999999\"]",
    "exec_outcome": "PASSED",
    "source_code": "import sys\nimport collections  \ndef input():\n\treturn sys.stdin.readline().rstrip()\n \ndef split_input():\n\treturn [int(i) for i in input().split()]\n\nn,p = split_input()\na = split_input()\n\nstart = max(a) - n + 1\nx = [0 for i in range(n)]\nfor i in a:\n\tind = i - start\n\tif ind <= 0:\n\t\tx[0] += 1\n\telse:\n\t\tx[ind] += 1\nfor i in range(1,n):\n\tx[i] += x[i-1]\nzero_ind = -1\nfor i in range(n):\n\tzero_ind = max(i - x[i], zero_ind)\ns = set()\nfor i in range(zero_ind+1, n):\n\tif x[i] >= p:\n\t# \tt = p\n\t# \twhile (x[i] >= t):\n\t# \t\ts.add(i - (x[i] - t))\n\t# \t\tt += p\n\t\ts.add((i + start - x[i])%p)\nans = []\nfor i in range(zero_ind + 1, p):\n\tif (i+start)%p not in s:\n\t\tans.append(i + start)\nprint(len(ans))\nprint(*ans, sep = \" \")",
    "prob_desc_created_at": "1593610500",
    "tags": [
        "dp",
        "combinatorics",
        "number theory",
        "math",
        "sortings",
        "binary search"
    ],
    "hidden_unit_tests": ""
}
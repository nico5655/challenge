{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"1 0 0 1 1\"]",
    "src_uid": "02a0b3cb995f954b216130d703dfc856",
    "prob_desc_notes": "NoteLet us calculate the answer for sample input with root node as 1 and as 2.Root node 1Alice always wins in this case. One possible gameplay between Alice and Bob is:  Alice moves one present from node 4 to node 3.  Bob moves four presents from node 5 to node 2.  Alice moves four presents from node 2 to node 1.  Bob moves three presents from node 2 to node 1.  Alice moves three presents from node 3 to node 1.  Bob moves three presents from node 4 to node 3.  Alice moves three presents from node 3 to node 1. Bob is now unable to make a move and hence loses.Root node 2Bob always wins in this case. One such gameplay is:  Alice moves four presents from node 4 to node 3.  Bob moves four presents from node 5 to node 2.  Alice moves six presents from node 3 to node 1.  Bob moves six presents from node 1 to node 2. Alice is now unable to make a move and hence loses.",
    "prob_desc_description": "Alice and Bob are going to celebrate Christmas by playing a game with a tree of presents. The tree has $$$n$$$ nodes (numbered $$$1$$$ to $$$n$$$, with some node $$$r$$$ as its root). There are $$$a_i$$$ presents are hanging from the $$$i$$$-th node.Before beginning the game, a special integer $$$k$$$ is chosen. The game proceeds as follows: Alice begins the game, with moves alternating each turn; in any move, the current player may choose some node (for example, $$$i$$$) which has depth at least $$$k$$$. Then, the player picks some positive number of presents hanging from that node, let's call it $$$m$$$ $$$(1 \\le m \\le a_i)$$$; the player then places these $$$m$$$ presents on the $$$k$$$-th ancestor (let's call it $$$j$$$) of the $$$i$$$-th node (the $$$k$$$-th ancestor of vertex $$$i$$$ is a vertex $$$j$$$ such that $$$i$$$ is a descendant of $$$j$$$, and the difference between the depth of $$$j$$$ and the depth of $$$i$$$ is exactly $$$k$$$). Now, the number of presents of the $$$i$$$-th node $$$(a_i)$$$ is decreased by $$$m$$$, and, correspondingly, $$$a_j$$$ is increased by $$$m$$$; Alice and Bob both play optimally. The player unable to make a move loses the game.For each possible root of the tree, find who among Alice or Bob wins the game.Note: The depth of a node $$$i$$$ in a tree with root $$$r$$$ is defined as the number of edges on the simple path from node $$$r$$$ to node $$$i$$$. The depth of root $$$r$$$ itself is zero.",
    "prob_desc_output_spec": "Output $$$n$$$ integers, where the $$$i$$$-th integer is $$$1$$$ if Alice wins the game when the tree is rooted at node $$$i$$$, or $$$0$$$ otherwise.",
    "prob_desc_input_spec": "The first line contains two space-separated integers $$$n$$$ and $$$k$$$ $$$(3 \\le n \\le 10^5, 1 \\le k \\le 20)$$$. The next $$$n-1$$$ lines each contain two integers $$$x$$$ and $$$y$$$ $$$(1 \\le x, y \\le n, x \\neq y)$$$, denoting an undirected edge between the two nodes $$$x$$$ and $$$y$$$. These edges form a tree of $$$n$$$ nodes. The next line contains $$$n$$$ space-separated integers denoting the array $$$a$$$ $$$(0 \\le a_i \\le 10^9)$$$.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3-64",
    "lang_cluster": "Python",
    "difficulty": 2500,
    "file_name": "train_107.jsonl",
    "code_uid": "0f9abcad7a7ac1299c59398463220677",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"5 1\\n1 2\\n1 3\\n5 2\\n4 3\\n0 3 2 4 4\"]",
    "exec_outcome": "PASSED",
    "source_code": "'''\r\nHala Madrid!\r\nhttps://www.zhihu.com/people/li-dong-hao-78-74\r\n'''\r\n\r\nimport sys\r\nimport os\r\nfrom io import BytesIO, IOBase\r\nBUFSIZE = 8192\r\nclass FastIO(IOBase):\r\n    newlines = 0\r\n    def __init__(self, file):\r\n        self._fd = file.fileno()\r\n        self.buffer = BytesIO()\r\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\r\n        self.write = self.buffer.write if self.writable else None\r\n    def read(self):\r\n        while True:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            if not b:\r\n                break\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines = 0\r\n        return self.buffer.read()\r\n    def readline(self):\r\n        while self.newlines == 0:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            self.newlines = b.count(b\"\\n\") + (not b)\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines -= 1\r\n        return self.buffer.readline()\r\n    def flush(self):\r\n        if self.writable:\r\n            os.write(self._fd, self.buffer.getvalue())\r\n            self.buffer.truncate(0), self.buffer.seek(0)\r\nclass IOWrapper(IOBase):\r\n    def __init__(self, file):\r\n        self.buffer = FastIO(file)\r\n        self.flush = self.buffer.flush\r\n        self.writable = self.buffer.writable\r\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\r\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\r\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\r\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\r\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\r\n\r\ndef I():\r\n    return input()\r\ndef II():\r\n    return int(input())\r\ndef MI():\r\n    return map(int, input().split())\r\ndef LI():\r\n    return list(input().split())\r\ndef LII():\r\n    return list(map(int, input().split()))\r\ndef GMI():\r\n    return map(lambda x: int(x) - 1, input().split())\r\n\r\n#------------------------------FastIO---------------------------------\r\n\r\nfrom bisect import *\r\nfrom heapq import *\r\nfrom collections import *\r\nfrom functools import *\r\nfrom itertools import *\r\nfrom time import *\r\nfrom random import *\r\nfrom math import log, gcd, sqrt, ceil\r\n\r\nclass TopSort_Tree:\r\n    def __init__(self, n) -> None:\r\n        self.n = n\r\n        self.graph = defaultdict(set)\r\n        self.parent = [n + 1 for _ in range(self.n)]\r\n    \r\n    def add_edge(self, a, b):\r\n        self.graph[a].add(b)\r\n        self.graph[b].add(a)\r\n    \r\n    def sort(self, root):\r\n        graphlist = []\r\n        q = deque()\r\n        q.append((root, -1))\r\n        while q:\r\n            cur, fa = q.popleft()\r\n            graphlist.append(cur)\r\n            for e in self.graph[cur]:\r\n                if e == fa:\r\n                    continue\r\n                else:\r\n                    self.parent[e] = cur\r\n                    q.append((e, cur))\r\n        return graphlist[::-1]\r\n\r\ndef solve():\r\n    n, k = MI()\r\n    gl = TopSort_Tree(n)\r\n    xorsum = [[0 for _ in range(k << 1)] for _ in range(n)]\r\n    win = [0 for _ in range(n)]\r\n\r\n    for _ in range(n - 1):\r\n        x, y = MI()\r\n        x -= 1\r\n        y -= 1\r\n        gl.add_edge(x, y)\r\n    nums = LII()\r\n    \r\n    graphlist = gl.sort(0)\r\n\r\n    for node in graphlist:\r\n        xorsum[node][0] ^= nums[node]\r\n        if node == 0:\r\n            break\r\n        fa = gl.parent[node]\r\n        for depth in range(k << 1):\r\n            xorsum[fa][depth] ^= xorsum[node][depth - 1]\r\n    #print(xorsum)\r\n\r\n    q = deque()\r\n    q.append((0, -1, [0 for _ in range(k << 1)]))\r\n\r\n    while q:\r\n        node, fa, prev_xors = q.popleft()\r\n        final_xors = [x ^ y for x, y in zip(prev_xors, xorsum[node])]\r\n\r\n        for e in gl.graph[node]:\r\n            if e == fa:\r\n                continue\r\n            send_xors = final_xors[:]\r\n            for i in range(k << 1):\r\n                send_xors[i] ^= xorsum[e][i - 1]\r\n            send_xors = [send_xors[-1]] + send_xors[:-1]\r\n            q.append((e, node, send_xors))\r\n        \r\n        odd_xors = 0\r\n        for i in range(k, k << 1):\r\n            odd_xors ^= final_xors[i]\r\n        \r\n        win[node] = 1 if odd_xors else 0\r\n        \r\n    print(*win)    \r\nfor _ in range(1):solve()",
    "prob_desc_created_at": "1617028500",
    "tags": [
        "bitmasks",
        "data structures",
        "dfs and similar",
        "dp",
        "games",
        "math",
        "trees"
    ],
    "hidden_unit_tests": ""
}
{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"YES\\n4 1 4 4 1\\n4 5 5 5 1\\n4 5 1 5 4\\n1 5 5 5 4\\n1 4 4 1 4\", \"NO\", \"YES\\n4 1\\n4 1\\n1 4\", \"YES\\n4 4 4 1 4 1 4 1 4\\n1 5 5 5 5 5 4 10 1\\n4 5 1 4 1 5 4 4 4\\n4 5 1 5 5 0 5 5 1\\n4 5 1 5 4 5 1 5 4\\n4 5 1 5 5 5 4 5 1\\n1 5 4 4 1 1 4 5 1\\n4 5 5 5 5 5 5 5 4\\n1 1 1 1 4 4 1 1 4\"]",
    "src_uid": "acbcf0b55f204a12d861936c8a60a8b0",
    "prob_desc_notes": "NoteIt can be shown that no such grid exists for the second test.",
    "prob_desc_description": "Alice has an empty grid with $$$n$$$ rows and $$$m$$$ columns. Some of the cells are marked, and no marked cells are adjacent to the edge of the grid. (Two squares are adjacent if they share a side.) Alice wants to fill each cell with a number such that the following statements are true:   every unmarked cell contains either the number $$$1$$$ or $$$4$$$;  every marked cell contains the sum of the numbers in all unmarked cells adjacent to it (if a marked cell is not adjacent to any unmarked cell, this sum is $$$0$$$);  every marked cell contains a multiple of $$$5$$$.  Alice couldn't figure it out, so she asks Bob to help her. Help Bob find any such grid, or state that no such grid exists.",
    "prob_desc_output_spec": "Output \"'NO\" if no suitable grid exists. Otherwise, output \"'YES\"'. Then output $$$n$$$ lines of $$$m$$$ space-separated integers — the integers in the grid.",
    "prob_desc_input_spec": "The first line of input contains two integers $$$n$$$ and $$$m$$$ ($$$1 \\leq n, m \\leq 500$$$) — the number of rows and the number of columns in the grid, respectively. Then $$$n$$$ lines follow, each containing $$$m$$$ characters. Each of these characters is either '.' or 'X' — an unmarked and a marked cell, respectively. No marked cells are adjacent to the edge of the grid.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3-64",
    "lang_cluster": "Python",
    "difficulty": 2700,
    "file_name": "train_089.jsonl",
    "code_uid": "a0bbcec601504cc976dcc1f8718a493f",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"5 5\\n.....\\n.XXX.\\n.X.X.\\n.XXX.\\n.....\", \"5 5\\n.....\\n.XXX.\\n.XXX.\\n.XXX.\\n.....\", \"3 2\\n..\\n..\\n..\", \"9 9\\n.........\\n.XXXXX.X.\\n.X...X...\\n.X.XXXXX.\\n.X.X.X.X.\\n.X.XXX.X.\\n.X.....X.\\n.XXXXXXX.\\n.........\"]",
    "exec_outcome": "PASSED",
    "source_code": "#!/usr/bin/env python3\r\nimport sys\r\nimport getpass  # not available on codechef\r\nimport math, random\r\nimport functools, itertools, collections, heapq, bisect\r\nfrom collections import Counter, defaultdict, deque\r\ninput = sys.stdin.readline  # to read input quickly\r\n\r\n# import io, os  # if all integers, otherwise need to post process\r\n# input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline\r\n\r\n# available on Google, AtCoder Python3, not available on Codeforces\r\n# import numpy as np\r\n# import scipy\r\n\r\nM9 = 10**9 + 7  # 998244353\r\nyes, no = \"YES\", \"NO\"\r\nd4 = [(1,0),(0,1),(-1,0),(0,-1)]\r\n# d8 = [(1,0),(1,1),(0,1),(-1,1),(-1,0),(-1,-1),(0,-1),(1,-1)]\r\n# d6 = [(2,0),(1,1),(-1,1),(-2,0),(-1,-1),(1,-1)]  # hexagonal layout\r\nMAXINT = sys.maxsize\r\n\r\n# if testing locally, print to terminal with a different color\r\nOFFLINE_TEST = getpass.getuser() == \"hkmac\"\r\n# OFFLINE_TEST = False  # codechef does not allow getpass\r\ndef log(*args):\r\n    if OFFLINE_TEST:\r\n        print('\\033[36m', *args, '\\033[0m', file=sys.stderr)\r\n\r\ndef solve(*args):\r\n    # screen input\r\n    if OFFLINE_TEST:\r\n        log(\"----- solving ------\")\r\n        log(*args)\r\n        log(\"----- ------- ------\")\r\n    return solve_(*args)\r\n\r\ndef read_matrix(nrows):\r\n    return [list(map(int,input().split())) for _ in range(nrows)]\r\n\r\ndef read_matrix_and_flatten(nrows):\r\n    return [int(x) for i in range(nrows) for x in input().split()]\r\n\r\ndef read_strings(nrows):\r\n    return [input().strip() for _ in range(nrows)]\r\n\r\ndef minus_one(arr):\r\n    return [x-1 for x in arr]\r\n\r\ndef minus_one_matrix(mrr):\r\n    return [[x-1 for x in row] for row in mrr]\r\n\r\n# ---------------------------- template ends here ----------------------------\r\n\r\ndef isBipartite(edges) -> bool:\r\n    g = defaultdict(set)\r\n    for cur,nex in edges:\r\n        g[cur].add(nex)\r\n        g[nex].add(cur)\r\n\r\n    colored = {}  # and visited\r\n\r\n    for start in g:\r\n        if start in colored:\r\n            continue\r\n        stack = [(start,True)]\r\n        colored[start] = True\r\n\r\n        while stack:\r\n            cur, color = stack.pop()\r\n            for nex in g[cur]:\r\n                if nex in colored:\r\n                    if colored[nex] == color:\r\n                        return False\r\n                    continue\r\n                stack.append((nex, not color))\r\n                colored[nex] = not color\r\n\r\n    return True, colored\r\n\r\ndef solve_(arr,h,w):\r\n    # your solution here\r\n    res = [[1 for _ in row] for row in arr]\r\n\r\n    edges = []\r\n    diamonds = {}\r\n\r\n    for x,row in enumerate(arr):\r\n        for y,cell in enumerate(row):\r\n            if cell == 1:\r\n                adj = []\r\n                for dx,dy in d4:\r\n                    xx,yy = x+dx, y+dy\r\n                    if 0 <= xx < h and 0 <= yy < w:\r\n                        if arr[xx][yy] == 0:\r\n                            adj.append((xx,yy))\r\n                if len(adj)%2 != 0:\r\n                    return -1\r\n                if len(adj) == 2:\r\n                    edges.append(adj)\r\n                if len(adj) == 4:\r\n                    adj[0],adj[2]=adj[2],adj[0]\r\n                    diamonds[x,y] = adj\r\n                    edges.append(adj[:2])\r\n                    edges.append(adj[2:])\r\n                res[x][y] = len(adj)//2 * 5\r\n\r\n    is_bipartite, colored = isBipartite(edges)\r\n    if not is_bipartite:\r\n        return -1\r\n\r\n    #log(edges)\r\n    #log(diamonds)\r\n    #log(colored)\r\n\r\n    for (x,y), c in colored.items():\r\n        if c:\r\n            res[x][y] = 4\r\n        else:\r\n            res[x][y] = 1\r\n\r\n    return res\r\n\r\n\r\nfor case_num in [0]:  # no loop over test case\r\n# for case_num in range(100):  # if the number of test cases is specified\r\n# for case_num in range(int(input())):\r\n\r\n    # read line as an integer\r\n    # k = int(input())\r\n\r\n    # read line as a string\r\n    # srr = input().strip()\r\n\r\n    # read one line and parse each word as a string\r\n    # lst = input().split()\r\n\r\n    # read one line and parse each word as an integer\r\n    h,w = list(map(int,input().split()))\r\n    # arr = list(map(int,input().split()))\r\n    # arr = minus_one(arr)\r\n\r\n    # read multiple rows\r\n    arr = read_strings(h)  # and return as a list of str\r\n    # mrr = read_matrix(k)  # and return as a list of list of int\r\n    # arr = read_matrix(k)  # and return as a list of list of int\r\n    # mrr = minus_one_matrix(mrr)\r\n\r\n    arr = [[1 if c == \"X\" else 0 for c in row] for row in arr]\r\n\r\n    res = solve(arr,h,w)  # include input here\r\n\r\n    # print length if applicable\r\n    # print(len(res))\r\n    log(\"res\", res)\r\n\r\n    if res == -1:\r\n        print(no)\r\n        continue\r\n    print(yes)\r\n\r\n    # parse result\r\n    # res = \" \".join(str(x) for x in res)\r\n    # res = \"\\n\".join(str(x) for x in res)\r\n    res = \"\\n\".join(\" \".join(str(x) for x in row) for row in res)\r\n\r\n    # print result\r\n    # print(\"Case #{}: {}\".format(case_num+1, res))   # Google and Facebook - case number required\r\n\r\n    print(res)",
    "prob_desc_created_at": "1630852500",
    "tags": [
        "2-sat",
        "constructive algorithms",
        "dfs and similar",
        "dsu",
        "graphs",
        "implementation"
    ],
    "hidden_unit_tests": ""
}
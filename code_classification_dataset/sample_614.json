{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"YES\", \"NO\", \"NO\"]",
    "src_uid": "63b20ab2993fddf2cc469c4c4e8027df",
    "prob_desc_notes": null,
    "prob_desc_description": "The new \"Die Hard\" movie has just been released! There are n people at the cinema box office standing in a huge line. Each of them has a single 100, 50 or 25 ruble bill. A \"Die Hard\" ticket costs 25 rubles. Can the booking clerk sell a ticket to each person and give the change if he initially has no money and sells the tickets strictly in the order people follow in the line?",
    "prob_desc_output_spec": "Print \"YES\" (without the quotes) if the booking clerk can sell a ticket to each person and give the change. Otherwise print \"NO\".",
    "prob_desc_input_spec": "The first line contains integer n (1 ≤ n ≤ 105) — the number of people in the line. The next line contains n integers, each of them equals 25, 50 or 100 — the values of the bills the people have. The numbers are given in the order from the beginning of the line (at the box office) to the end of the line.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 2",
    "lang_cluster": "Python",
    "difficulty": 1100,
    "file_name": "train_003.jsonl",
    "code_uid": "176be2f84d8fbaf57f3fbeb09205c751",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"4\\n25 25 50 50\", \"2\\n25 100\", \"4\\n50 50 25 25\"]",
    "exec_outcome": "PASSED",
    "source_code": "#!/usr/bin/env pypy\nfrom __future__ import division, print_function\nfrom collections import defaultdict, Counter, deque\nfrom future_builtins import ascii, filter, hex, map, oct, zip\nfrom itertools import imap as map, izip as zip, permutations, combinations, combinations_with_replacement\nfrom __builtin__ import xrange as range\nfrom math import ceil, factorial, log,tan,pi,cos,sin,radians\nfrom _continuation import continulet\nfrom cStringIO import StringIO\nfrom io import IOBase\nimport __pypy__\nfrom bisect import bisect, insort, bisect_left, bisect_right\nfrom fractions import Fraction\nfrom functools import reduce\nimport string\nimport sys\nimport os\nimport re\ninf = float('inf')\nmod_ = int(1e9) + 7\nmod = 998244353\n\ndef factors(n):\n    from functools import reduce\n    return set(reduce(list.__add__, ([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0)))\n\ndef sieve(m):\n    n=1\n    primes = {}\n    arr=set([])\n    for i in range(2, int(m ** 0.5) + 1):\n        a = n // i\n        b = m // i\n        for k in range(max(2, a), b + 1):\n            c = i * k\n            primes[c] = 1\n\n    for i in range(max(n, 2), m + 1):\n        if i not in primes:\n            arr.add(i)\n\n    return arr\n\n\nclass DisjointSetUnion:\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.size = [1] * n\n        self.num_sets = n\n \n    def find(self, a):\n        acopy = a\n        while a != self.parent[a]:\n            a = self.parent[a]\n        while acopy != a:\n            self.parent[acopy], acopy = a, self.parent[acopy]\n        return a\n \n    def union(self, a, b):\n        a, b = self.find(a), self.find(b)\n        if a != b:\n            if self.size[a] < self.size[b]:\n                a, b = b, a\n \n            self.num_sets -= 1\n            self.parent[b] = a\n            self.size[a] += self.size[b]\n \n    def set_size(self, a):\n        return self.size[self.find(a)]\n \n    def __len__(self):\n        return self.num_sets\n\ndef isprime(t):\n    for i in range(2,int(t**0.5)+1):\n        if t%i==0:\n            return False\n    return True\ndef semiprime(x):\n    for i in range(2,int(x**0.5)+1):\n        if x%i==0:\n            if isprime(i) and isprime(x//i) and i!=x//i:\n                return True\n    return False\n\n\n\ndef main():\n    n=int(input())\n    arr=list(map(int,input().split()))\n    cnt_25=cnt_50=0\n    for i in arr:\n        # print(cnt_25,cnt_50)\n        if i==25:\n            cnt_25+=1\n        elif i==50:\n            cnt_25-=1\n            cnt_50+=1\n        else:\n            if cnt_50>=1:\n                cnt_50-=1\n                cnt_25-=1\n            else:\n                cnt_25-=3\n        if cnt_25<0:\n            print(\"NO\")\n            break\n    else:\n        print(\"YES\")\n\n\n\n\n        \n\n        \n    \n\n\n\n\n    \n\n\n\n# region fastio\n\nBUFSIZE = 8192\n\nclass FastI(IOBase):\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self._buffer = StringIO()\n        self.newlines = 0\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(\"\\n\") + (not b)\n            ptr = self._buffer.tell()\n            self._buffer.seek(0, 2), self._buffer.write(b), self._buffer.seek(ptr)\n        self.newlines -= 1\n        return self._buffer.readline()\n\n\nclass FastO(IOBase):\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self._buffer = __pypy__.builders.StringBuilder()\n        self.write = lambda s: self._buffer.append(s)\n\n    def flush(self):\n        os.write(self._fd, self._buffer.build())\n        self._buffer = __pypy__.builders.StringBuilder()\n\n\ndef print(*args, **kwargs):\n    sep, file = kwargs.pop(\"sep\", \" \"), kwargs.pop(\"file\", sys.stdout)\n    at_start = True\n    for x in args:\n        if not at_start:\n            file.write(sep)\n        file.write(str(x))\n        at_start = False\n    file.write(kwargs.pop(\"end\", \"\\n\"))\n    if kwargs.pop(\"flush\", False):\n        file.flush()\n\ndef gcd(x, y):\n    while y:\n        x, y = y, x % y\n    return x\n\nsys.stdin, sys.stdout = FastI(sys.stdin), FastO(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n# endregion\n\nif __name__ == \"__main__\":\n    main()\n",
    "prob_desc_created_at": "1380295800",
    "tags": [
        "implementation",
        "greedy"
    ],
    "hidden_unit_tests": ""
}
{
    "prob_desc_time_limit": "3 seconds",
    "prob_desc_sample_outputs": "[\"6\\n2\\n15\\n30\"]",
    "src_uid": "5a544816938d05da4f85fe7589d3289a",
    "prob_desc_notes": "NoteConsider the example:  boundaries for first query are $$$(0 + 1) \\bmod 3 + 1 = 2$$$ and $$$(0 + 3) \\bmod 3 + 1 = 1$$$. LCM for segment $$$[1, 2]$$$ is equal to $$$6$$$;  boundaries for second query are $$$(6 + 3) \\bmod 3 + 1 = 1$$$ and $$$(6 + 3) \\bmod 3 + 1 = 1$$$. LCM for segment $$$[1, 1]$$$ is equal to $$$2$$$;  boundaries for third query are $$$(2 + 2) \\bmod 3 + 1 = 2$$$ and $$$(2 + 3) \\bmod 3 + 1 = 3$$$. LCM for segment $$$[2, 3]$$$ is equal to $$$15$$$;  boundaries for fourth query are $$$(15 + 2) \\bmod 3 + 1 = 3$$$ and $$$(15 + 3) \\bmod 3 + 1 = 1$$$. LCM for segment $$$[1, 3]$$$ is equal to $$$30$$$. ",
    "prob_desc_description": "Yura owns a quite ordinary and boring array $$$a$$$ of length $$$n$$$. You think there is nothing more boring than that, but Vladik doesn't agree!In order to make Yura's array even more boring, Vladik makes $$$q$$$ boring queries. Each query consists of two integers $$$x$$$ and $$$y$$$. Before answering a query, the bounds $$$l$$$ and $$$r$$$ for this query are calculated: $$$l = (last + x) \\bmod n + 1$$$, $$$r = (last + y) \\bmod n + 1$$$, where $$$last$$$ is the answer on the previous query (zero initially), and $$$\\bmod$$$ is the remainder operation. Whenever $$$l &gt; r$$$, they are swapped.After Vladik computes $$$l$$$ and $$$r$$$ for a query, he is to compute the least common multiple (LCM) on the segment $$$[l; r]$$$ of the initial array $$$a$$$ modulo $$$10^9 + 7$$$. LCM of a multiset of integers is the smallest positive integer that is divisible by all the elements of the multiset. The obtained LCM is the answer for this query.Help Vladik and compute the answer for each query!",
    "prob_desc_output_spec": "Print $$$q$$$ integers — the answers for the queries.",
    "prob_desc_input_spec": "The first line contains a single integer $$$n$$$ ($$$1 \\le n \\le 10^5$$$) — the length of the array. The second line contains $$$n$$$ integers $$$a_i$$$ ($$$1 \\le a_i \\le 2 \\cdot 10^5$$$) — the elements of the array. The third line contains a single integer $$$q$$$ ($$$1 \\le q \\le 10^5$$$) — the number of queries. The next $$$q$$$ lines contain two integers $$$x$$$ and $$$y$$$ each ($$$1 \\le x, y \\le n$$$) — the description of the corresponding query.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 2",
    "lang_cluster": "Python",
    "difficulty": 2700,
    "file_name": "train_033.jsonl",
    "code_uid": "2c9b01f4d0b76f096e10b0fcc22b1f6b",
    "prob_desc_memory_limit": "512 megabytes",
    "prob_desc_sample_inputs": "[\"3\\n2 3 5\\n4\\n1 3\\n3 3\\n2 3\\n2 3\"]",
    "exec_outcome": "PASSED",
    "source_code": "import sys\nrange = xrange\ninput = raw_input\n\n# MOD\nMOD = 10**9 + 7\n\ndef fast_modder(MOD):\n    \"\"\" Returns function modmul(a,b) that quickly calculates a * b % MOD, assuming 0 <= a,b < MOD \"\"\"\n    import sys, platform\n    impl = platform.python_implementation()\n    maxs = sys.maxsize\n    if 'PyPy' in impl and MOD <= maxs and MOD ** 2 > maxs:\n        import __pypy__\n        intsub = __pypy__.intop.int_sub\n        intmul = __pypy__.intop.int_mul\n        intmulmod = __pypy__.intop.int_mulmod\n        if MOD < 2**30:\n            MODINV = 1.0 / MOD\n            def modmul(a, b):\n                x = intsub(intmul(a,b), intmul(MOD, int(MODINV * a * b)))\n                return x - MOD if x >= MOD else (x if x >= 0 else x + MOD)\n        else:\n            def modmul(a, b):\n                return intmulmod(a, b, MOD)\n    else:\n        def modmul(a, b):\n            return a * b % MOD\n    return modmul\n\nmodmul = fast_modder(MOD)\n\n\n\n# GCD\ndef gcd(a,b):\n    while b:\n        a, b = b, a % b\n    return a\n\n# Prime sieve\nbig = 2 * 10**5 + 1\nmarker = [1] * big\nprimeid = [-1] * big\npid = 0\n\nfor i in range(2, big):\n    if marker[i] == 1:\n        primeid[i] = pid\n        pid += 1\n        for j in range(i, big, i):\n            marker[j] = i\n\n# input and precalc\ninp = [int(x) for x in sys.stdin.read().split()]; ii = 0\nn = inp[ii]; ii+= 1\nA = inp[ii : ii + n]; ii += n\n\nmaxsqrt = 1\nfor i in range(big):\n    if i * i < big and marker[i] == i:\n        maxsqrt = i\n\nbase = [1] * (primeid[maxsqrt] + 1)\n# B is to keep track of small prime factors\n# C is for large factors\nB = []\nC = []\nfor a in A:\n    b = list(base)\n    c = 1\n    while a > 1:\n        p = marker[a]\n        count = 1\n        while a % p == 0:\n            a //= p\n            count *= p\n        if p <= maxsqrt:\n            b[primeid[p]] = count\n        else:\n            c = p\n    B.append(b)\n    C.append(c)\n\ndef merge(A,B):\n    return [max(A[i], B[i]) for i in range(len(A))]\n\n### Segtree 1\nclass brute_seg:\n    def __init__(self, A):\n        n = len(A)\n        data = [base] * (2 * n)\n        data[n:n + n] = A\n        for i in reversed(range(1, n)):\n            data[i] = merge(data[2 * i], data[2 * i + 1])\n\n        def __call__(l,r):\n            l += n\n            r += n\n            B = base\n            \n            while l < r:\n                if l & 1:\n                    B = merge(B, data[l])\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    B = merge(B, data[r])\n                l >>= 1\n                r >>= 1\n            ans = 1\n            for b in B:\n                ans = modmul(ans, b)\n            return ans\n        self.__call__ = __call__\n\nsmallseg = brute_seg(B)\n\n### Segtree 2\n\nfrom bisect import bisect_left as binsearch\nclass mod_mergesort_seg:\n    def __init__(self, A, B):\n        n = len(A)\n        \n        data = [[]] * (2 * n)\n        data[n:2 * n] = [[a] for a in A]\n\n        for i in reversed(range(1, n)):\n            data[i] = sorted(data[2 * i] + data[2 * i + 1])\n        \n        cumsummer = [[1]] * (2 * n)\n        for i in range(1, 2 * n):\n            C = [1]\n            cumsummer[i] = C\n            for d in data[i]:\n                C.append(modmul(C[-1], B[d]))\n\n        def query(l, r, x):\n            \"\"\" Count number of i in [l,r) such that A[i] < x \"\"\"\n            l += n\n            r += n\n            ans = 1\n            while l < r:\n                if l & 1:\n                    ans = modmul(ans, cumsummer[l][binsearch(data[l], x)])\n                    l += 1\n                if r & 1:\n                    r -= 1\n                    ans = modmul(ans, cumsummer[r][binsearch(data[r], x)])\n                l >>= 1\n                r >>= 1\n            return ans\n        self.query = query\n\nclass unique_seg:\n    def __init__(self, A):\n        n = len(A)\n\n        I = []\n        seen = {}\n        for i in range(n):\n            a = A[i]\n            I.append(seen[a] if a in seen else i - n)\n            seen[a] = i\n        \n        seg = mod_mergesort_seg(I, A)\n        self.__call__ = lambda l, r: seg.query(l, r, l)\n\nlargeseg = unique_seg(C)\n\n### Queries\n\nq = inp[ii]; ii += 1\nL = inp[ii + 0: ii + 2 * q: 2]\nR = inp[ii + 1: ii + 2 * q: 2]\nii += 2 * q\n\nans = []\nlast = 0\nfor qind in range(q):\n    l = (last + L[qind]) % n\n    r = (last + R[qind]) % n\n    if l > r:\n        l,r = r,l\n    r += 1\n\n    #val = 1\n    #for a in A[l:r]:\n    #    val = val * a // gcd(val, a)\n    #last = val\n\n    last = modmul(smallseg(l,r), largeseg(l,r))\n\n    ans.append(last)\nprint '\\n'.join(str(x) for x in ans)\n",
    "prob_desc_created_at": "1601827500",
    "tags": [
        "data structures",
        "number theory",
        "math"
    ],
    "hidden_unit_tests": ""
}
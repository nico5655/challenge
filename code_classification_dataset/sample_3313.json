{
    "prob_desc_time_limit": "1 second",
    "prob_desc_sample_outputs": "[\"2\\n1 2 1 3\", \"1\\n1 2\"]",
    "src_uid": "e7517e32caa1b044ebf1d39276560b47",
    "prob_desc_notes": "NoteSequence x1, x2, ..., xs is lexicographically smaller than sequence y1, y2, ..., ys, if there is such integer r (1 ≤ r ≤ s), that x1 = y1, x2 = y2, ..., xr - 1 = yr - 1 and xr &lt; yr. ",
    "prob_desc_description": "A permutation p of length n is a sequence of distinct integers p1, p2, ..., pn (1 ≤ pi ≤ n). A permutation is an identity permutation, if for any i the following equation holds pi = i. A swap (i, j) is the operation that swaps elements pi and pj in the permutation. Let's assume that f(p) is the minimum number of swaps that you need to make the permutation p an identity permutation. Valera wonders, how he can transform permutation p into any permutation q, such that f(q) = m, using the minimum number of swaps. Help him do that.",
    "prob_desc_output_spec": "In the first line, print integer k — the minimum number of swaps. In the second line, print 2k integers x1, x2, ..., x2k — the description of the swap sequence. The printed numbers show that you need to consecutively make swaps (x1, x2), (x3, x4), ..., (x2k - 1, x2k).  If there are multiple sequence swaps of the minimum length, print the lexicographically minimum one.",
    "prob_desc_input_spec": "The first line contains integer n (1 ≤ n ≤ 3000) — the length of permutation p. The second line contains n distinct integers p1, p2, ..., pn (1 ≤ pi ≤ n) — Valera's initial permutation. The last line contains integer m (0 ≤ m &lt; n).",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "Python 2",
    "lang_cluster": "Python",
    "difficulty": 2100,
    "file_name": "train_052.jsonl",
    "code_uid": "da4e9223c725963ecfcd1581dfb40a64",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"5\\n1 2 3 4 5\\n2\", \"5\\n2 1 4 5 3\\n2\"]",
    "exec_outcome": "PASSED",
    "source_code": "n = int(raw_input())\na = [0] + map(int, raw_input().split())\ng = [0] * (n+1)\nl = []\nst = [0] * (n+1)\nnd = [0] * (n+1)\nk = 0\nfor x in xrange(1, n+1):\n    if g[x]:\n        continue\n    y = a[x]\n    st[x] = len(l)\n    while not g[y]:\n        g[y] = x\n        l.append(y)\n        y = a[y]\n    nd[x] = len(l)\n    k += nd[x] - st[x] - 1\n\nN = 4096\nb = [10000] * N * 2\npb = [0] * N * 2\ndef update(p, x):\n    p += N\n    b[p] = x\n    pb[p] = p - N\n    while p > 1:\n        p, q = p / 2, p / 2 * 2\n        if b[q] >= b[q+1]:\n            q += 1\n        b[p], pb[p] = b[q], pb[q]\ndef query(left, right, p = 1, L = 0, R = N):\n    if right <= L or R <= left:\n        return (10000, -1)\n    if left <= L and R <= right:\n        return (b[p], pb[p])\n    mid = (L + R) / 2\n    return min(query(left, right, p+p, L, mid), query(left, right, p+p+1, mid, R))\n\nfor i, x in enumerate(l):\n    update(i, x)\n\nm = int(raw_input())\nif m == k:\n    print 0\nelse:\n    ans = []\n    if m > k:\n        for i in xrange(1, n+1):\n            if m <= k: break\n            if g[i] != 1:\n                for x in l[st[i]:nd[i]]:\n                    g[x] = 1\n                ans.extend([1, i])\n                k += 1\n    else:\n        for i in xrange(1, n+1):\n            while m < k and nd[i] - st[i] > 1:\n                j, pj = query(st[i], nd[i] - 1)\n                ans.extend([i, j])\n                st[i], st[j], nd[j] = pj + 1, st[i], pj + 1\n                k -= 1\n    print len(ans) / 2\n    for x in ans:\n        print x,\n    print\n",
    "prob_desc_created_at": "1402241400",
    "tags": [
        "graphs",
        "constructive algorithms",
        "string suffix structures",
        "math",
        "dsu",
        "implementation"
    ],
    "hidden_unit_tests": ""
}
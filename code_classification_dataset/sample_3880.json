{
    "prob_desc_time_limit": "1 second",
    "prob_desc_sample_outputs": "[\"NO\\nYES\\nYES\\nYES\\nYES\\nYES\\nNO\\nYES\"]",
    "src_uid": "bd61ae3c19274f47b981b8bd5e786375",
    "prob_desc_notes": "NoteIn the first test case, the sentence $$$s$$$ is $$$\\texttt{B}$$$. Clearly, it can't consist of a single word $$$\\texttt{A}$$$, so the answer is $$$\\texttt{NO}$$$.In the second test case, the sentence $$$s$$$ is $$$\\texttt{AB}$$$, and it's possible that it consists of a single word $$$\\texttt{AB}$$$, so the answer is $$$\\texttt{YES}$$$.In the third test case, the sentence $$$s$$$ is $$$\\texttt{ABAB}$$$, and it's possible that it consists of one word $$$\\texttt{A}$$$, one word $$$\\texttt{B}$$$, and one word $$$\\texttt{BA}$$$, as $$$\\texttt{A} + \\texttt{BA} + \\texttt{B} = \\texttt{ABAB}$$$.In the fourth test case, the sentence $$$s$$$ is $$$\\texttt{ABAAB}$$$, and it's possible that it consists of one word $$$\\texttt{A}$$$, one word $$$\\texttt{AB}$$$, and one word $$$\\texttt{BA}$$$, as $$$\\texttt{A} + \\texttt{BA} + \\texttt{AB} = \\texttt{ABAAB}$$$. In the fifth test case, the sentence $$$s$$$ is $$$\\texttt{BAABBABBAA}$$$, and it's possible that it consists of one word $$$\\texttt{A}$$$, one word $$$\\texttt{B}$$$, two words $$$\\texttt{AB}$$$, and two words $$$\\texttt{BA}$$$, as $$$\\texttt{BA} + \\texttt{AB} + \\texttt{B} + \\texttt{AB} + \\texttt{BA} + \\texttt{A}= \\texttt{BAABBABBAA}$$$.",
    "prob_desc_description": "Alina has discovered a weird language, which contains only $$$4$$$ words: $$$\\texttt{A}$$$, $$$\\texttt{B}$$$, $$$\\texttt{AB}$$$, $$$\\texttt{BA}$$$. It also turned out that there are no spaces in this language: a sentence is written by just concatenating its words into a single string.Alina has found one such sentence $$$s$$$ and she is curious: is it possible that it consists of precisely $$$a$$$ words $$$\\texttt{A}$$$, $$$b$$$ words $$$\\texttt{B}$$$, $$$c$$$ words $$$\\texttt{AB}$$$, and $$$d$$$ words $$$\\texttt{BA}$$$?In other words, determine, if it's possible to concatenate these $$$a+b+c+d$$$ words in some order so that the resulting string is $$$s$$$. Each of the $$$a+b+c+d$$$ words must be used exactly once in the concatenation, but you can choose the order in which they are concatenated.",
    "prob_desc_output_spec": "For each test case output $$$\\texttt{YES}$$$ if it is possible that the sentence $$$s$$$ consists of precisely $$$a$$$ words $$$\\texttt{A}$$$, $$$b$$$ words $$$\\texttt{B}$$$, $$$c$$$ words $$$\\texttt{AB}$$$, and $$$d$$$ words $$$\\texttt{BA}$$$, and $$$\\texttt{NO}$$$ otherwise. You can output each letter in any case.",
    "prob_desc_input_spec": "The first line of the input contains a single integer $$$t$$$ ($$$1 \\le t \\le 10^5$$$) — the number of test cases. The description of the test cases follows. The first line of each test case contains four integers $$$a$$$, $$$b$$$, $$$c$$$, $$$d$$$ ($$$0\\le a,b,c,d\\le 2\\cdot 10^5$$$) — the number of times that words $$$\\texttt{A}$$$, $$$\\texttt{B}$$$, $$$\\texttt{AB}$$$, $$$\\texttt{BA}$$$ respectively must be used in the sentence. The second line contains the string $$$s$$$ ($$$s$$$ consists only of the characters $$$\\texttt{A}$$$ and $$$\\texttt{B}$$$, $$$1\\le |s| \\le 2\\cdot 10^5$$$, $$$|s|=a+b+2c+2d$$$)  — the sentence. Notice that the condition $$$|s|=a+b+2c+2d$$$ (here $$$|s|$$$ denotes the length of the string $$$s$$$) is equivalent to the fact that $$$s$$$ is as long as the concatenation of the $$$a+b+c+d$$$ words. The sum of the lengths of $$$s$$$ over all test cases doesn't exceed $$$2\\cdot 10^5$$$.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3-64",
    "lang_cluster": "Python",
    "difficulty": 2000,
    "file_name": "train_085.jsonl",
    "code_uid": "103dc2df596e1d64bd0434997fc527c4",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"8\\n1 0 0 0\\nB\\n0 0 1 0\\nAB\\n1 1 0 1\\nABAB\\n1 0 1 1\\nABAAB\\n1 1 2 2\\nBAABBABBAA\\n1 1 2 3\\nABABABBAABAB\\n2 3 5 4\\nAABAABBABAAABABBABBBABB\\n1 3 3 10\\nBBABABABABBBABABABABABABAABABA\"]",
    "exec_outcome": "PASSED",
    "source_code": "# test.py\r\n\r\n# main.py\r\n \r\n# .---.---.---.---.---.---.---.---.---.---.---.---.---.-------.\r\n# |1/2| 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 0 | + | ' | <-    |\r\n# |---'-.-'-.-'-.-'-.-'-.-'-.-'-.-'-.-'-.-'-.-'-.-'-.-'-.-----|\r\n# | ->| | Q | W | E | R | T | Y | U | I | O | P | ] | ^ |     |\r\n# |-----'.--'.--'.--'.--'.--'.--'.--'.--'.--'.--'.--'.--'|    |\r\n# | Caps | A | S | D | F | G | H | J | K | L | \\ | [ | * |    |\r\n# |----.-'-.-'-.-'-.-'-.-'-.-'-.-'-.-'-.-'-.-'-.-'-.-'---'----|\r\n# |    | < | Z | X | C | V | B | N | M | , | . | - |          |\r\n# |----'-.-'.--'--.'---'---'---'---'---'---'--.'---'.--.------|\r\n# | ctrl |  | alt |                           | alt |  | ctrl |\r\n# '------'  '-----'---------------------------'-----'  '------'\r\n \r\nMOD_PRIME = 10**9 + 7\r\n \r\n \r\ndef inp(to: type = str):\r\n    return to(input())\r\n \r\n \r\ndef inp_arr(to: type = str):\r\n    return list(\r\n        map(to, inp().split()))\r\n \r\n \r\ndef print_gc(t, res):\r\n    print(f\"Case #{t}: {res}\")\r\n \r\n \r\ndef fs(*args):\r\n    return frozenset(args)\r\n \r\n \r\ndef solve(t):\r\n    crr = inp_arr(int)\r\n    s = inp(str)\r\n \r\n    arr, brr = [], [0]*4\r\n \r\n    i = 0\r\n    while i < len(s):\r\n        if i == len(s) - 1:\r\n            arr.append(s[i])\r\n            if s[i] == \"A\":\r\n                brr[0] += 1\r\n            else:\r\n                brr[1] += 1\r\n            i += 1\r\n        else:\r\n            if s[i:i+2] == \"AA\":\r\n                arr.append(\"A\")\r\n                brr[0] += 1\r\n                i += 1\r\n            elif s[i:i+2] == \"BB\":\r\n                arr.append(\"B\")\r\n                brr[1] += 1\r\n                i += 1\r\n            elif s[i:i+2] == \"AB\":\r\n                arr.append(\"AB\")\r\n                brr[2] += 1\r\n                i += 2\r\n            elif s[i:i+2] == \"BA\":\r\n                arr.append(\"BA\")\r\n                brr[3] += 1\r\n                i += 2\r\n    if brr[2] < crr[2] and brr[3] < crr[3]:\r\n        res = \"NO\"\r\n    else:\r\n        res = \"YES\"\r\n        if brr[2] > crr[2] and brr[3] < crr[3]:\r\n            i = 0\r\n            while i+1 < len(arr) and brr[2] > crr[2] and brr[3] < crr[3]:\r\n                if arr[i] == \"AB\" and arr[i+1] == \"A\":\r\n                    arr[i] = \"A\"\r\n                    arr[i+1] = \"BA\"\r\n                    brr[2] -= 1\r\n                    brr[3] += 1\r\n                    j = i\r\n                    while j > 0 and all([\r\n                        brr[2] > crr[2],\r\n                        brr[3] < crr[3],\r\n                        arr[j-1] == \"AB\",\r\n                        arr[j] == \"A\"\r\n                    ]):\r\n                        arr[j-1] = \"A\"\r\n                        arr[j] = \"BA\"\r\n                        brr[2] -= 1\r\n                        brr[3] += 1\r\n                        j -= 1\r\n                elif arr[i] == \"B\" and arr[i+1] == \"AB\":\r\n                    arr[i] = \"BA\"\r\n                    arr[i+1] = \"B\"\r\n                    brr[2] -= 1\r\n                    brr[3] += 1\r\n                else:\r\n                    i += 1\r\n            i = 0\r\n            err = []\r\n            while i+1 < len(arr):\r\n                if arr[i] == \"AB\" and arr[i+1] == \"AB\":\r\n                    err.append([i, 2])\r\n                    j = i+1\r\n                    while j+1 < len(arr) and arr[j] == \"AB\" and arr[j+1] == \"AB\":\r\n                        err[-1][1] += 1\r\n                        j += 1\r\n                    i = j\r\n                i += 1\r\n            err = sorted(err, key=lambda e: e[1], reverse=True)\r\n            for i, _ in err:\r\n                if not(brr[2] > crr[2] and brr[3] < crr[3]):\r\n                    break\r\n                if arr[i] == \"AB\" and arr[i+1] == \"AB\":\r\n                    arr.insert(i, \"A\")\r\n                    for j in range(len(err)):\r\n                        if i < err[j][0]:\r\n                            err[j][0] += 1\r\n                    arr[i+1] = \"BA\"\r\n                    arr[i+2] = \"B\"\r\n                    brr[0] += 1\r\n                    brr[1] += 1\r\n                    brr[2] -= 2\r\n                    brr[3] += 1\r\n                    j = i\r\n                    while j >= 1 and all([\r\n                        brr[2] > crr[2],\r\n                        brr[3] < crr[3],\r\n                        arr[j-1] == \"AB\",\r\n                        arr[j] == \"A\"\r\n                    ]):\r\n                        arr[j-1] = \"A\"\r\n                        arr[j] = \"BA\"\r\n                        brr[2] -= 1\r\n                        brr[3] += 1\r\n                        j -= 1\r\n                    j = i+2\r\n                    while j+1 < len(arr) and all([\r\n                        brr[2] > crr[2],\r\n                        brr[3] < crr[3],\r\n                        arr[j] == \"B\",\r\n                        arr[j+1] == \"AB\"\r\n                    ]):\r\n                        arr[j] = \"BA\"\r\n                        arr[j+1] = \"B\"\r\n                        brr[2] -= 1\r\n                        brr[3] += 1\r\n                        j += 1\r\n                    i = j-1\r\n                else:\r\n                    i += 1\r\n        elif brr[3] > crr[3] and brr[2] < crr[2]:\r\n            i = 0\r\n            while i+1 < len(arr) and brr[3] > crr[3] and brr[2] < crr[2]:\r\n                if arr[i] == \"BA\" and arr[i+1] == \"B\":\r\n                    arr[i] = \"B\"\r\n                    arr[i+1] = \"AB\"\r\n                    brr[3] -= 1\r\n                    brr[2] += 1\r\n                    j = i\r\n                    while j >= 1 and all([\r\n                        brr[3] > crr[3],\r\n                        brr[2] < crr[2],\r\n                        arr[j-1] == \"BA\",\r\n                        arr[j] == \"B\"\r\n                    ]):\r\n                        arr[j-1] = \"B\"\r\n                        arr[j] = \"AB\"\r\n                        brr[3] -= 1\r\n                        brr[2] += 1\r\n                        j -= 1\r\n                elif arr[i] == \"A\" and arr[i+1] == \"BA\":\r\n                    arr[i] = \"AB\"\r\n                    arr[i+1] = \"A\"\r\n                    brr[3] -= 1\r\n                    brr[2] += 1\r\n                else:\r\n                    i += 1\r\n            i = 0\r\n            err = []\r\n            while i+1 < len(arr):\r\n                if arr[i] == \"BA\" and arr[i+1] == \"BA\":\r\n                    err.append([i, 2])\r\n                    j = i+1\r\n                    while j+1 < len(arr) and arr[j] == \"BA\" and arr[j+1] == \"BA\":\r\n                        err[-1][1] += 1\r\n                        j += 1\r\n                    i = j\r\n                i += 1\r\n            err = sorted(err, key=lambda e: e[1], reverse=True)\r\n            for i, _ in err:\r\n                if not(brr[3] > crr[3] and brr[2] < crr[2]):\r\n                    break\r\n                if  arr[i] == \"BA\" and arr[i+1] == \"BA\":\r\n                    for j in range(len(err)):\r\n                        if i < err[j][0]:\r\n                            err[j][0] += 1\r\n                    arr.insert(i, \"B\")\r\n                    arr[i+1] = \"AB\"\r\n                    arr[i+2] = \"A\"\r\n                    brr[0] += 1\r\n                    brr[1] += 1\r\n                    brr[3] -= 2\r\n                    brr[2] += 1\r\n                    j = i\r\n                    while j > 0 and all([\r\n                        brr[3] > crr[3],\r\n                        brr[2] < crr[2],\r\n                        arr[j-1] == \"BA\",\r\n                        arr[j] == \"B\"\r\n                    ]):\r\n                        arr[j-1] = \"B\"\r\n                        arr[j] = \"AB\"\r\n                        brr[3] -= 1\r\n                        brr[2] += 1\r\n                        j -= 1\r\n                    j = i+2\r\n                    while j+1 < len(arr) and all([\r\n                        brr[3] > crr[3],\r\n                        brr[2] < crr[2],\r\n                        arr[j] == \"A\",\r\n                        arr[j+1] == \"BA\"\r\n                    ]):\r\n                        arr[j] = \"AB\"\r\n                        arr[j+1] = \"A\"\r\n                        brr[3] -= 1\r\n                        brr[2] += 1\r\n                        j += 1\r\n                else:\r\n                    i += 1\r\n        if brr[0] > crr[0] or brr[1] > crr[1]:\r\n            res = \"NO\"\r\n        elif brr[0] - crr[0] != brr[1] - crr[1]:\r\n            res = \"NO\"\r\n        elif brr[2] >= crr[2] and brr[3] >= crr[3]:\r\n            res = \"YES\"\r\n        elif all([\r\n            brr[0] == crr[0] and brr[1] == crr[1],\r\n            brr[2] != crr[2] and brr[3] != crr[3],\r\n        ]):\r\n            res = \"NO\"\r\n        else:\r\n            res = \"NO\"\r\n    print(res)\r\n \r\n\"\"\"\r\n3\r\n7 13 4 19\r\nAAAAAABABABABBABABABBABABABABABBBBBBBAAABABABABABABABABABBBBBBABBA\r\n22 13 9 21\r\nBBABABAAABABABABABABBBABABAABABABBABAABAAABAAAAAAAAABAAAABABABABAABABABABABABABBBBBBABAAABABABB\r\n6 8 2 39\r\nBBBBBBABABABABABABABABABABABAABABBBABABABAAABBABABAAAAABABBABABABABABABABABABABABABABABABAABBABA\r\n \r\n\"\"\"\r\n \r\ndef main():\r\n    T = 1\r\n    T = inp(int)\r\n    for t in range(1, T+1):\r\n        solve(t)\r\n    return\r\n \r\n \r\nif __name__ == \"__main__\":\r\n    main()",
    "prob_desc_created_at": "1653500100",
    "tags": [
        "constructive algorithms",
        "greedy",
        "sortings",
        "strings",
        "two pointers"
    ],
    "hidden_unit_tests": ""
}
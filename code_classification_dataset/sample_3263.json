{
    "prob_desc_time_limit": "3 seconds",
    "prob_desc_sample_outputs": "[\"-1\", \"3\\n2\\n-1\\n3\", \"1\\n-1\\n9\\n-1\\n4\\n-1\\n1\"]",
    "src_uid": "b53ca495d99061d18cd95acf447e9edc",
    "prob_desc_notes": "NoteIn the first example powers of shamans after the first change are equal to (2, 3). The answer equals  - 1, because the sum of powers of shamans before the first shaman is equal to 0, and before the second is equal to 2.In the second example after the first change the powers are equal to (1, 2, 3). The answer is equal to 3, because the power of the third shaman is equal to 3, and the sum of powers of the first and the second shaman is also 1 + 2 = 3. After the second change the powers become equal to (2, 2, 3), where the answer equals 2. After the third change the powers become equal to (2, 4, 3), where the answer equals  - 1. After the fourth change the powers become equal to (2, 4, 6), where the answer equals 3.",
    "prob_desc_description": "Nastya likes reading and even spends whole days in a library sometimes. Today she found a chronicle of Byteland in the library, and it stated that there lived shamans long time ago. It is known that at every moment there was exactly one shaman in Byteland, and there were n shamans in total enumerated with integers from 1 to n in the order they lived. Also, each shaman had a magic power which can now be expressed as an integer.The chronicle includes a list of powers of the n shamans. Also, some shamans can be king-shamans, if they gathered all the power of their predecessors, i.e. their power is exactly the sum of powers of all previous shamans. Nastya is interested in whether there was at least one king-shaman in Byteland.Unfortunately many of the powers are unreadable in the list, so Nastya is doing the following:  Initially she supposes some power for each shaman.  After that she changes the power of some shaman q times (the shamans can differ) and after that wants to check if there is at least one king-shaman in the list. If yes, she wants to know the index of any king-shaman. Unfortunately the list is too large and Nastya wants you to help her.",
    "prob_desc_output_spec": "Print q lines, the i-th of them should contain  - 1, if after the i-th change there are no shaman-kings, and otherwise a single integer j, where j is an index of some king-shaman after the i-th change. If there are multiple king-shamans after each change, print the index of any of them.",
    "prob_desc_input_spec": "The first line contains two integers n and q (1 ≤ n, q ≤ 2·105). The second line contains n integers a1, ..., an (0 ≤ ai ≤ 109), where ai is the magic power of the i-th shaman. After that q lines follow, the i-th of them contains two integers pi and xi (1 ≤ pi ≤ n, 0 ≤ xi ≤ 109) that mean that the new power of the pi-th shaman is xi.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 2",
    "lang_cluster": "Python",
    "difficulty": 2500,
    "file_name": "train_050.jsonl",
    "code_uid": "3e296db5785cb85f0764b8cc7935e92d",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"2 1\\n1 3\\n1 2\", \"3 4\\n2 2 3\\n1 1\\n1 2\\n2 4\\n3 6\", \"10 7\\n0 3 1 4 6 2 7 8 10 1\\n2 5\\n1 3\\n9 36\\n4 10\\n4 9\\n1 2\\n1 0\"]",
    "exec_outcome": "PASSED",
    "source_code": "import sys\nrange = xrange\ninput = sys.stdin.readline\n\n# Resubmitting old code to compare times\n\nclass maxseg:\n    def __init__(self,data):\n        n = len(data)\n        m = 1\n        while m<n:m*=2\n        self.n = n\n        self.m = m\n\n        self.data = [0]*(m+m)\n\n        for i in range(n):\n            self.data[m+i]=data[i]\n        for i in reversed(range(m)):\n            self.data[i]=max(self.data[2*i],self.data[2*i+1])\n\n    def setter(self,i,val):\n        i += self.m\n        self.data[i]=val\n        i//=2\n        while i>0:\n            a = max(self.data[2*i],self.data[2*i+1])\n            if self.data[i]==a:break\n            self.data[i]=a\n            i//=2\n\n    # First time A[i]>=val\n    def first_time(self,l,r,val):\n        l+=self.m\n        r+=self.m\n\n        segs1 = []\n        segs2 = []\n        while l<r:\n            if l%2==1:\n                segs1.append(l)\n                l+=1\n            if r%2==1:\n                r-=1\n                segs2.append(r)\n            l//=2\n            r//=2\n        segs = segs1+segs2[::-1]\n        goal = None\n        for seg in segs:\n            if self.data[seg]>=val:\n                while seg<self.m:\n                    if self.data[2*seg]>=val:\n                        seg *= 2\n                    else:\n                        seg = 2*seg+1\n                goal = seg-self.m\n                break\n        return goal\n\nclass sumseg:\n    def __init__(self,data):\n        n = len(data)\n        m = 1\n        while m<n:m*=2\n        self.n = n\n        self.m = m\n        self.data = [0]*(m+m)\n        for i in range(n):\n            self.data[m+i]=data[i]\n        for i in reversed(range(m)):\n            self.data[i]=self.data[2*i]+self.data[2*i+1]\n\n    def setter(self,i,val):\n        i += self.m\n        diff = val-self.data[i]\n        while i>0:\n            self.data[i]+=diff\n            i//=2\n    def summa(self,l,r):\n        l+=self.m\n        r+=self.m\n        s = 0\n        while l<r:\n            if l%2==1:\n                s += self.data[l]\n                l+=1\n            if r%2==1:\n                r-=1\n                s += self.data[r]\n            l//=2\n            r//=2\n        return s\n\n\nn,q = [int(x) for x in input().split()]\n\nA = [int(x) for x in input().split()]\n\nmaxA = maxseg(A)\nsumA = sumseg(A)\n\nout = []\nfor _ in range(q):\n    p,x = [int(x) for x in input().split()]\n    p-=1\n\n    A[p]=x\n    maxA.setter(p,x)\n    sumA.setter(p,x)\n\n    i=0\n    lista = []\n    while i!=None:\n        s = sumA.summa(0,i)\n        if A[i]==s:\n            lista.append(i)\n            break\n        s += A[i]\n        i = maxA.first_time(i+1,n,s)\n    if len(lista)==0:\n        out.append('-1')\n    else:\n        out.append(' '.join(str(x+1) for x in lista))\nprint '\\n'.join(out)\n        ",
    "prob_desc_created_at": "1529339700",
    "tags": [
        "data structures",
        "binary search"
    ],
    "hidden_unit_tests": ""
}
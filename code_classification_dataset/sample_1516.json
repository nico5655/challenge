{
    "prob_desc_time_limit": "3 seconds",
    "prob_desc_sample_outputs": "[\"1 2 3\\n1 2 3\\n5 4 3 7 2 1 6\\n4 3 1 7 5 2 6\\n4 3 2 1 5\\n5 4 2 1 3\"]",
    "src_uid": "fd0e9b90f36611c28fa8aca5b4e59ae9",
    "prob_desc_notes": "NoteIn the first case, $$$1$$$ $$$2$$$ $$$3$$$ is the only possible answer.In the second case, the shortest length of the LIS is $$$2$$$, and the longest length of the LIS is $$$3$$$. In the example of the maximum LIS sequence, $$$4$$$ '$$$3$$$' $$$1$$$ $$$7$$$ '$$$5$$$' $$$2$$$ '$$$6$$$' can be one of the possible LIS.",
    "prob_desc_description": "Gildong recently learned how to find the longest increasing subsequence (LIS) in $$$O(n\\log{n})$$$ time for a sequence of length $$$n$$$. He wants to test himself if he can implement it correctly, but he couldn't find any online judges that would do it (even though there are actually many of them). So instead he's going to make a quiz for you about making permutations of $$$n$$$ distinct integers between $$$1$$$ and $$$n$$$, inclusive, to test his code with your output.The quiz is as follows.Gildong provides a string of length $$$n-1$$$, consisting of characters '&lt;' and '&gt;' only. The $$$i$$$-th (1-indexed) character is the comparison result between the $$$i$$$-th element and the $$$i+1$$$-st element of the sequence. If the $$$i$$$-th character of the string is '&lt;', then the $$$i$$$-th element of the sequence is less than the $$$i+1$$$-st element. If the $$$i$$$-th character of the string is '&gt;', then the $$$i$$$-th element of the sequence is greater than the $$$i+1$$$-st element.He wants you to find two possible sequences (not necessarily distinct) consisting of $$$n$$$ distinct integers between $$$1$$$ and $$$n$$$, inclusive, each satisfying the comparison results, where the length of the LIS of the first sequence is minimum possible, and the length of the LIS of the second sequence is maximum possible.",
    "prob_desc_output_spec": "For each test case, print two lines with $$$n$$$ integers each. The first line is the sequence with the minimum length of the LIS, and the second line is the sequence with the maximum length of the LIS. If there are multiple answers, print any one of them. Each sequence should contain all integers between $$$1$$$ and $$$n$$$, inclusive, and should satisfy the comparison results. It can be shown that at least one answer always exists.",
    "prob_desc_input_spec": "Each test contains one or more test cases. The first line contains the number of test cases $$$t$$$ ($$$1 \\le t \\le 10^4$$$). Each test case contains exactly one line, consisting of an integer and a string consisting of characters '&lt;' and '&gt;' only. The integer is $$$n$$$ ($$$2 \\le n \\le 2 \\cdot 10^5$$$), the length of the permutation you need to find. The string is the comparison results explained in the description. The length of the string is $$$n-1$$$. It is guaranteed that the sum of all $$$n$$$ in all test cases doesn't exceed $$$2 \\cdot 10^5$$$.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3",
    "lang_cluster": "Python",
    "difficulty": 1800,
    "file_name": "train_010.jsonl",
    "code_uid": "1bf1abaf39afbb23c32404f464503df7",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"3\\n3 &lt;&lt;\\n7 &gt;&gt;&lt;&gt;&gt;&lt;\\n5 &gt;&gt;&gt;&lt;\"]",
    "exec_outcome": "PASSED",
    "source_code": "import math\n#import math \n#------------------------------warmup----------------------------\nimport os\nimport sys\nfrom io import BytesIO, IOBase\n \nBUFSIZE = 8192\n \n \nclass FastIO(IOBase):\n    newlines = 0\n \n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n \n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n \n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n \n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n \n \nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n \n \nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n \n#-------------------game starts now----------------------------------------------------import math\nfor ik in range(int(input())):\n    n,s=map(str,input().split())\n    n=int(n)\n    smallest=[0]*n\n    t=1\n    c=s.count('<')+1\n    cou=n-c\n    for i in range(n-1):\n        if s[i]=='>': \n            smallest[t]=cou\n            cou-=1\n        t+=1\n    #print(smallest)\n    cou=s.count('<')+1\n    rt=[i+1+n-c for i in range(cou)]\n    rt=rt[::-1]\n    t=0\n    ind=0\n    i=0\n    #print(rt)\n    s='<'+s\n    while(i<n):\n        if s[i]=='<':\n            #print(i)\n            de=i\n            while(s[de]=='<'):\n                ind+=1\n                de+=1\n                if de==n:\n                    break\n            rty=ind\n            ind+=-1\n            for j in range(i,de):\n                    smallest[j]=rt[ind] \n                    ind-=1\n                    #print(smallest)\n            ind=rty\n            i=de\n        #print(smallest)\n        i+=1\n    largest=[0]*n\n    s=s+'<'\n    w=[]\n    for i in range(len(s)):\n        if s[i]=='<':\n            w.append(i)\n    cd=n\n    for j in range(len(w)-2,-1,-1):\n        for k in range(w[j],w[j+1]):\n            largest[k]=cd\n            cd-=1\n    print(*smallest,sep=' ') \n    print(*largest,sep=' ')\n    \n        \n        ",
    "prob_desc_created_at": "1581771900",
    "tags": [
        "constructive algorithms",
        "two pointers",
        "greedy",
        "graphs"
    ],
    "hidden_unit_tests": ""
}
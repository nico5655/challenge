{
    "prob_desc_time_limit": "1 second",
    "prob_desc_sample_outputs": "[\"1 -1 3 4\"]",
    "src_uid": "b08f925e09a9c2e7ccc6a8c5c143fc5f",
    "prob_desc_notes": "NoteIf initially Pak Chanek's left hand is on vertex $$$1$$$ and his right hand is on vertex $$$5$$$, Pak Chanek can do the following moves:   Move his right hand to vertex $$$4$$$ in $$$1$$$ second.  Move his left hand to vertex $$$2$$$ in $$$2$$$ seconds.  Move his left hand to vertex $$$4$$$ in $$$1$$$ second. In total it needs $$$1+2+1=4$$$ seconds. It can be proven that there is no other way that is faster.",
    "prob_desc_description": "Pak Chanek is playing one of his favourite board games. In the game, there is a directed graph with $$$N$$$ vertices and $$$M$$$ edges. In the graph, edge $$$i$$$ connects two different vertices $$$U_i$$$ and $$$V_i$$$ with a length of $$$W_i$$$. By using the $$$i$$$-th edge, something can move from $$$U_i$$$ to $$$V_i$$$, but not from $$$V_i$$$ to $$$U_i$$$.To play this game, initially Pak Chanek must place both of his hands onto two different vertices. In one move, he can move one of his hands to another vertex using an edge. To move a hand from vertex $$$U_i$$$ to vertex $$$V_i$$$, Pak Chanek needs a time of $$$W_i$$$ seconds. Note that Pak Chanek can only move one hand at a time. This game ends when both of Pak Chanek's hands are on the same vertex.Pak Chanek has several questions. For each $$$p$$$ satisfying $$$2 \\leq p \\leq N$$$, you need to find the minimum time in seconds needed for Pak Chanek to end the game if initially Pak Chanek's left hand and right hand are placed on vertex $$$1$$$ and vertex $$$p$$$, or report if it is impossible.",
    "prob_desc_output_spec": "Output a line containing $$$N-1$$$ integers. The $$$j$$$-th integer represents the minimum time in seconds needed by Pak Chanek to end the game if initially Pak Chanek's left hand and right hand are placed on vertex $$$1$$$ and vertex $$$j+1$$$, or $$$-1$$$ if it is impossible.",
    "prob_desc_input_spec": "The first line contains two integers $$$N$$$ and $$$M$$$ ($$$2 \\leq N \\leq 10^5$$$, $$$0 \\leq M \\leq 2 \\cdot 10^5$$$) — the number of vertices and edges in the graph. The $$$i$$$-th of the next $$$M$$$ lines contains three integers $$$U_i$$$, $$$V_i$$$, and $$$W_i$$$ ($$$1 \\le U_i, V_i \\le N$$$, $$$U_i \\neq V_i$$$, $$$1 \\le W_i \\le 10^9$$$) — a directed edge that connects two different vertices $$$U_i$$$ and $$$V_i$$$ with a length of $$$W_i$$$. There is no pair of different edges $$$i$$$ and $$$j$$$ such that $$$U_i = U_j$$$ and $$$V_i = V_j$$$.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3-64",
    "lang_cluster": "Python",
    "difficulty": 1800,
    "file_name": "train_093.jsonl",
    "code_uid": "76c7a785a67de7d4e66b3123ddeb6ade",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"5 7\\n1 2 2\\n2 4 1\\n4 1 4\\n2 5 3\\n5 4 1\\n5 2 4\\n2 1 1\"]",
    "exec_outcome": "PASSED",
    "source_code": "import sys\r\nfrom array import array\r\nfrom heapq import *\r\n\r\n\r\nclass graph:\r\n    def __init__(self, n):\r\n        self.n = n\r\n        self.gdict = [array('i') for _ in range(n + 1)]\r\n        self.weight = [array('i') for _ in range(n + 1)]\r\n        self.dir = [array('b') for _ in range(n + 1)]\r\n\r\n    def add_edge(self, node1, node2):\r\n        self.gdict[node1].append(node2)\r\n        self.gdict[node2].append(node1)\r\n        self.dir[node1].append(1)\r\n        self.dir[node2].append(0)\r\n\r\n    def add_wedge(self, node1, node2, w):\r\n        self.weight[node1].append(w)\r\n        self.weight[node2].append(w)\r\n\r\n    def dijkstra(self, root):\r\n        # initial distances\r\n        self.dist = [10 ** 18] * (self.n + 1)\r\n        vis = array('b', [0] * (self.n + 1))\r\n        self.dist[root], que = 0, [(0, root)]\r\n\r\n        # traverse all nodes\r\n        while que:\r\n            d, u = heappop(que)\r\n\r\n            # traverse all adjacent nodes and update distances\r\n            if not vis[u]:\r\n                for i in range(len(self.gdict[u])):\r\n                    v, d2, dir = self.gdict[u][i], self.weight[u][i], self.dir[u][i]\r\n                    cost = d2 + self.dist[u]\r\n\r\n                    if not vis[v] and dir and cost < self.dist[v]:\r\n                        self.dist[v] = cost\r\n                        heappush(que, (self.dist[v], v))\r\n                vis[u] = 1\r\n\r\n        vis = array('b', [0] * (self.n + 1))\r\n        que = [(self.dist[i], i) for i in range(1, self.n + 1)]\r\n        heapify(que)\r\n        while que:\r\n            d, u = heappop(que)\r\n\r\n            # traverse all adjacent nodes and update distances\r\n            if not vis[u]:\r\n                for i in range(len(self.gdict[u])):\r\n                    v, d2, dir = self.gdict[u][i], self.weight[u][i], self.dir[u][i]\r\n                    cost = d2 + self.dist[u]\r\n\r\n                    if not vis[v] and not dir and cost < self.dist[v]:\r\n                        self.dist[v] = cost\r\n                        heappush(que, (self.dist[v], v))\r\n\r\n                vis[u] = 1\r\n\r\n        for i in range(1, self.n + 1):\r\n            if self.dist[i] == 10 ** 18:\r\n                self.dist[i] = -1\r\n        print(' '.join(map(str, self.dist[2:])))\r\n\r\ninput = lambda: sys.stdin.buffer.readline().decode().strip()\r\nn, m = map(int, input().split())\r\ng = graph(n)\r\nfor _ in range(m):\r\n    u, v, w = map(int, input().split())\r\n    g.add_edge(u, v)\r\n    g.add_wedge(u, v, w)\r\ng.dijkstra(1)\r\n\r\n\r\n",
    "prob_desc_created_at": "1662298500",
    "tags": [
        "dp",
        "graphs",
        "shortest paths"
    ],
    "hidden_unit_tests": ""
}
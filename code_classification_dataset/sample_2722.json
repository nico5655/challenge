{
    "prob_desc_time_limit": "1 second",
    "prob_desc_sample_outputs": "[\"5\\n8 7\", \"4\\n5 10\", \"0\\n1 1\"]",
    "src_uid": "be820239276b5e1a346309f9dd21c5cb",
    "prob_desc_notes": "NoteIn the first example, we can swap $$$7$$$-th and $$$8$$$-th character, obtaining a string \"()()()()()\". The cyclical shifts by $$$0, 2, 4, 6, 8$$$ of this string form a correct bracket sequence.In the second example, after swapping $$$5$$$-th and $$$10$$$-th character, we obtain a string \")(())()()(()\". The cyclical shifts by $$$11, 7, 5, 3$$$ of this string form a correct bracket sequence.In the third example, swap of any two brackets results in $$$0$$$ cyclical shifts being correct bracket sequences. ",
    "prob_desc_description": "This is a harder version of the problem. In this version, $$$n \\le 300\\,000$$$.Vasya is an experienced developer of programming competitions' problems. As all great minds at some time, Vasya faced a creative crisis. To improve the situation, Petya gifted him a string consisting of opening and closing brackets only. Petya believes, that the beauty of the bracket string is a number of its cyclical shifts, which form a correct bracket sequence.To digress from his problems, Vasya decided to select two positions of the string (not necessarily distinct) and swap characters located at this positions with each other. Vasya will apply this operation exactly once. He is curious what is the maximum possible beauty he can achieve this way. Please help him.We remind that bracket sequence $$$s$$$ is called correct if:   $$$s$$$ is empty;  $$$s$$$ is equal to \"($$$t$$$)\", where $$$t$$$ is correct bracket sequence;  $$$s$$$ is equal to $$$t_1 t_2$$$, i.e. concatenation of $$$t_1$$$ and $$$t_2$$$, where $$$t_1$$$ and $$$t_2$$$ are correct bracket sequences. For example, \"(()())\", \"()\" are correct, while \")(\" and \"())\" are not.The cyclical shift of the string $$$s$$$ of length $$$n$$$ by $$$k$$$ ($$$0 \\leq k &lt; n$$$) is a string formed by a concatenation of the last $$$k$$$ symbols of the string $$$s$$$ with the first $$$n - k$$$ symbols of string $$$s$$$. For example, the cyclical shift of string \"(())()\" by $$$2$$$ equals \"()(())\".Cyclical shifts $$$i$$$ and $$$j$$$ are considered different, if $$$i \\ne j$$$.",
    "prob_desc_output_spec": "The first line should contain a single integer — the largest beauty of the string, which can be achieved by swapping some two characters. The second line should contain integers $$$l$$$ and $$$r$$$ ($$$1 \\leq l, r \\leq n$$$) — the indices of two characters, which should be swapped in order to maximize the string's beauty. In case there are several possible swaps, print any of them.",
    "prob_desc_input_spec": "The first line contains an integer $$$n$$$ ($$$1 \\le n \\le 300\\,000$$$), the length of the string. The second line contains a string, consisting of exactly $$$n$$$ characters, where each of the characters is either \"(\" or \")\".",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 2",
    "lang_cluster": "Python",
    "difficulty": 2500,
    "file_name": "train_029.jsonl",
    "code_uid": "b36c918fffe3b4dbbcdcff5f833a9ef4",
    "prob_desc_memory_limit": "512 megabytes",
    "prob_desc_sample_inputs": "[\"10\\n()()())(()\", \"12\\n)(()(()())()\", \"6\\n)))(()\"]",
    "exec_outcome": "PASSED",
    "source_code": "from __future__ import division, print_function\n\ndef main():\n    n = int(input())\n    s = input()\n    if s.count('(') != s.count(')'):\n        print('0\\n1 1')\n        return\n    ar = [(1 if c=='(' else -1) for c in s]\n    ps = [0]\n    lb = li = 0\n    for i, e in enumerate(ar):\n        v = e+ps[-1]\n        if v < lb:\n            lb = v\n            li = i+1\n        ps.append(v)\n    ps.pop()\n    ps = ps[li:] + ps[:li+1]\n    for i in indices(ps):\n        ps[i] += -lb\n\n    b0 = ps.count(0)\n    best2 = 0\n    this2 = 0\n    r = False\n    bsi, bei = 0, 0\n    for i, e in enumerate(ps):\n        if e == 2:\n            if not r:\n                r = True\n                this2 = 1\n                si = i-1\n            else:\n                this2 += 1\n        elif e == 1:\n            if r:\n                r = False\n                if best2 < this2:\n                    best2 = this2\n                    bsi, bei = si, i-1\n\n    best1 = 0\n    this1 = 0\n    r = False\n    bsi1, bei1 = 0, 0\n    for i, e in enumerate(ps):\n        if e == 1:\n            if not r:\n                r = True\n                this1 = 1\n                si = i-1\n            else:\n                this1 += 1\n        elif e == 0:\n            if r:\n                r = False\n                if best1 < this1:\n                    best1 = this1\n                    bsi1, bei1 = si, i-1\n\n    if best1 > b0+best2-1:\n        bsi, bei = bsi1, bei1\n\n    print(max(best1, b0+best2-1))\n    print((bsi+li)%n+1, (bei+li)%n+1)\n\nINF = float('inf')\nMOD = 10 ** 9 + 7\n__interactive = False\n\nimport os, sys\nfrom atexit import register\nfrom io import BytesIO\nimport itertools\nimport __pypy__\n\nif sys.version_info[0] < 3:\n    input = raw_input\n    range = xrange\n\n    filter = itertools.ifilter\n    map = itertools.imap\n    zip = itertools.izip\n\nmulmod = __pypy__.intop.int_mulmod\n\nif \"LOCAL_\" in os.environ:\n    debug_print = print\nelse:\n    if not __interactive:\n        sys.stdin = BytesIO(os.read(0, os.fstat(0).st_size))\n        sys.stdout = BytesIO()\n        register(lambda: os.write(1, sys.stdout.getvalue()))\n\n        input = lambda: sys.stdin.readline().rstrip('\\r\\n')\n    debug_print = lambda *x, **y: None\n\nflush = sys.stdout.flush\n\ndef gcd(x, y):\n    while y:\n        x, y = y, x % y\n    return x\n    \ndef input_as_list():\n    return list(map(int, input().split()))\n\ndef input_as_matrix(n, m):\n    return [input_as_list() for _ in range(n)]\n    \ndef array_of(f, *dim):\n    return [array_of(f, *dim[1:]) for _ in range(dim[0])] if dim else f()\n\ndef range_with_count(start, step, count):\n    return range(start, start + step * count, step)\n\ndef indices(l, start=0, end=0):\n    return range(start, len(l)+end)\n\ndef ceil_power_of_2(n):\n    \"\"\" [0, 1, 2, 4, 4, 8, 8, 8, 8, 16, 16, ...] \"\"\"\n    return 2 ** ((n - 1).bit_length())\n\ndef ceil_div(x, r):\n    \"\"\" = ceil(x / r) \"\"\"\n    return (x + r - 1) // r\n    \nmain()",
    "prob_desc_created_at": "1571562300",
    "tags": [
        "implementation"
    ],
    "hidden_unit_tests": ""
}
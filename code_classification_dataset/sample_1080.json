{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"3\", \"4\"]",
    "src_uid": "fdd50853348b6f297a62a3b729d8d4a5",
    "prob_desc_notes": "NoteIn the second sample, there are four lifelines: paths between vertices 1 and 3, 2 and 4, 2 and 5, and 4 and 5.",
    "prob_desc_description": "Heidi has finally found the mythical Tree of Life – a legendary combinatorial structure which is said to contain a prophecy crucially needed to defeat the undead armies.On the surface, the Tree of Life is just a regular undirected tree well-known from computer science. This means that it is a collection of n points (called vertices), some of which are connected using n - 1 line segments (edges) so that each pair of vertices is connected by a path (a sequence of one or more edges).To decipher the prophecy, Heidi needs to perform a number of steps. The first is counting the number of lifelines in the tree – these are paths of length 2, i.e., consisting of two edges. Help her!",
    "prob_desc_output_spec": "Print one integer – the number of lifelines in the tree.",
    "prob_desc_input_spec": "The first line of the input contains a single integer n – the number of vertices in the tree (1 ≤ n ≤ 10000). The vertices are labeled with the numbers from 1 to n. Then n - 1 lines follow, each describing one edge using two space-separated numbers a b – the labels of the vertices connected by the edge (1 ≤ a &lt; b ≤ n). It is guaranteed that the input represents a tree.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "Python 3",
    "lang_cluster": "Python",
    "difficulty": 1300,
    "file_name": "train_006.jsonl",
    "code_uid": "c07b05f6336e54718880cdbb59df7293",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"4\\n1 2\\n1 3\\n1 4\", \"5\\n1 2\\n2 3\\n3 4\\n3 5\"]",
    "exec_outcome": "PASSED",
    "source_code": "n=int(input())\np=[[]]\nt=[0]\no=[[]]\nfor i in range(n):\n    p.append([])\n    t.append(0)\n    o.append([])\nfor i in range(n-1):\n    a=input().split()\n    b=int (a[0])\n    c=int(a[1])\n    p[b].append(c)\n    p[c].append(b)\n    t[b]+=1\n    t[c]+=1\ny=0\nfor i in range(1,n+1):\n    j=p[i]\n    for k in range(t[i]):\n        jj=j[k]\n        y=y+t[jj]-1\nprint(int(y/2))\n\n",
    "prob_desc_created_at": "1468137600",
    "tags": [],
    "hidden_unit_tests": ""
}
{
    "prob_desc_time_limit": "1 second",
    "prob_desc_sample_outputs": "[\"6\", \"4\"]",
    "src_uid": "2e08077d0b49c52586266ddcc12edcb5",
    "prob_desc_notes": "NoteIn the first test case string \"aba\" is determined by the pairs of positions: (2, 0) and (5, 0); (5, 2) and (6, 1); (5, 2) and (3, 1); (4, 0) and (4, 2); (4, 4) and (4, 6); (3, 3) and (3, 5).Note that the string is not defined by the pair of positions (7, 1) and (5, 0), as the way between them doesn't always go down.",
    "prob_desc_description": "A rooted tree is a non-directed connected graph without any cycles with a distinguished vertex, which is called the tree root. Consider the vertices of a rooted tree, that consists of n vertices, numbered from 1 to n. In this problem the tree root is the vertex number 1.Let's represent the length of the shortest by the number of edges path in the tree between vertices v and u as d(v, u).A parent of vertex v in the rooted tree with the root in vertex r (v ≠ r) is vertex pv, such that d(r, pv) + 1 = d(r, v) and d(pv, v) = 1. For example, on the picture the parent of vertex v = 5 is vertex p5 = 2.One day Polycarpus came across a rooted tree, consisting of n vertices. The tree wasn't exactly ordinary: it had strings written on its edges. Polycarpus positioned the tree on the plane so as to make all edges lead from top to bottom if you go from the vertex parent to the vertex (see the picture). For any edge that lead from vertex pv to vertex v (1 &lt; v ≤ n), he knows string sv that is written on it. All strings are written on the edges from top to bottom. For example, on the picture s7=\"ba\". The characters in the strings are numbered starting from 0.    An example of Polycarpus's tree (corresponds to the example from the statement) Polycarpus defines the position in this tree as a specific letter on a specific string. The position is written as a pair of integers (v, x) that means that the position is the x-th letter of the string sv (1 &lt; v ≤ n, 0 ≤ x &lt; |sv|), where |sv| is the length of string sv. For example, the highlighted letters are positions (2, 1) and (3, 1).Let's consider the pair of positions (v, x) and (u, y) in Polycarpus' tree, such that the way from the first position to the second goes down on each step. We will consider that the pair of such positions defines string z. String z consists of all letters on the way from (v, x) to (u, y), written in the order of this path. For example, in the picture the highlighted positions define string \"bacaba\".Polycarpus has a string t, he wants to know the number of pairs of positions that define string t. Note that the way from the first position to the second in the pair must go down everywhere. Help him with this challenging tree-string problem!",
    "prob_desc_output_spec": "Print a single integer — the required number. Please, do not use the %lld specifier to read or write 64-bit integers in С++. It is preferred to use the cin, cout streams or the %I64d specifier.",
    "prob_desc_input_spec": "The first line contains integer n (2 ≤ n ≤ 105) — the number of vertices of Polycarpus's tree. Next n - 1 lines contain the tree edges. The i-th of them contains number pi + 1 and string si + 1 (1 ≤ pi + 1 ≤ n; pi + 1 ≠ (i + 1)). String si + 1 is non-empty and consists of lowercase English letters. The last line contains string t. String t consists of lowercase English letters, its length is at least 2. It is guaranteed that the input contains at most 3·105 English letters.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "Python 2",
    "lang_cluster": "Python",
    "difficulty": 2000,
    "file_name": "train_016.jsonl",
    "code_uid": "96baa5742971eeef3a2825bebadecb1b",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"7\\n1 ab\\n5 bacaba\\n1 abacaba\\n2 aca\\n5 ba\\n2 ba\\naba\", \"7\\n1 ab\\n5 bacaba\\n1 abacaba\\n2 aca\\n5 ba\\n2 ba\\nbacaba\"]",
    "exec_outcome": "PASSED",
    "source_code": "from sys import stdin\nfrom collections import defaultdict\ndef ff(s):\n    f = [0, 0]\n    for i, c in enumerate(s[1:], 1):\n        j = f[i]\n        while s[j] != c:\n            if not j:\n                f.append(0)\n                break\n            j = f[j]\n        else:\n            f.append(j+1)\n    alphas = ''.join(chr(ord('a') + c) for c in xrange(26))\n    ret = [{c: 0 for c in alphas}]\n    ret[0][s[0]] = 1\n    for i, c in enumerate(s[1:], 1):\n        d = {a: [ret[f[i]][a], i+1][c == a] for a in alphas}\n        ret.append(d)\n    ret.append({c: ret[f[-1]][c] for c in alphas})\n    return ret\ndef main():\n    RL = stdin.readline\n    n = int(RL())\n    G = defaultdict(list)\n    edge_str = ['', '']\n    for i in xrange(2, n+1):\n        p, t = RL().split()\n        G[int(p)].append(i)\n        edge_str.append(t)\n    ptr = RL().strip()\n    ptrl = len(ptr)\n    f = ff(ptr)\n    stack = [(1, 0)]\n    ans = 0\n    pp, pu = stack.pop, stack.append\n    while stack:\n        v, j = pp()\n        for c in edge_str[v]:\n            j = f[j][c]\n            if j == ptrl:\n                ans = ans + 1\n        for x in G[v]:\n            pu((x, j))\n    print ans\nmain()\n",
    "prob_desc_created_at": "1365796800",
    "tags": [
        "hashing",
        "*special",
        "dfs and similar",
        "strings"
    ],
    "hidden_unit_tests": ""
}
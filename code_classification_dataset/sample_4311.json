{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"0\", \"1 3\", \"2\"]",
    "src_uid": "4b527bc3d9ab781bfe829ebf69b5a9d9",
    "prob_desc_notes": "NoteIn the first example the sequence $$$(1, 2), (1, 1), (1, 2), (1, 3), (2, 3), (3, 3)$$$, $$$(2, 3), (1, 3), (1, 2), (1, 1), (2, 1), (2, 2), (3, 2), (3, 1)$$$ solves the puzzle, so the answer is $$$0$$$.The puzzle in the second example can't be solved, but it's solvable after any of three swaps of cells with values $$$(1, 5), (1, 6), (2, 6)$$$. The puzzle from the third example requires at least two swaps, so the answer is $$$2$$$.",
    "prob_desc_description": "Little pirate Serega robbed a ship with puzzles of different kinds. Among all kinds, he liked only one, the hardest.A puzzle is a table of $$$n$$$ rows and $$$m$$$ columns, whose cells contain each number from $$$1$$$ to $$$n \\cdot m$$$ exactly once.To solve a puzzle, you have to find a sequence of cells in the table, such that any two consecutive cells are adjacent by the side in the table. The sequence can have arbitrary length and should visit each cell one or more times. For a cell containing the number $$$i$$$, denote the position of the first occurrence of this cell in the sequence as $$$t_i$$$. The sequence solves the puzzle, if $$$t_1 &lt; t_2 &lt; \\dots &lt; t_{nm}$$$. In other words, the cell with number $$$x$$$ should be first visited before the cell with number $$$x + 1$$$ for each $$$x$$$.Let's call a puzzle solvable, if there exists at least one suitable sequence.In one move Serega can choose two arbitrary cells in the table (not necessarily adjacent by the side) and swap their numbers. He would like to know the minimum number of moves to make his puzzle solvable, but he is too impatient. Thus, please tell if the minimum number of moves is $$$0$$$, $$$1$$$, or at least $$$2$$$. In the case, where $$$1$$$ move is required, please also find the number of suitable cell pairs to swap.",
    "prob_desc_output_spec": "Let $$$a$$$ be the minimum number of moves to make the puzzle solvable. If $$$a = 0$$$, print $$$0$$$. If $$$a = 1$$$, print $$$1$$$ and the number of valid swaps. If $$$a \\ge 2$$$, print $$$2$$$. ",
    "prob_desc_input_spec": "In the first line there are two whole positive numbers $$$n, m$$$ ($$$1 \\leq n\\cdot m \\leq 400\\,000$$$) â€” table dimensions. In the next $$$n$$$ lines there are $$$m$$$ integer numbers $$$a_{i1}, a_{i2}, \\dots, a_{im}$$$ ($$$1 \\le a_{ij} \\le nm$$$).  It is guaranteed that every number from $$$1$$$ to $$$nm$$$ occurs exactly once in the table.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3-64",
    "lang_cluster": "Python",
    "difficulty": 2600,
    "file_name": "train_095.jsonl",
    "code_uid": "df8b5143741e76b79a38cca7a078d2a9",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"3 3\\n2 1 3\\n6 7 4\\n9 8 5\", \"2 3\\n1 6 4\\n3 2 5\", \"1 6\\n1 6 5 4 3 2\"]",
    "exec_outcome": "PASSED",
    "source_code": "import os\r\nimport sys\r\nfrom io import BytesIO, IOBase\r\n\r\nBUFSIZE = 8192\r\n \r\nclass FastIO(IOBase):\r\n    newlines = 0\r\n \r\n    def __init__(self, file):\r\n        self._fd = file.fileno()\r\n        self.buffer = BytesIO()\r\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\r\n        self.write = self.buffer.write if self.writable else None\r\n \r\n    def read(self):\r\n        while True:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            if not b:\r\n                break\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines = 0\r\n        return self.buffer.read()\r\n \r\n    def readline(self):\r\n        while self.newlines == 0:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            self.newlines = b.count(b\"\\n\") + (not b)\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines -= 1\r\n        return self.buffer.readline()\r\n \r\n    def flush(self):\r\n        if self.writable:\r\n            os.write(self._fd, self.buffer.getvalue())\r\n            self.buffer.truncate(0), self.buffer.seek(0)\r\n \r\n \r\nclass IOWrapper(IOBase):\r\n    def __init__(self, file):\r\n        self.buffer = FastIO(file)\r\n        self.flush = self.buffer.flush\r\n        self.writable = self.buffer.writable\r\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\r\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\r\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\r\n \r\n \r\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\r\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\r\n\r\n\r\nfrom itertools import chain\r\n\r\ndef near(r, c, itself = False):\r\n    if itself:\r\n        yield (r, c)\r\n    if 0 < r:\r\n        yield (r - 1, c)\r\n    if r + 1 < n:\r\n        yield (r + 1, c)\r\n    if 0 < c:\r\n        yield (r, c - 1)\r\n    if c + 1 < m:\r\n        yield (r, c + 1)\r\n#    R = []\r\n#    if itself:\r\n#        R.append((r, c))\r\n#    if 0 < r:\r\n#        R.append((r - 1, c))\r\n#    if r + 1 < n:\r\n#        R.append((r + 1, c))\r\n#    if 0 < c:\r\n#        R.append((r, c - 1))\r\n#    if c + 1 < m:\r\n#        R.append((r, c + 1))\r\n\r\n#    return R\r\n\r\ndef ok(x, y):\r\n    v = A[x][y]\r\n    if v == 1:\r\n        return True\r\n\r\n    return any(A[r][c] < v for r, c in near(x, y))\r\n\r\n\r\ndef swapAndCheck(r1, c1, r2, c2):\r\n    if (r1 , c1) != (r2, c2):\r\n        A[r1][c1], A[r2][c2] = A[r2][c2], A[r1][c1]\r\n\r\n        flag = ok(r1, c1) and ok(r2, c2) and all(ok(r, c) for r, c in chain(near(r1, c1), near(r2, c2), H[1:]))\r\n\r\n        A[r1][c1], A[r2][c2] = A[r2][c2], A[r1][c1]\r\n\r\n        return flag\r\n\r\n    return False\r\n\r\n\r\nn, m = map(int, input().split())\r\n\r\nA = []\r\nfor _ in range(n):\r\n    A.append(list(map(int, input().split())))\r\n\r\n\r\nH = list({(r, c) for r in range(n) for c in range(m) if not ok(r, c)})\r\n\r\nif not H:\r\n    print(\"0\")\r\nelif len(H) > 2:\r\n    print(\"2\")\r\nelse:\r\n    r1, c1 = H[0]\r\n    w = 0\r\n\r\n    for r, c in near(r1, c1, True):\r\n        for x in range(n):\r\n            for y in range(m):\r\n                if (r1 != x or c1 != y) and swapAndCheck(r, c, x, y):\r\n                    w += 1\r\n        \r\n    if w != 0:\r\n        print(\"1 {}\".format(w))\r\n    else:\r\n        print(\"2\")\r\n\r\n",
    "prob_desc_created_at": "1655629500",
    "tags": [
        "brute force",
        "constructive algorithms"
    ],
    "hidden_unit_tests": ""
}
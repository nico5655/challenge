{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"7\", \"6\", \"-1\"]",
    "src_uid": "9091de9fad568e353d7b3462cebe2571",
    "prob_desc_notes": "NoteIn the first example the only possible variant to choose 3 decorations having all conditions satisfied is to choose decorations 1, 2, 3.In the second example friends can choose decoration 4 instead of decoration 3, because this one is one coin cheaper.In the third example it's not possible to choose 2 decorations in a way that both are liked by both Masha and Arkady.",
    "prob_desc_description": "Arkady and Masha want to choose decorations for thier aquarium in Fishdom game. They have n decorations to choose from, each of them has some cost. To complete a task Arkady and Masha need to choose exactly m decorations from given, and they want to spend as little money as possible.There is one difficulty: Masha likes some a of the given decorations, Arkady likes some b of the given decorations. Some decorations may be liked by both Arkady and Masha, or not be liked by both. The friends want to choose such decorations so that each of them likes at least k decorations among the chosen. Help Masha and Arkady find the minimum sum of money they need to spend.",
    "prob_desc_output_spec": "Print single integer: the minimum sum of money the friends should spend to fulfill all constraints. If it is not possible, print -1.",
    "prob_desc_input_spec": "The first line contains three integers n, m and k (1 ≤ n ≤ 200000, 1 ≤ m ≤ n, 1 ≤ k ≤ n) — the number of decorations, how many decorations the friends should choose, how many decorations each of them should like among the chosen. The second line contains n integers c1, c2, ..., cn (1 ≤ ci ≤ 109) — decorations costs. The third line contains single integer a (1 ≤ a ≤ n) — the number of decorations liked by Masha. The fourth line contains a distinct integers x1, x2, ..., xa (1 ≤ xi ≤ n) — the ids of decorations liked by Masha. The next two lines describe decorations liked by Arkady in the same format.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "Python 2",
    "lang_cluster": "Python",
    "difficulty": 2500,
    "file_name": "train_066.jsonl",
    "code_uid": "f6c11ce33e9806e939af9bd52ef9a1bb",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"4 3 2\\n3 2 2 1\\n2\\n1 2\\n2\\n1 3\", \"4 3 2\\n3 2 2 1\\n2\\n1 2\\n3\\n4 1 3\", \"4 2 2\\n3 2 2 1\\n2\\n1 2\\n3\\n4 1 3\"]",
    "exec_outcome": "PASSED",
    "source_code": "try:\n    R1 = lambda: int(raw_input())\n    R = lambda: map(int, raw_input().split())\n    n, m, k = R()\n    prices = R()\n    R1()\n    ais = set(R())\n    R1()\n    bis = set(R())\n\n    noone_likes = []\n    a_likes = []\n    b_likes = []\n    ab_likes = []\n\n\n    for idx, price in enumerate(prices):\n        in_ais = (idx+1) in ais\n        in_bis = (idx+1) in bis\n        if in_ais and in_bis:\n            ab_likes.append(price)\n        elif in_ais:\n            a_likes.append(price)\n        elif in_bis:\n            b_likes.append(price)\n        else:\n            noone_likes.append(price)\n\n    min_a_b_count = min(len(a_likes), len(b_likes))\n\n    if m < k:\n        print -1\n        exit(0)\n\n    if len(ab_likes) < k and len(ab_likes) + (k - len(ab_likes)) * 2 > m:\n        print -1\n        exit(0)\n\n    if min_a_b_count + len(ab_likes) < k:\n        print -1\n        exit(0)\n\n\n    for i in [a_likes, b_likes, ab_likes, noone_likes]:\n        i.sort()\n\n\n    import heapq\n    free_heap = []\n\n\n    if min_a_b_count > min(k, m - k):\n        min_a_b_count = min(k, m - k)\n\n    for i in [a_likes, b_likes]:\n        for j in i[min_a_b_count:]:\n            heapq.heappush(free_heap, j)\n\n    a_likes = a_likes[:min_a_b_count]\n    b_likes = b_likes[:min_a_b_count]\n\n    for j in noone_likes:\n        heapq.heappush(free_heap, j)\n\n    # Only ab_likes\n    if not a_likes:\n        s = sum(ab_likes[:k])\n        for i in ab_likes[k:]:\n            heapq.heappush(free_heap, i)\n        s += sum(heapq.heappop(free_heap) for _ in xrange(m - k))\n        print s\n        exit(0)\n\n    # Minimal set of likes\n    if len(a_likes) + len(ab_likes) == k:\n        s = sum(ab_likes) + sum(a_likes) + sum(b_likes)\n        s += sum(heapq.heappop(free_heap) for _ in xrange(m - (k + len(b_likes))))\n        print s\n        exit(0)\n\n    # Sum with min number of ab_likes\n    s = sum(ab_likes[:k - min_a_b_count]) + sum(a_likes) + sum(b_likes)\n    count = k - min_a_b_count + (min_a_b_count * 2)\n\n    extra_heap = []  # need to know max in extra values\n    for _ in xrange(m - count):\n        if not free_heap:  # if not too many ab_likes...\n            break\n        heapq.heappush(extra_heap, -1 * heapq.heappop(free_heap))\n    s += -1 * sum(extra_heap)\n    count += len(extra_heap)\n\n    min_sum = s\n    # Iterate on reminder of ab_likes\n    for i in xrange(k - min_a_b_count, len(ab_likes)):\n        if count == m:\n            s += ab_likes[i] - a_likes[-1] - b_likes[-1]\n            heapq.heappush(free_heap, a_likes.pop())\n            heapq.heappush(free_heap, b_likes.pop())\n\n            extra_item = heapq.heappop(free_heap)\n            s += extra_item\n            heapq.heappush(extra_heap, -1 * extra_item)\n\n            # Make sure that newly added items are in extra_heap if they are cheaper\n            free_min = heapq.heappop(free_heap)\n            extra_min = -1 * heapq.heappop(extra_heap)\n            if free_min < extra_min:\n                s -= extra_min - free_min\n                heapq.heappush(free_heap, extra_min)\n                heapq.heappush(extra_heap, -1 * free_min)\n            else:\n                heapq.heappush(extra_heap, -1 * extra_min)\n                heapq.heappush(free_heap, free_min)\n\n            min_sum = min(min_sum, s)\n\n            if not a_likes:\n                for j in ab_likes[i+1:]:\n                    if j < -1 * extra_heap[0]:\n                        s -= -1 * extra_heap[0] - j\n                        heapq.heappushpop(extra_heap, -1 * j)\n                    else:\n                        break\n                min_sum = min(min_sum, s)\n                break\n        else:\n            s += ab_likes[i]\n            count += 1\n            if count == m:\n                min_sum = s\n\n    print min_sum\n\nexcept Exception, e:\n    import sys\n    print('L{}'.format(sys.exc_info()[-1].tb_lineno), type(e).__name__, len(ab_likes), len(a_likes), len(free_heap))",
    "prob_desc_created_at": "1494516900",
    "tags": [
        "data structures",
        "two pointers",
        "greedy"
    ],
    "hidden_unit_tests": ""
}
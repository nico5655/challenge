{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"6\\n4\\n10\\n7\"]",
    "src_uid": "0373262cf6c4c6d29fbf2177a1649cee",
    "prob_desc_notes": "NoteFor the first query, $$$l = 2$$$ and $$$r = 5$$$, and the non-decreasing subarrays $$$[p,q]$$$ are $$$[2,2]$$$, $$$[3,3]$$$, $$$[4,4]$$$, $$$[5,5]$$$, $$$[2,3]$$$ and $$$[4,5]$$$.",
    "prob_desc_description": "Alice has recently received an array $$$a_1, a_2, \\dots, a_n$$$ for her birthday! She is very proud of her array, and when she showed her friend Bob the array, he was very happy with her present too!However, soon Bob became curious, and as any sane friend would do, asked Alice to perform $$$q$$$ operations of two types on her array:  $$$1$$$ $$$x$$$ $$$y$$$: update the element $$$a_x$$$ to $$$y$$$ (set $$$a_x = y$$$).  $$$2$$$ $$$l$$$ $$$r$$$: calculate how many non-decreasing subarrays exist within the subarray $$$[a_l, a_{l+1}, \\dots, a_r]$$$. More formally, count the number of pairs of integers $$$(p,q)$$$ such that $$$l \\le p \\le q \\le r$$$ and $$$a_p \\le a_{p+1} \\le \\dots \\le a_{q-1} \\le a_q$$$. Help Alice answer Bob's queries!",
    "prob_desc_output_spec": "For each query of type $$$2$$$, print a single integer, the answer to the query.",
    "prob_desc_input_spec": "The first line contains two integers $$$n$$$ and $$$q$$$ ($$$1 \\le n, q \\le 2 \\cdot 10^5$$$) — the size of the array, and the number of queries, respectively. The second line contains $$$n$$$ integers $$$a_1, a_2, \\dots, a_n$$$ ($$$1 \\le a_i \\le 10^9$$$) — the elements of Alice's array. The next $$$q$$$ lines consist of three integers each. The first integer of the $$$i$$$-th line is $$$t_i$$$, the operation being performed on the $$$i$$$-th step ($$$t_i = 1$$$ or $$$t_i = 2$$$). If $$$t_i = 1$$$, the next two integers are $$$x_i$$$ and $$$y_i$$$ ($$$1 \\le x_i \\le n$$$; $$$1 \\le y_i \\le 10^9$$$), updating the element at position $$$x_i$$$ to $$$y_i$$$ (setting $$$a_{x_i} = y_i$$$). If $$$t_i = 2$$$, the next two integers are $$$l_i$$$ and $$$r_i$$$ ($$$1 \\le l_i \\le r_i \\le n$$$), the two indices Bob asks Alice about for the $$$i$$$-th query. It's guaranteed that there is at least one operation of the second type.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3",
    "lang_cluster": "Python",
    "difficulty": 2200,
    "file_name": "train_089.jsonl",
    "code_uid": "dae7be27505f90ba6d946c0f0c8c02cf",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"5 6\\n3 1 4 1 5\\n2 2 5\\n2 1 3\\n1 4 4\\n2 2 5\\n1 2 6\\n2 2 5\"]",
    "exec_outcome": "PASSED",
    "source_code": "# Based on https://codeforces.com/contest/1567/submission/127989410\n# But use ffi for data layout and use double instead of big integer for answer\n\nimport sys\nfrom cffi import FFI\n\ninput = sys.stdin.buffer.readline\n\nffi = FFI()\nffi.cdef(\n    \"\"\"\n    typedef struct {\n        int first;\n        int last;\n        int suf;\n        int pre;\n        int length;\n        double ans;\n    } node_t;\n    \"\"\"\n)\n\n\n\n\nMX = 2 << ((2 * 10 ** 5) - 1).bit_length()\ndata = ffi.new(\"node_t[]\", MX + 3)\ndata[MX] = (0, 0, 0, 0, 0, 0)\nid_node = data[MX]\nres_left = MX + 1\nres_right = MX + 2\n\n\n\ndef combine(a, b):\n    if a.length == 0:\n        return b\n    if b.length == 0:\n        return a\n    first = a.first\n    last = b.last\n    suf = 0\n    pre = 0\n    length = a.length + b.length\n    ans = a.ans + b.ans\n    if a.last <= b.first:\n        if a.length == a.pre:\n            pre = b.pre + a.length\n        else:\n            pre = a.pre\n        if b.length == b.suf:\n            suf = a.suf + b.length\n        else:\n            suf = b.suf\n        ans += a.suf * b.pre\n    else:\n        pre = a.pre\n        suf = b.suf\n    return (first, last, suf, pre, length, ans)\n\n\ndef mapValue(x):\n    return (x, x, 1, 1, 1, 1)\n\n\nclass SegmentTree:\n    def __init__(self, N, A):\n        self._len = N\n        self._size = _size = 1 << (self._len - 1).bit_length()\n        for i in range(2 * _size):\n            data[i] = id_node\n        for i, x in enumerate(A):\n            data[_size + i] = mapValue(x)\n        for i in reversed(range(_size)):\n            data[i] = combine(data[i + i], data[i + i + 1])\n\n    def __delitem__(self, idx):\n        self[idx] = id_node\n\n    def __getitem__(self, idx):\n        return data[idx + self._size]\n\n    def __setitem__(self, idx, value):\n        idx += self._size\n        data[idx] = value\n        idx >>= 1\n        while idx:\n            data[idx] = combine(data[2 * idx], data[2 * idx + 1])\n            idx >>= 1\n\n    def __len__(self):\n        return self._len\n\n    def query(self, start, stop):\n        \"\"\"func of data[start, stop)\"\"\"\n        start += self._size\n        stop += self._size\n        data[res_left] = id_node\n        data[res_right] = id_node\n        while start < stop:\n            if start & 1:\n                data[res_left] = combine(data[res_left], data[start])\n                start += 1\n            if stop & 1:\n                stop -= 1\n                data[res_right] = combine(data[stop], data[res_right])\n            start >>= 1\n            stop >>= 1\n        data[res_left] = combine(data[res_left], data[res_right])\n        return data[res_left]\n\n\ndef main():\n    n, q = map(int, input().split())\n    segtree = SegmentTree(n, map(int, input().split()))\n    ans = []\n    for _ in range(q):\n        t, l, r = map(int, input().split())\n        l -= 1\n        if t == 1:\n            segtree[l] = mapValue(r)\n        else:\n            ans.append(int(segtree.query(l, r).ans))\n    print(\"\\n\".join(map(str, ans)))\n\n\nif __name__ == \"__main__\":\n    main()\n\n",
    "prob_desc_created_at": "1630852500",
    "tags": [
        "data structures",
        "divide and conquer",
        "math"
    ],
    "hidden_unit_tests": ""
}
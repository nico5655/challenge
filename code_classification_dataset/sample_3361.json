{
    "prob_desc_time_limit": "3 seconds",
    "prob_desc_sample_outputs": "[\"15\", \"21\"]",
    "src_uid": "2e432951f2881f3cb0f9163ef1d901ca",
    "prob_desc_notes": "NoteIn the first example, the best trade overall is to buy at a price of 1 on day 9 and sell at a price of 9 on day 10 and the second best trade overall is to buy at a price of 2 on day 1 and sell at a price of 9 on day 4. Since these two trades do not overlap, both can be made and the profit is the sum of the profits of the two trades. Thus the trade strategy looks like this: 2    | 7    | 3    | 9    | 8    | 7    | 9    | 7    | 1    | 9buy  |      |      | sell |      |      |      |      | buy  | sellThe total profit is then (9 - 2) + (9 - 1) = 15.In the second example, even though Manao is allowed up to 5 trades there are only 4 profitable trades available. Making a fifth trade would cost Manao money so he only makes the following 4: 2    | 7    | 3    | 9    | 8    | 7    | 9    | 7    | 1    | 9buy  | sell | buy  | sell |      | buy  | sell |      | buy  | sellThe total profit is then (7 - 2) + (9 - 3) + (9 - 7) + (9 - 1) = 21.",
    "prob_desc_description": "This problem consists of three subproblems: for solving subproblem F1 you will receive 8 points, for solving subproblem F2 you will receive 15 points, and for solving subproblem F3 you will receive 10 points.Manao has developed a model to predict the stock price of a company over the next n days and wants to design a profit-maximizing trading algorithm to make use of these predictions. Unfortunately, Manao's trading account has the following restrictions:   It only allows owning either zero or one shares of stock at a time;  It only allows buying or selling a share of this stock once per day;  It allows a maximum of k buy orders over the next n days; For the purposes of this problem, we define a trade to a be the act of buying one share of stock on day i, then holding the stock until some day j &gt; i at which point the share is sold. To restate the above constraints, Manao is permitted to make at most k non-overlapping trades during the course of an n-day trading period for which Manao's model has predictions about the stock price.Even though these restrictions limit the amount of profit Manao can make compared to what would be achievable with an unlimited number of trades or the ability to hold more than one share at a time, Manao still has the potential to make a lot of money because Manao's model perfectly predicts the daily price of the stock. For example, using this model, Manao could wait until the price is low, then buy one share and hold until the price reaches a high value, then sell for a profit, and repeat this process up to k times until n days have passed.Nevertheless, Manao is not satisfied by having a merely good trading algorithm, and wants to develop an optimal strategy for trading subject to these constraints. Help Manao achieve this goal by writing a program that will determine when to buy and sell stock to achieve the greatest possible profit during the n-day trading period subject to the above constraints.",
    "prob_desc_output_spec": "For this problem, the program will only report the amount of the optimal profit, rather than a list of trades that can achieve this profit. Therefore, the program should print one line containing a single integer, the maximum profit Manao can achieve over the next n days with the constraints of starting with no shares on the first day of trading, always owning either zero or one shares of stock, and buying at most k shares over the course of the n-day trading period.",
    "prob_desc_input_spec": "The first line contains two integers n and k, separated by a single space, with . The i-th of the following n lines contains a single integer pi (0 ≤ pi ≤ 1012), where pi represents the price at which someone can either buy or sell one share of stock on day i. The problem consists of three subproblems. The subproblems have different constraints on the input. You will get some score for the correct submission of the subproblem. The description of the subproblems follows.   In subproblem F1 (8 points), n will be between 1 and 3000, inclusive.  In subproblem F2 (15 points), n will be between 1 and 100000, inclusive.  In subproblem F3 (10 points), n will be between 1 and 4000000, inclusive. ",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "Python 2",
    "lang_cluster": "Python",
    "difficulty": null,
    "file_name": "train_054.jsonl",
    "code_uid": "310824445ce6c958a1d862d08f6b1c91",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"10 2\\n2\\n7\\n3\\n9\\n8\\n7\\n9\\n7\\n1\\n9\", \"10 5\\n2\\n7\\n3\\n9\\n8\\n7\\n9\\n7\\n1\\n9\"]",
    "exec_outcome": "PASSED",
    "source_code": "def maxProfit( k, prices):\n    n = len(prices)\n    if n == 0 or n == 1 or k == 0:\n        return 0\n    if k >= n / 2:\n        profit = 0\n        for n in range(n - 1):\n            diff = prices[n + 1] - prices[n]\n            if diff > 0:\n                profit += diff\n        return profit\n\n    hold = k * [float('-inf')]\n    hold_prev = k * [float('-inf')]\n    release = k * [float('-inf')]\n    release_prev = k * [float('-inf')]\n    for price in prices:\n        for i in range(0, k):\n            if i == 0:\n                hold[i] = max(-price, hold_prev[i])\n            else:\n                hold[i] = max(release_prev[i - 1] - price, hold_prev[i])\n            release[i] = max(hold_prev[i] + price, release_prev[i])\n        hold_prev = hold\n        release_prev = release\n    return release[-1]\n\nvar = raw_input()\nl = int(var.split(\" \")[0])\nk = int(var.split(\" \")[1])\nps = []\nfor i in range(l):\n    v = raw_input()\n    ps.append(int(v))\nprint maxProfit(k,ps)",
    "prob_desc_created_at": "1392573600",
    "tags": [
        "dp"
    ],
    "hidden_unit_tests": ""
}
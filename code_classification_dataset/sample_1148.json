{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"0\\n0\\n4\\n4\\n12\\n990998587\\n804665184\"]",
    "src_uid": "43ace9254c5d879d11e3484eacb0bcc4",
    "prob_desc_notes": "NoteIt's easy to see that the answer for RDB of level $$$1$$$ or $$$2$$$ is $$$0$$$.The answer for RDB of level $$$3$$$ is $$$4$$$ since there is only one claw we can choose: $$$\\{1, 2, 3, 4\\}$$$.The answer for RDB of level $$$4$$$ is $$$4$$$ since we can choose either single claw $$$\\{1, 3, 2, 4\\}$$$ or single claw $$$\\{2, 7, 5, 6\\}$$$. There are no other claws in the RDB of level $$$4$$$ (for example, we can't choose $$$\\{2, 1, 7, 6\\}$$$, since $$$1$$$ is not a child of center vertex $$$2$$$).  Rooted Dead Bush of level 4. ",
    "prob_desc_description": "Lee tried so hard to make a good div.2 D problem to balance his recent contest, but it still doesn't feel good at all. Lee invented it so tediously slow that he managed to develop a phobia about div.2 D problem setting instead. And now he is hiding behind the bushes...Let's define a Rooted Dead Bush (RDB) of level $$$n$$$ as a rooted tree constructed as described below.A rooted dead bush of level $$$1$$$ is a single vertex. To construct an RDB of level $$$i$$$ we, at first, construct an RDB of level $$$i-1$$$, then for each vertex $$$u$$$:   if $$$u$$$ has no children then we will add a single child to it;  if $$$u$$$ has one child then we will add two children to it;  if $$$u$$$ has more than one child, then we will skip it.   Rooted Dead Bushes of level $$$1$$$, $$$2$$$ and $$$3$$$. Let's define a claw as a rooted tree with four vertices: one root vertex (called also as center) with three children. It looks like a claw:  The center of the claw is the vertex with label $$$1$$$. Lee has a Rooted Dead Bush of level $$$n$$$. Initially, all vertices of his RDB are green.In one move, he can choose a claw in his RDB, if all vertices in the claw are green and all vertices of the claw are children of its center, then he colors the claw's vertices in yellow.He'd like to know the maximum number of yellow vertices he can achieve. Since the answer might be very large, print it modulo $$$10^9+7$$$.",
    "prob_desc_output_spec": "For each test case, print a single integer — the maximum number of yellow vertices Lee can make modulo $$$10^9 + 7$$$.",
    "prob_desc_input_spec": "The first line contains one integer $$$t$$$ ($$$1 \\le t \\le 10^4$$$) — the number of test cases. Next $$$t$$$ lines contain test cases — one per line. The first line of each test case contains one integer $$$n$$$ ($$$1 \\le n \\le 2 \\cdot 10^6$$$) — the level of Lee's RDB.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3",
    "lang_cluster": "Python",
    "difficulty": 1900,
    "file_name": "train_006.jsonl",
    "code_uid": "3e28bedf4a6ff9813d8f457a0ba529da",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"7\\n1\\n2\\n3\\n4\\n5\\n100\\n2000000\"]",
    "exec_outcome": "PASSED",
    "source_code": "#!/usr/bin/env python\nimport os\nimport sys\nfrom io import BytesIO, IOBase\nimport threading \nfrom math import floor\nfrom bisect import bisect_right\nfrom collections import Counter\nfrom math import gcd\n\n\nmod=10**9+7\n\n\n\ndef main():\n    size=2*10**6+1\n    ans=[0]*(size)\n    a=0\n    b=0\n    for i in range(1,2*10**6+1):\n        # if i<10:\n            # print(i,a,b)\n        a,b=b,b+2*a\n        if i%3==0:\n            b+=1\n        a%=mod\n        b%=mod\n        ans[i]=b\n\n    for _ in range(int(input())):\n        # print(ans[:10])\n        n=int(input())\n        print(ans[n]*4%mod)\n\n\n\n\n\n\n        \n\n\n\n        \n\n\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n# endregion\n\nif __name__ == \"__main__\":\n    main()",
    "prob_desc_created_at": "1592921100",
    "tags": [
        "dp",
        "greedy",
        "graphs",
        "math",
        "trees"
    ],
    "hidden_unit_tests": ""
}
{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"9\", \"0\", \"10\"]",
    "src_uid": "89c54eb60bd0adcbe8892c922d86b0d8",
    "prob_desc_notes": "NoteIn the first example Arkady should build the second fountain with beauty 4, which costs 3 coins. The first fountain he can't build because he don't have enough coins. Also Arkady should build the third fountain with beauty 5 which costs 6 diamonds. Thus the total beauty of built fountains is 9.In the second example there are two fountains, but Arkady can't build both of them, because he needs 5 coins for the first fountain, and Arkady has only 4 coins. ",
    "prob_desc_description": "Arkady plays Gardenscapes a lot. Arkady wants to build two new fountains. There are n available fountains, for each fountain its beauty and cost are known. There are two types of money in the game: coins and diamonds, so each fountain cost can be either in coins or diamonds. No money changes between the types are allowed.Help Arkady to find two fountains with maximum total beauty so that he can buy both at the same time.",
    "prob_desc_output_spec": "Print the maximum total beauty of exactly two fountains Arkady can build. If he can't build two fountains, print 0.",
    "prob_desc_input_spec": "The first line contains three integers n, c and d (2 ≤ n ≤ 100 000, 0 ≤ c, d ≤ 100 000) — the number of fountains, the number of coins and diamonds Arkady has. The next n lines describe fountains. Each of these lines contain two integers bi and pi (1 ≤ bi, pi ≤ 100 000) — the beauty and the cost of the i-th fountain, and then a letter \"C\" or \"D\", describing in which type of money is the cost of fountain i: in coins or in diamonds, respectively.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "Python 2",
    "lang_cluster": "Python",
    "difficulty": 1800,
    "file_name": "train_034.jsonl",
    "code_uid": "cb779f7ef0ede3a372d7b4e8a4c0c5a9",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"3 7 6\\n10 8 C\\n4 3 C\\n5 6 D\", \"2 4 5\\n2 5 C\\n2 1 D\", \"3 10 10\\n5 5 C\\n5 5 C\\n10 11 D\"]",
    "exec_outcome": "PASSED",
    "source_code": "# -*- coding=utf-8 -*-\n# 这里有一个巨大的bug就是没有考虑cost = [1,2,2,2,2,3,4,5,6,6,6,7,8,9,9,9,9]也就是传说中的单调不递减\n# 不能够用bisect_left，只能够用bisect_right.由于它没有原生支持key所以得自己实现。要改same_p_beauty的用法\n# def bisearch_left(arr, num, key = None):\n# \t# according to num find the pos(index)\n# \tif key == None:\n# \t\tkey = lambda x:x\n# \tdef bi(l, r = len(arr)):\n# \t\twhile l < r:\n# \t\t\tmid = (l + r) // 2\n# \t\t\tif key(arr[mid]) <= num:\n# \t\t\t\tl = mid\n# \t\t\telse:\n# \t\t\t\tr = mid\n# \t\treturn r\n# \treturn bi(0)\nfrom bisect import *\n\ndef get(sort_arr, all_cost, n, c,d):\n\t# pair:(cost, beauty)\n\t\n\n\tif sort_arr == []:\n\t\treturn 0\n\tcost_arr, beauty_arr = zip(*sort_arr) # for bisect\n\t# print 'sort_arr',list(reversed(sort_arr))\n\t# print \"sort_arr\", sort_arr\n\t# if n == 49999 and c == 100000:\n\t# \tprint 'sort_arr',list(reversed(sort_arr))\n\tmaxB = [0]*len(sort_arr)\n\tmaxB[0] = sort_arr[0][1]\n\tfor i, pair in enumerate(sort_arr[1:]):\n\t\tif pair[1] >= maxB[i]:\n\t\t\tmaxB[i+1] = pair[1]\n\t\telse:\n\t\t\tmaxB[i+1] = maxB[i]\n\t# print 'maxB',maxB\n\t# if n == 49999 and c == 100000:\n\t# \tprint 'maxB',maxB\n\t# if p1 == p2 is true\n\tsame_p_beauty = 0\n\tfor i, pair in enumerate(sort_arr[1:]):\n\t\tcost, beauty = pair\n\t\tif sort_arr[i][0] == cost and cost + sort_arr[i][0] <= all_cost:\n\t\t\ttemp = sort_arr[i][1] + beauty\n\t\t\tif same_p_beauty < temp:\n\t\t\t\tsame_p_beauty = temp\n\t# print 'same_p_beauty',same_p_beauty\n\t# if p1 < p2 is true\n\tmax_beauty = 0\n\tfor index, pair in enumerate(reversed(sort_arr)):\n\t\tcost, beauty = pair # p2 is bigger\n\t\t# print 'all_cost:',type(all_cost)\n\t\t# print 'cost:',type(cost)\n\t\tleave = all_cost - cost\n\t\t# if n == 49999 and c == 100000:\n\t\t# \tprint 'leave', leave\n\t\tif leave < sort_arr[0][0]: # out of range\n\t\t\tcontinue\n\t\ttemp = beauty\n\t\t# next_pos = bisearch_left(sort_arr, leave, key = lambda x: x[0])\n\t\tnext_pos = bisect_right(cost_arr, leave)\n\t\t# print 'sort_arr[next_pos-1][0]',sort_arr[next_pos-1][0]\n\t\t# print 'cost',cost\n\t\t# print 'leave',leave\n\t\t# print 'max_beauty',max_beauty\n\t\t# print '(len(sort_arr) - 1 - index - 1)',(len(sort_arr) - 1 - index - 1)\n\t\tif next_pos-1 == len(sort_arr) - 1 - index or (len(sort_arr) - 1 - index - 1) < 0:\n\n\t\t\tcontinue\n\n\t\tif sort_arr[next_pos-1][0] > cost:\n\t\t\tif maxB[len(sort_arr) - 1 - index - 1] + temp >= max_beauty :\n\t\t\t\tmax_beauty = temp + maxB[len(sort_arr) - 1 - index - 1]\n\t\t\tcontinue\n\t\tif temp + maxB[next_pos-1] > max_beauty:\n\n\t\t\tmax_beauty = temp + maxB[next_pos-1]\n\t\t\t# print temp\n\t\t\t# print  maxB[next_pos-1]\n\treturn max(max_beauty, same_p_beauty)\n\n\ndef helper():\n\tn, c, d = map(int, raw_input().split())\n\tC = []\n\tD = []\n\tfor i in xrange(n):\n\t\tbeauty, cost, type = raw_input().split()\n\t\tif type == 'C':\n\t\t\tC.append((int(cost), int(beauty)))\n\t\telse:\n\t\t\tD.append((int(cost), int(beauty)))\n\tC.sort() # change into two sort ... maybe complicate\n\tD.sort() # 排序嵌套，复杂度高，要复习，问问\n\tmaxC = 0\n\tmaxD = 0\n\t# maybe bisect\n\tfor pair in C:\n\t\tif pair[0] <= c:\n\t\t\tif maxC < pair[1]:\n\t\t\t\tmaxC = pair[1]\n\t\telse:\n\t\t\tbreak\n\tfor pair in D:\n\t\tif pair[0] <= d:\n\t\t\tif maxD < pair[1]:\n\t\t\t\tmaxD = pair[1]\n\t\telse:\n\t\t\tbreak\n\tres = 0\n\tif maxC == 0 or maxD == 0:\n\t\tres = 0\n\telse:\n\t\tres = maxD + maxC\n\t# print res\n\treturn max(get(C, c, n, c, d), get(D, d, n, c, d), res)\n\n# l = helper()\n# if l == 651:\n# \tprint 652\n# elif l == 9998:\n# \tprint 9999\n# else:\n# \tprint l\nprint helper()",
    "prob_desc_created_at": "1494516900",
    "tags": [
        "data structures",
        "binary search",
        "implementation"
    ],
    "hidden_unit_tests": ""
}
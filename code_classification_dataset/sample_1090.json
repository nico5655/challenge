{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"2\\n0\\n4\"]",
    "src_uid": "d4249cd3147e888e13e85767d3457d0b",
    "prob_desc_notes": "Note$$$\\require{cancel}$$$Let's denote as $$$a_1 a_2 \\ldots \\cancel{a_i} \\underline{a_{i+1}} \\ldots a_n \\rightarrow a_1 a_2 \\ldots a_{i-1} a_{i+1} \\ldots a_{n-1}$$$ an operation over an element with index $$$i$$$: removal of element $$$a_i$$$ from array $$$a$$$ and appending element $$$a_{i+1}$$$ to array $$$b$$$.In the first example test, the following two options can be used to produce the given array $$$b$$$:  $$$1 2 \\underline{3} \\cancel{4} 5 \\rightarrow 1 \\underline{2} \\cancel{3} 5 \\rightarrow 1 \\cancel{2} \\underline{5} \\rightarrow 1 2$$$; $$$(t_1, t_2, t_3) = (4, 3, 2)$$$;  $$$1 2 \\underline{3} \\cancel{4} 5 \\rightarrow \\cancel{1} \\underline{2} 3 5 \\rightarrow 2 \\cancel{3} \\underline{5} \\rightarrow 1 5$$$; $$$(t_1, t_2, t_3) = (4, 1, 2)$$$. In the second example test, it is impossible to achieve the given array no matter the operations used. That's because, on the first application, we removed the element next to $$$4$$$, namely number $$$3$$$, which means that it couldn't be added to array $$$b$$$ on the second step.In the third example test, there are four options to achieve the given array $$$b$$$:  $$$1 4 \\cancel{7} \\underline{3} 6 2 5 \\rightarrow 1 4 3 \\cancel{6} \\underline{2} 5 \\rightarrow \\cancel{1} \\underline{4} 3 2 5 \\rightarrow 4 3 \\cancel{2} \\underline{5} \\rightarrow 4 3 5$$$; $$$1 4 \\cancel{7} \\underline{3} 6 2 5 \\rightarrow 1 4 3 \\cancel{6} \\underline{2} 5 \\rightarrow 1 \\underline{4} \\cancel{3} 2 5 \\rightarrow 1 4 \\cancel{2} \\underline{5} \\rightarrow 1 4 5$$$; $$$1 4 7 \\underline{3} \\cancel{6} 2 5 \\rightarrow 1 4 7 \\cancel{3} \\underline{2} 5 \\rightarrow \\cancel{1} \\underline{4} 7 2 5 \\rightarrow 4 7 \\cancel{2} \\underline{5} \\rightarrow 4 7 5$$$; $$$1 4 7 \\underline{3} \\cancel{6} 2 5 \\rightarrow 1 4 7 \\cancel{3} \\underline{2} 5 \\rightarrow 1 \\underline{4} \\cancel{7} 2 5 \\rightarrow 1 4 \\cancel{2} \\underline{5} \\rightarrow 1 4 5$$$;",
    "prob_desc_description": "We start with a permutation $$$a_1, a_2, \\ldots, a_n$$$ and with an empty array $$$b$$$. We apply the following operation $$$k$$$ times.On the $$$i$$$-th iteration, we select an index $$$t_i$$$ ($$$1 \\le t_i \\le n-i+1$$$), remove $$$a_{t_i}$$$ from the array, and append one of the numbers $$$a_{t_i-1}$$$ or $$$a_{t_i+1}$$$ (if $$$t_i-1$$$ or $$$t_i+1$$$ are within the array bounds) to the right end of the array $$$b$$$. Then we move elements $$$a_{t_i+1}, \\ldots, a_n$$$ to the left in order to fill in the empty space.You are given the initial permutation $$$a_1, a_2, \\ldots, a_n$$$ and the resulting array $$$b_1, b_2, \\ldots, b_k$$$. All elements of an array $$$b$$$ are distinct. Calculate the number of possible sequences of indices $$$t_1, t_2, \\ldots, t_k$$$ modulo $$$998\\,244\\,353$$$.",
    "prob_desc_output_spec": "For each test case print one integer: the number of possible sequences modulo $$$998\\,244\\,353$$$.",
    "prob_desc_input_spec": "Each test contains multiple test cases. The first line contains an integer $$$t$$$ ($$$1 \\le t \\le 100\\,000$$$), denoting the number of test cases, followed by a description of the test cases. The first line of each test case contains two integers $$$n, k$$$ ($$$1 \\le k &lt; n \\le 200\\,000$$$): sizes of arrays $$$a$$$ and $$$b$$$. The second line of each test case contains $$$n$$$ integers $$$a_1, a_2, \\ldots, a_n$$$ ($$$1 \\le a_i \\le n$$$): elements of $$$a$$$. All elements of $$$a$$$ are distinct. The third line of each test case contains $$$k$$$ integers $$$b_1, b_2, \\ldots, b_k$$$ ($$$1 \\le b_i \\le n$$$): elements of $$$b$$$. All elements of $$$b$$$ are distinct. The sum of all $$$n$$$ among all test cases is guaranteed to not exceed $$$200\\,000$$$.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3",
    "lang_cluster": "Python",
    "difficulty": 1800,
    "file_name": "train_006.jsonl",
    "code_uid": "581e03461769cb34fcb3bd580a3366b7",
    "prob_desc_memory_limit": "512 megabytes",
    "prob_desc_sample_inputs": "[\"3\\n5 3\\n1 2 3 4 5\\n3 2 5\\n4 3\\n4 3 2 1\\n4 3 1\\n7 4\\n1 4 7 3 6 2 5\\n3 2 4 5\"]",
    "exec_outcome": "PASSED",
    "source_code": "\"\"\"\n    Author - Satwik Tiwari .\n    2nd NOV , 2020  - Monday\n\"\"\"\n\n#===============================================================================================\n#importing some useful libraries.\n\n\nfrom __future__ import division, print_function\nfrom fractions import Fraction\nimport sys\nimport os\nfrom io import BytesIO, IOBase\nfrom functools import cmp_to_key\n\n# from itertools import *\nfrom heapq import *\nfrom math import gcd, factorial,floor,ceil,sqrt\n\nfrom copy import deepcopy\nfrom collections import deque\n\n\nfrom bisect import bisect_left as bl\nfrom bisect import bisect_right as br\nfrom bisect import bisect\n\n#==============================================================================================\n#fast I/O region\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\ndef print(*args, **kwargs):\n    \"\"\"Prints the values to a stream, or to sys.stdout by default.\"\"\"\n    sep, file = kwargs.pop(\"sep\", \" \"), kwargs.pop(\"file\", sys.stdout)\n    at_start = True\n    for x in args:\n        if not at_start:\n            file.write(sep)\n        file.write(str(x))\n        at_start = False\n    file.write(kwargs.pop(\"end\", \"\\n\"))\n    if kwargs.pop(\"flush\", False):\n        file.flush()\n\n\nif sys.version_info[0] < 3:\n    sys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)\nelse:\n    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\n\n# inp = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n#===============================================================================================\n### START ITERATE RECURSION ###\nfrom types import GeneratorType\ndef iterative(f, stack=[]):\n  def wrapped_func(*args, **kwargs):\n    if stack: return f(*args, **kwargs)\n    to = f(*args, **kwargs)\n    while True:\n      if type(to) is GeneratorType:\n        stack.append(to)\n        to = next(to)\n        continue\n      stack.pop()\n      if not stack: break\n      to = stack[-1].send(to)\n    return to\n  return wrapped_func\n#### END ITERATE RECURSION ####\n\n#===============================================================================================\n#some shortcuts\n\ndef inp(): return sys.stdin.readline().rstrip(\"\\r\\n\") #for fast input\ndef out(var): sys.stdout.write(str(var))  #for fast output, always take string\ndef lis(): return list(map(int, inp().split()))\ndef stringlis(): return list(map(str, inp().split()))\ndef sep(): return map(int, inp().split())\ndef strsep(): return map(str, inp().split())\n# def graph(vertex): return [[] for i in range(0,vertex+1)]\ndef zerolist(n): return [0]*n\ndef nextline(): out(\"\\n\")  #as stdout.write always print sring.\ndef testcase(t):\n    for pp in range(t):\n        solve(pp)\ndef printlist(a) :\n    for p in range(0,len(a)):\n        out(str(a[p]) + ' ')\ndef google(p):\n    print('Case #'+str(p)+': ',end='')\ndef lcm(a,b): return (a*b)//gcd(a,b)\ndef power(x, y, p) :\n    y%=(p-1)  #not so sure about this. used when y>p-1. if p is prime.\n    res = 1     # Initialize result\n    x = x % p  # Update x if it is more , than or equal to p\n    if (x == 0) :\n        return 0\n    while (y > 0) :\n        if ((y & 1) == 1) : # If y is odd, multiply, x with result\n            res = (res * x) % p\n\n        y = y >> 1      # y = y/2\n        x = (x * x) % p\n    return res\ndef ncr(n,r): return factorial(n) // (factorial(r) * factorial(max(n - r, 1)))\ndef isPrime(n) :\n    if (n <= 1) : return False\n    if (n <= 3) : return True\n    if (n % 2 == 0 or n % 3 == 0) : return False\n    i = 5\n    while(i * i <= n) :\n        if (n % i == 0 or n % (i + 2) == 0) :\n            return False\n        i = i + 6\n    return True\ninf = pow(10,20)\nmod = 998244353\n#===============================================================================================\n# code here ;))\n\ndef solve(case):\n    n,k = sep()\n    a = lis()\n    b = lis()\n\n    have = {}\n    for i in range(k):\n        have[b[i]] = 1\n\n    pos = {}\n    for i in range(n):\n        pos[a[i]] = i\n\n    if(len(b) == 1 and len(a)<3):\n        if(b[0] in a):\n            print(1)\n        else:\n            print(0)\n        return\n\n    ans = 1\n    for i in range(k):\n        # print(i)\n        # print(have)\n        left = -1\n        right = -1\n        ind = pos[b[i]]\n        del have[b[i]]\n        # print(ind)\n\n        if(ind == 0):\n            if(a[ind+1] in have):\n                ans = 0\n                break\n        elif(ind == n-1):\n            if(a[ind-1] in have):\n                ans = 0\n                break\n        else:\n            if(a[ind-1] in have and a[ind+1] in have):\n                ans = 0\n                break\n            if(a[ind-1] not in have and a[ind+1] not in have):\n                ans*=2\n\n                # print(i,ans)\n\n        ans%=mod\n    print(ans%mod)\n\n\n\n\n\"\"\"\n2\n13\n1 1 1 1 1 4 3 4 4 3 4 3\n13\n1 1 1 2 2 2 3 3 3 4 4 4 \n\"\"\"\n\n# testcase(1)\ntestcase(int(inp()))\n\n\n\n\n\n\n\n\n\n",
    "prob_desc_created_at": "1604327700",
    "tags": [
        "greedy",
        "combinatorics",
        "math",
        "data structures",
        "brute force"
    ],
    "hidden_unit_tests": ""
}
{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"4\\n1 4 3 5 \\n3\\n2 4 5 \\n4\\n6 7 1 2 \\n-1\\n4\\n2 4 3 5\", \"-1\\n4\\n3 4 1 5 \\n1\\n1\"]",
    "src_uid": "e745f777e5676c2629f806e09f83a739",
    "prob_desc_notes": null,
    "prob_desc_description": "Vitaly enrolled in the course Advanced Useless Algorithms. The course consists of $$$n$$$ tasks. Vitaly calculated that he has $$$a_i$$$ hours to do the task $$$i$$$ from the day he enrolled in the course. That is, the deadline before the $$$i$$$-th task is $$$a_i$$$ hours. The array $$$a$$$ is sorted in ascending order, in other words, the job numbers correspond to the order in which the assignments are turned in.Vitaly does everything conscientiously, so he wants to complete each task by $$$100$$$ percent, or more. Initially, his completion rate for each task is $$$0$$$ percent.Vitaly has $$$m$$$ training options, each option can be used not more than once. The $$$i$$$th option is characterized by three integers: $$$e_i, t_i$$$ and $$$p_i$$$. If Vitaly uses the $$$i$$$th option, then after $$$t_i$$$ hours (from the current moment) he will increase the progress of the task $$$e_i$$$ by $$$p_i$$$ percent. For example, let Vitaly have $$$3$$$ of tasks to complete. Let the array $$$a$$$ have the form: $$$a = [5, 7, 8]$$$. Suppose Vitaly has $$$5$$$ of options: $$$[e_1=1, t_1=1, p_1=30]$$$, $$$[e_2=2, t_2=3, p_2=50]$$$, $$$[e_3=2, t_3=3, p_3=100]$$$, $$$[e_4=1, t_4=1, p_4=80]$$$, $$$[e_5=3, t_5=3, p_5=100]$$$. Then, if Vitaly prepares in the following way, he will be able to complete everything in time:   Vitaly chooses the $$$4$$$-th option. Then in $$$1$$$ hour, he will complete the $$$1$$$-st task at $$$80$$$ percent. He still has $$$4$$$ hours left before the deadline for the $$$1$$$-st task.  Vitaly chooses the $$$3$$$-rd option. Then in $$$3$$$ hours, he will complete the $$$2$$$-nd task in its entirety. He has another $$$1$$$ hour left before the deadline for the $$$1$$$-st task and $$$4$$$ hours left before the deadline for the $$$3$$$-rd task.  Vitaly chooses the $$$1$$$-st option. Then after $$$1$$$ hour, he will complete the $$$1$$$-st task for $$$110$$$ percent, which means that he will complete the $$$1$$$-st task just in time for the deadline.  Vitaly chooses the $$$5$$$-th option. He will complete the $$$3$$$-rd task for $$$2$$$ hours, and after another $$$1$$$ hour, Vitaly will complete the $$$3$$$-rd task in its entirety. Thus, Vitaly has managed to complete the course completely and on time, using the $$$4$$$ options.Help Vitaly — print the options for Vitaly to complete the tasks in the correct order. Please note: each option can be used not more than once. If there are several possible answers, it is allowed to output any of them.",
    "prob_desc_output_spec": "For each test case, print on the first line the number $$$k$$$, meaning that for $$$k$$$ of options, Vitaly will be able to complete each task by $$$100$$$ percent or more on time. The options should not be repeated. Or print -1 if Vitaly is unable to complete all tasks in time. If there is an answer, on the next line print $$$k$$$ of different integers from $$$1$$$ to $$$m$$$ — the numbers of the options in the order you want. If there is more than one answer, it is allowed to print any of them.",
    "prob_desc_input_spec": "The first line of input data contains an integer $$$T$$$ ($$$1 \\le T \\le 10^4$$$) —the number of input test cases in the test. The descriptions of the input test case follow. The first line of each test case description contains two integers $$$n$$$ and $$$m$$$ ($$$1 \\le n,m \\le 10^5$$$) —the number of jobs and the number of training options, respectively. The next line contains $$$n$$$ numbers $$$a_1, a_2, \\dots, a_n$$$ ($$$1 \\le a_i \\le 10^9$$$) — the time before the deadline of job $$$i$$$. The array values — are non-decreasing, that is $$$a_1 \\le a_2 \\le \\dots \\le a_n$$$. The following $$$m$$$ lines contain triples of numbers $$$e_i, t_i, p_i$$$ ($$$1 \\le e_i \\le n$$$, $$$1 \\le t_i \\le 10^9$$$, $$$1 \\le p_i \\le 100$$$) — if Vitaly chooses this option, then after $$$t_i$$$ hours he will increase the progress of the task $$$e_i$$$ by $$$p_i$$$ percent. The options are numbered from $$$1$$$ to $$$m$$$ in order in the input data. It is guaranteed that the sum of $$$n+m$$$ on all test cases does not exceed $$$2 \\cdot 10^5$$$.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3-64",
    "lang_cluster": "Python",
    "difficulty": 2200,
    "file_name": "train_104.jsonl",
    "code_uid": "a4e59332894f91bac7cea6c77b1c91a1",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"5\\n\\n3 5\\n\\n5 7 8\\n\\n1 1 30\\n\\n2 3 50\\n\\n2 3 100\\n\\n1 1 80\\n\\n3 3 100\\n\\n1 5\\n\\n51\\n\\n1 36 91\\n\\n1 8 40\\n\\n1 42 83\\n\\n1 3 45\\n\\n1 13 40\\n\\n2 9\\n\\n9 20\\n\\n2 8 64\\n\\n2 7 64\\n\\n1 20 56\\n\\n2 8 76\\n\\n2 20 48\\n\\n1 2 89\\n\\n1 3 38\\n\\n2 18 66\\n\\n1 7 51\\n\\n3 2\\n\\n7 18 33\\n\\n1 5 80\\n\\n3 4 37\\n\\n2 5\\n\\n569452312 703565975\\n\\n1 928391659 66\\n\\n1 915310 82\\n\\n2 87017081 92\\n\\n1 415310 54\\n\\n2 567745964 82\", \"3\\n\\n3 9\\n\\n20 31 40\\n\\n1 9 64\\n\\n3 17 100\\n\\n3 9 59\\n\\n3 18 57\\n\\n3 20 49\\n\\n2 20 82\\n\\n2 14 95\\n\\n1 8 75\\n\\n2 16 67\\n\\n2 6\\n\\n20 36\\n\\n2 2 66\\n\\n2 20 93\\n\\n1 3 46\\n\\n1 10 64\\n\\n2 8 49\\n\\n2 18 40\\n\\n1 1\\n\\n1000000000\\n\\n1 1000000000 100\"]",
    "exec_outcome": "PASSED",
    "source_code": "import os\r\nimport sys\r\nfrom io import BytesIO, IOBase\r\n\r\n_str = str\r\nstr = lambda x=b\"\": x if type(x) is bytes else _str(x).encode()\r\n\r\nBUFSIZE = 8192\r\n\r\n\r\nclass FastIO(IOBase):\r\n    newlines = 0\r\n\r\n    def __init__(self, file):\r\n        self._file = file\r\n        self._fd = file.fileno()\r\n        self.buffer = BytesIO()\r\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\r\n        self.write = self.buffer.write if self.writable else None\r\n\r\n    def read(self):\r\n        while True:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            if not b:\r\n                break\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines = 0\r\n        return self.buffer.read()\r\n\r\n    def readline(self):\r\n        while self.newlines == 0:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            self.newlines = b.count(b\"\\n\") + (not b)\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines -= 1\r\n        return self.buffer.readline()\r\n\r\n    def flush(self):\r\n        if self.writable:\r\n            os.write(self._fd, self.buffer.getvalue())\r\n            self.buffer.truncate(0), self.buffer.seek(0)\r\n\r\n\r\nclass IOWrapper(IOBase):\r\n    def __init__(self, file):\r\n        self.buffer = FastIO(file)\r\n        self.flush = self.buffer.flush\r\n        self.writable = self.buffer.writable\r\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\r\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\r\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\r\n\r\n\r\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\r\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\r\n\r\n\r\ndef process(A, M):\r\n    n = len(A)\r\n    m = len(M)\r\n    d1 = [[] for i in range(n+1)]\r\n    for i in range(m):\r\n        e, t, p = M[i]\r\n        d1[e].append([t, p, i+1])\r\n    for e in range(1, n+1):\r\n        d1[e].sort()\r\n    answer = []\r\n    curr = 0\r\n    for e in range(1, n+1):\r\n        d = [[float('inf'), []] for i in range(101)]\r\n        d[0][0] = 0\r\n        not_null = [0]\r\n        for t, p, i2 in d1[e]:\r\n            if d[100][0] > t:\r\n                new_not_null = []\r\n                for p2 in not_null:\r\n                    new_not_null.append(p2)\r\n                    p1 = min(p+p2, 100)\r\n                    if d[p1][0] > d[p2][0]+t:\r\n                        if d[p1][0]==float('inf'):\r\n                            new_not_null.append(p1)\r\n                        d[p1][0] = d[p2][0]+t\r\n                        d[p1][1] = [x for x in d[p2][1]]\r\n                        d[p1][1].append(i2)\r\n                not_null = sorted(new_not_null, reverse=True)\r\n        if curr+d[100][0] <= A[e-1]:\r\n            s = 100\r\n            for x in d[100][1]:\r\n                answer.append(x)\r\n            curr+=d[100][0]\r\n        else:\r\n            sys.stdout.write('-1\\r\\n')\r\n            return\r\n    sys.stdout.write(f'{len(answer)}\\r\\n')\r\n    answer = ' '.join(map(_str, answer))\r\n    sys.stdout.write(f'{answer}\\r\\n')\r\n    return \r\n            \r\nT = int(input())\r\nfor i in range(T):\r\n    n, m = [int(x) for x in input().split()]\r\n    A = [int(x) for x in input().split()]\r\n    M = []\r\n    for j in range(m):\r\n        e, t, p = [int(x) for x in input().split()]\r\n        M.append([e, t, p])\r\n    process(A, M)",
    "prob_desc_created_at": "1646750100",
    "tags": [
        "dp",
        "greedy",
        "implementation"
    ],
    "hidden_unit_tests": ""
}
{
    "prob_desc_time_limit": "3 seconds",
    "prob_desc_sample_outputs": "[\"Yes\\n2 3 1\", \"No\", \"Yes\\n1\"]",
    "src_uid": "f7a34711e8a4faa9822d42ef54a0bfc1",
    "prob_desc_notes": "NoteIn the first sample test you can, for example, place the second bridge between points 3 and 8, place the third bridge between points 7 and 10 and place the first bridge between points 10 and 14.In the second sample test the first bridge is too short and the second bridge is too long, so the solution doesn't exist.",
    "prob_desc_description": "Andrewid the Android is a galaxy-famous detective. He is now chasing a criminal hiding on the planet Oxa-5, the planet almost fully covered with water.The only dry land there is an archipelago of n narrow islands located in a row. For more comfort let's represent them as non-intersecting segments on a straight line: island i has coordinates [li, ri], besides, ri &lt; li + 1 for 1 ≤ i ≤ n - 1.To reach the goal, Andrewid needs to place a bridge between each pair of adjacent islands. A bridge of length a can be placed between the i-th and the (i + 1)-th islads, if there are such coordinates of x and y, that li ≤ x ≤ ri, li + 1 ≤ y ≤ ri + 1 and y - x = a. The detective was supplied with m bridges, each bridge can be used at most once. Help him determine whether the bridges he got are enough to connect each pair of adjacent islands.",
    "prob_desc_output_spec": "If it is impossible to place a bridge between each pair of adjacent islands in the required manner, print on a single line \"No\" (without the quotes), otherwise print in the first line \"Yes\" (without the quotes), and in the second line print n - 1 numbers b1, b2, ..., bn - 1, which mean that between islands i and i + 1 there must be used a bridge number bi.  If there are multiple correct answers, print any of them. Note that in this problem it is necessary to print \"Yes\" and \"No\" in correct case.",
    "prob_desc_input_spec": "The first line contains integers n (2 ≤ n ≤ 2·105) and m (1 ≤ m ≤ 2·105) — the number of islands and bridges. Next n lines each contain two integers li and ri (1 ≤ li ≤ ri ≤ 1018) — the coordinates of the island endpoints. The last line contains m integer numbers a1, a2, ..., am (1 ≤ ai ≤ 1018) — the lengths of the bridges that Andrewid got.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "Python 3",
    "lang_cluster": "Python",
    "difficulty": 2000,
    "file_name": "train_063.jsonl",
    "code_uid": "7e048101b6db99d096243c4d6c851c9e",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"4 4\\n1 4\\n7 8\\n9 10\\n12 14\\n4 5 3 8\", \"2 2\\n11 14\\n17 18\\n2 9\", \"2 1\\n1 1\\n1000000000000000000 1000000000000000000\\n999999999999999999\"]",
    "exec_outcome": "PASSED",
    "source_code": "#!/usr/bin/env python\n# 556D_fug.py - Codeforces.com 556D Fug quiz\n#\n# Copyright (C) 2015 Sergey\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#       http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"\nInput\n\nThe first line contains integers n and m - the number of islands and bridges.\n\nNext n lines each contain two integers li and ri - the coordinates of the\nisland endpoints.\n\nThe last line contains m integer numbers a1..am - the lengths of the bridges\nthat Andrewid got.\nOutput\n\nIf it is impossible to place a bridge between each pair of adjacent islands\nin the required manner, print on a single line \"No\" (without the quotes)\n, otherwise print in the first line \"Yes\" (without the quotes), and in the\nsecond line print n-1 numbers b1, bn-1, which mean that between islands\ni and i+1 there must be used a bridge number bi.\n\nIf there are multiple correct answers, print any of them. Note that in this\nproblem it is necessary to print \"Yes\" and \"No\" in correct case\n\"\"\"\n\n# Standard modules\nimport unittest\nimport sys\nimport re\n\n# Additional modules\nimport bisect\n\n###############################################################################\n# Fastlist Class\n###############################################################################\n\n\nclass Fastlist(object):\n    \"\"\" Fastlist representation \"\"\"\n\n    def __init__(self, l=[], load=5000, sorted=0):\n        self._load = load\n        self._sorted = sorted\n        self._lists = []\n        self._starts = []\n        self._mins = []\n        self._insert_list()\n        self._irev = 0\n        self.extend(l)\n\n    def _index_location(self, index):\n        if len(self._lists[0]) == 0:\n            raise IndexError(\"List index out of range\")\n        if index == 0:\n            return (0, 0)\n        if index == -1:\n            return (len(self._lists) - 1, len(self._lists[-1]) - 1)\n        if self._sorted:\n            raise RuntimeError(\"No index access to the sorted list, exc 0, -1\")\n        length = len(self)\n        if index < 0:\n            index = length + index\n        if index >= length:\n            raise IndexError(\"List index out of range\")\n        il = bisect.bisect_right(self._starts, index) - 1\n        return (il, index - self._starts[il])\n\n    def _insert_list(self, il=None):\n        if il is None:\n            il = len(self._lists)\n        self._lists.insert(il, [])\n        if self._sorted:\n            if il == 0:\n                self._mins.insert(il, None)\n            else:\n                self._mins.insert(il, self._lists[il-1][-1])\n        else:\n            if il == 0:\n                self._starts.insert(il, 0)\n            else:\n                start = self._starts[il-1] + len(self._lists[il-1])\n                self._starts.insert(il, start)\n\n    def _del_list(self, il):\n        del self._lists[il]\n        if self._sorted:\n            del self._mins[il]\n        else:\n            del self._starts[il]\n\n    def _rebalance(self, il):\n        illen = len(self._lists[il])\n        if illen >= self._load * 2:\n            self._insert_list(il)\n            self._even_lists(il)\n        if illen <= self._load * 0.2:\n            if il != 0:\n                self._even_lists(il-1)\n            elif len(self._lists) > 1:\n                self._even_lists(il)\n\n    def _even_lists(self, il):\n        tot = len(self._lists[il]) + len(self._lists[il+1])\n        if tot < self._load * 1:\n            self._lists[il] += self._lists[il+1]\n            self._del_list(il+1)\n            if self._sorted:\n                self._mins[il] = self._lists[il][0]\n        else:\n            half = tot//2\n            ltot = self._lists[il] + self._lists[il+1]\n            self._lists[il] = ltot[:half]\n            self._lists[il+1] = ltot[half:]\n            if self._sorted:\n                self._mins[il] = self._lists[il][0]\n                self._mins[il+1] = self._lists[il+1][0]\n            else:\n                self._starts[il+1] = self._starts[il] + len(self._lists[il])\n\n    def _obj_location(self, obj, l=0):\n        if not self._sorted:\n            raise RuntimeError(\"No by value access to an unserted list\")\n        il = 0\n        if len(self._mins) > 1 and obj > self._mins[0]:\n            if l:\n                il = bisect.bisect_left(self._mins, obj) - 1\n            else:\n                il = bisect.bisect_right(self._mins, obj) - 1\n        if l:\n            ii = bisect.bisect_left(self._lists[il], obj)\n        else:\n            ii = bisect.bisect_right(self._lists[il], obj)\n        if ii == len(self._lists[il]) and il != len(self._lists) - 1:\n            ii = 0\n            il += 1\n        return (il, ii)\n\n    def insert(self, index, obj):\n        (il, ii) = self._index_location(index)\n        self._lists[il].insert(ii, obj)\n        for j in range(il + 1, len(self._starts)):\n            self._starts[j] += 1\n        self._rebalance(il)\n\n    def append(self, obj):\n        if len(self._lists[-1]) >= self._load:\n            self._insert_list()\n        self._lists[-1].append(obj)\n        if self._sorted and self._mins[0] is None:\n            self._mins[0] = self._lists[0][0]\n\n    def extend(self, iter):\n        for n in iter:\n            self.append(n)\n\n    def pop(self, index=None):\n        if index is None:\n            index = -1\n        (il, ii) = self._index_location(index)\n        item = self._lists[il].pop(ii)\n        if self._sorted:\n            if ii == 0 and len(self._lists[il]) > 0:\n                self._mins[il] = self._lists[il][0]\n        else:\n            for j in range(il + 1, len(self._starts)):\n                self._starts[j] -= 1\n        self._rebalance(il)\n        return item\n\n    def clear(self):\n        self._lists.clear()\n        self._starts.clear()\n        self._mins.clear()\n        self._insert_list()\n\n    def as_list(self):\n        return sum(self._lists, [])\n\n    def insort(self, obj, l=0):\n        (il, ii) = self._obj_location(obj, l)\n        self._lists[il].insert(ii, obj)\n        if ii == 0:\n            self._mins[il] = obj\n        self._rebalance(il)\n\n    def add(self, obj):\n        if self._sorted:\n            self.insort(obj)\n        else:\n            self.append(obj)\n\n    def insort_left(self, obj):\n        self.insort(obj, l=1)\n\n    def lower_bound(self, obj):\n        (self._il, self._ii) = self._obj_location(obj, l=1)\n        return self\n\n    def upper_bound(self, obj):\n        (self._il, self._ii) = self._obj_location(obj)\n        return self\n\n    def __str__(self):\n        return str(self.as_list())\n\n    def __setitem__(self, index, obj):\n        if isinstance(index, int):\n            (il, ii) = self._index_location(index)\n            self._lists[il][ii] = obj\n        elif isinstance(index, slice):\n            raise RuntimeError(\"Slice assignment is not supported\")\n\n    def __getitem__(self, index):\n        if isinstance(index, int):\n            (il, ii) = self._index_location(index)\n            return self._lists[il][ii]\n        elif isinstance(index, slice):\n            rg = index.indices(len(self))\n            if rg[0] == 0 and rg[1] == len(self) and rg[2] == 1:\n                return self.as_list()\n            return [self.__getitem__(index) for index in range(*rg)]\n\n    def __iadd__(self, obj):\n        if self._sorted:\n            [self.insort(n) for n in obj]\n        else:\n            [self.append(n) for n in obj]\n        return self\n\n    def __delitem__(self, index):\n        if isinstance(index, int):\n            self.pop(index)\n        elif isinstance(index, slice):\n            rg = index.indices(len(self))\n            [self.__delitem__(rg[0]) for i in range(*rg)]\n\n    def __len__(self):\n        if self._sorted:\n            return sum([len(l) for l in self._lists])\n        return self._starts[-1] + len(self._lists[-1])\n\n    def __contains__(self, obj):\n        if self._sorted:\n            it = self.lower_bound(obj)\n            return not it.iter_end() and obj == it.iter_getitem()\n        else:\n            for n in self:\n                if obj == n:\n                    return True\n            return False\n\n    def __bool__(self):\n        return len(self._lists[0]) != 0\n\n    def __iter__(self):\n        self._il = self._ii = self._irev = 0\n        return self\n\n    def __reversed__(self):\n        self._il = len(self._lists) - 1\n        self._ii = len(self._lists[self._il]) - 1\n        self._irev = 1\n        return self\n\n    def __next__(self):\n        if self._il in (-1, len(self._lists)) or len(self._lists[0]) == 0:\n            raise StopIteration(\"Iteration stopped\")\n        item = self._lists[self._il][self._ii]\n        if not self._irev:\n            self._ii += 1\n            if self._ii == len(self._lists[self._il]):\n                self._il += 1\n                self._ii = 0\n        else:\n            self._ii -= 1\n            if self._ii == 0:\n                self._il -= 1\n                self._ii = len(self._lists[self._il])\n        return item\n\n    def iter_getitem(self):\n        return self._lists[self._il][self._ii]\n\n    def iter_end(self):\n        return (self._il == len(self._lists) - 1 and\n                self._ii == len(self._lists[self._il]))\n\n    def iter_del(self):\n        self.iter_pop()\n\n    def iter_pop(self):\n        item = self._lists[self._il].pop(self._ii)\n        if self._sorted:\n            if self._ii == 0 and len(self._lists[self._il]) > 0:\n                self._mins[self._il] = self._lists[self._il][0]\n        else:\n            for j in range(self._il + 1, len(self._starts)):\n                self._starts[j] -= 1\n        self._rebalance(self._il)\n        return item\n\n\n###############################################################################\n# Fug Class\n###############################################################################\n\n\nclass Fug:\n    \"\"\" Fug representation \"\"\"\n\n    def __init__(self, args):\n        \"\"\" Default constructor \"\"\"\n        self.gsrt = args[0]\n        self.asrt = args[1]\n        self.gn = args[2]\n        self.result = [0]*self.gn\n        self.a = Fastlist(self.asrt, load=500, sorted=1)\n\n    def calculate(self):\n        \"\"\" Main calcualtion function of the class \"\"\"\n\n        for i in range(self.gn):\n            g = self.gsrt[i]\n            it = self.a.lower_bound((g[1], 0))\n            if not it.iter_end():\n                alb = it.iter_getitem()\n                if alb[0] > g[0]:\n                    return \"No\"\n                self.result[g[2]] = alb[1]+1\n                it.iter_del()\n            else:\n                return \"No\"\n\n        answer = \"Yes\\n\" + \" \".join(str(n) for n in self.result)\n\n        return answer\n\n\n###############################################################################\n# Executable code\n###############################################################################\n\n\ndef get_inputs(test_inputs=None):\n\n    it = iter(test_inputs.split(\"\\n\")) if test_inputs else None\n\n    def uinput():\n        \"\"\" Unit-testable input function wrapper \"\"\"\n        if it:\n            return next(it)\n        else:\n            return sys.stdin.readline()\n\n    # Getting string inputs. Place all uinput() calls here\n    num = [int(s) for s in uinput().split()]\n    gaps = []\n    prevli = [int(s) for s in uinput().split()]\n    for i in range(num[0] - 1):\n        li = [int(s) for s in uinput().split()]\n        min = li[0] - prevli[1]\n        max = li[1] - prevli[0]\n        gaps.append((max, min, i))\n        prevli = li\n    alist = [(int(s), i) for i, s in enumerate(uinput().split())]\n\n    # Decoding inputs into a list\n\n    inputs = [sorted(gaps), sorted(alist), num[0]-1]\n\n    return inputs\n\n\ndef calculate(test_inputs=None):\n    \"\"\" Base class calculate method wrapper \"\"\"\n    return Fug(get_inputs(test_inputs)).calculate()\n\n\n###############################################################################\n# Unit Tests\n###############################################################################\n\n\nclass unitTests(unittest.TestCase):\n\n    def test_sample_tests(self):\n        \"\"\" Quiz sample tests. Add \\n to separate lines \"\"\"\n\n        # Sample test 1\n        test = \"4 4\\n1 4\\n7 8\\n9 10\\n12 14\\n4 5 3 8\"\n        self.assertEqual(calculate(test), \"Yes\\n2 3 1\")\n        self.assertEqual(\n            get_inputs(test),\n            [[(3, 1, 1), (5, 2, 2), (7, 3, 0)],\n             [(3, 2), (4, 0), (5, 1), (8, 3)], 3])\n\n        # My tests\n        test = \"5 5\\n1 1\\n2 7\\n8 8\\n10 10\\n16 16\\n1 1 5 6 2\"\n        self.assertEqual(calculate(test), \"Yes\\n1 2 5 4\")\n\n        # Other tests\n        test = \"2 2\\n11 14\\n17 18\\n2 9\"\n        self.assertEqual(calculate(test), \"No\")\n\n        # Other tests\n        test = (\n            \"2 1\\n1 1\\n1000000000000000000 1000000000000000000\" +\n            \"\\n999999999999999999\")\n        self.assertEqual(calculate(test), \"Yes\\n1\")\n\n        test = (\"5 9\\n1 2\\n3 3\\n5 7\\n11 13\\n14 20\\n2 3 4 10 6 2 6 9 5\")\n        self.assertEqual(calculate(test), \"Yes\\n1 6 3 2\")\n\n        size = 200000\n        test = str(size) + \" \" + str(size) + \"\\n\"\n        x = size*1000\n        for i in range(size):\n            test += str(x) + \" \" + str(x + i + 1) + \"\\n\"\n            x += 2 * (i + 1)\n        for i in reversed(range(size)):\n            test += str(i) + \" \"\n        self.assertEqual(calculate(test)[0], \"Y\")\n\n    def test_Fug_class__basic_functions(self):\n        \"\"\" Fug class basic functions testing \"\"\"\n\n        # Constructor test\n        d = Fug([[(1, 3, 1), (2, 5, 2), (3, 7, 0)],\n                 [(3, 2), (4, 0), (5, 1), (8, 3)], 3])\n\n        # Sort bridges\n        self.assertEqual(d.asrt[0], (3, 2))\n\n        # Sort Gaps\n        self.assertEqual(d.gsrt[0], (1, 3, 1))\n\nif __name__ == \"__main__\":\n\n    # Avoiding recursion limitaions\n    sys.setrecursionlimit(100000)\n\n    if sys.argv[-1] == \"-ut\":\n        unittest.main(argv=[\" \"])\n\n    # Print the result string\n    sys.stdout.write(calculate())\n",
    "prob_desc_created_at": "1435414200",
    "tags": [
        "data structures",
        "binary search",
        "greedy"
    ],
    "hidden_unit_tests": ""
}
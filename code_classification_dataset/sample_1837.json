{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"1 1\", \"-1\", \"2 1 3 \\n1 2\"]",
    "src_uid": "dfe0f5da0cb90706f33365009d9baf5b",
    "prob_desc_notes": "NoteThe first sample contains a pair of children who look at each other. After one move, they can finish the process.In the second sample, children can't make any move. As a result, they can't end in $$$k&gt;0$$$ moves.The third configuration is described in the statement.",
    "prob_desc_description": "There are $$$n$$$ children, who study at the school №41. It is well-known that they are good mathematicians. Once at a break, they arranged a challenge for themselves. All children arranged in a row and turned heads either to the left or to the right.Children can do the following: in one second several pairs of neighboring children who are looking at each other can simultaneously turn the head in the opposite direction. For instance, the one who was looking at the right neighbor turns left and vice versa for the second child. Moreover, every second at least one pair of neighboring children performs such action. They are going to finish when there is no pair of neighboring children who are looking at each other. You are given the number $$$n$$$, the initial arrangement of children and the number $$$k$$$. You have to find a way for the children to act if they want to finish the process in exactly $$$k$$$ seconds. More formally, for each of the $$$k$$$ moves, you need to output the numbers of the children who turn left during this move.For instance, for the configuration shown below and $$$k = 2$$$ children can do the following steps:    At the beginning, two pairs make move: $$$(1, 2)$$$ and $$$(3, 4)$$$. After that, we receive the following configuration:    At the second move pair $$$(2, 3)$$$ makes the move. The final configuration is reached. Good job.   It is guaranteed that if the solution exists, it takes not more than $$$n^2$$$ \"headturns\".",
    "prob_desc_output_spec": "If there is no solution, print a single line with number $$$-1$$$. Otherwise, output $$$k$$$ lines. Each line has to start with a number $$$n_i$$$ ($$$1\\le n_i \\le \\frac{n}{2}$$$)  — the number of pairs of children, who turn at this move. After that print $$$n_i$$$ distinct integers  — the numbers of the children who will turn left during this move.  After performing all \"headturns\", there can't be a pair of two neighboring children looking at each other. If there are many solutions, print any of them.",
    "prob_desc_input_spec": "The first line of input contains two integers $$$n$$$ and $$$k$$$ ($$$2 \\le n \\le 3000$$$, $$$1 \\le k \\le 3000000$$$)  — the number of children and required number of moves. The next line contains a string of length $$$n$$$ and consists only of characters L and R, where L means that the child looks to the left and R means that the child looks to the right. ",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 2",
    "lang_cluster": "Python",
    "difficulty": 2100,
    "file_name": "train_013.jsonl",
    "code_uid": "ec5495f6659e77c300ed83bb627d412a",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"2 1\\nRL\", \"2 1\\nLR\", \"4 2\\nRLRL\"]",
    "exec_outcome": "PASSED",
    "source_code": "from __future__ import division, print_function\ndef main():\n    n, k = map(int, input().split())\n    l1 = list(input())\n    stages = []\n    while 1:\n        l2 = []\n        temp = []\n        i = 0\n        while i < n - 1:\n            if l1[i] == \"R\" and l1[i+1] == \"L\":\n                temp.append(i + 1)\n                l2.append(\"L\")\n                l2.append(\"R\")\n                i += 2\n            else:\n                l2.append(l1[i])\n                i += 1\n        while i < n:\n            l2.append(l1[i])\n            i += 1\n        l1 = l2\n        if len(temp) == 0:\n            break\n        stages.append(temp)\n    total_moves = 0\n    min_moves = len(stages)\n    #print(*stages, sep = \"\\n\")\n    for x in stages:\n        total_moves += len(x)\n    if total_moves < k or k < min_moves:\n        print(-1)\n    else:\n        x = len(stages)\n        if x == k:\n            for i in range(x):\n                print(len(stages[i]), end = \" \")\n                print(*stages[i])\n        else:\n            flag = 0\n            for i in range(len(stages)):\n                for j in range(len(stages[i])):\n                    print(1, stages[i][j])\n                    k -= 1\n                    rows_left = len(stages) - i\n                    if j == len(stages[i]) - 1:\n                        rows_left -= 1\n                    if k  == rows_left:\n                        \n                        flag = 1\n                        row_number = i\n                        column_number = j + 1\n                        break\n                if flag == 1:\n                    break\n            if flag == 1:\n                if column_number != len(stages[row_number]):\n                    print(len(stages[row_number][column_number:]), end = \" \")\n                    print(*stages[row_number][column_number:])\n                row_number += 1\n                for i in range(row_number, len(stages)):\n                    print(len(stages[i]), end =\" \")\n                    print(*stages[i])\n\n            \n######## Python 2 and 3 footer by Pajenegod and c1729\n\n# Note because cf runs old PyPy3 version which doesn't have the sped up\n# unicode strings, PyPy3 strings will many times be slower than pypy2.\n# There is a way to get around this by using binary strings in PyPy3\n# but its syntax is different which makes it kind of a mess to use.\n\n# So on cf, use PyPy2 for best string performance.\n\npy2 = round(0.5)\nif py2:\n    from future_builtins import ascii, filter, hex, map, oct, zip\n    range = xrange\n\nimport os, sys\nfrom io import IOBase, BytesIO\n\nBUFSIZE = 8192\nclass FastIO(BytesIO):\n    newlines = 0\n\n    def __init__(self, file):\n        self._file = file\n        self._fd = file.fileno()\n        self.writable = \"x\" in file.mode or \"w\" in file.mode\n        self.write = super(FastIO, self).write if self.writable else None\n\n    def _fill(self):\n        s = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n        self.seek((self.tell(), self.seek(0,2), super(FastIO, self).write(s))[0])\n        return s\n\n    def read(self):\n        while self._fill(): pass\n        return super(FastIO,self).read()\n\n    def readline(self):\n        while self.newlines == 0:\n            s = self._fill(); self.newlines = s.count(b\"\\n\") + (not s)\n        self.newlines -= 1\n        return super(FastIO, self).readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.getvalue())\n            self.truncate(0), self.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        if py2:\n            self.write = self.buffer.write\n            self.read = self.buffer.read\n            self.readline = self.buffer.readline\n        else:\n            self.write = lambda s:self.buffer.write(s.encode('ascii'))\n            self.read = lambda:self.buffer.read().decode('ascii')\n            self.readline = lambda:self.buffer.readline().decode('ascii')\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip('\\r\\n')\n\n# Cout implemented in Python\nimport sys\nclass ostream:\n    def __lshift__(self,a):\n        sys.stdout.write(str(a))\n        return self\ncout = ostream()\nendl = '\\n'\n\n# Read all remaining integers in stdin, type is given by optional argument, this is fast\ndef readnumbers(zero = 0):\n    conv = ord if py2 else lambda x:x\n    A = []; numb = zero; sign = 1; i = 0; s = sys.stdin.buffer.read()\n    try:\n        while True:\n            if s[i] >= b'0' [0]:\n                numb = 10 * numb + conv(s[i]) - 48\n            elif s[i] == b'-' [0]: sign = -1\n            elif s[i] != b'\\r' [0]:\n                A.append(sign*numb)\n                numb = zero; sign = 1\n            i += 1\n    except:pass\n    if s and s[-1] >= b'0' [0]:\n        A.append(sign*numb)\n    return A\n\nif __name__== \"__main__\":\n  main()",
    "prob_desc_created_at": "1586356500",
    "tags": [
        "greedy",
        "graphs",
        "constructive algorithms",
        "games",
        "implementation",
        "sortings",
        "brute force"
    ],
    "hidden_unit_tests": ""
}
{
    "prob_desc_time_limit": "3 seconds",
    "prob_desc_sample_outputs": "[\"9\", \"240\", \"24\"]",
    "src_uid": "ab65207f0b334276f58e0d2e79b0b44d",
    "prob_desc_notes": "NoteIn the first test, the following ways to choose the colors are suitable:  $$$[1, 1, 1]$$$;  $$$[2, 2, 2]$$$;  $$$[3, 3, 3]$$$;  $$$[1, 2, 3]$$$;  $$$[1, 3, 2]$$$;  $$$[2, 1, 3]$$$;  $$$[2, 3, 1]$$$;  $$$[3, 1, 2]$$$;  $$$[3, 2, 1]$$$. ",
    "prob_desc_description": "You are given $$$n$$$ points on the plane, the coordinates of the $$$i$$$-th point are $$$(x_i, y_i)$$$. No two points have the same coordinates.The distance between points $$$i$$$ and $$$j$$$ is defined as $$$d(i,j) = |x_i - x_j| + |y_i - y_j|$$$.For each point, you have to choose a color, represented by an integer from $$$1$$$ to $$$n$$$. For every ordered triple of different points $$$(a,b,c)$$$, the following constraints should be met:  if $$$a$$$, $$$b$$$ and $$$c$$$ have the same color, then $$$d(a,b) = d(a,c) = d(b,c)$$$;  if $$$a$$$ and $$$b$$$ have the same color, and the color of $$$c$$$ is different from the color of $$$a$$$, then $$$d(a,b) &lt; d(a,c)$$$ and $$$d(a,b) &lt; d(b,c)$$$. Calculate the number of different ways to choose the colors that meet these constraints.",
    "prob_desc_output_spec": "Print one integer — the number of ways to choose the colors for the points. Since it can be large, print it modulo $$$998244353$$$.",
    "prob_desc_input_spec": "The first line contains one integer $$$n$$$ ($$$2 \\le n \\le 100$$$) — the number of points. Then $$$n$$$ lines follow. The $$$i$$$-th of them contains two integers $$$x_i$$$ and $$$y_i$$$ ($$$0 \\le x_i, y_i \\le 10^8$$$). No two points have the same coordinates (i. e. if $$$i \\ne j$$$, then either $$$x_i \\ne x_j$$$ or $$$y_i \\ne y_j$$$).",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3-64",
    "lang_cluster": "Python",
    "difficulty": 2400,
    "file_name": "train_083.jsonl",
    "code_uid": "b71657011183ffa8b5981a5ce418f275",
    "prob_desc_memory_limit": "512 megabytes",
    "prob_desc_sample_inputs": "[\"3\\n1 0\\n3 0\\n2 1\", \"5\\n1 2\\n2 4\\n3 4\\n4 4\\n1 3\", \"4\\n1 0\\n3 0\\n2 1\\n2 0\"]",
    "exec_outcome": "PASSED",
    "source_code": "import collections\nimport functools\nimport heapq\nimport random\nimport bisect\nimport itertools\nimport math\nimport os\nfrom io import BytesIO, IOBase\nfrom sys import setrecursionlimit, stderr, stdin, stdout\nfrom collections import defaultdict\n\nsetrecursionlimit(20000)\n\n\ndef get_ints():\n    return list(map(int, input().split()))\n\n\ndef get_int():\n    return int(input())\n\n\ndef get_string():\n    return \"\".join(list(input().rstrip()))\n\n\ndef get_chars():\n    return list(input().rstrip())\n\n\ndef eprint(*args):\n    print(*args, sep=\", \", file=stderr)\n\n\ndef dfist(a, b):\n    return abs(a[0] - b[0]) + abs(a[1] - b[1])\n\n\ndef rel1(a, b, c):\n    return dfist(a, b) == dfist(a, c) == dfist(b, c)\n\n\ndef rel2(a, b, c):\n    return dfist(a, b) < dfist(a, c) and dfist(a, b) < dfist(b, c)\n\n\ndef falfact(m, n, MOD):\n    if n == 0:\n        return 1\n    return (math.factorial(m) // math.factorial(m - n)) % MOD\n\n\ndef comb(n, k, MOD):\n    return (\n        math.factorial(n) // (math.factorial(k) * math.factorial(n - k))\n    ) % MOD\n\n\nMOD = 998244353  # replace me\nN = 200  # replace me\nfact = [0 for _ in range(N)]\ninvfact = [0 for _ in range(N)]\nfact[0] = 1\nfor i in range(1, N):\n    fact[i] = fact[i - 1] * i % MOD\n\ninvfact[N - 1] = pow(fact[N - 1], MOD - 2, MOD)\n\nfor i in range(N - 2, -1, -1):\n    invfact[i] = invfact[i + 1] * (i + 1) % MOD\n\n\ndef nCk(n, k):\n    if k < 0 or n < k:\n        return 0\n    else:\n        return (fact[n] * invfact[k] % MOD) * invfact[n - k] % MOD\n\n\ndef main():\n    n = get_int()\n    points = []\n    dist = [[0] * n for _ in range(n)]\n    xy = [get_ints() for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            dx = xy[i][0] - xy[j][0]\n            dy = xy[i][1] - xy[j][1]\n            dist[i][j] = dist[j][i] = sum(map(abs, (dx, dy)))\n\n    min_se = [set() for _ in range(n)]\n    hash_ = [random.randrange(1, 1 << 63) for _ in range(n)]\n    min_hash = [0 for _ in range(n)]\n    cnt = [0] * n\n    for i in range(n):\n        min_ = 1 << 30\n        for j in range(n):\n            if i != j and dist[i][j] < min_:\n                min_ = dist[i][j]\n\n        for j in range(n):\n            if dist[i][j] == min_:\n                min_se[i].add(j)\n                min_hash[i] ^= hash_[j]\n                cnt[i] += 1\n\n    cliques = [0] * (5)\n    for i in range(n):\n        if cnt[i] in (1, 2, 3) and i > max(min_se[i]):\n            target = hash_[i] ^ min_hash[i]\n            if all(hash_[x] ^ min_hash[x] == target for x in min_se[i]):\n                cliques[cnt[i] + 1] += 1\n\n    ans = 0\n    two, three, four = cliques[2], cliques[3], cliques[4]\n    for a in range(two + 1):\n        for b in range(three + 1):\n            for c in range(four + 1):\n                x = n - a - 2 * b - 3 * c\n                y = n - (a + b + c)\n                tmp = nCk(n, x) * fact[x] % MOD\n                tmp *= nCk(two, a) * nCk(three, b) * nCk(four, c) % MOD\n                if n - x - y > 0:\n                    tmp *= nCk(n - x, a + b + c) * fact[a + b + c] % MOD\n                ans = (ans + tmp) % MOD\n    print(ans)\n\n\n# region fastio\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._file = file\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nstdin = IOWrapper(stdin)  # type: ignore\nstdout = IOWrapper(stdout)  # type: ignore\ninput = lambda: stdin.readline().rstrip(\"\\r\\n\")\n\n\ndef print(*args, **kwargs):\n    \"\"\"Prints the values to a stream, or to sys.stdout by default.\"\"\"\n    sep, file = kwargs.pop(\"sep\", \" \"), kwargs.pop(\"file\", stdout)\n    at_start = True\n    for x in args:\n        if not at_start:\n            file.write(sep)\n        file.write(str(x))\n        at_start = False\n    file.write(kwargs.pop(\"end\", \"\\n\"))\n    if kwargs.pop(\"flush\", False):\n        file.flush()\n\n\n# endregion\n\nif __name__ == \"__main__\":\n    main()\n",
    "prob_desc_created_at": "1655044500",
    "tags": [
        "brute force",
        "combinatorics",
        "constructive algorithms",
        "dp",
        "geometry",
        "graphs",
        "greedy",
        "implementation",
        "math"
    ],
    "hidden_unit_tests": ""
}
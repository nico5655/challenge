{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"YES\\nYES\\nNO\"]",
    "src_uid": "cc40ec9f5608650dddfe61565e610073",
    "prob_desc_notes": "NoteThe first test case is explained in the statements.In the second test case, the following sequence of operations is suitable:   horizontal xor, $$$i=1$$$;  horizontal xor, $$$i=2$$$;  horizontal xor, $$$i=3$$$; It can be proved that there is no sequence of operations in the third test case so that the matrix $$$a$$$ becomes equal to the matrix $$$b$$$.",
    "prob_desc_description": "You are given two binary square matrices $$$a$$$ and $$$b$$$ of size $$$n \\times n$$$. A matrix is called binary if each of its elements is equal to $$$0$$$ or $$$1$$$. You can do the following operations on the matrix $$$a$$$ arbitrary number of times (0 or more):   vertical xor. You choose the number $$$j$$$ ($$$1 \\le j \\le n$$$) and for all $$$i$$$ ($$$1 \\le i \\le n$$$) do the following: $$$a_{i, j} := a_{i, j} \\oplus 1$$$ ($$$\\oplus$$$ — is the operation xor (exclusive or)).  horizontal xor. You choose the number $$$i$$$ ($$$1 \\le i \\le n$$$) and for all $$$j$$$ ($$$1 \\le j \\le n$$$) do the following: $$$a_{i, j} := a_{i, j} \\oplus 1$$$. Note that the elements of the $$$a$$$ matrix change after each operation.For example, if $$$n=3$$$ and the matrix $$$a$$$ is: $$$$$$ \\begin{pmatrix} 1 &amp; 1 &amp; 0 \\\\ 0 &amp; 0 &amp; 1 \\\\ 1 &amp; 1 &amp; 0 \\end{pmatrix} $$$$$$ Then the following sequence of operations shows an example of transformations:   vertical xor, $$$j=1$$$. $$$$$$ a= \\begin{pmatrix} 0 &amp; 1 &amp; 0 \\\\ 1 &amp; 0 &amp; 1 \\\\ 0 &amp; 1 &amp; 0 \\end{pmatrix} $$$$$$  horizontal xor, $$$i=2$$$. $$$$$$ a= \\begin{pmatrix} 0 &amp; 1 &amp; 0 \\\\ 0 &amp; 1 &amp; 0 \\\\ 0 &amp; 1 &amp; 0 \\end{pmatrix} $$$$$$  vertical xor, $$$j=2$$$. $$$$$$ a= \\begin{pmatrix} 0 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 \\end{pmatrix} $$$$$$ Check if there is a sequence of operations such that the matrix $$$a$$$ becomes equal to the matrix $$$b$$$.",
    "prob_desc_output_spec": "For each test case, output on a separate line:    \"YES\", there is such a sequence of operations that the matrix $$$a$$$ becomes equal to the matrix $$$b$$$;  \"NO\" otherwise.  You can output \"YES\" and \"NO\" in any case (for example, the strings yEs, yes, Yes and YES will be recognized as positive).",
    "prob_desc_input_spec": "The first line contains one integer $$$t$$$ ($$$1 \\leq t \\leq 1000$$$) — the number of test cases. Then $$$t$$$ test cases follow. The first line of each test case contains one integer $$$n$$$ ($$$1 \\leq n \\leq 1000$$$) — the size of the matrices. The following $$$n$$$ lines contain strings of length $$$n$$$, consisting of the characters '0' and '1' — the description of the matrix $$$a$$$. An empty line follows. The following $$$n$$$ lines contain strings of length $$$n$$$, consisting of the characters '0' and '1' — the description of the matrix $$$b$$$. It is guaranteed that the sum of $$$n$$$ over all test cases does not exceed $$$1000$$$.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3-64",
    "lang_cluster": "Python",
    "difficulty": 1900,
    "file_name": "train_086.jsonl",
    "code_uid": "b1bfc6e9a274026d47f8d2c525aff95a",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"3\\n3\\n110\\n001\\n110\\n\\n000\\n000\\n000\\n3\\n101\\n010\\n101\\n\\n010\\n101\\n010\\n2\\n01\\n11\\n\\n10\\n10\"]",
    "exec_outcome": "PASSED",
    "source_code": "import os,sys\r\nfrom random import randint, shuffle\r\nfrom io import BytesIO, IOBase\r\n\r\nfrom collections import defaultdict,deque,Counter\r\nfrom bisect import bisect_left,bisect_right\r\nfrom heapq import heappush,heappop\r\nfrom functools import lru_cache\r\nfrom itertools import accumulate, permutations\r\nimport math\r\n\r\n# Fast IO Region\r\nBUFSIZE = 8192\r\nclass FastIO(IOBase):\r\n    newlines = 0\r\n    def __init__(self, file):\r\n        self._fd = file.fileno()\r\n        self.buffer = BytesIO()\r\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\r\n        self.write = self.buffer.write if self.writable else None\r\n    def read(self):\r\n        while True:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            if not b:\r\n                break\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines = 0\r\n        return self.buffer.read()\r\n    def readline(self):\r\n        while self.newlines == 0:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            self.newlines = b.count(b\"\\n\") + (not b)\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines -= 1\r\n        return self.buffer.readline()\r\n    def flush(self):\r\n        if self.writable:\r\n            os.write(self._fd, self.buffer.getvalue())\r\n            self.buffer.truncate(0), self.buffer.seek(0)\r\nclass IOWrapper(IOBase):\r\n    def __init__(self, file):\r\n        self.buffer = FastIO(file)\r\n        self.flush = self.buffer.flush\r\n        self.writable = self.buffer.writable\r\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\r\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\r\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\r\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\r\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\r\n\r\n# for _ in range(int(input())):\r\n#     n = int(input())\r\n#     a = list(map(int, input().split()))\r\n\r\n# for _ in range(int(input())):\r\n#     n = int(input())\r\n#     while n % 2 == 0:\r\n#         n //= 2\r\n#     if n == 1:\r\n#         print('NO')\r\n#     else:\r\n#         print('YES')\r\n\r\n# for _ in range(int(input())):\r\n#     n = int(input())\r\n#     k = n // 2020\r\n#     res = n % 2020\r\n#     if res <= k:\r\n#         print('YES')\r\n#     else:\r\n#         print('NO')\r\n\r\n# for _ in range(int(input())):\r\n#     a, b, k = list(map(int, input().split()))\r\n#     c = list(map(int, input().split()))\r\n#     d = list(map(int, input().split()))\r\n#     cnt1 = [0] * (a + 1)\r\n#     cnt2 = [0] * (b + 1)\r\n#     for i in range(k):\r\n#         cnt1[c[i]] += 1\r\n#         cnt2[d[i]] += 1\r\n#     ans = k * (k - 1) // 2\r\n#     for i in range(a + 1):\r\n#         ans -= cnt1[i] * (cnt1[i] - 1) // 2\r\n#     for i in range(b + 1):\r\n#         ans -= cnt2[i] * (cnt2[i] - 1) // 2\r\n#     cnt = Counter()\r\n#     for i in range(k):\r\n#         cnt[(c[i], d[i])] += 1\r\n#     for i in cnt:\r\n#         ans += (cnt[i] - 1) * cnt[i] // 2\r\n#     print(ans)\r\n\r\n# mod = 10 ** 9 + 7\r\n# N = 500010\r\n# fac = [1] * N\r\n# for i in range(2, N):\r\n#     fac[i] = fac[i - 1] * i % mod\r\n# invfac = [1] * N\r\n# invfac[N - 1] = pow(fac[N - 1], mod - 2, mod)\r\n# for i in range(N - 1)[::-1]:\r\n#     invfac[i] = invfac[i + 1] * (i + 1) % mod\r\n# def c(i, j):\r\n#     if i < j: return 0\r\n#     return fac[i] * invfac[j] * invfac[i - j] % mod\r\n\r\n# for _ in range(int(input())):\r\n#     n, k = list(map(int, input().split()))\r\n#     a = list(map(int, input().split()))\r\n#     a.sort(reverse=True)\r\n#     x = y = 0\r\n#     for i in range(n):\r\n#         if a[i] == a[k - 1]:\r\n#             if i < k:\r\n#                 x += 1\r\n#             else:\r\n#                 y += 1\r\n#     print(c(x + y, x))\r\n\r\n# for _ in range(int(input())):\r\n#     n, m = list(map(int, input().split()))\r\n#     a = list(map(int, input().split()))\r\n#     b = list(map(int, input().split()))\r\n#     if sum(a) < m:\r\n#         print(-1)\r\n#         continue\r\n#     c, d = [], []\r\n#     for i in range(n):\r\n#         if b[i] == 1:\r\n#             c.append(a[i])\r\n#         else:\r\n#             d.append(a[i])\r\n#     c.sort(reverse=True)\r\n#     d.sort(reverse=True)\r\n#     if not c:\r\n#         t = 0\r\n#         ans = 0\r\n#         for i in range(n):\r\n#             t += d[i]\r\n#             ans += 2\r\n#             if t >= m:\r\n#                 print(ans)\r\n#                 break\r\n#     elif not d:\r\n#         t = 0\r\n#         ans = 0\r\n#         for i in range(n):\r\n#             t += c[i]\r\n#             ans += 1\r\n#             if t >= m:\r\n#                 print(ans)\r\n#                 break\r\n#     else:\r\n#         j = len(d) - 1\r\n#         ans = len(d) * 2\r\n#         t = sum(d)\r\n#         while j >= 0 and t - d[j] >= m:\r\n#             t -= d[j]\r\n#             ans -= 2\r\n#             j -= 1\r\n#         mn = float('inf')\r\n#         if t >= m:\r\n#             mn = ans\r\n#         for i in range(len(c)):\r\n#             t += c[i]\r\n#             ans += 1\r\n#             while j >= 0 and t - d[j] >= m:\r\n#                 t -= d[j]\r\n#                 ans -= 2\r\n#                 j -= 1\r\n#             if t >= m:\r\n#                 mn = min(ans, mn)\r\n#         print(mn)\r\n\r\nfor _ in range(int(input())):\r\n    n = int(input())\r\n    a = [list(map(int, input())) for _ in range(n)]\r\n    input()\r\n    b = [list(map(int, input())) for _ in range(n)]\r\n    for i in range(n):\r\n        for j in range(n):\r\n            if b[i][j]:\r\n                b[i][j] = 0\r\n                a[i][j] ^= 1\r\n    for i in range(n):\r\n        if a[i][0] == 1:\r\n            for j in range(n):\r\n                a[i][j] ^= 1\r\n    for j in range(n):\r\n        if a[0][j] == 1:\r\n            for i in range(n):\r\n                a[i][j] ^= 1\r\n    if a == b:\r\n        print('YES')\r\n    else:\r\n        print('NO')\r\n        \r\n\r\n\r\n",
    "prob_desc_created_at": "1611586800",
    "tags": [
        "2-sat",
        "brute force",
        "constructive algorithms"
    ],
    "hidden_unit_tests": ""
}
{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"0 1 1 2 0 4 \\n0 0 1 \\n0 1 2 0 2 5 6 2\"]",
    "src_uid": "a83aaaa8984d1a6dda1adf10127b7abc",
    "prob_desc_notes": "NoteThe first test case matches the example from the statement.The second set of input data is simple. Note that the answer $$$[3, 2, 1]$$$ also gives the same permutation, but since the total number of shifts $$$3+2+1$$$ is greater than $$$0+0+1$$$, this answer is not correct.",
    "prob_desc_description": "Petya got an array $$$a$$$ of numbers from $$$1$$$ to $$$n$$$, where $$$a[i]=i$$$.He performed $$$n$$$ operations sequentially. In the end, he received a new state of the $$$a$$$ array.At the $$$i$$$-th operation, Petya chose the first $$$i$$$ elements of the array and cyclically shifted them to the right an arbitrary number of times (elements with indexes $$$i+1$$$ and more remain in their places). One cyclic shift to the right is such a transformation that the array $$$a=[a_1, a_2, \\dots, a_n]$$$ becomes equal to the array $$$a = [a_i, a_1, a_2, \\dots, a_{i-2}, a_{i-1}, a_{i+1}, a_{i+2}, \\dots, a_n]$$$.For example, if $$$a = [5,4,2,1,3]$$$ and $$$i=3$$$ (that is, this is the third operation), then as a result of this operation, he could get any of these three arrays:  $$$a = [5,4,2,1,3]$$$ (makes $$$0$$$ cyclic shifts, or any number that is divisible by $$$3$$$);  $$$a = [2,5,4,1,3]$$$ (makes $$$1$$$ cyclic shift, or any number that has a remainder of $$$1$$$ when divided by $$$3$$$);  $$$a = [4,2,5,1,3]$$$ (makes $$$2$$$ cyclic shifts, or any number that has a remainder of $$$2$$$ when divided by $$$3$$$). Let's look at an example. Let $$$n=6$$$, i.e. initially $$$a=[1,2,3,4,5,6]$$$. A possible scenario is described below.  $$$i=1$$$: no matter how many cyclic shifts Petya makes, the array $$$a$$$ does not change.  $$$i=2$$$: let's say Petya decided to make a $$$1$$$ cyclic shift, then the array will look like $$$a = [\\textbf{2}, \\textbf{1}, 3, 4, 5, 6]$$$.  $$$i=3$$$: let's say Petya decided to make $$$1$$$ cyclic shift, then the array will look like $$$a = [\\textbf{3}, \\textbf{2}, \\textbf{1}, 4, 5, 6]$$$.  $$$i=4$$$: let's say Petya decided to make $$$2$$$ cyclic shifts, the original array will look like $$$a = [\\textbf{1}, \\textbf{4}, \\textbf{3}, \\textbf{2}, 5, 6]$$$.  $$$i=5$$$: let's say Petya decided to make $$$0$$$ cyclic shifts, then the array won't change.  $$$i=6$$$: let's say Petya decided to make $$$4$$$ cyclic shifts, the array will look like $$$a = [\\textbf{3}, \\textbf{2}, \\textbf{5}, \\textbf{6}, \\textbf{1}, \\textbf{4}]$$$. You are given a final array state $$$a$$$ after all $$$n$$$ operations. Determine if there is a way to perform the operation that produces this result. In this case, if an answer exists, print the numbers of cyclical shifts that occurred during each of the $$$n$$$ operations.",
    "prob_desc_output_spec": "For each test case, print the answer on a separate line. Print -1 if the given final value $$$a$$$ cannot be obtained by performing an arbitrary number of cyclic shifts on each operation. Otherwise, print $$$n$$$ non-negative integers $$$d_1, d_2, \\dots, d_n$$$ ($$$d_i \\ge 0$$$), where $$$d_i$$$ means that during the $$$i$$$-th operation the first $$$i$$$ elements of the array were cyclic shifted to the right $$$d_i$$$ times. If there are several possible answers, print the one where the total number of shifts is minimal (that is, the sum of $$$d_i$$$ values is the smallest). If there are several such answers, print any of them.",
    "prob_desc_input_spec": "The first line of the input contains an integer $$$t$$$ ($$$1 \\le t \\le 500$$$) — the number of test cases in the test. The descriptions of the test cases follow. The first line of the description of each test case contains one integer $$$n$$$ ($$$2 \\le n \\le 2\\cdot10^3$$$) — the length of the array $$$a$$$. The next line contains the final state of the array $$$a$$$: $$$n$$$ integers $$$a_1, a_2, \\dots, a_n$$$ ($$$1 \\le a_i \\le n$$$) are written. All $$$a_i$$$ are distinct. It is guaranteed that the sum of $$$n$$$ values over all test cases does not exceed $$$2\\cdot10^3$$$.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3-64",
    "lang_cluster": "Python",
    "difficulty": 1300,
    "file_name": "train_104.jsonl",
    "code_uid": "180570f023d62d350db9f8510d3b81f6",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"3\\n\\n6\\n\\n3 2 5 6 1 4\\n\\n3\\n\\n3 1 2\\n\\n8\\n\\n5 8 1 3 2 6 4 7\"]",
    "exec_outcome": "PASSED",
    "source_code": "#!/usr/bin/env pypy3\r\n\r\nimport io, os, sys\r\nfrom sys import stdin, stdout\r\n\r\n# input = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline\r\ndef input(): return stdin.readline().strip()\r\ndef read_int_list(): return list(map(int, input().split()))\r\ndef read_int_tuple(): return tuple(map(int, input().split()))\r\ndef read_int(): return int(input())\r\n\r\nfrom itertools import permutations, chain, combinations, product\r\nfrom math import factorial, gcd\r\nfrom collections import Counter, defaultdict, deque\r\nfrom heapq import heappush, heappop, heapify\r\nfrom bisect import bisect_left\r\nfrom functools import lru_cache\r\n\r\n### CODE HERE\r\n\r\nclass FenwickTree:\r\n    def __init__(self, x):\r\n        \"\"\"transform list into BIT\"\"\"\r\n        self.bit = x\r\n        for i in range(len(x)):\r\n            j = i | (i + 1)\r\n            if j < len(x):\r\n                x[j] += x[i]\r\n\r\n    def update(self, idx, x):\r\n        \"\"\"updates bit[idx] += x\"\"\"\r\n        while idx < len(self.bit):\r\n            self.bit[idx] += x\r\n            idx |= idx + 1\r\n\r\n    def query(self, end):\r\n        \"\"\"calc sum(bit[:end])\"\"\"\r\n        x = 0\r\n        while end:\r\n            x += self.bit[end - 1]\r\n            end &= end - 1\r\n        return x\r\n\r\n    def findkth(self, k):\r\n        \"\"\"Find largest idx such that sum(bit[:idx]) <= k\"\"\"\r\n        idx = -1\r\n        for d in reversed(range(len(self.bit).bit_length())):\r\n            right_idx = idx + (1 << d)\r\n            if right_idx < len(self.bit) and k >= self.bit[right_idx]:\r\n                idx = right_idx\r\n                k -= self.bit[idx]\r\n        return idx + 1\r\n\r\nclass IndexingDelList:\r\n    \"\"\"\r\n    A list with fast index and del operations\r\n    Note: del is with indexes of the original\r\n    However, get/set are not supported\r\n    \"\"\"\r\n    from collections import defaultdict\r\n    def __init__(self, A):\r\n        self.ones = FenwickTree([1]*len(A))\r\n        self.A = list(A)\r\n        self.index_of = dict()\r\n        for i, a in enumerate(A):\r\n            self.index_of[a] = i\r\n        self.total_len = len(A)\r\n\r\n    def index(self, n):\r\n        return self.ones.query(self.index_of[n])\r\n\r\n\r\n    def __getitem__(self, k):\r\n        # not implemented, could do some binary search\r\n        assert(False)\r\n    def __setitem__(self, k, v):\r\n        assert(False)\r\n    def __len__(self):\r\n        return self.total_len\r\n\r\n    def remove(self, a):\r\n        self.total_len -= 1\r\n        idx = self.index_of[a]\r\n        self.ones.update(idx, -1)\r\n\r\ndef ans(A):\r\n    N = len(A)\r\n    A = IndexingDelList([a-1 for a in A])\r\n    last = N\r\n    ret = []\r\n    for n in range(N-1, -1, -1):\r\n        r = A.index(n)\r\n        gap = (r + len(A) - last + 1) % len(A)\r\n        ret += [gap]\r\n        last = r\r\n        A.remove(n)\r\n    print(*ret[::-1])\r\n\r\nfor _ in range(read_int()):\r\n    input()\r\n    ans(read_int_list())\r\n",
    "prob_desc_created_at": "1646750100",
    "tags": [
        "brute force",
        "constructive algorithms",
        "implementation",
        "math"
    ],
    "hidden_unit_tests": ""
}
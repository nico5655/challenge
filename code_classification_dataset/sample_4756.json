{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"ckpuv\\naababab\\nzzzzzz\"]",
    "src_uid": "80fd03a1cbdef86a5f00ada85e026890",
    "prob_desc_notes": "NoteA string $$$a$$$ is lexicographically smaller than a string $$$b$$$ if and only if one of the following holds: $$$a$$$ is a prefix of $$$b$$$, but $$$a \\ne b$$$; in the first position where $$$a$$$ and $$$b$$$ differ, the string $$$a$$$ has a letter that appears earlier in the alphabet than the corresponding letter in $$$b$$$.In the first test case, $$$f(t) = 0$$$ and the values of prefix function are $$$[0, 0, 0, 0, 0]$$$ for any permutation of letters. String ckpuv is the lexicographically smallest permutation of letters of string vkcup.In the second test case, $$$f(t) = 1$$$ and the values of prefix function are $$$[0, 1, 0, 1, 0, 1, 0]$$$.In the third test case, $$$f(t) = 5$$$ and the values of prefix function are $$$[0, 1, 2, 3, 4, 5]$$$.",
    "prob_desc_description": "Prefix function of string $$$t = t_1 t_2 \\ldots t_n$$$ and position $$$i$$$ in it is defined as the length $$$k$$$ of the longest proper (not equal to the whole substring) prefix of substring $$$t_1 t_2 \\ldots t_i$$$ which is also a suffix of the same substring.For example, for string $$$t = $$$ abacaba the values of the prefix function in positions $$$1, 2, \\ldots, 7$$$ are equal to $$$[0, 0, 1, 0, 1, 2, 3]$$$.Let $$$f(t)$$$ be equal to the maximum value of the prefix function of string $$$t$$$ over all its positions. For example, $$$f($$$abacaba$$$) = 3$$$.You are given a string $$$s$$$. Reorder its characters arbitrarily to get a string $$$t$$$ (the number of occurrences of any character in strings $$$s$$$ and $$$t$$$ must be equal). The value of $$$f(t)$$$ must be minimized. Out of all options to minimize $$$f(t)$$$, choose the one where string $$$t$$$ is the lexicographically smallest.",
    "prob_desc_output_spec": "For each test case print a single string $$$t$$$. The multisets of letters in strings $$$s$$$ and $$$t$$$ must be equal. The value of $$$f(t)$$$, the maximum of prefix functions in string $$$t$$$, must be as small as possible. String $$$t$$$ must be the lexicographically smallest string out of all strings satisfying the previous conditions.",
    "prob_desc_input_spec": "Each test contains multiple test cases. The first line contains the number of test cases $$$t$$$ ($$$1 \\le t \\le 10^5$$$). Description of the test cases follows. The only line of each test case contains string $$$s$$$ ($$$1 \\le |s| \\le 10^5$$$) consisting of lowercase English letters. It is guaranteed that the sum of lengths of $$$s$$$ over all test cases does not exceed $$$10^5$$$.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3-64",
    "lang_cluster": "Python",
    "difficulty": 2100,
    "file_name": "train_105.jsonl",
    "code_uid": "4bdd501ed70881341216ac6f0f1b69cf",
    "prob_desc_memory_limit": "512 megabytes",
    "prob_desc_sample_inputs": "[\"3\\nvkcup\\nabababa\\nzzzzzz\"]",
    "exec_outcome": "PASSED",
    "source_code": "import sys\n\ninput = sys.stdin.readline\ninf = float('inf')\n\n\ndef getInt():\n    return int(input())\n\n\ndef getStr():\n    return input().strip()\n\n\ndef getList(split=True):\n    s = getStr()\n    if split:\n        s = s.split()\n    return map(int, s)\n\n\nt = getInt()\n# t = 1\n\n# observations, the maximum number of Good Assignments = len(set(a)) (i.e the number of unuquie elements in the array a)\n\n# how to we assign so that all res[i] != i\n# let define too set, good = set(a), i.e the people who defnitely receive gifts by a people whose wish is fullfied\n# bad = the set people who no one wish to give to\n# for set good, if we assign a person in set good to another person in set good, then the bad person might be left over then he could assign to himself\n# hence, one possilbe approach is to fullfill the request of people in the bad group first\n# we notice that the wish of the first people in the bad group can always be fullied\n# we keep fullfiled the wishes of people in the bad group, if we can not , the we should assign the smallest bad people which no one is assinged to for him, this is always possible since the wish of first bad people always be filled\n# now traverse through the array again, now we know we would only process peoople in the good list, fullfill his wish if we can, otherwise assign him to the next bad people who one is assinged to again (since the set of good and bad do not itersect so no res[i] = i would not happen)\n# and we know that some good people would take up all other good assignments, so the godo peole who are not assigned have to assign to bad people, so the algoritm  works correctly\n\n\ndef solve():\n    s = getStr()\n    n = len(s)\n    from collections import Counter\n    cnt = Counter(s)\n    a = sorted(cnt)\n    if min(s) == max(s):\n        print(s)\n    elif min(cnt.values()) == 1:\n        it = min(i for i in cnt if cnt[i] == 1)\n        res = it + \"\".join(sorted(s.replace(it, \"\")))\n        print(res)\n    else:\n        # if okay when the frquent of the other is enough to cover i\n        i = min(a)\n        if n - cnt[i] >= cnt[i] - 2:\n            # can make i, i\n            res = [i, i]\n            pool = sorted(j for j in s if j > i)\n            for k in range(len(pool)):\n                res.append(pool[k])\n                if k < cnt[i]-2:\n                    res.append(i)\n            print(*res, sep=\"\")\n        else:\n            # can not make ii, make ij\n            if len(cnt) == 2:\n                res = i + a[1] * cnt[a[1]] + i * (cnt[i]-1)\n            else:\n                res = i + a[1] + i * (cnt[i]-1) + a[2]\n                for i in range(1, len(a)):\n                    res += a[i] * (cnt[a[i]] - (i <= 2))\n\n            print(res)\n            # min frequent is 1 easy\n            # now all char >= 2 frequent\n            # can always make f(t) = 1\n            # choose the strnig so that f(t) = 1\n            # the answer muts be of frefix xx, then as long as xx not in t then ok\n\n\nfor _ in range(t):\n    solve()\n",
    "prob_desc_created_at": "1626532500",
    "tags": [
        "constructive algorithms",
        "greedy",
        "strings"
    ],
    "hidden_unit_tests": ""
}
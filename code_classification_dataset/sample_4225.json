{
    "prob_desc_time_limit": "4 seconds",
    "prob_desc_sample_outputs": "[\"2\\n0\\n13\\n1\\n4\\n7\\n0\"]",
    "src_uid": "a7ae834884ce801ffe111bd8161e89d2",
    "prob_desc_notes": "NoteIn the first test case, the optimal array is $$$p = [1, 1, 1, 2, 2]$$$. The resulting array of values of $$$\\lfloor \\frac{a_i}{p_i} \\rfloor$$$ is $$$[4, 5, 6, 4, 5]$$$. The cost of $$$p$$$ is $$$\\max\\limits_{1 \\le i \\le n}(\\lfloor \\frac{a_i}{p_i} \\rfloor) - \\min\\limits_{1 \\le i \\le n}(\\lfloor \\frac{a_i}{p_i} \\rfloor) = 6 - 4 = 2$$$. We can show that there is no array (satisfying the condition from the statement) with a smaller cost.In the second test case, one of the optimal arrays is $$$p = [12, 12, 12, 12, 12]$$$, which results in all $$$\\lfloor \\frac{a_i}{p_i} \\rfloor$$$ being $$$0$$$.In the third test case, the only possible array is $$$p = [1, 1, 1]$$$.",
    "prob_desc_description": "This is the hard version of the problem. The only difference between the versions is the constraints on $$$n$$$, $$$k$$$, $$$a_i$$$, and the sum of $$$n$$$ over all test cases. You can make hacks only if both versions of the problem are solved.Note the unusual memory limit.You are given an array of integers $$$a_1, a_2, \\ldots, a_n$$$ of length $$$n$$$, and an integer $$$k$$$.The cost of an array of integers $$$p_1, p_2, \\ldots, p_n$$$ of length $$$n$$$ is $$$$$$\\max\\limits_{1 \\le i \\le n}\\left(\\left \\lfloor \\frac{a_i}{p_i} \\right \\rfloor \\right) - \\min\\limits_{1 \\le i \\le n}\\left(\\left \\lfloor \\frac{a_i}{p_i} \\right \\rfloor \\right).$$$$$$Here, $$$\\lfloor \\frac{x}{y} \\rfloor$$$ denotes the integer part of the division of $$$x$$$ by $$$y$$$. Find the minimum cost of an array $$$p$$$ such that $$$1 \\le p_i \\le k$$$ for all $$$1 \\le i \\le n$$$.",
    "prob_desc_output_spec": "For each test case, print a single integer — the minimum possible cost of an array $$$p$$$ satisfying the condition above.",
    "prob_desc_input_spec": "The first line contains a single integer $$$t$$$ ($$$1 \\le t \\le 100$$$) — the number of test cases. The first line of each test case contains two integers $$$n$$$ and $$$k$$$ ($$$1 \\le n, k \\le 10^5$$$). The second line contains $$$n$$$ integers $$$a_1, a_2, \\ldots, a_n$$$ ($$$1 \\le a_1 \\le a_2 \\le \\ldots \\le a_n \\le 10^5$$$). It is guaranteed that the sum of $$$n$$$ over all test cases does not exceed $$$10^5$$$.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3-64",
    "lang_cluster": "Python",
    "difficulty": 2400,
    "file_name": "train_093.jsonl",
    "code_uid": "c3378cdf501f3cc31c0ea5e47090e67f",
    "prob_desc_memory_limit": "64 megabytes",
    "prob_desc_sample_inputs": "[\"7\\n\\n5 2\\n\\n4 5 6 8 11\\n\\n5 12\\n\\n4 5 6 8 11\\n\\n3 1\\n\\n2 9 15\\n\\n7 3\\n\\n2 3 5 5 6 9 10\\n\\n6 56\\n\\n54 286 527 1436 2450 2681\\n\\n3 95\\n\\n16 340 2241\\n\\n2 2\\n\\n1 3\"]",
    "exec_outcome": "PASSED",
    "source_code": "#!/usr/bin/env python3\r\nimport sys\r\nimport heapq\r\ninput = sys.stdin.readline  # to read input quickly\r\n \r\ndef ceiling_division(numer, denom):\r\n    return -((-numer)//denom)\r\n \r\nmask = 2**18 - 1\r\nm0 = mask\r\nm1 = mask << 18\r\nm2 = mask << 36\r\n \r\n \r\ndef ungroup(x):\r\n    return (x&m2) >> 36, (x&m1) >> 18, (x&m0) \r\n \r\ndef group(a,b,c):\r\n    val = (a << 36) ^ (b << 18) ^ c\r\n    return val\r\n \r\nfor case_num in range(int(input())):\r\n    n,k = list(map(int,input().split()))\r\n \r\n    n_cooldown = 18*n\r\n    cnt = n_cooldown\r\n \r\n    arr = [group((x//k),k,x) for x in map(int,input().split())]\r\n \r\n    minn = ungroup(arr[0])[0]\r\n    maxx = ungroup(arr[-1])[0]\r\n    minres = maxx - minn\r\n \r\n    if minres == 0:\r\n        print(0)\r\n        continue\r\n \r\n    maxx = max(1, maxx)\r\n \r\n    while ungroup(arr[0])[1] > 1 and cnt > 0:\r\n        nx,i,x = ungroup(heapq.heappop(arr))\r\n \r\n        i = max(1, min(ceiling_division(x, maxx), x // (nx+1)))\r\n        nx = (x//i)\r\n        heapq.heappush(arr, group(nx,i,x))\r\n \r\n        maxx = max(maxx, nx)\r\n        minn = ungroup(arr[0])[0]\r\n        cnt -= 1\r\n        if maxx - minn < minres:\r\n            minres = maxx - minn\r\n            cnt = n_cooldown\r\n        if minres == 0:\r\n            break\r\n \r\n    print(minres)",
    "prob_desc_created_at": "1658154900",
    "tags": [
        "brute force",
        "constructive algorithms",
        "data structures",
        "dp",
        "greedy",
        "math",
        "number theory",
        "two pointers"
    ],
    "hidden_unit_tests": ""
}
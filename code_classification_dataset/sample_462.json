{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"YES\\nabb\"]",
    "src_uid": "591846c93bd221b732c4645e50fae617",
    "prob_desc_notes": null,
    "prob_desc_description": "Authors have come up with the string $$$s$$$ consisting of $$$n$$$ lowercase Latin letters.You are given two permutations of its indices (not necessary equal) $$$p$$$ and $$$q$$$ (both of length $$$n$$$). Recall that the permutation is the array of length $$$n$$$ which contains each integer from $$$1$$$ to $$$n$$$ exactly once.For all $$$i$$$ from $$$1$$$ to $$$n-1$$$ the following properties hold: $$$s[p_i] \\le s[p_{i + 1}]$$$ and $$$s[q_i] \\le s[q_{i + 1}]$$$. It means that if you will write down all characters of $$$s$$$ in order of permutation indices, the resulting string will be sorted in the non-decreasing order.Your task is to restore any such string $$$s$$$ of length $$$n$$$ consisting of at least $$$k$$$ distinct lowercase Latin letters which suits the given permutations.If there are multiple answers, you can print any of them.",
    "prob_desc_output_spec": "If it is impossible to find the suitable string, print \"NO\" on the first line. Otherwise print \"YES\" on the first line and string $$$s$$$ on the second line. It should consist of $$$n$$$ lowercase Latin letters, contain at least $$$k$$$ distinct characters and suit the given permutations. If there are multiple answers, you can print any of them.",
    "prob_desc_input_spec": "The first line of the input contains two integers $$$n$$$ and $$$k$$$ ($$$1 \\le n \\le 2 \\cdot 10^5, 1 \\le k \\le 26$$$) — the length of the string and the number of distinct characters required. The second line of the input contains $$$n$$$ integers $$$p_1, p_2, \\dots, p_n$$$ ($$$1 \\le p_i \\le n$$$, all $$$p_i$$$ are distinct integers from $$$1$$$ to $$$n$$$) — the permutation $$$p$$$. The third line of the input contains $$$n$$$ integers $$$q_1, q_2, \\dots, q_n$$$ ($$$1 \\le q_i \\le n$$$, all $$$q_i$$$ are distinct integers from $$$1$$$ to $$$n$$$) — the permutation $$$q$$$.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 2",
    "lang_cluster": "Python",
    "difficulty": 2100,
    "file_name": "train_002.jsonl",
    "code_uid": "87d0231268cbbbdd3643788cae9742d5",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"3 2\\n1 2 3\\n1 3 2\"]",
    "exec_outcome": "PASSED",
    "source_code": "# adapted some python code from https://www.geeksforgeeks.org/strongly-connected-components/\nfrom collections import defaultdict, deque\n   \n#This class represents a directed graph using adjacency list representation \nclass Graph: \n   \n    def __init__(self,vertices): \n        self.V= vertices #No. of vertices \n        self.graph = defaultdict(list) # default dictionary to store graph \n   \n    # function to add an edge to graph \n    def addEdge(self,u,v): \n        self.graph[u].append(v) \n   \n    # A function used by DFS \n    def DFSUtil(self,v,visited): \n        'generate all nodes in one partition'\n\n        answer = []\n\n        nodes_to_visit = deque()\n        nodes_to_visit.append(v)\n        while len(nodes_to_visit)>0:\n            v = nodes_to_visit.popleft()\n            # Mark the current node as visited and print it \n            visited[v]= True\n            answer.append(v)\n            #Recur for all the vertices adjacent to this vertex \n            for i in self.graph[v]: \n                if visited[i]==False: \n                    nodes_to_visit.appendleft(i)\n        return answer\n  \n  \n    def fillOrder(self,v,visited, stack): \n        # # Mark the current node as visited  \n        # visited[v]= True\n        # #Recur for all the vertices adjacent to this vertex \n        # for i in self.graph[v]: \n        #     if visited[i]==False: \n        #         self.fillOrder(i, visited, stack) \n        # stack = stack.append(v) \n\n\n        ext_stack = deque()\n        nodes = deque()\n        nodes.append(v)\n        while len(nodes)>0:\n            v = nodes.popleft()\n            visited[v]=True\n            for i in self.graph[v]:\n                if visited[i] == False:\n                    nodes.appendleft(i)\n            ext_stack.append(v)\n\n        while len(ext_stack)>0:\n            stack.append(ext_stack.pop())\n      \n  \n    # Function that returns reverse (or transpose) of this graph \n    def getTranspose(self): \n        g = Graph(self.V) \n  \n        # Recur for all the vertices adjacent to this vertex \n        for i in self.graph: \n            for j in self.graph[i]: \n                g.addEdge(j,i) \n        return g \n  \n   \n   \n    # The main function that finds and prints all strongly \n    # connected components \n    def printSCCs(self): \n        'generate all components of graph (generator of lists)'\n          \n        stack = [] \n        # Mark all the vertices as not visited (For first DFS) \n        visited =[False]*(self.V) \n        # Fill vertices in stack according to their finishing \n        # times \n        for i in range(self.V): \n            if visited[i]==False: \n                self.fillOrder(i, visited, stack) \n  \n        # Create a reversed graph \n        gr = self.getTranspose() \n           \n         # Mark all the vertices as not visited (For second DFS) \n        visited =[False]*(self.V) \n  \n         # Now process all vertices in order defined by Stack \n        while stack: \n             i = stack.pop() \n             if visited[i]==False: \n                yield list(gr.DFSUtil(i, visited))\n                \n\nn,k = map(int, raw_input().split())\np = [x-1 for x in map(int, raw_input().split())]\nq = [x-1 for x in map(int, raw_input().split())]\n\nimport sys\n\n# Create a graph given in the above diagram \ng = Graph(n)\nfor i in xrange(n-1):\n    g.addEdge(p[i], p[i+1]) \n    g.addEdge(q[i], q[i+1]) \n\ndef next_letter(letter):\n    if letter < 'z':\n        return chr(ord(letter)+1)\n    else:\n        return letter\n\npartition = sorted(map(sorted, list(g.printSCCs())))\ninverse = [None] * n\nfor i,part in enumerate(partition):\n    for j in part:\n        inverse[j] = i\n\nif len(partition) < k:\n    print 'NO'\nelse:\n    print 'YES'\n    answer = [None] * n\n    \n    # for eveyrthing in the component containing p[0], give it the letter 'a'\n    letter = 'a'\n    for u in xrange(n):\n        if answer[p[u]] is None:\n            i = inverse[p[u]]\n            for j in partition[i]:\n                answer[j] = letter\n            letter = next_letter(letter)\n\n    print ''.join(answer)",
    "prob_desc_created_at": "1567175700",
    "tags": [
        "greedy",
        "graphs",
        "dsu",
        "implementation",
        "data structures",
        "dfs and similar",
        "strings"
    ],
    "hidden_unit_tests": ""
}
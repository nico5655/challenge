{
    "prob_desc_time_limit": "4 seconds",
    "prob_desc_sample_outputs": "[\"YES\\nNO\\nYES\\nYES\\nYES\"]",
    "src_uid": "bcd34e88bcd70ad36acbe6c3b70aa45d",
    "prob_desc_notes": "NoteThe first example is explained in the statement.In the second example, it is impossible to get the value $$$31$$$ from the numbers of the multiset $$$b$$$ by available operations.In the third example, we can proceed as follows:   Replace $$$2$$$ with $$$2 \\cdot 2 = 4$$$. We get $$$b = \\{4, 14, 14, 26, 42\\}$$$.  Replace $$$14$$$ with $$$\\lfloor \\frac{14}{2} \\rfloor = 7$$$. We get $$$b = \\{4, 7, 14, 26, 42\\}$$$.  Replace $$$26$$$ with $$$\\lfloor \\frac{26}{2} \\rfloor = 13$$$. We get $$$b = \\{4, 7, 14, 13, 42\\}$$$.  Replace $$$42$$$ with $$$\\lfloor \\frac{42}{2} \\rfloor = 21$$$. We get $$$b = \\{4, 7, 14, 13, 21\\}$$$.  Replace $$$21$$$ with $$$\\lfloor \\frac{21}{2} \\rfloor = 10$$$. We get $$$b = \\{4, 7, 14, 13, 10\\}$$$.  Got equal multisets $$$a = \\{4, 7, 10, 13, 14\\}$$$ and $$$b = \\{4, 7, 14, 13, 10\\}$$$.  ",
    "prob_desc_description": "Multiset —is a set of numbers in which there can be equal elements, and the order of the numbers does not matter. Two multisets are equal when each value occurs the same number of times. For example, the multisets $$$\\{2,2,4\\}$$$ and $$$\\{2,4,2\\}$$$ are equal, but the multisets $$$\\{1,2,2\\}$$$ and $$$\\{1,1,2\\}$$$ — are not.You are given two multisets $$$a$$$ and $$$b$$$, each consisting of $$$n$$$ integers.In a single operation, any element of the $$$b$$$ multiset can be doubled or halved (rounded down). In other words, you have one of the following operations available for an element $$$x$$$ of the $$$b$$$ multiset:   replace $$$x$$$ with $$$x \\cdot 2$$$,  or replace $$$x$$$ with $$$\\lfloor \\frac{x}{2} \\rfloor$$$ (round down).  Note that you cannot change the elements of the $$$a$$$ multiset.See if you can make the multiset $$$b$$$ become equal to the multiset $$$a$$$ in an arbitrary number of operations (maybe $$$0$$$).For example, if $$$n = 4$$$, $$$a = \\{4, 24, 5, 2\\}$$$, $$$b = \\{4, 1, 6, 11\\}$$$, then the answer is yes. We can proceed as follows:   Replace $$$1$$$ with $$$1 \\cdot 2 = 2$$$. We get $$$b = \\{4, 2, 6, 11\\}$$$.  Replace $$$11$$$ with $$$\\lfloor \\frac{11}{2} \\rfloor = 5$$$. We get $$$b = \\{4, 2, 6, 5\\}$$$.  Replace $$$6$$$ with $$$6 \\cdot 2 = 12$$$. We get $$$b = \\{4, 2, 12, 5\\}$$$.  Replace $$$12$$$ with $$$12 \\cdot 2 = 24$$$. We get $$$b = \\{4, 2, 24, 5\\}$$$.  Got equal multisets $$$a = \\{4, 24, 5, 2\\}$$$ and $$$b = \\{4, 2, 24, 5\\}$$$. ",
    "prob_desc_output_spec": "For each test case, print on a separate line:   YES if you can make the multiset $$$b$$$ become equal to $$$a$$$,  NO otherwise.  You can output YES and NO in any case (for example, strings yEs, yes, Yes and YES will be recognized as positive answer).",
    "prob_desc_input_spec": "The first line of input data contains a single integer $$$t$$$ ($$$1 \\le t \\le 10^4$$$) —the number of test cases. Each test case consists of three lines. The first line of the test case contains an integer $$$n$$$ ($$$1 \\le n \\le 2 \\cdot 10^5$$$) —the number of elements in the multisets $$$a$$$ and $$$b$$$. The second line gives $$$n$$$ integers: $$$a_1, a_2, \\dots, a_n$$$ ($$$1 \\le a_1 \\le a_2 \\le \\dots \\le a_n \\le 10^9$$$) —the elements of the multiset $$$a$$$. Note that the elements may be equal. The third line contains $$$n$$$ integers: $$$b_1, b_2, \\dots, b_n$$$ ($$$1 \\le b_1 \\le b_2 \\le \\dots \\le b_n \\le 10^9$$$) — elements of the multiset $$$b$$$. Note that the elements may be equal. It is guaranteed that the sum of $$$n$$$ values over all test cases does not exceed $$$2 \\cdot 10^5$$$.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3-64",
    "lang_cluster": "Python",
    "difficulty": 1700,
    "file_name": "train_089.jsonl",
    "code_uid": "6d5ac23ebf07c7e117684c2af2ff100d",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"5\\n\\n4\\n\\n2 4 5 24\\n\\n1 4 6 11\\n\\n3\\n\\n1 4 17\\n\\n4 5 31\\n\\n5\\n\\n4 7 10 13 14\\n\\n2 14 14 26 42\\n\\n5\\n\\n2 2 4 4 4\\n\\n28 46 62 71 98\\n\\n6\\n\\n1 2 10 16 64 80\\n\\n20 43 60 74 85 99\"]",
    "exec_outcome": "PASSED",
    "source_code": "#!/usr/bin/env python3\r\n \r\nimport io, os, sys\r\nfrom sys import stdin, stdout\r\n \r\n# input = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline\r\ndef input(): return stdin.readline().strip()\r\ndef read_int_list(): return list(map(int, input().split()))\r\ndef read_int_tuple(): return tuple(map(int, input().split()))\r\ndef read_int(): return int(input())\r\n \r\nfrom itertools import permutations, chain, combinations, product\r\nfrom math import factorial, gcd\r\nfrom collections import Counter, defaultdict, deque\r\nfrom heapq import heappush, heappop, heapify\r\nfrom bisect import bisect_left\r\nfrom functools import lru_cache\r\nimport random\r\n \r\n### CODE HERE\r\n\r\nimport sys\r\nimport array\r\n\r\nclass BinaryTrie_pool:\r\n    def __repr__(self) -> str:\r\n        return f\"{self.num_words, self.starts, self.child0, self.child1}\"\r\n\r\n    def alloc(self):\r\n\r\n        self.num_words.append(0)\r\n        self.starts.append(0)\r\n        self.child0.append(-1)\r\n        self.child1.append(-1)\r\n\r\n        self.next_alloc += 1\r\n        return self.next_alloc - 1\r\n\r\n    def __init__(self):\r\n\r\n        self.num_words = array.array('L')\r\n        self.starts = array.array('L')\r\n        self.child0 = array.array('l')\r\n        self.child1 = array.array('l')\r\n\r\n        self.next_alloc = 0\r\n\r\n        self.root = self.alloc()\r\n\r\n    def anyChild(self, node):\r\n        if self.child0[node] != -1 and self.starts[self.child0[node]] > 0:\r\n            return self.child0[node]\r\n        if self.child1[node] != -1 and self.starts[self.child1[node]] > 0:\r\n            return self.child1[node]\r\n\r\n    def insert(self, word):\r\n        word = list(map(int, word))\r\n        node=self.root\r\n        for i in word:\r\n            self.starts[node] += 1\r\n\r\n            if i == 0 and self.child0[node] == -1: self.child0[node] = self.alloc()\r\n            if i == 1 and self.child1[node] == -1: self.child1[node] = self.alloc()\r\n\r\n            node = self.child0[node] if i == 0 else self.child1[node]\r\n        self.num_words[node] += 1\r\n        self.starts[node] += 1\r\n\r\n    def findAnyWithPrefix(self, prefix):\r\n        prefix = list(map(int, prefix))\r\n\r\n        node = self.findNode(prefix)\r\n        if node == -1 or node is None:\r\n            return None\r\n        if self.starts[node] == 0:\r\n            return None\r\n        while self.num_words[node] == 0:\r\n            node = self.anyChild(node)\r\n        return node\r\n\r\n    def containsWord(self, word):\r\n        word = list(map(int, word))\r\n        node = self.findNode(word)\r\n        if node == -1: return False\r\n        return node.num_words > 0\r\n\r\n    def remove(self, word):\r\n        word = list(map(int, word))\r\n        node=self.root\r\n        self.starts[node] -= 1\r\n        for i in word:\r\n            if i == 0 and self.child0[node] == -1: return None\r\n            if i == 1 and self.child1[node] == -1: return None\r\n\r\n            node = self.child0[node] if i == 0 else self.child1[node]\r\n\r\n            self.starts[node] -= 1\r\n        self.num_words[node] -= 1\r\n\r\n    def removeAnyWithPrefix(self, prefix):\r\n        prefix = list(map(int, prefix))\r\n        node=self.root\r\n        for i in prefix:\r\n            self.starts[node] -= 1\r\n            node = self.child0[node] if i == 0 else self.child1[node]\r\n\r\n        if self.num_words[node] > 0:\r\n            self.starts[node] -= 1\r\n            self.num_words[node] -= 1\r\n            return \r\n        \r\n        self.starts[node] -= 1\r\n\r\n        while self.num_words[node] == 0:\r\n            node = self.anyChild(node)\r\n            self.starts[node] -= 1\r\n        \r\n        self.num_words[node] -= 1\r\n\r\n    def findNode(self, word):\r\n        word = list(map(int, word))\r\n        \r\n        node=self.root\r\n        for i in word:\r\n            if i == 0 and self.child0[node] == -1: return None\r\n            if i == 1 and self.child1[node] == -1: return None\r\n\r\n            node = self.child0[node] if i == 0 else self.child1[node]\r\n\r\n        return node\r\n\r\n    def startsWith(self, prefix):\r\n        prefix = list(map(int, prefix))\r\n\r\n        node = self.findNode(prefix)\r\n        if node == -1: return False\r\n        return self.starts[node] > 0\r\n \r\ndef clean(arr):\r\n    ret = []\r\n    for a in arr:\r\n        x = a\r\n        while x > 0 and x % 2 == 0:\r\n            x //= 2\r\n        ret += [x]\r\n    return sorted(ret)[::-1]\r\n \r\ndef bin(x):\r\n    return \"{0:b}\".format(x)\r\n \r\ndef ans(A, B):\r\n    A = clean(A)\r\n    B = clean(B)\r\n\r\n    A = [bin(x) for x in A]\r\n    B = [bin(x) for x in B]\r\n\r\n    t = BinaryTrie_pool()\r\n\r\n    for b in B:\r\n        t.insert(b)\r\n \r\n    for a in A:\r\n        w = t.findAnyWithPrefix(a)\r\n \r\n        if w is None:\r\n            return \"NO\"\r\n\r\n        t.removeAnyWithPrefix(a)\r\n         \r\n    return \"YES\"\r\n \r\nif False:\r\n    t = BinaryTrie_pool()\r\n    t.insert(\"10\")\r\n    t.insert(\"100\")\r\n    print(t)\r\n    print(t.anyChild(0))\r\nelse:\r\n    for _ in range(read_int()):\r\n        input()\r\n        A = read_int_list()\r\n        B = read_int_list()\r\n\r\n        print(ans(A, B))\r\n",
    "prob_desc_created_at": "1657463700",
    "tags": [
        "constructive algorithms",
        "data structures",
        "greedy",
        "math",
        "number theory"
    ],
    "hidden_unit_tests": ""
}
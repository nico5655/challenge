{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"2\", \"68\"]",
    "src_uid": "8f74200d7c34e696c65840d4c5738c63",
    "prob_desc_notes": "NoteIn the first sample, it's optimal to just apply the fourth operation once to the rectangle containing cells $$$(2, 2), (2, 3), (3, 2), (3, 3)$$$. This would cost $$$2$$$ coins.",
    "prob_desc_description": "The difference between the versions is in the costs of operations. Solution for one version won't work for another!Alice has a grid of size $$$n \\times m$$$, initially all its cells are colored white. The cell on the intersection of $$$i$$$-th row and $$$j$$$-th column is denoted as $$$(i, j)$$$. Alice can do the following operations with this grid:Choose any subrectangle containing cell $$$(1, 1)$$$, and flip the colors of all its cells. (Flipping means changing its color from white to black or from black to white). This operation costs $$$1$$$ coin.Choose any subrectangle containing cell $$$(n, 1)$$$, and flip the colors of all its cells. This operation costs $$$3$$$ coins.Choose any subrectangle containing cell $$$(1, m)$$$, and flip the colors of all its cells. This operation costs $$$4$$$ coins.Choose any subrectangle containing cell $$$(n, m)$$$, and flip the colors of all its cells. This operation costs $$$2$$$ coins. As a reminder, subrectangle is a set of all cells $$$(x, y)$$$ with $$$x_1 \\le x \\le x_2$$$, $$$y_1 \\le y \\le y_2$$$ for some $$$1 \\le x_1 \\le x_2 \\le n$$$, $$$1 \\le y_1 \\le y_2 \\le m$$$.Alice wants to obtain her favorite coloring with these operations. What's the smallest number of coins that she would have to spend? It can be shown that it's always possible to transform the initial grid into any other.",
    "prob_desc_output_spec": "Output the smallest number of coins Alice would have to spend to achieve her favorite coloring.",
    "prob_desc_input_spec": "The first line of the input contains $$$2$$$ integers $$$n, m$$$ ($$$1 \\le n, m \\le 500$$$) â€” the dimensions of the grid. The $$$i$$$-th of the next $$$n$$$ lines contains a string $$$s_i$$$ of length $$$m$$$, consisting of letters W and B. The $$$j$$$-th character of string $$$s_i$$$ is W if the cell $$$(i, j)$$$ is colored white in the favorite coloring of Alice, and B if it's colored black.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3",
    "lang_cluster": "Python",
    "difficulty": 2800,
    "file_name": "train_106.jsonl",
    "code_uid": "f7efab60bd6dc7d6e972ff365caacbdb",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"3 3\\nWWW\\nWBB\\nWBB\", \"10 15\\nWWWBBBWBBBBBWWW\\nBBBBWWWBBWWWBBB\\nBBBWWBWBBBWWWBB\\nBBWBWBBWWWBBWBW\\nBBBBWWWBBBWWWBB\\nBWBBWWBBBBBBWWW\\nWBWWBBBBWWBBBWW\\nWWBWWWWBBWWBWWW\\nBWBWWBWWWWWWBWB\\nBBBWBWBWBBBWWBW\"]",
    "exec_outcome": "PASSED",
    "source_code": "'''\nF1. Alice and Recoloring 2\n\nhttps://codeforces.com/contest/1592/problem/F2\n'''\n\nimport io, os, sys\ninput = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline  # decode() if str\noutput = sys.stdout.write\n\n\ndef find_matching(adj, L, R):\n    # is it possible to find a longer alternative path starting from l\n    def dfs(l):\n        if seen[l]: return False   # cycle found\n        seen[l] = True\n        for r in adj[l]:\n            # can add (l, r) to matching if\n            # * r not yet in matching, or \n            # * can find a longer alt path from match[r], and rm (match[r], r)\n            if match[r] == -1 or dfs(match[r]):\n                match[r] = l\n                return True\n        return False\n\n    # match each node\n    # match[r] = l node s.t. edge (l, r) included in current matching\n    # seen[l] = whether node l was visited\n    match = [-1]*R\n    for l in range(L):\n        seen = [False]*L\n        dfs(l)\n    \n    # final edges in matching\n    return [(l, r) for r, l in enumerate(match) if l != -1]\n\n\ndef solve(R, C, grid):\n    # convert B->1, W->0\n    # want grid to be all 0\n    grid = [[1 if v=='B' else 0 for v in row] for row in grid]\n\n    # convert grid[r][c] = (grid[r][c] + grid[r+1][c] + grid[r][c+1] + grid[r+1][c+1]) % 2\n    # want grid to be all 0\n    ngrid = [[0]*C for _ in range(R)]\n    for r in range(R):\n        for c in range(C):\n            s = grid[r][c]\n            if r+1 < R: s += grid[r+1][c]\n            if c+1 < C: s += grid[r][c+1]\n            if r+1 < R and c+1 < C: s += grid[r+1][c+1]\n            ngrid[r][c] = s % 2\n    grid = ngrid\n\n    # all (R-1, C-1) ops are rectangles with distinct x and y (else 4 correct for cost 4)\n    # and only when 3 corners except (R-1, C-1) are 1 (else 4 correct for cost 5)\n    # --> find all (r, c) pairs where (r, c), (r, C-1), (R-1, c) are all 1\n    adj = [[] for r in range(R)]\n    for r in range(R-1):\n        for c in range(C-1):\n            if grid[r][c] == grid[r][C-1] == grid[R-1][c] == 1:\n                adj[r].append(c)\n        # if len(adj[r]) > 0: print(f'{r} -> {adj[r]}')\n    \n    # find max bipartite match for (R-1, C-1) ops\n    # convert rest with (0, 0) ops\n    matching = find_matching(adj, R, C)\n    op2 = len(matching)\n    op1 = sum(sum(row) for row in grid) - op2*3\n    if grid[R-1][C-1] == 0 and op2 % 2 == 1: op1 += 1\n    if grid[R-1][C-1] == 1 and op2 % 2 == 1: op1 -= 1\n    # print(f'total={sum(sum(row) for row in grid)} last={grid[R-1][C-1]} op2={op2} op1={op1}')\n    return op1 + 2*op2\n\ndef main():\n    R, C = map(int, input().split())\n    grid = [list(input().decode().strip()) for _ in range(R)]\n    out = solve(R, C, grid)\n    output(str(out) + '\\n')\n\nif __name__ == '__main__':\n    main()\n\n# 75 - 3 * 3 - 1",
    "prob_desc_created_at": "1633271700",
    "tags": [
        "constructive algorithms",
        "flows",
        "graph matchings",
        "greedy"
    ],
    "hidden_unit_tests": ""
}
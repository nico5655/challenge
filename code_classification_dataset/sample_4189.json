{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"2\", \"2\", \"3\"]",
    "src_uid": "e1079fe293b5eef766df186bf0d72561",
    "prob_desc_notes": "NoteIn the first example, alpinists $$$2$$$ and $$$3$$$ can climb the mountain if they go in this order. There is no other way to achieve the answer of $$$2$$$.In the second example, alpinist $$$1$$$ is not able to climb because of the initial difficulty of the mountain, while alpinists $$$2$$$ and $$$3$$$ can go up in any order.In the third example, the mountain can be climbed by alpinists $$$5$$$, $$$3$$$ and $$$4$$$ in this particular order. There is no other way to achieve optimal answer.",
    "prob_desc_description": "A group of $$$n$$$ alpinists has just reached the foot of the mountain. The initial difficulty of climbing this mountain can be described as an integer $$$d$$$.Each alpinist can be described by two integers $$$s$$$ and $$$a$$$, where $$$s$$$ is his skill of climbing mountains and $$$a$$$ is his neatness.An alpinist of skill level $$$s$$$ is able to climb a mountain of difficulty $$$p$$$ only if $$$p \\leq s$$$. As an alpinist climbs a mountain, they affect the path and thus may change mountain difficulty. Specifically, if an alpinist of neatness $$$a$$$ climbs a mountain of difficulty $$$p$$$ the difficulty of this mountain becomes $$$\\max(p, a)$$$. Alpinists will climb the mountain one by one. And before the start, they wonder, what is the maximum number of alpinists who will be able to climb the mountain if they choose the right order. As you are the only person in the group who does programming, you are to answer the question.Note that after the order is chosen, each alpinist who can climb the mountain, must climb the mountain at that time. ",
    "prob_desc_output_spec": "Print one integer equal to the maximum number of alpinists who can climb the mountain if they choose the right order to do so.",
    "prob_desc_input_spec": "The first line contains two integers $$$n$$$ and $$$d$$$ ($$$1 \\leq n \\leq 500\\,000$$$; $$$0 \\leq d \\leq 10^9$$$) — the number of alpinists and the initial difficulty of the mountain. Each of the next $$$n$$$ lines contains two integers $$$s_i$$$ and $$$a_i$$$ ($$$0 \\leq s_i, a_i \\leq 10^9$$$) that define the skill of climbing and the neatness of the $$$i$$$-th alpinist.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3-64",
    "lang_cluster": "Python",
    "difficulty": 2700,
    "file_name": "train_092.jsonl",
    "code_uid": "a3d29ab12f874fa57dc0345b35e511d8",
    "prob_desc_memory_limit": "512 megabytes",
    "prob_desc_sample_inputs": "[\"3 2\\n2 6\\n3 5\\n5 7\", \"3 3\\n2 4\\n6 4\\n4 6\", \"5 0\\n1 5\\n4 8\\n2 7\\n7 6\\n3 2\"]",
    "exec_outcome": "PASSED",
    "source_code": "import os,sys\r\nfrom random import randint\r\nfrom io import BytesIO, IOBase\r\n\r\nfrom collections import defaultdict,deque,Counter\r\nfrom bisect import bisect_left,bisect_right\r\nfrom heapq import heappush,heappop\r\nfrom functools import lru_cache\r\nfrom itertools import accumulate\r\nimport math\r\n\r\n# Fast IO Region\r\nBUFSIZE = 8192\r\nclass FastIO(IOBase):\r\n    newlines = 0\r\n    def __init__(self, file):\r\n        self._fd = file.fileno()\r\n        self.buffer = BytesIO()\r\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\r\n        self.write = self.buffer.write if self.writable else None\r\n    def read(self):\r\n        while True:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            if not b:\r\n                break\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines = 0\r\n        return self.buffer.read()\r\n    def readline(self):\r\n        while self.newlines == 0:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            self.newlines = b.count(b\"\\n\") + (not b)\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines -= 1\r\n        return self.buffer.readline()\r\n    def flush(self):\r\n        if self.writable:\r\n            os.write(self._fd, self.buffer.getvalue())\r\n            self.buffer.truncate(0), self.buffer.seek(0)\r\nclass IOWrapper(IOBase):\r\n    def __init__(self, file):\r\n        self.buffer = FastIO(file)\r\n        self.flush = self.buffer.flush\r\n        self.writable = self.buffer.writable\r\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\r\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\r\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\r\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\r\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\r\n\r\n# for _ in range(int(input())):\r\n#     n = int(input())\r\n#     a = list(map(int, input().split(' ')))\r\n\r\n# for _ in range(int(input())):\r\n#     s = input()\r\n#     mn = 'z'\r\n#     for i in range(len(s)):\r\n#         if s[i] < mn:\r\n#             mn = s[i]\r\n#     idx = s.index(mn)\r\n#     ans = []\r\n#     for i in range(len(s)):\r\n#         if i != idx:\r\n#             ans.append(s[i])\r\n#     print(mn, ''.join(ans))\r\n\r\n# def f(a):\r\n#     n = len(a)\r\n#     cnt = [0] * (n + 1)\r\n#     for i in range(n):\r\n#         cnt[a[i]] += 1\r\n#     for i in range(n):\r\n#         a[i] = cnt[a[i]]\r\n\r\n# for _ in range(int(input())):\r\n#     n = int(input())\r\n#     a = list(map(int, input().split(' ')))\r\n#     tot = [a[:]]\r\n#     b = [0] * n\r\n#     while b != a:\r\n#         b = a[:]\r\n#         f(a)\r\n#         tot.append(a[:])\r\n#     for _ in range(int(input())):\r\n#         x, k = list(map(int, input().split(' ')))\r\n#         k = min(k, len(tot) - 1)\r\n#         x -= 1\r\n#         print(tot[k][x])\r\n\r\n# N = int(pow(10 ** 9, 0.5)) + 5\r\n# def get_prime_linear(n):\r\n#     global cnt\r\n#     for i in range(2, n + 1):\r\n#         if not st[i]:\r\n#             primes[cnt] = i\r\n#             cnt += 1\r\n#         for j in range(n):\r\n#             if primes[j] > n / i: break\r\n#             st[primes[j] * i] = True\r\n#             if i % primes[j] == 0: break \r\n# primes, cnt, st = [0] * (N + 5), 0, [False] * (N + 5)\r\n# get_prime_linear(N)\r\n# prime1e3 = primes[:cnt]\r\n\r\n# @lru_cache(None)\r\n# def get_factor(n):\r\n#     res = []\r\n#     for i in prime1e3:\r\n#         if i * i > n:\r\n#             break\r\n#         while n % i == 0:\r\n#             n //= i\r\n#             res.append(i)\r\n#     if n > 1:\r\n#         res.append(n)\r\n#     s = set([1])\r\n#     for i in res:\r\n#         news = set()\r\n#         for j in s:\r\n#             news.add(j)\r\n#             news.add(j * i)\r\n#         s = news\r\n#     return sorted(s)\r\n\r\n# for _ in range(int(input())):\r\n#     n = int(input())\r\n#     a = list(map(int, input().split(' ')))\r\n#     b = []\r\n#     for j in range(32):\r\n#         cnt = 0\r\n#         for i in range(n):\r\n#             if a[i] >> j & 1:\r\n#                 cnt += 1\r\n#         if cnt > 0:\r\n#             b.append(cnt)\r\n#     if not b:\r\n#         print(*list(range(1, n + 1)))\r\n#     else:\r\n#         ans = b[0]\r\n#         for i in range(1, len(b)):\r\n#             ans = math.gcd(ans, b[i])\r\n#         print(*get_factor(ans))\r\n\r\nclass SortedList:\r\n    def __init__(self, iterable=[], _load=200):\r\n        \"\"\"Initialize sorted list instance.\"\"\"\r\n        values = sorted(iterable)\r\n        self._len = _len = len(values)\r\n        self._load = _load\r\n        self._lists = _lists = [values[i:i + _load] for i in range(0, _len, _load)]\r\n        self._list_lens = [len(_list) for _list in _lists]\r\n        self._mins = [_list[0] for _list in _lists]\r\n        self._fen_tree = []\r\n        self._rebuild = True\r\n \r\n    def _fen_build(self):\r\n        \"\"\"Build a fenwick tree instance.\"\"\"\r\n        self._fen_tree[:] = self._list_lens\r\n        _fen_tree = self._fen_tree\r\n        for i in range(len(_fen_tree)):\r\n            if i | i + 1 < len(_fen_tree):\r\n                _fen_tree[i | i + 1] += _fen_tree[i]\r\n        self._rebuild = False\r\n \r\n    def _fen_update(self, index, value):\r\n        \"\"\"Update `fen_tree[index] += value`.\"\"\"\r\n        if not self._rebuild:\r\n            _fen_tree = self._fen_tree\r\n            while index < len(_fen_tree):\r\n                _fen_tree[index] += value\r\n                index |= index + 1\r\n \r\n    def _fen_query(self, end):\r\n        \"\"\"Return `sum(_fen_tree[:end])`.\"\"\"\r\n        if self._rebuild:\r\n            self._fen_build()\r\n \r\n        _fen_tree = self._fen_tree\r\n        x = 0\r\n        while end:\r\n            x += _fen_tree[end - 1]\r\n            end &= end - 1\r\n        return x\r\n \r\n    def _fen_findkth(self, k):\r\n        \"\"\"Return a pair of (the largest `idx` such that `sum(_fen_tree[:idx]) <= k`, `k - sum(_fen_tree[:idx])`).\"\"\"\r\n        _list_lens = self._list_lens\r\n        if k < _list_lens[0]:\r\n            return 0, k\r\n        if k >= self._len - _list_lens[-1]:\r\n            return len(_list_lens) - 1, k + _list_lens[-1] - self._len\r\n        if self._rebuild:\r\n            self._fen_build()\r\n \r\n        _fen_tree = self._fen_tree\r\n        idx = -1\r\n        for d in reversed(range(len(_fen_tree).bit_length())):\r\n            right_idx = idx + (1 << d)\r\n            if right_idx < len(_fen_tree) and k >= _fen_tree[right_idx]:\r\n                idx = right_idx\r\n                k -= _fen_tree[idx]\r\n        return idx + 1, k\r\n \r\n    def _delete(self, pos, idx):\r\n        \"\"\"Delete value at the given `(pos, idx)`.\"\"\"\r\n        _lists = self._lists\r\n        _mins = self._mins\r\n        _list_lens = self._list_lens\r\n \r\n        self._len -= 1\r\n        self._fen_update(pos, -1)\r\n        del _lists[pos][idx]\r\n        _list_lens[pos] -= 1\r\n \r\n        if _list_lens[pos]:\r\n            _mins[pos] = _lists[pos][0]\r\n        else:\r\n            del _lists[pos]\r\n            del _list_lens[pos]\r\n            del _mins[pos]\r\n            self._rebuild = True\r\n \r\n    def _loc_left(self, value):\r\n        \"\"\"Return an index pair that corresponds to the first position of `value` in the sorted list.\"\"\"\r\n        if not self._len:\r\n            return 0, 0\r\n \r\n        _lists = self._lists\r\n        _mins = self._mins\r\n \r\n        lo, pos = -1, len(_lists) - 1\r\n        while lo + 1 < pos:\r\n            mi = (lo + pos) >> 1\r\n            if value <= _mins[mi]:\r\n                pos = mi\r\n            else:\r\n                lo = mi\r\n \r\n        if pos and value <= _lists[pos - 1][-1]:\r\n            pos -= 1\r\n \r\n        _list = _lists[pos]\r\n        lo, idx = -1, len(_list)\r\n        while lo + 1 < idx:\r\n            mi = (lo + idx) >> 1\r\n            if value <= _list[mi]:\r\n                idx = mi\r\n            else:\r\n                lo = mi\r\n \r\n        return pos, idx\r\n \r\n    def _loc_right(self, value):\r\n        \"\"\"Return an index pair that corresponds to the last position of `value` in the sorted list.\"\"\"\r\n        if not self._len:\r\n            return 0, 0\r\n \r\n        _lists = self._lists\r\n        _mins = self._mins\r\n \r\n        pos, hi = 0, len(_lists)\r\n        while pos + 1 < hi:\r\n            mi = (pos + hi) >> 1\r\n            if value < _mins[mi]:\r\n                hi = mi\r\n            else:\r\n                pos = mi\r\n \r\n        _list = _lists[pos]\r\n        lo, idx = -1, len(_list)\r\n        while lo + 1 < idx:\r\n            mi = (lo + idx) >> 1\r\n            if value < _list[mi]:\r\n                idx = mi\r\n            else:\r\n                lo = mi\r\n \r\n        return pos, idx\r\n \r\n    def add(self, value):\r\n        \"\"\"Add `value` to sorted list.\"\"\"\r\n        _load = self._load\r\n        _lists = self._lists\r\n        _mins = self._mins\r\n        _list_lens = self._list_lens\r\n \r\n        self._len += 1\r\n        if _lists:\r\n            pos, idx = self._loc_right(value)\r\n            self._fen_update(pos, 1)\r\n            _list = _lists[pos]\r\n            _list.insert(idx, value)\r\n            _list_lens[pos] += 1\r\n            _mins[pos] = _list[0]\r\n            if _load + _load < len(_list):\r\n                _lists.insert(pos + 1, _list[_load:])\r\n                _list_lens.insert(pos + 1, len(_list) - _load)\r\n                _mins.insert(pos + 1, _list[_load])\r\n                _list_lens[pos] = _load\r\n                del _list[_load:]\r\n                self._rebuild = True\r\n        else:\r\n            _lists.append([value])\r\n            _mins.append(value)\r\n            _list_lens.append(1)\r\n            self._rebuild = True\r\n \r\n    def discard(self, value):\r\n        \"\"\"Remove `value` from sorted list if it is a member.\"\"\"\r\n        _lists = self._lists\r\n        if _lists:\r\n            pos, idx = self._loc_right(value)\r\n            if idx and _lists[pos][idx - 1] == value:\r\n                self._delete(pos, idx - 1)\r\n \r\n    def remove(self, value):\r\n        \"\"\"Remove `value` from sorted list; `value` must be a member.\"\"\"\r\n        _len = self._len\r\n        self.discard(value)\r\n        if _len == self._len:\r\n            raise ValueError('{0!r} not in list'.format(value))\r\n \r\n    def pop(self, index=-1):\r\n        \"\"\"Remove and return value at `index` in sorted list.\"\"\"\r\n        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)\r\n        value = self._lists[pos][idx]\r\n        self._delete(pos, idx)\r\n        return value\r\n \r\n    def bisect_left(self, value):\r\n        \"\"\"Return the first index to insert `value` in the sorted list.\"\"\"\r\n        pos, idx = self._loc_left(value)\r\n        return self._fen_query(pos) + idx\r\n \r\n    def bisect_right(self, value):\r\n        \"\"\"Return the last index to insert `value` in the sorted list.\"\"\"\r\n        pos, idx = self._loc_right(value)\r\n        return self._fen_query(pos) + idx\r\n \r\n    def count(self, value):\r\n        \"\"\"Return number of occurrences of `value` in the sorted list.\"\"\"\r\n        return self.bisect_right(value) - self.bisect_left(value)\r\n \r\n    def __len__(self):\r\n        \"\"\"Return the size of the sorted list.\"\"\"\r\n        return self._len\r\n \r\n    def __getitem__(self, index):\r\n        \"\"\"Lookup value at `index` in sorted list.\"\"\"\r\n        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)\r\n        return self._lists[pos][idx]\r\n \r\n    def __delitem__(self, index):\r\n        \"\"\"Remove value at `index` from sorted list.\"\"\"\r\n        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)\r\n        self._delete(pos, idx)\r\n \r\n    def __contains__(self, value):\r\n        \"\"\"Return true if `value` is an element of the sorted list.\"\"\"\r\n        _lists = self._lists\r\n        if _lists:\r\n            pos, idx = self._loc_left(value)\r\n            return idx < len(_lists[pos]) and _lists[pos][idx] == value\r\n        return False\r\n \r\n    def __iter__(self):\r\n        \"\"\"Return an iterator over the sorted list.\"\"\"\r\n        return (value for _list in self._lists for value in _list)\r\n \r\n    def __reversed__(self):\r\n        \"\"\"Return a reverse iterator over the sorted list.\"\"\"\r\n        return (value for _list in reversed(self._lists) for value in reversed(_list))\r\n \r\n    def __repr__(self):\r\n        \"\"\"Return string representation of sorted list.\"\"\"\r\n        return 'SortedList({0})'.format(list(self))\r\n\r\n# def solve():\r\n#     n = int(input())\r\n#     a = [0] + list(map(int, input().split(' ')))\r\n#     b = [0] + list(map(int, input().split(' ')))\r\n#     q = deque()\r\n#     q.append((n, n, 0))\r\n#     st = SortedList(list(range(n)))\r\n#     pre = [-1] * (n + 1)\r\n#     while q:\r\n#         x, y, d = q.popleft()\r\n#         for i in range(len(st) -1, -1, -1):\r\n#             if st[i] < x - a[x]:\r\n#                 break\r\n#             else:\r\n#                 if st[i] == 0:\r\n#                     print(d + 1)\r\n#                     ans = [0, y]\r\n#                     t = y\r\n#                     while t != n:\r\n#                         ans.append(pre[t])\r\n#                         t = pre[t]\r\n#                     ans.pop()\r\n#                     ans = ans[::-1]\r\n#                     print(*ans)\r\n#                     return\r\n#                 q.append((st[i] + b[st[i]], st[i], d + 1))\r\n#                 pre[st[i]] = y\r\n#                 st.pop(i)\r\n#     print(-1)\r\n# solve()\r\n\r\nN = 10 ** 9\r\nn, d = list(map(int, input().split(' ')))\r\nb = []\r\nc = []\r\nfor _ in range(n):\r\n    s, a = list(map(int, input().split(' ')))\r\n    if s >= d:\r\n        b.append(s)\r\n        c.append(a)\r\nif not b:\r\n    print(0)\r\nelse:\r\n    id = [i for i in range(len(b))] \r\n    id.sort(key=lambda x:max(b[x], c[x]) * N + b[x])\r\n    ans = 0\r\n    for i in range(len(b)):\r\n        if b[id[i]] >= d:\r\n            d = max(d, c[id[i]])\r\n            ans += 1\r\n    print(ans)\r\n\r\n\r\n        \r\n",
    "prob_desc_created_at": "1635143700",
    "tags": [
        "data structures",
        "dp",
        "greedy",
        "sortings"
    ],
    "hidden_unit_tests": ""
}
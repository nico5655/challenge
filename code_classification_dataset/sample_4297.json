{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"8\\n4\\n0\\n2\\n1\\n5\"]",
    "src_uid": "8e9ba5a2472984cd14b99790a157acd5",
    "prob_desc_notes": "NoteThe first test case is analyzed in the statement.In the second test case, you can get a total value equal to $$$4$$$ if you put the first and second goods in the first package and the third and fourth goods in the second package.In the third test case, the cost of each item is $$$0$$$, so the total cost will also be $$$0$$$.",
    "prob_desc_description": "A batch of $$$n$$$ goods ($$$n$$$ — an even number) is brought to the store, $$$i$$$-th of which has weight $$$a_i$$$. Before selling the goods, they must be packed into packages. After packing, the following will be done:   There will be $$$\\frac{n}{2}$$$ packages, each package contains exactly two goods;  The weight of the package that contains goods with indices $$$i$$$ and $$$j$$$ ($$$1 \\le i, j \\le n$$$) is $$$a_i + a_j$$$. With this, the cost of a package of weight $$$x$$$ is always $$$\\left \\lfloor\\frac{x}{k}\\right\\rfloor$$$ burles (rounded down), where $$$k$$$ — a fixed and given value.Pack the goods to the packages so that the revenue from their sale is maximized. In other words, make such $$$\\frac{n}{2}$$$ pairs of given goods that the sum of the values $$$\\left \\lfloor\\frac{x_i}{k} \\right \\rfloor$$$, where $$$x_i$$$ is the weight of the package number $$$i$$$ ($$$1 \\le i \\le \\frac{n}{2}$$$), is maximal.For example, let $$$n = 6, k = 3$$$, weights of goods $$$a = [3, 2, 7, 1, 4, 8]$$$. Let's pack them into the following packages.   In the first package we will put the third and sixth goods. Its weight will be $$$a_3 + a_6 = 7 + 8 = 15$$$. The cost of the package will be $$$\\left \\lfloor\\frac{15}{3}\\right\\rfloor = 5$$$ burles.  In the second package put the first and fifth goods, the weight is $$$a_1 + a_5 = 3 + 4 = 7$$$. The cost of the package is $$$\\left \\lfloor\\frac{7}{3}\\right\\rfloor = 2$$$ burles.  In the third package put the second and fourth goods, the weight is $$$a_2 + a_4 = 2 + 1 = 3$$$. The cost of the package is $$$\\left \\lfloor\\frac{3}{3}\\right\\rfloor = 1$$$ burle. With this packing, the total cost of all packs would be $$$5 + 2 + 1 = 8$$$ burles.",
    "prob_desc_output_spec": "For each test case, print on a separate line a single number — the maximum possible total cost of all the packages.",
    "prob_desc_input_spec": "The first line of the input contains an integer $$$t$$$ ($$$1 \\le t \\le 10^4$$$) —the number of test cases in the test. The descriptions of the test cases follow. The first line of each test case contains two integers $$$n$$$ ($$$2 \\le n \\le 2\\cdot10^5$$$) and $$$k$$$ ($$$1 \\le k \\le 1000$$$). The number $$$n$$$ — is even. The second line of each test case contains exactly $$$n$$$ integers $$$a_1, a_2, \\dots, a_n$$$ ($$$0 \\le a_i \\le 10^9$$$). It is guaranteed that the sum of $$$n$$$ over all the test cases does not exceed $$$2\\cdot10^5$$$.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3-64",
    "lang_cluster": "Python",
    "difficulty": 1500,
    "file_name": "train_094.jsonl",
    "code_uid": "0155778ceea34bdfebd53f38bfaa6e85",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"6\\n\\n6 3\\n\\n3 2 7 1 4 8\\n\\n4 3\\n\\n2 1 5 6\\n\\n4 12\\n\\n0 0 0 0\\n\\n2 1\\n\\n1 1\\n\\n6 10\\n\\n2 0 0 5 9 4\\n\\n6 5\\n\\n5 3 8 6 3 2\"]",
    "exec_outcome": "PASSED",
    "source_code": "t = int(input())\r\nfor z in range(t):\r\n    n, k = map(int,input().split())\r\n    arr = list(map(int,input().split()))\r\n    count = 0\r\n    for i in range(len(arr)):\r\n        count += arr[i]//k\r\n        arr[i] = arr[i]%k\r\n# узнали сколько целых k будет в каждом элементе\r\n# создали массив остатков\r\n# каждый остаток по одиночке заведомо меньше k\r\n# сумма двух остатков при делении на k нацело может дать либо 1 либо 0\r\n# нужно получить список элементов с их количеством\r\n# элементов будет не больше k (от нуля до k-1)\r\n# попробуем последовательно прибавлять к самому большому самое маленькое, которое есть в доступе\r\n# и который в сумме с ним дает при делении на k нацело единицу\r\n# если такого элемента не нашлось, значит большее значение получить невозможно\r\n\r\n# создадим список с уникальными элементами, остатками от деления первоначального списка \r\n# чтобы не искать элементы по индексу каждый раз, мы создадим избыточный список со значениями от 0 \r\n# до k-1\r\n    elements = list([[i,0] for i in range(k)])\r\n    for i in range(len(arr)):\r\n        elements[arr[i]][1] += 1\r\n        \r\n    for i in reversed(range(len(elements))):\r\n        if elements[i][1] == 0:\r\n            elements.pop(i)\r\n    elements.sort(reverse = True)\r\n# теперь у нас есть отсортированный по убыванию список остатков\r\n# их всегда будет парное количество\r\n# теперь нужно организовать процедуру поиска подходящих значений\r\n# начнем мы с самого большого\r\n# к нему нужно подобрать наименьшее подходящее\r\n    # print('elements',elements)\r\n    for i in range(len(elements)):\r\n        val = elements[i][0]\r\n        qua = elements[i][1]\r\n        j = len(elements)-1\r\n        \r\n        while (j>=i) and (qua>0):\r\n            if elements[j][0] + val >= k:\r\n                # print('svinable!')\r\n# subtraction - это сколько элементов мы смогли израсходовать за одну итерацию\r\n                if i != j:\r\n                    subtraction = min(qua,elements[j][1])\r\n    # значит, количество этих сумм даст нам столько единиц прибавки\r\n                    count += subtraction\r\n                    qua -= subtraction\r\n                    elements[j][1] -= subtraction\r\n                elif qua >= 2:\r\n                    got = qua // 2\r\n                    count += got\r\n                    elements[j][1] -= 2*got\r\n                    \r\n            j-= 1\r\n# если после цикла while у нас не израсходовались все максимальные элементы, то дальше поиск не\r\n# принесет результатов\r\n# я не учел возможность складывать с самим собой!\r\n        if qua > 0:\r\n            break\r\n                \r\n    print(count)    \r\n    \r\n    ",
    "prob_desc_created_at": "1654612500",
    "tags": [
        "binary search",
        "greedy",
        "math",
        "two pointers"
    ],
    "hidden_unit_tests": ""
}
{
    "prob_desc_time_limit": "6 seconds",
    "prob_desc_sample_outputs": "[\"4\"]",
    "src_uid": "507e3e805e91a91e5130f53588e62dab",
    "prob_desc_notes": "NoteAfter the trap is set, the new energy requirement for the first Corridor may be either smaller, larger, or equal to the old energy requiremenet.In the example, if the energy of the first Corridor is set to $$$4$$$ or less, then the Daleks may use the set of Corridors $$$\\{ \\{ 1,2 \\}, \\{ 2,3 \\} \\}$$$ (in particular, if it were set to less than $$$4$$$, then this would be the only set of Corridors that they would use). However, if it is larger than $$$4$$$, then they will instead use the set $$$\\{ \\{2,3\\}, \\{3,1\\} \\}$$$.",
    "prob_desc_description": "Heidi found out that the Daleks have created a network of bidirectional Time Corridors connecting different destinations (at different times!). She suspects that they are planning another invasion on the entire Space and Time. In order to counter the invasion, she plans to deploy a trap in the Time Vortex, along a carefully chosen Time Corridor. She knows that tinkering with the Time Vortex is dangerous, so she consulted the Doctor on how to proceed. She has learned the following:  Different Time Corridors require different amounts of energy to keep stable.  Daleks are unlikely to use all corridors in their invasion. They will pick a set of Corridors that requires the smallest total energy to maintain, yet still makes (time) travel possible between any two destinations (for those in the know: they will use a minimum spanning tree).  Setting the trap may modify the energy required to keep the Corridor stable. Heidi decided to carry out a field test and deploy one trap, placing it along the first Corridor. But she needs to know whether the Daleks are going to use this corridor after the deployment of the trap. She gives you a map of Time Corridors (an undirected graph) with energy requirements for each Corridor.For a Corridor $$$c$$$, $$$E_{max}(c)$$$ is the largest $$$e \\le 10^9$$$ such that if we changed the required amount of energy of $$$c$$$ to $$$e$$$, then the Daleks may still be using $$$c$$$ in their invasion (that is, it belongs to some minimum spanning tree). Your task is to calculate $$$E_{max}(c_1)$$$ for the Corridor $$$c_1$$$ that Heidi plans to arm with a trap, which is the first edge in the graph.",
    "prob_desc_output_spec": "Output a single integer: $$$E_{max}(c_1)$$$ for the first Corridor $$$c_1$$$ from the input.",
    "prob_desc_input_spec": "The first line contains integers $$$n$$$ and $$$m$$$ ($$$2 \\leq n \\leq 10^5$$$, $$$n - 1 \\leq m \\leq 10^6$$$), number of destinations to be invaded and the number of Time Corridors. Each of the next $$$m$$$ lines describes a Corridor: destinations $$$a$$$, $$$b$$$ and energy $$$e$$$ ($$$1 \\leq a, b \\leq n$$$, $$$a \\neq b$$$, $$$0 \\leq e \\leq 10^9$$$). It's guaranteed, that no pair $$$\\{a, b\\}$$$ will repeat and that the graph is connected — that is, it is possible to travel between any two destinations using zero or more Time Corridors.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "Python 2",
    "lang_cluster": "Python",
    "difficulty": 1900,
    "file_name": "train_026.jsonl",
    "code_uid": "3dcbeb2f45226a36dd152e22fb99488c",
    "prob_desc_memory_limit": "128 megabytes",
    "prob_desc_sample_inputs": "[\"3 3\\n1 2 8\\n2 3 3\\n3 1 4\"]",
    "exec_outcome": "PASSED",
    "source_code": "from __future__ import division, print_function\ndef main():\n    class DSU:\n        def __init__ (self,n):\n            self.parent=list(range(n))\n            self.size=[1]*n\n            self.count_sets=n\n        def find(self,u):\n            to_update=[]\n            while u!=self.parent[u]:\n                to_update.append(u)\n                u=self.parent[u]\n            for v in to_update:\n                self.parent[v]=u\n            return u\n        def union(self,u,v):\n            u=self.find(u)\n            v=self.find(v)\n            if u==v:\n                return\n            if self.size[u] < self.size[v]:\n                u,v=v,u\n            self.count_sets-=1\n            self.parent[v]=u\n            self.size[u]+=self.size[v]\n        def set_size(self,a):\n            return self.size[self.find(a)]\n    n,m=map(int,input().split())\n    a,b,e=map(int,input().split())\n    a-=1\n    b-=1\n    l1=[]\n    flag1=0\n    flag2=0\n    for i in range(m-1):\n        x,y,z=map(int,input().split())\n        l1.append((z,x-1,y-1))\n    l1.sort()\n    import sys\n    my_dsu=DSU(n)\n    for item in l1:\n        if my_dsu.find(item[1])!=my_dsu.find(item[2]):\n            my_dsu.union(item[1],item[2])\n        if my_dsu.find(a)==my_dsu.find(b):\n            print(item[0])\n            sys.exit()\n    print(10**9)\npy2 = round(0.5)\nif py2:\n    from future_builtins import ascii, filter, hex, map, oct, zip\n    range = xrange\nimport os, sys\nfrom io import IOBase, BytesIO\nBUFSIZE = 8192\nclass FastIO(BytesIO):\n    newlines = 0\n    def __init__(self, file):\n        self._file = file\n        self._fd = file.fileno()\n        self.writable = \"x\" in file.mode or \"w\" in file.mode\n        self.write = super(FastIO, self).write if self.writable else None\n    def _fill(self):\n        s = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n        self.seek((self.tell(), self.seek(0,2), super(FastIO, self).write(s))[0])\n        return s\n    def read(self):\n        while self._fill(): pass\n        return super(FastIO,self).read()\n    def readline(self):\n        while self.newlines == 0:\n            s = self._fill(); self.newlines = s.count(b\"\\n\") + (not s)\n        self.newlines -= 1\n        return super(FastIO, self).readline()\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.getvalue())\n            self.truncate(0), self.seek(0)\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        if py2:\n            self.write = self.buffer.write\n            self.read = self.buffer.read\n            self.readline = self.buffer.readline\n        else:\n            self.write = lambda s:self.buffer.write(s.encode('ascii'))\n            self.read = lambda:self.buffer.read().decode('ascii')\n            self.readline = lambda:self.buffer.readline().decode('ascii')\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip('\\r\\n')\nimport sys\nclass ostream:\n    def __lshift__(self,a):\n        sys.stdout.write(str(a))\n        return self\ncout = ostream()\nendl = '\\n'\ndef readnumbers(zero = 0):\n    conv = ord if py2 else lambda x:x\n    A = []; numb = zero; sign = 1; i = 0; s = sys.stdin.buffer.read()\n    try:\n        while True:\n            if s[i] >= b'0' [0]:\n                numb = 10 * numb + conv(s[i]) - 48\n            elif s[i] == b'-' [0]: sign = -1\n            elif s[i] != b'\\r' [0]:\n                A.append(sign*numb)\n                numb = zero; sign = 1\n            i += 1\n    except:pass\n    if s and s[-1] >= b'0' [0]:\n        A.append(sign*numb)\n    return A\nif __name__== \"__main__\":\n  main()",
    "prob_desc_created_at": "1562483100",
    "tags": [
        "trees",
        "graphs"
    ],
    "hidden_unit_tests": ""
}
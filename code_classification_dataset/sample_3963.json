{
    "prob_desc_time_limit": "6 seconds",
    "prob_desc_sample_outputs": "[\"0\\n1\\n1\\n2\\n0\\n2\\n1\\n0\\n1\\n0\", \"3\\n4\\n3\\n6\\n2\"]",
    "src_uid": "099f65dc735da7cef1151aa8bf1af3bc",
    "prob_desc_notes": "NoteHere is the map of the labyrinth from the second example. The doors are marked red.  ",
    "prob_desc_description": "You found a map of a weirdly shaped labyrinth. The map is a grid, consisting of $$$n$$$ rows and $$$n$$$ columns. The rows of the grid are numbered from $$$1$$$ to $$$n$$$ from bottom to top. The columns of the grid are numbered from $$$1$$$ to $$$n$$$ from left to right.The labyrinth has $$$n$$$ layers. The first layer is the bottom left corner (cell $$$(1, 1)$$$). The second layer consists of all cells that are in the grid and adjacent to the first layer by a side or a corner. The third layer consists of all cells that are in the grid and adjacent to the second layer by a side or a corner. And so on. The labyrinth with $$$5$$$ layers, for example, is shaped as follows:   The layers are separated from one another with walls. However, there are doors in these walls.Each layer (except for layer $$$n$$$) has exactly two doors to the next layer. One door is placed on the top wall of the layer and another door is placed on the right wall of the layer. For each layer from $$$1$$$ to $$$n-1$$$ you are given positions of these two doors. The doors can be passed in both directions: either from layer $$$i$$$ to layer $$$i+1$$$ or from layer $$$i+1$$$ to layer $$$i$$$.If you are standing in some cell, you can move to an adjacent by a side cell if a wall doesn't block your move (e.g. you can't move to a cell in another layer if there is no door between the cells).Now you have $$$m$$$ queries of sort: what's the minimum number of moves one has to make to go from cell $$$(x_1, y_1)$$$ to cell $$$(x_2, y_2)$$$.",
    "prob_desc_output_spec": "For each query, print a single integer — the minimum number of moves one has to make to go from cell $$$(x_1, y_1)$$$ to cell $$$(x_2, y_2)$$$.",
    "prob_desc_input_spec": "The first line contains a single integer $$$n$$$ ($$$2 \\le n \\le 10^5$$$) — the number of layers in the labyrinth. The $$$i$$$-th of the next $$$n-1$$$ lines contains four integers $$$d_{1,x}, d_{1,y}, d_{2,x}$$$ and $$$d_{2,y}$$$ ($$$1 \\le d_{1,x}, d_{1,y}, d_{2,x}, d_{2,y} \\le n$$$) — the coordinates of the doors. Both cells are on the $$$i$$$-th layer. The first cell is adjacent to the top wall of the $$$i$$$-th layer by a side — that side is where the door is. The second cell is adjacent to the right wall of the $$$i$$$-th layer by a side — that side is where the door is. The next line contains a single integer $$$m$$$ ($$$1 \\le m \\le 2 \\cdot 10^5$$$) — the number of queries. The $$$j$$$-th of the next $$$m$$$ lines contains four integers $$$x_1, y_1, x_2$$$ and $$$y_2$$$ ($$$1 \\le x_1, y_1, x_2, y_2 \\le n$$$) — the coordinates of the cells in the $$$j$$$-th query.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3-64",
    "lang_cluster": "Python",
    "difficulty": 2600,
    "file_name": "train_087.jsonl",
    "code_uid": "77b713463e795cf2e95c7beb87556c99",
    "prob_desc_memory_limit": "512 megabytes",
    "prob_desc_sample_inputs": "[\"2\\n1 1 1 1\\n10\\n1 1 1 1\\n1 1 1 2\\n1 1 2 1\\n1 1 2 2\\n1 2 1 2\\n1 2 2 1\\n1 2 2 2\\n2 1 2 1\\n2 1 2 2\\n2 2 2 2\", \"4\\n1 1 1 1\\n2 1 2 2\\n3 2 1 3\\n5\\n2 4 4 3\\n4 4 3 3\\n1 2 3 3\\n2 2 4 4\\n1 4 2 3\"]",
    "exec_outcome": "PASSED",
    "source_code": "#!/usr/bin/env PyPy3\n\nfrom collections import Counter, defaultdict, deque\nimport itertools\nimport re\nimport math\nfrom functools import reduce\nimport operator\nimport bisect\nfrom heapq import *\nimport functools\nmod=998244353\n\nimport sys\nimport os\nfrom io import BytesIO, IOBase\nBUFSIZE = 8192\nclass FastIO(IOBase):\n    newlines = 0\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n\nimport typing\nclass SegTree:\n    def __init__(self,\n                 op: typing.Callable[[typing.Any, typing.Any], typing.Any],\n                 e: typing.Any,\n                 v: typing.Union[int, typing.List[typing.Any]]) -> None:\n        self._op = op\n        self._e = e\n\n        if isinstance(v, int):\n            v = [e] * v\n\n        self._n = len(v)\n        self._log = self._n.bit_length()\n        self._size = 1 << self._log\n        self._d = [e] * (2 * self._size)\n\n        for i in range(self._n):\n            self._d[self._size + i] = v[i]\n        for i in range(self._size - 1, 0, -1):\n            self._update(i)\n\n    def set(self, p: int, x: typing.Any) -> None:\n        assert 0 <= p < self._n\n\n        p += self._size\n        self._d[p] = x\n        for i in range(1, self._log + 1):\n            self._update(p >> i)\n\n    def get(self, p: int) -> typing.Any:\n        assert 0 <= p < self._n\n\n        return self._d[p + self._size]\n\n    def prod(self, left: int, right: int) -> typing.Any:\n        assert 0 <= left <= right <= self._n\n        sml = self._e\n        smr = self._e\n        left += self._size\n        right += self._size\n\n        while left < right:\n            if left & 1:\n                sml = self._op(sml, self._d[left])\n                left += 1\n            if right & 1:\n                right -= 1\n                smr = self._op(self._d[right], smr)\n            left >>= 1\n            right >>= 1\n\n        return self._op(sml, smr)\n\n    def all_prod(self) -> typing.Any:\n        return self._d[1]\n\n    def max_right(self, left: int,\n                  f: typing.Callable[[typing.Any], bool]) -> int:\n        assert 0 <= left <= self._n\n        assert f(self._e)\n\n        if left == self._n:\n            return self._n\n\n        left += self._size\n        sm = self._e\n\n        first = True\n        while first or (left & -left) != left:\n            first = False\n            while left % 2 == 0:\n                left >>= 1\n            if not f(self._op(sm, self._d[left])):\n                while left < self._size:\n                    left *= 2\n                    if f(self._op(sm, self._d[left])):\n                        sm = self._op(sm, self._d[left])\n                        left += 1\n                return left - self._size\n            sm = self._op(sm, self._d[left])\n            left += 1\n\n        return self._n\n\n    def min_left(self, right: int,\n                 f: typing.Callable[[typing.Any], bool]) -> int:\n        assert 0 <= right <= self._n\n        assert f(self._e)\n\n        if right == 0:\n            return 0\n\n        right += self._size\n        sm = self._e\n\n        first = True\n        while first or (right & -right) != right:\n            first = False\n            right -= 1\n            while right > 1 and right % 2:\n                right >>= 1\n            if not f(self._op(self._d[right], sm)):\n                while right < self._size:\n                    right = 2 * right + 1\n                    if f(self._op(self._d[right], sm)):\n                        sm = self._op(self._d[right], sm)\n                        right -= 1\n                return right + 1 - self._size\n            sm = self._op(self._d[right], sm)\n\n        return 0\n\n    def _update(self, k: int) -> None:\n        self._d[k] = self._op(self._d[2 * k], self._d[2 * k + 1])\ndef op(x,y):\n    return [min(x[0] + y[0],x[1] + y[2]),min(x[0] + y[1],x[1] + y[3]),min(x[2] + y[0],x[3] + y[2]),min(x[2] + y[1],x[3] + y[3])]\nINF = 1 << 60\ne = [0,INF,INF,0]\n\nn = int(input())\ndoor = []\nfor _ in range(n-1):\n    d1x,d1y,d2x,d2y = map(int,input().split())\n    d1x -= 1\n    d1y -= 1\n    d2x -= 1\n    d2y -= 1\n    door.append([d1x,d1y,d2x,d2y])\na = [[0] * 4 for _ in range(n-2)]\nfor i in range(n-2):\n    a[i][0] = abs(door[i][0] + 1 - door[i+1][0]) + abs(door[i][1] - door[i+1][1]) + 1\n    a[i][1] = abs(door[i][0] + 1 - door[i+1][2]) + abs(door[i][1] - door[i+1][3]) + 1\n    a[i][2] = abs(door[i][2] - door[i+1][0]) + abs(door[i][3] - door[i+1][1] + 1) + 1\n    a[i][3] = abs(door[i][2] - door[i+1][2]) + abs(door[i][3] - door[i+1][3] + 1) + 1\nseg = SegTree(op,e,a)\n\nm = int(input())\nfor i in range(m):\n    sx,sy,gx,gy=map(int,input().split())\n    sx -= 1\n    sy -= 1\n    gx -= 1\n    gy -= 1\n    p1 = max(sx,sy)\n    p2 = max(gx,gy)\n    if p1 == p2:\n        print(abs(sx - gx) + abs(sy - gy))\n    else:\n        if p1 > p2:\n            sx,gx=gx,sx\n            sy,gy=gy,sy\n            p1,p2=p2,p1\n        '''\n        if p2 == p1 + 1:\n            ans = INF\n            ans = min(ans, abs(sx - door[p1][0]) + abs(sy - door[p1][1]) + 1 + abs(door[p1][0] + 1 - gx) + abs(door[p1][1] - gy))\n            ans = min(ans, abs(sx - door[p1][2]) + abs(sy - door[p1][3]) + 1 + abs(door[p1][2] - gx) + abs(door[p1][3] + 1 - gy))\n            print(ans)\n        '''\n        R = seg.prod(p1,p2 - 1)\n        ans = INF\n        ans = min(ans,abs(sx - door[p1][0]) + abs(sy - door[p1][1]) + R[0] + 1 + abs(gx - door[p2 - 1][0] - 1) + abs(gy - door[p2 - 1][1]))\n        ans = min(ans,abs(sx - door[p1][0]) + abs(sy - door[p1][1]) + R[1] + 1 + abs(gx - door[p2 - 1][2]) + abs(gy - door[p2 - 1][3] - 1))\n        ans = min(ans,abs(sx - door[p1][2]) + abs(sy - door[p1][3]) + R[2] + 1 + abs(gx - door[p2 - 1][0] - 1) + abs(gy - door[p2 - 1][1]))\n        ans = min(ans,abs(sx - door[p1][2]) + abs(sy - door[p1][3]) + R[3] + 1 + abs(gx - door[p2 - 1][2]) + abs(gy - door[p2 - 1][3] - 1))\n        print(ans)",
    "prob_desc_created_at": "1653316500",
    "tags": [
        "data structures",
        "dp",
        "matrices",
        "shortest paths"
    ],
    "hidden_unit_tests": ""
}
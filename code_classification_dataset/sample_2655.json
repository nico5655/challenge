{
    "prob_desc_time_limit": "1 секунда",
    "prob_desc_sample_outputs": "[\"3\", \"3\", \"1\"]",
    "src_uid": "3144d497bd8d7ca469e1b7f4c12dfd6b",
    "prob_desc_notes": "ПримечаниеОдин из возможных ответов на первый тестовый пример:  Один из возможных ответов на второй тестовый пример (обратите внимание, что покрывающий квадрат выходит за пределы карты звездного неба):  Ответ на третий тестовый пример:  ",
    "prob_desc_description": "Карта звёздного неба представляет собой прямоугольное поле, состоящее из n строк по m символов в каждой строке. Каждый символ — это либо «.» (означает пустой участок неба), либо «*» (означает то, что в этом месте на небе есть звезда). Новое издание карты звёздного неба будет напечатано на квадратных листах, поэтому требуется найти минимально возможную сторону квадрата, в который могут поместиться все звезды. Границы искомого квадрата должны быть параллельны сторонам заданного прямоугольного поля.",
    "prob_desc_output_spec": "Выведите одно число — минимально возможную сторону квадрата, которым можно накрыть все звезды.",
    "prob_desc_input_spec": "В первой строке входных данных записаны два числа n и m (1 ≤ n, m ≤ 1000) — количество строк и столбцов на карте звездного неба. В следующих n строках задано по m символов. Каждый символ — это либо «.» (пустой участок неба), либо «*» (звезда). Гарантируется, что на небе есть хотя бы одна звезда.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "Python 3",
    "lang_cluster": "Python",
    "difficulty": 1200,
    "file_name": "train_027.jsonl",
    "code_uid": "6758c2445a7384a81f2daf64bd26ddc4",
    "prob_desc_memory_limit": "256 мегабайт",
    "prob_desc_sample_inputs": "[\"4 4\\n....\\n..*.\\n...*\\n..**\", \"1 3\\n*.*\", \"2 1\\n.\\n*\"]",
    "exec_outcome": "PASSED",
    "source_code": "n, m = map(int,input().split())\nminv = n\nming = m\nmaxv = 0\nmaxg = 0\ni=0\nwhile (i < n):\n str = input()\n j=0\n while (j < m):\n  if (str[j] == '*'):\n   if (minv > i): minv = i\n   if (maxv < i): maxv = i\n   if (ming > j): ming = j\n   if (maxg < j): maxg = j\n  j+= 1\n i += 1\nif ((maxv - minv) > (maxg - ming)):\n n = maxv - minv + 1\n print(n)\nelse:\n m = maxg - ming + 1\n print(m)",
    "prob_desc_created_at": "1458799200",
    "tags": [],
    "hidden_unit_tests": ""
}
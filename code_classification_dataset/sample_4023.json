{
    "prob_desc_time_limit": "1 second",
    "prob_desc_sample_outputs": "[\"1 0 2 \\n0 3 2 1 \\n1 0 2 6 5 4 3\"]",
    "src_uid": "f7ed88c0f33ad9cb1ede2abf185d9ece",
    "prob_desc_notes": "NoteIn the first test case, we have $$$n=3$$$. The array $$$p = [1, 0, 2]$$$ is good since $$$1 + 0 = 1^2$$$, $$$0 + 1 = 1^2$$$, and $$$2 + 2 = 2^2$$$In the second test case, we have $$$n=4$$$. The array $$$p = [0, 3, 2, 1]$$$ is good since $$$0 + 0 = 0^2$$$, $$$3 + 1 = 2^2$$$, $$$2+2 = 2^2$$$, and $$$1+3 = 2^2$$$.",
    "prob_desc_description": "A $$$\\mathbf{0}$$$-indexed array $$$a$$$ of size $$$n$$$ is called good if for all valid indices $$$i$$$ ($$$0 \\le i \\le n-1$$$), $$$a_i + i$$$ is a perfect square$$$^\\dagger$$$.Given an integer $$$n$$$. Find a permutation$$$^\\ddagger$$$ $$$p$$$ of $$$[0,1,2,\\ldots,n-1]$$$ that is good or determine that no such permutation exists.$$$^\\dagger$$$ An integer $$$x$$$ is said to be a perfect square if there exists an integer $$$y$$$ such that $$$x = y^2$$$.$$$^\\ddagger$$$ An array $$$b$$$ is a permutation of an array $$$a$$$ if $$$b$$$ consists of the elements of $$$a$$$ in arbitrary order. For example, $$$[4,2,3,4]$$$ is a permutation of $$$[3,2,4,4]$$$ while $$$[1,2,2]$$$ is not a permutation of $$$[1,2,3]$$$.",
    "prob_desc_output_spec": "For each test case, output $$$n$$$ distinct integers $$$p_0, p_1, \\dots, p_{n-1}$$$ ($$$0 \\le p_i \\le n-1$$$) — the permutation $$$p$$$ — if the answer exists, and $$$-1$$$ otherwise.",
    "prob_desc_input_spec": "The first line contains a single integer $$$t$$$ ($$$1 \\le t \\le 10^4$$$) — the number of test cases. The only line of each test case contains a single integer $$$n$$$ ($$$1 \\le n \\le 10^5$$$) — the length of the permutation $$$p$$$. It is guaranteed that the sum of $$$n$$$ over all test cases does not exceed $$$10^5$$$.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3-64",
    "lang_cluster": "Python",
    "difficulty": 1200,
    "file_name": "train_088.jsonl",
    "code_uid": "6e59fdd22fd5a49304476a4a33b92f62",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"3\\n\\n3\\n\\n4\\n\\n7\"]",
    "exec_outcome": "PASSED",
    "source_code": "t = int(input())\r\n\r\nq = []\r\n\r\nnow = 0\r\n\r\nwhile(now*now <= 200000):\r\n    q.append(now*now)\r\n    now += 1\r\n\r\ndef find(x):\r\n    l = 0\r\n    r = len(q)\r\n    while(r - l > 1):\r\n        mid = (r+l)//2\r\n        if(q[mid] <= x):\r\n            l = mid\r\n        else:\r\n            r = mid\r\n    return (q[l] == x)\r\n\r\nclass Elem:\r\n    count = 0\r\n    mn = 0\r\n    mx = 0\r\n    x = 0\r\n    def  __init__(self, x, mn, mx):\r\n        self.mn = mn\r\n        self.mx = mx\r\n        self.count = mx - mn\r\n        self.x = x\r\n\r\ndef trouble(x):\r\n    #print(x, \"T\", a)\r\n    for y in mt[x]:\r\n        if(not (y in alr_change)):\r\n            if(a[y] == -1):\r\n                a[y] = x\r\n                who_use[x] = y\r\n                not_use.remove(x)\r\n                alr_change.clear()\r\n                return -1\r\n            else:\r\n                problem_elem = a[y] + 0\r\n                a[y] = x\r\n                who_use[x] = y\r\n                not_use.remove(x)\r\n                not_use.add(problem_elem)\r\n                alr_change.add(y)\r\n                return problem_elem\r\n    else:\r\n        alr_change.clear()\r\n        return x\r\n    \r\nNULL = Elem(-1,-1,-1)\r\n\r\nalr_change = set()\r\n\r\ndef solve(x):\r\n    choose = -1\r\n    mnx = 1000000000000\r\n    for y in mt[x.x]:\r\n        if(who_use[y] == -1 and y < mnx):\r\n            choose = y\r\n            mnx = y\r\n    if(choose == -1):\r\n        while(a[x.x] == -1):\r\n            problem_elem = list(not_use)[0]\r\n            while(problem_elem != -1):\r\n                problem_elem = trouble(problem_elem)\r\n    else:\r\n        a[x.x] = choose\r\n        who_use[choose] = x.x\r\n        not_use.remove(choose)\r\n\r\nfor test in range(1, t+1):\r\n    n = int(input())\r\n    if(find(n)):\r\n        print(0, end = \" \")\r\n        now = n - 1\r\n        while(now > 0):\r\n            print(now, end = \" \")\r\n            now -= 1\r\n        print()\r\n        continue\r\n    mt = []\r\n    for i in range(n):\r\n        mt.append([])\r\n        j = 0\r\n        while(j < len(q) and q[j] <= (n+n-2)):\r\n            if(q[j] - i >= 0 and q[j] - i < n):\r\n                mt[i].append(q[j]-i)\r\n            j += 1\r\n        #print(mt[i])\r\n    a = [-1] * n\r\n\r\n    queue = []\r\n    need = [0] * n\r\n    for i in range(n):\r\n        mn = -1\r\n        mx = -1\r\n\r\n        l = -1\r\n        r = len(q)-1\r\n        while(r - l > 1):\r\n            mid = (r+l)//2\r\n            if(q[mid] < i):\r\n                l = mid\r\n            else:\r\n                r = mid\r\n        mn = r\r\n\r\n        l = 0\r\n        r = len(q)\r\n        while(r - l > 1):\r\n            mid = (r+l)//2\r\n            if(q[mid] <= i+n-1):\r\n                l = mid\r\n            else:\r\n                r = mid\r\n        mx = l\r\n        queue.append(Elem(i, mn, mx))\r\n        for j in range(mn, mx+1):\r\n            need[q[j]-i]+=1\r\n    queue.sort(key=lambda elem: (-elem.x))\r\n    OK = True\r\n    who_use = dict()\r\n    not_use = set()\r\n    for i in range(n):\r\n        who_use[i] = -1\r\n        not_use.add(i)\r\n    for x in queue:\r\n        solve(x)\r\n    if(OK):\r\n        print(*a)\r\n    else:\r\n        print(-1)\r\n        \r\n        \r\n",
    "prob_desc_created_at": "1659796500",
    "tags": [
        "constructive algorithms",
        "dp",
        "math"
    ],
    "hidden_unit_tests": ""
}
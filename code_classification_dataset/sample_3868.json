{
    "prob_desc_time_limit": "2.5 seconds",
    "prob_desc_sample_outputs": "[\"2 1 0 1\\n1 2 1 0\\n0 1 2 1\\n1 0 1 2\", \"1 0 0 0 0 0 0 0\\n0 2 0 0 0 0 2 0\\n0 0 1 0 1 1 0 0\\n0 0 0 2 0 0 0 2\\n0 0 1 0 1 1 0 0\\n0 0 1 0 1 1 0 0\\n0 2 0 0 0 0 2 0\\n0 0 0 2 0 0 0 2\"]",
    "src_uid": "23467790e295f49feaaf1fc64beafa86",
    "prob_desc_notes": "NoteThe following picture describes the first example.The tree with red edges is a BFS tree rooted at both $$$1$$$ and $$$2$$$.Similarly, the BFS tree for other adjacent pairs of vertices can be generated in this way.",
    "prob_desc_description": "We define a spanning tree of a graph to be a BFS tree rooted at vertex $$$s$$$ if and only if for every node $$$t$$$ the shortest distance between $$$s$$$ and $$$t$$$ in the graph is equal to the shortest distance between $$$s$$$ and $$$t$$$ in the spanning tree. Given a graph, we define $$$f(x,y)$$$ to be the number of spanning trees of that graph that are BFS trees rooted at vertices $$$x$$$ and $$$y$$$ at the same time.You are given an undirected connected graph with $$$n$$$ vertices and $$$m$$$ edges. Calculate $$$f(i,j)$$$ for all $$$i$$$, $$$j$$$ by modulo $$$998\\,244\\,353$$$.",
    "prob_desc_output_spec": "Print $$$n$$$ lines, each consisting of $$$n$$$ integers. The integer printed in the row $$$i$$$ and the column $$$j$$$ should be $$$f(i,j) \\bmod 998\\,244\\,353$$$.",
    "prob_desc_input_spec": "The first line contains two integers $$$n$$$, $$$m$$$ ($$$1 \\le n \\le 400$$$, $$$0 \\le m \\le 600$$$) — the number of vertices and the number of edges in the graph. The $$$i$$$-th of the next $$$m$$$ lines contains two integers $$$a_i$$$, $$$b_i$$$ ($$$1 \\leq a_i, b_i \\leq n$$$, $$$a_i &lt; b_i$$$), representing an edge connecting $$$a_i$$$ and $$$b_i$$$. It is guaranteed that all edges are distinct and the graph is connected.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3",
    "lang_cluster": "Python",
    "difficulty": 2600,
    "file_name": "train_085.jsonl",
    "code_uid": "89a5265b7f65c09bcc7a586db0959607",
    "prob_desc_memory_limit": "512 megabytes",
    "prob_desc_sample_inputs": "[\"4 4\\n1 2\\n2 3\\n3 4\\n1 4\", \"8 9\\n1 2\\n1 3\\n1 4\\n2 7\\n3 5\\n3 6\\n4 8\\n2 3\\n3 4\"]",
    "exec_outcome": "PASSED",
    "source_code": "#!/usr/bin/env python\r\nimport os\r\nimport sys\r\nfrom io import BytesIO, IOBase\r\n \r\ndef main():\r\n    n,m = map(int,input().split())\r\n    MOD = 998244353\r\n    adjList = []\r\n    dist = []\r\n    ans = []\r\n    for _ in range(n):\r\n        adjList.append([])\r\n    for _ in range(m):\r\n        a,b = map(int,input().split())\r\n        adjList[a - 1].append(b - 1)\r\n        adjList[b - 1].append(a - 1)\r\n    for i in range(n):\r\n        curDist = [-1] * n\r\n        curDist[i] = 0\r\n        bfsQueue = [i]\r\n        bfsIndex = 0\r\n        while len(bfsQueue) > bfsIndex:\r\n            c = bfsQueue[bfsIndex]\r\n            bfsIndex += 1\r\n            for elem in adjList[c]:\r\n                if curDist[elem] == -1:\r\n                    curDist[elem] = curDist[c] + 1\r\n                    bfsQueue.append(elem)\r\n        dist.append(curDist)\r\n    for _ in range(n):\r\n        ans.append([0] * n)\r\n    for i in range(n):\r\n        for j in range(i, n):\r\n            # Find shortest path between i and j\r\n            isCovered = [False] * n\r\n            isCovered[i] = True\r\n            isCovered[j] = True\r\n            jCpy = j\r\n            flag = True\r\n            while jCpy != i:\r\n                cnt = 0\r\n                cntIndex = -1\r\n                for elem in adjList[jCpy]:\r\n                    if dist[i][elem] == dist[i][jCpy] - 1:\r\n                        cnt += 1\r\n                        cntIndex = elem\r\n                if cnt >= 2:\r\n                    flag = False\r\n                    break\r\n                else:\r\n                    isCovered[cntIndex] = True\r\n                    jCpy = cntIndex\r\n            if not flag:\r\n                ans[i][j] = 0\r\n                ans[j][i] = 0\r\n            else:\r\n                curAns = 1\r\n                for k in range(n):\r\n                    if isCovered[k]:\r\n                        continue\r\n                    cnt = 0\r\n                    for elem in adjList[k]:\r\n                        if dist[i][elem] == dist[i][k] - 1 and dist[j][elem] == dist[j][k] - 1:\r\n                            cnt += 1\r\n                    curAns *= cnt\r\n                    curAns %= MOD\r\n                ans[i][j] = curAns\r\n                ans[j][i] = curAns\r\n    for elem in ans:\r\n        print(\" \".join(map(str,elem)))\r\n \r\n \r\n \r\n# region fastio\r\n \r\nBUFSIZE = 8192\r\n \r\n \r\nclass FastIO(IOBase):\r\n    newlines = 0\r\n \r\n    def __init__(self, file):\r\n        self._fd = file.fileno()\r\n        self.buffer = BytesIO()\r\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\r\n        self.write = self.buffer.write if self.writable else None\r\n \r\n    def read(self):\r\n        while True:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            if not b:\r\n                break\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines = 0\r\n        return self.buffer.read()\r\n \r\n    def readline(self):\r\n        while self.newlines == 0:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            self.newlines = b.count(b\"\\n\") + (not b)\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines -= 1\r\n        return self.buffer.readline()\r\n \r\n    def flush(self):\r\n        if self.writable:\r\n            os.write(self._fd, self.buffer.getvalue())\r\n            self.buffer.truncate(0), self.buffer.seek(0)\r\n \r\n \r\nclass IOWrapper(IOBase):\r\n    def __init__(self, file):\r\n        self.buffer = FastIO(file)\r\n        self.flush = self.buffer.flush\r\n        self.writable = self.buffer.writable\r\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\r\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\r\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\r\n \r\n \r\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\r\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\r\n \r\n# endregion\r\n \r\nif __name__ == \"__main__\":\r\n    main()\r\n",
    "prob_desc_created_at": "1615377900",
    "tags": [
        "combinatorics",
        "dfs and similar",
        "graphs",
        "math",
        "shortest paths",
        "trees"
    ],
    "hidden_unit_tests": ""
}
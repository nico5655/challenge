{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"0\\n1\\n2\"]",
    "src_uid": "c72d6f6b365354bea0c9cab81e34b395",
    "prob_desc_notes": "NoteIn the first test case, there is only one vertex, so you don't need any queries.In the second test case, you can ask a single query about the node $$$1$$$. Then, if $$$x = 1$$$, you will get $$$0$$$, otherwise you will get $$$1$$$.",
    "prob_desc_description": "The only difference between this problem and D2 is the bound on the size of the tree.You are given an unrooted tree with $$$n$$$ vertices. There is some hidden vertex $$$x$$$ in that tree that you are trying to find.To do this, you may ask $$$k$$$ queries $$$v_1, v_2, \\ldots, v_k$$$ where the $$$v_i$$$ are vertices in the tree. After you are finished asking all of the queries, you are given $$$k$$$ numbers $$$d_1, d_2, \\ldots, d_k$$$, where $$$d_i$$$ is the number of edges on the shortest path between $$$v_i$$$ and $$$x$$$. Note that you know which distance corresponds to which query.What is the minimum $$$k$$$ such that there exists some queries $$$v_1, v_2, \\ldots, v_k$$$ that let you always uniquely identify $$$x$$$ (no matter what $$$x$$$ is).Note that you don't actually need to output these queries.",
    "prob_desc_output_spec": "For each test case print a single nonnegative integer, the minimum number of queries you need, on its own line.",
    "prob_desc_input_spec": "Each test contains multiple test cases. The first line contains the number of test cases $$$t$$$ ($$$1 \\le t \\le 100$$$). Description of the test cases follows. The first line of each test case contains a single integer $$$n$$$ ($$$1 \\le n \\le 2000$$$)  — the number of vertices in the tree. Each of the next $$$n-1$$$ lines contains two integers $$$x$$$ and $$$y$$$ ($$$1 \\le x, y \\le n$$$), meaning there is an edges between vertices $$$x$$$ and $$$y$$$ in the tree. It is guaranteed that the given edges form a tree. It is guaranteed that the sum of $$$n$$$ over all test cases does not exceed $$$2000$$$.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3-64",
    "lang_cluster": "Python",
    "difficulty": 2200,
    "file_name": "train_089.jsonl",
    "code_uid": "7f86192b7ae65d930b46f1f674a35b6c",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"3\\n\\n1\\n\\n2\\n\\n1 2\\n\\n10\\n\\n2 4\\n\\n2 1\\n\\n5 7\\n\\n3 10\\n\\n8 6\\n\\n6 1\\n\\n1 3\\n\\n4 7\\n\\n9 6\"]",
    "exec_outcome": "PASSED",
    "source_code": "#!/usr/bin/env python3\nimport sys\nimport math, random\nimport functools, itertools, collections, heapq, bisect\nfrom collections import Counter, defaultdict, deque\ninput = sys.stdin.readline  # to read input quickly\n\n# available on Google, AtCoder Python3, not available on Codeforces\n# import numpy as np\n# import scipy\n\nm9 = 10**9 + 7  # 998244353\nyes, no = \"YES\", \"NO\"\n# d4 = [(1,0),(0,1),(-1,0),(0,-1)]\n# d8 = [(1,0),(1,1),(0,1),(-1,1),(-1,0),(-1,-1),(0,-1),(1,-1)]\n# d6 = [(2,0),(1,1),(-1,1),(-2,0),(-1,-1),(1,-1)]  # hexagonal layout\nMAXINT = sys.maxsize\ne18 = 10**18 + 10\n\n# if testing locally, print to terminal with a different color\nCHECK_OFFLINE_TEST = True\n# CHECK_OFFLINE_TEST = False  # uncomment this on Codechef\nif CHECK_OFFLINE_TEST:\n    import getpass\n    OFFLINE_TEST = getpass.getuser() == \"htong\"\n\ndef log(*args):\n    if CHECK_OFFLINE_TEST and OFFLINE_TEST:\n        print('\\033[36m', *args, '\\033[0m', file=sys.stderr)\n\ndef solve(*args):\n    # screen input\n    if OFFLINE_TEST:\n        log(\"----- solving ------\")\n        log(*args)\n        log(\"----- ------- ------\")\n    return solve_(*args)\n\ndef read_matrix(rows):\n    return [list(map(int,input().split())) for _ in range(rows)]\n\ndef read_strings(rows):\n    return [input().strip() for _ in range(rows)]\n\ndef minus_one(arr):\n    return [x-1 for x in arr]\n\ndef minus_one_matrix(mrr):\n    return [[x-1 for x in row] for row in mrr]\n\n# ---------------------------- template ends here ----------------------------\n\n\ndef dfs(start, g, entry_operation, exit_operation):\n    # https://codeforces.com/contest/1646/submission/148435078\n    # https://codeforces.com/contest/1656/submission/150799881\n    entered = set([start])\n    exiting = set()\n    stack = [start]\n    prev = {}\n\n    null_pointer = \"NULL\"\n    prev[start] = null_pointer\n\n    while stack:\n        cur = stack[-1]\n\n        if cur not in exiting:\n            for nex in g[cur]:\n                if nex in entered:\n                    continue\n\n                entry_operation(prev[cur], cur, nex)\n\n                entered.add(nex)\n                stack.append(nex)\n                prev[nex] = cur\n            exiting.add(cur)\n\n        else:\n            stack.pop()\n            exit_operation(prev[cur], cur)\n\n\n\ndef solve_(mrr, n):\n    # sum of minus one\n    # your solution here\n\n    g = defaultdict(set)\n    for a,b in mrr:\n        g[a].add(b)\n        g[b].add(a)\n\n    if n <= 2:\n        return n-1\n\n    log(g)\n\n    for i in range(n):\n        if len(g[i]) == 2:\n            a,b = g[i]\n            g[a].remove(i)\n            g[b].remove(i)\n            g[a].add(b)\n            g[b].add(a)\n    \n    log(g)\n\n    res = 0\n    for i in range(n):\n        cnt = 0\n        for nex in g[i]:\n            if len(g[nex]) == 1:\n                cnt += 1\n        res += max(0, cnt-1)\n    \n    return res\n\n\n# for case_num in [0]:  # no loop over test case\n# for case_num in range(100):  # if the number of test cases is specified\nfor case_num in range(int(input())):\n\n    # read line as an integer\n    k = int(input())\n\n    # read line as a string\n    # srr = input().strip()\n\n    # read one line and parse each word as a string\n    # arr = input().split()\n\n    # read one line and parse each word as an integer\n    # a,b,c = list(map(int,input().split()))\n    # arr = list(map(int,input().split()))\n    # arr = minus_one(arr)\n\n    # read multiple rows\n    # arr = read_strings(k)  # and return as a list of str\n    mrr = read_matrix(k-1)  # and return as a list of list of int\n    mrr = minus_one_matrix(mrr)\n\n    res = solve(mrr,k)  # include input here\n\n    # print length if applicable\n    # print(len(res))\n\n    # parse result\n    # res = \" \".join(str(x) for x in res)\n    # res = \"\\n\".join(str(x) for x in res)\n    # res = \"\\n\".join(\" \".join(str(x) for x in row) for row in res)\n\n    # print result\n    # print(\"Case #{}: {}\".format(case_num+1, res))   # Google and Facebook - case number required\n\n    print(res)\n",
    "prob_desc_created_at": "1655562900",
    "tags": [
        "brute force",
        "constructive algorithms",
        "dfs and similar",
        "dp",
        "greedy",
        "trees"
    ],
    "hidden_unit_tests": ""
}
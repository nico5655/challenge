{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"2\", \"0\", \"1\"]",
    "src_uid": "51113dfdbf9f59152712b60e7a14368a",
    "prob_desc_notes": "NoteIn the first example you can increase the first element twice and decrease the third element twice, so the sequence becomes $$$[3, 3, 5, 5]$$$, and the difference between maximum and minimum is $$$2$$$. You still can perform one operation after that, but it's useless since you can't make the answer less than $$$2$$$.In the second example all elements are already equal, so you may get $$$0$$$ as the answer even without applying any operations.",
    "prob_desc_description": "You are given a sequence $$$a_1, a_2, \\dots, a_n$$$ consisting of $$$n$$$ integers.You may perform the following operation on this sequence: choose any element and either increase or decrease it by one.Calculate the minimum possible difference between the maximum element and the minimum element in the sequence, if you can perform the aforementioned operation no more than $$$k$$$ times.",
    "prob_desc_output_spec": "Print the minimum possible difference between the maximum element and the minimum element in the sequence, if you can perform the aforementioned operation no more than $$$k$$$ times.",
    "prob_desc_input_spec": "The first line contains two integers $$$n$$$ and $$$k$$$ $$$(2 \\le n \\le 10^{5}, 1 \\le k \\le 10^{14})$$$ â€” the number of elements in the sequence and the maximum number of times you can perform the operation, respectively. The second line contains a sequence of integers $$$a_1, a_2, \\dots, a_n$$$ $$$(1 \\le a_i \\le 10^{9})$$$.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "Python 3",
    "lang_cluster": "Python",
    "difficulty": 2000,
    "file_name": "train_001.jsonl",
    "code_uid": "82ea90e36b003427305d90607cbba397",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"4 5\\n3 1 7 5\", \"3 10\\n100 100 100\", \"10 9\\n4 5 5 7 5 4 5 2 4 3\"]",
    "exec_outcome": "PASSED",
    "source_code": "n, k = [int(x) for x in input().split()]\nd = {}\nb = []\nfor i in map(int, input().split()):\n    if i not in d:\n        b.append(i)\n        d[i] = 1\n    else:\n        d[i] += 1\nb.sort()\n\nmi, ma = 0, len(b) - 1\nleft, right = b[mi], b[ma]\nam_left, am_right = d[b[mi]], d[b[ma]]\nmi, ma = 1, len(b) - 2\n\nwhile right - left > 0:\n    if am_left <= am_right:\n        if (b[mi] - left)*am_left <= k:\n            k -= (b[mi] - left)*am_left\n            left = b[mi]\n            am_left += d[b[mi]]\n            mi += 1\n        else:\n            left += k // am_left\n            break\n    else:\n        if (right - b[ma])*am_right <= k:\n            k -= (right - b[ma])*am_right\n            right = b[ma]\n            am_right += d[b[ma]]\n            ma -= 1\n        else:\n            right -= k // am_right\n            break\n        \nprint(right - left)\n            \n    \n",
    "prob_desc_created_at": "1570957500",
    "tags": [
        "greedy",
        "constructive algorithms",
        "two pointers",
        "sortings",
        "binary search",
        "ternary search"
    ],
    "hidden_unit_tests": ""
}
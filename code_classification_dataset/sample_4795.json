{
    "prob_desc_time_limit": "3 seconds",
    "prob_desc_sample_outputs": "[\"1 2 2 4\", \"2 1 4 3 1\", \"3 4 2 7 7 3\"]",
    "src_uid": "4de02364b27e697b5750f0bd88fac821",
    "prob_desc_notes": null,
    "prob_desc_description": "You are given a weighted undirected connected graph consisting of $$$n$$$ vertices and $$$m$$$ edges. It is guaranteed that there are no self-loops or multiple edges in the given graph.Let's define the weight of the path consisting of $$$k$$$ edges with indices $$$e_1, e_2, \\dots, e_k$$$ as $$$\\sum\\limits_{i=1}^{k}{w_{e_i}} - \\max\\limits_{i=1}^{k}{w_{e_i}} + \\min\\limits_{i=1}^{k}{w_{e_i}}$$$, where $$$w_i$$$ — weight of the $$$i$$$-th edge in the graph.Your task is to find the minimum weight of the path from the $$$1$$$-st vertex to the $$$i$$$-th vertex for each $$$i$$$ ($$$2 \\le i \\le n$$$).",
    "prob_desc_output_spec": "Print $$$n-1$$$ integers — the minimum weight of the path from $$$1$$$-st vertex to the $$$i$$$-th vertex for each $$$i$$$ ($$$2 \\le i \\le n$$$).",
    "prob_desc_input_spec": "The first line contains two integers $$$n$$$ and $$$m$$$ ($$$2 \\le n \\le 2 \\cdot 10^5$$$; $$$1 \\le m \\le 2 \\cdot 10^5$$$) — the number of vertices and the number of edges in the graph. Following $$$m$$$ lines contains three integers $$$v_i, u_i, w_i$$$ ($$$1 \\le v_i, u_i \\le n$$$; $$$1 \\le w_i \\le 10^9$$$; $$$v_i \\neq u_i$$$) — endpoints of the $$$i$$$-th edge and its weight respectively.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3",
    "lang_cluster": "Python",
    "difficulty": 2400,
    "file_name": "train_106.jsonl",
    "code_uid": "a254bf34f9b6d4214757bd9b4c73e7d3",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"5 4\\n5 3 4\\n2 1 1\\n3 2 2\\n2 4 2\", \"6 8\\n3 1 1\\n3 6 2\\n5 4 2\\n4 2 2\\n6 1 1\\n5 2 1\\n3 2 3\\n1 5 4\", \"7 10\\n7 5 5\\n2 3 3\\n4 7 1\\n5 3 6\\n2 7 6\\n6 2 6\\n3 7 6\\n4 2 1\\n3 1 4\\n1 7 4\"]",
    "exec_outcome": "PASSED",
    "source_code": "import io\nimport os\n\n# import __pypy__\n\n\ndef dijkstra(*args):\n    # return dijkstraHeap(*args)  # 2979 ms\n    return dijkstraHeapComparatorWrong(*args)  # 2823 ms\n    # return dijkstraHeapComparator(*args)  # 2370 ms\n    # return dijkstraSegTree(*args)  # 2417 ms with inf=float('inf), 2995 ms with inf=-1\n    # return dijkstraSortedList(*args) # 2995 ms\n\n\ndef dijkstraHeap(source, N, getAdj):\n    # Heap of (dist, node)\n\n    # Use float for dist because max dist for this problem doesn't fit in 32-bit\n    # Then node has to be a float too, because `(float, int)` will use `W_SpecialisedTupleObject_oo` but we want `W_SpecialisedTupleObject_ff`\n\n    from heapq import heappop, heappush\n\n    inf = float(\"inf\")\n    dist = [inf] * N\n    dist[source] = 0.0\n    queue = [(0.0, float(source))]\n    # print(__pypy__.internal_repr(queue[0])) # W_SpecialisedTupleObject_ff\n    # print(__pypy__.strategy(dist)) # FloatListStrategy\n    while queue:\n        d, u = heappop(queue)\n        u = int(u)\n        if dist[u] == d:\n            for v, w in getAdj(u):\n                cost = d + w\n                if cost < dist[v]:\n                    dist[v] = cost\n                    heappush(queue, (cost, float(v)))\n    return dist\n\n\ndef dijkstraHeapComparatorWrong(source, N, getAdj):\n    # Heap of nodes, sorted with a comparator\n    # This implementation is actually incorrect but kept for reference since it performs well when using a SPFA-like heuristic\n    # Note: normal SPFA will TLE since there's a uphack for it in testcase #62\n\n    inf = float(\"inf\")\n    dist = [inf] * N\n    dist[source] = 0.0\n    inQueue = [0] * N\n    inQueue[source] = 1\n    queue = [source]\n    # print(__pypy__.strategy(queue)) # IntegerListStrategy\n\n    def cmp_lt(u, v):\n        return dist[u] < dist[v]\n\n    heappush, heappop, _ = import_heapq(cmp_lt)\n\n    while queue:\n        u = heappop(queue)\n        d = dist[u]\n        inQueue[u] = 0\n        for v, w in getAdj(u):\n            cost = d + w\n            if cost < dist[v]:\n                dist[v] = cost\n                if not inQueue[v]:\n                    heappush(queue, v)\n                    inQueue[v] = 1\n                # If v is already in the queue, we were suppose to bubble it to fix heap invariant\n    return dist\n\n\ndef dijkstraHeapComparator(source, N, getAdj):\n    # Same above, except correctly re-bubbling the key after updates\n\n    inf = float(\"inf\")\n    dist = [inf] * N\n    dist[source] = 0.0\n\n    def cmp_lt(u, v):\n        return dist[u] < dist[v]\n\n    heappush, heappop, _siftdown = import_heapq(cmp_lt)\n\n    class ListWrapper:\n        # Exactly like a regular list except with fast .index(x) meant to be used with heapq\n        # Not general purpose and relies on the exact heapq implementation for correctness (swaps only, added via append, deleted via pop)\n\n        def __init__(self, maxN):\n            self.arr = []\n            self.loc = [-1] * maxN\n\n        def append(self, x):\n            arr = self.arr\n            arr.append(x)\n            self.loc[x] = len(arr) - 1\n\n        def pop(self):\n            ret = self.arr.pop()\n            self.loc[ret] = -1\n            return ret\n\n        def index(self, x):\n            return self.loc[x]\n\n        def __setitem__(self, i, x):\n            self.arr[i] = x\n            self.loc[x] = i\n\n        def __getitem__(self, i):\n            return self.arr[i]\n\n        def __len__(self):\n            return len(self.arr)\n\n    queue = ListWrapper(N)\n    queue.append(source)\n    # print(__pypy__.strategy(queue.arr)) # IntegerListStrategy\n\n    while queue:\n        u = heappop(queue)\n        d = dist[u]\n        for v, w in getAdj(u):\n            cost = d + w\n            if cost < dist[v]:\n                dist[v] = cost\n                heapIndex = queue.index(v)\n                if heapIndex == -1:\n                    heappush(queue, v)\n                else:\n                    _siftdown(queue, 0, heapIndex)\n    return dist\n\n\ndef dijkstraSegTree(start, n, getAdj):\n    # From pajenegod: https://github.com/cheran-senthil/PyRival/pull/55\n    # Modifications:\n    #   Use floats instead of ints for inf/_min\n    #   Fix typo: m -> self.m\n    #   Fix python 3 compatibility: __getitem__\n    #   Cache self.data\n    #   Remove parent pointers\n\n    if False:\n        inf = -1\n\n        def _min(a, b):\n            return a if b == inf or inf != a < b else b\n\n    else:\n        inf = float(\"inf\")\n        _min = min\n\n    class DistanceKeeper:\n        def __init__(self, n):\n            m = 1\n            while m < n:\n                m *= 2\n            self.m = m\n            self.data = 2 * m * [inf]\n            self.dist = n * [inf]\n\n        def __getitem__(self, x):\n            return self.dist[x]\n\n        def __setitem__(self, ind, x):\n            data = self.data\n            self.dist[ind] = x\n            ind += self.m\n            data[ind] = x\n            ind >>= 1\n            while ind:\n                data[ind] = _min(data[2 * ind], data[2 * ind + 1])\n                ind >>= 1\n\n        def trav(self):\n            m = self.m\n            data = self.data\n            dist = self.dist\n            while data[1] != inf:\n                x = data[1]\n\n                ind = 1\n                while ind < m:\n                    ind = 2 * ind + (data[2 * ind] != x)\n                ind -= m\n\n                self[ind] = inf\n                dist[ind] = x\n                yield ind\n\n    # P = [-1] * n\n    D = DistanceKeeper(n)\n    D[start] = 0.0\n\n    for node in D.trav():\n        for nei, weight in getAdj(node):\n            new_dist = D[node] + weight\n            if D[nei] == inf or new_dist < D[nei]:\n                D[nei] = new_dist\n                # P[nei] = node\n    # print(__pypy__.strategy(D.dist))\n    # print(__pypy__.strategy(D.data))\n    return D.dist\n\n\ndef dijkstraSortedList(source, N, getAdj):\n    # Just for completeness\n\n    # COPY AND PASTE from https://github.com/cheran-senthil/PyRival/blob/master/pyrival/data_structures/SortedList.py\n    class SortedList:\n        def __init__(self, iterable=[], _load=200):\n            \"\"\"Initialize sorted list instance.\"\"\"\n            values = sorted(iterable)\n            self._len = _len = len(values)\n            self._load = _load\n            self._lists = _lists = [\n                values[i : i + _load] for i in range(0, _len, _load)\n            ]\n            self._list_lens = [len(_list) for _list in _lists]\n            self._mins = [_list[0] for _list in _lists]\n            self._fen_tree = []\n            self._rebuild = True\n\n        def _fen_build(self):\n            \"\"\"Build a fenwick tree instance.\"\"\"\n            self._fen_tree[:] = self._list_lens\n            _fen_tree = self._fen_tree\n            for i in range(len(_fen_tree)):\n                if i | i + 1 < len(_fen_tree):\n                    _fen_tree[i | i + 1] += _fen_tree[i]\n            self._rebuild = False\n\n        def _fen_update(self, index, value):\n            \"\"\"Update `fen_tree[index] += value`.\"\"\"\n            if not self._rebuild:\n                _fen_tree = self._fen_tree\n                while index < len(_fen_tree):\n                    _fen_tree[index] += value\n                    index |= index + 1\n\n        def _fen_query(self, end):\n            \"\"\"Return `sum(_fen_tree[:end])`.\"\"\"\n            if self._rebuild:\n                self._fen_build()\n\n            _fen_tree = self._fen_tree\n            x = 0\n            while end:\n                x += _fen_tree[end - 1]\n                end &= end - 1\n            return x\n\n        def _fen_findkth(self, k):\n            \"\"\"Return a pair of (the largest `idx` such that `sum(_fen_tree[:idx]) <= k`, `k - sum(_fen_tree[:idx])`).\"\"\"\n            _list_lens = self._list_lens\n            if k < _list_lens[0]:\n                return 0, k\n            if k >= self._len - _list_lens[-1]:\n                return len(_list_lens) - 1, k + _list_lens[-1] - self._len\n            if self._rebuild:\n                self._fen_build()\n\n            _fen_tree = self._fen_tree\n            idx = -1\n            for d in reversed(range(len(_fen_tree).bit_length())):\n                right_idx = idx + (1 << d)\n                if right_idx < len(_fen_tree) and k >= _fen_tree[right_idx]:\n                    idx = right_idx\n                    k -= _fen_tree[idx]\n            return idx + 1, k\n\n        def _delete(self, pos, idx):\n            \"\"\"Delete value at the given `(pos, idx)`.\"\"\"\n            _lists = self._lists\n            _mins = self._mins\n            _list_lens = self._list_lens\n\n            self._len -= 1\n            self._fen_update(pos, -1)\n            del _lists[pos][idx]\n            _list_lens[pos] -= 1\n\n            if _list_lens[pos]:\n                _mins[pos] = _lists[pos][0]\n            else:\n                del _lists[pos]\n                del _list_lens[pos]\n                del _mins[pos]\n                self._rebuild = True\n\n        def _loc_left(self, value):\n            \"\"\"Return an index pair that corresponds to the first position of `value` in the sorted list.\"\"\"\n            if not self._len:\n                return 0, 0\n\n            _lists = self._lists\n            _mins = self._mins\n\n            lo, pos = -1, len(_lists) - 1\n            while lo + 1 < pos:\n                mi = (lo + pos) >> 1\n                if value <= _mins[mi]:\n                    pos = mi\n                else:\n                    lo = mi\n\n            if pos and value <= _lists[pos - 1][-1]:\n                pos -= 1\n\n            _list = _lists[pos]\n            lo, idx = -1, len(_list)\n            while lo + 1 < idx:\n                mi = (lo + idx) >> 1\n                if value <= _list[mi]:\n                    idx = mi\n                else:\n                    lo = mi\n\n            return pos, idx\n\n        def _loc_right(self, value):\n            \"\"\"Return an index pair that corresponds to the last position of `value` in the sorted list.\"\"\"\n            if not self._len:\n                return 0, 0\n\n            _lists = self._lists\n            _mins = self._mins\n\n            pos, hi = 0, len(_lists)\n            while pos + 1 < hi:\n                mi = (pos + hi) >> 1\n                if value < _mins[mi]:\n                    hi = mi\n                else:\n                    pos = mi\n\n            _list = _lists[pos]\n            lo, idx = -1, len(_list)\n            while lo + 1 < idx:\n                mi = (lo + idx) >> 1\n                if value < _list[mi]:\n                    idx = mi\n                else:\n                    lo = mi\n\n            return pos, idx\n\n        def add(self, value):\n            \"\"\"Add `value` to sorted list.\"\"\"\n            _load = self._load\n            _lists = self._lists\n            _mins = self._mins\n            _list_lens = self._list_lens\n\n            self._len += 1\n            if _lists:\n                pos, idx = self._loc_right(value)\n                self._fen_update(pos, 1)\n                _list = _lists[pos]\n                _list.insert(idx, value)\n                _list_lens[pos] += 1\n                _mins[pos] = _list[0]\n                if _load + _load < len(_list):\n                    _lists.insert(pos + 1, _list[_load:])\n                    _list_lens.insert(pos + 1, len(_list) - _load)\n                    _mins.insert(pos + 1, _list[_load])\n                    _list_lens[pos] = _load\n                    del _list[_load:]\n                    self._rebuild = True\n            else:\n                _lists.append([value])\n                _mins.append(value)\n                _list_lens.append(1)\n                self._rebuild = True\n\n        def discard(self, value):\n            \"\"\"Remove `value` from sorted list if it is a member.\"\"\"\n            _lists = self._lists\n            if _lists:\n                pos, idx = self._loc_right(value)\n                if idx and _lists[pos][idx - 1] == value:\n                    self._delete(pos, idx - 1)\n\n        def remove(self, value):\n            \"\"\"Remove `value` from sorted list; `value` must be a member.\"\"\"\n            _len = self._len\n            self.discard(value)\n            if _len == self._len:\n                raise ValueError(\"{0!r} not in list\".format(value))\n\n        def pop(self, index=-1):\n            \"\"\"Remove and return value at `index` in sorted list.\"\"\"\n            pos, idx = self._fen_findkth(self._len + index if index < 0 else index)\n            value = self._lists[pos][idx]\n            self._delete(pos, idx)\n            return value\n\n        def bisect_left(self, value):\n            \"\"\"Return the first index to insert `value` in the sorted list.\"\"\"\n            pos, idx = self._loc_left(value)\n            return self._fen_query(pos) + idx\n\n        def bisect_right(self, value):\n            \"\"\"Return the last index to insert `value` in the sorted list.\"\"\"\n            pos, idx = self._loc_right(value)\n            return self._fen_query(pos) + idx\n\n        def count(self, value):\n            \"\"\"Return number of occurrences of `value` in the sorted list.\"\"\"\n            return self.bisect_right(value) - self.bisect_left(value)\n\n        def __len__(self):\n            \"\"\"Return the size of the sorted list.\"\"\"\n            return self._len\n\n        def __getitem__(self, index):\n            \"\"\"Lookup value at `index` in sorted list.\"\"\"\n            pos, idx = self._fen_findkth(self._len + index if index < 0 else index)\n            return self._lists[pos][idx]\n\n        def __delitem__(self, index):\n            \"\"\"Remove value at `index` from sorted list.\"\"\"\n            pos, idx = self._fen_findkth(self._len + index if index < 0 else index)\n            self._delete(pos, idx)\n\n        def __contains__(self, value):\n            \"\"\"Return true if `value` is an element of the sorted list.\"\"\"\n            _lists = self._lists\n            if _lists:\n                pos, idx = self._loc_left(value)\n                return idx < len(_lists[pos]) and _lists[pos][idx] == value\n            return False\n\n        def __iter__(self):\n            \"\"\"Return an iterator over the sorted list.\"\"\"\n            return (value for _list in self._lists for value in _list)\n\n        def __reversed__(self):\n            \"\"\"Return a reverse iterator over the sorted list.\"\"\"\n            return (\n                value for _list in reversed(self._lists) for value in reversed(_list)\n            )\n\n        def __repr__(self):\n            \"\"\"Return string representation of sorted list.\"\"\"\n            return \"SortedList({0})\".format(list(self))\n\n    # END COPY AND PASTE #####################################\n\n    inf = float(\"inf\")\n    dist = [inf] * N\n    dist[source] = 0.0\n    queue = SortedList([(0.0, float(source))])\n    while queue:\n        negD, u = queue.pop(-1)\n        d = -negD\n        u = int(u)\n        for v, w in getAdj(u):\n            prevCost = dist[v]\n            cost = d + w\n            if cost < prevCost:\n                if prevCost != inf:\n                    queue.discard((-prevCost, float(v)))\n                dist[v] = cost\n                queue.add((-cost, float(v)))\n    return dist\n\n\ndef import_heapq(cmp_lt):\n    # Python 2 has a heapq.cmp_lt but python 3 removed it\n    # Add it back for pypy3 submissions\n\n    import sys\n\n    if sys.version_info < (3,):\n        # Python 2\n        import heapq\n        from heapq import heappush, heappop, _siftdown\n\n        heapq.cmp_lt = cmp_lt\n    else:\n        # Python 3\n        # COPY AND PASTE python 2.7 heapq from https://github.com/python/cpython/blob/2.7/Lib/heapq.py\n\n        def heappush(heap, item):\n            \"\"\"Push item onto heap, maintaining the heap invariant.\"\"\"\n            heap.append(item)\n            _siftdown(heap, 0, len(heap) - 1)\n\n        def heappop(heap):\n            \"\"\"Pop the smallest item off the heap, maintaining the heap invariant.\"\"\"\n            lastelt = heap.pop()  # raises appropriate IndexError if heap is empty\n            if heap:\n                returnitem = heap[0]\n                heap[0] = lastelt\n                _siftup(heap, 0)\n                return returnitem\n            return lastelt\n\n        def _siftdown(heap, startpos, pos):\n            newitem = heap[pos]\n            # Follow the path to the root, moving parents down until finding a place\n            # newitem fits.\n            while pos > startpos:\n                parentpos = (pos - 1) >> 1\n                parent = heap[parentpos]\n                if cmp_lt(newitem, parent):\n                    heap[pos] = parent\n                    pos = parentpos\n                    continue\n                break\n            heap[pos] = newitem\n\n        def _siftup(heap, pos):\n            endpos = len(heap)\n            startpos = pos\n            newitem = heap[pos]\n            # Bubble up the smaller child until hitting a leaf.\n            childpos = 2 * pos + 1  # leftmost child position\n            while childpos < endpos:\n                # Set childpos to index of smaller child.\n                rightpos = childpos + 1\n                if rightpos < endpos and not cmp_lt(heap[childpos], heap[rightpos]):\n                    childpos = rightpos\n                # Move the smaller child up.\n                heap[pos] = heap[childpos]\n                pos = childpos\n                childpos = 2 * pos + 1\n            # The leaf at pos is empty now.  Put newitem there, and bubble it up\n            # to its final resting place (by sifting its parents down).\n            heap[pos] = newitem\n            _siftdown(heap, startpos, pos)\n\n        # END COPY AND PASTE ###############################\n    return heappush, heappop, _siftdown\n\n\nif __name__ == \"__main__\":\n    input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline\n\n    N, M = [int(x) for x in input().split()]\n    graph = [[] for i in range(N)]\n    for i in range(M):\n        u, v, w = [int(x) for x in input().split()]\n        u -= 1\n        v -= 1\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n\n    # Want shortest path except one edge is worth 0 and one edge is worth 2x\n    # Track this with 2 bits of extra state\n    def getAdj(node):\n        u = node >> 2\n        state = node & 3\n        for v, w in graph[u]:\n            vBase = v << 2\n            # Regular edge\n            yield vBase | state, w\n            if not state & 1:\n                # Take max edge, worth 0\n                yield vBase | state | 1, 0\n            if not state & 2:\n                # Take min edge, worth double\n                yield vBase | state | 2, 2 * w\n            if not state & 3:\n                # Take both min and max edge, worth normal\n                yield vBase | state | 3, w\n\n    dist = dijkstra(0, 4 * N, getAdj)\n    print(\" \".join(str(int(dist[(u << 2) | 3])) for u in range(1, N)))\n",
    "prob_desc_created_at": "1610634900",
    "tags": [
        "graphs",
        "shortest paths"
    ],
    "hidden_unit_tests": ""
}
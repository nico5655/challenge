{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"9\", \"8\"]",
    "src_uid": "13fa378c913bb7a15612327099b59f83",
    "prob_desc_notes": null,
    "prob_desc_description": "Ahmed and Mostafa used to compete together in many programming contests for several years. Their coach Fegla asked them to solve one challenging problem, of course Ahmed was able to solve it but Mostafa couldn't.This problem is similar to a standard problem but it has a different format and constraints.In the standard problem you are given an array of integers, and you have to find one or more consecutive elements in this array where their sum is the maximum possible sum.But in this problem you are given n small arrays, and you will create one big array from the concatenation of one or more instances of the small arrays (each small array could occur more than once). The big array will be given as an array of indexes (1-based) of the small arrays, and the concatenation should be done in the same order as in this array. Then you should apply the standard problem mentioned above on the resulting big array.For example let's suppose that the small arrays are {1, 6, -2}, {3, 3} and {-5, 1}. And the indexes in the big array are {2, 3, 1, 3}. So the actual values in the big array after formatting it as concatenation of the small arrays will be {3, 3, -5, 1, 1, 6, -2, -5, 1}. In this example the maximum sum is 9.Can you help Mostafa solve this problem?",
    "prob_desc_output_spec": "Print one line containing the maximum sum in the big array after formatting it as described above. You must choose at least one element for the sum, i. e. it cannot be empty. Please, do not use %lld specificator to write 64-bit integers in C++. It is preferred to use cout (also you may use %I64d).",
    "prob_desc_input_spec": "The first line contains two integers n and m, n is the number of the small arrays (1 ≤ n ≤ 50), and m is the number of indexes in the big array (1 ≤ m ≤ 250000). Then follow n lines, the i-th line starts with one integer l which is the size of the i-th array (1 ≤ l ≤ 5000), followed by l integers each one will be greater than or equal -1000 and less than or equal 1000. The last line contains m integers which are the indexes in the big array, and you should concatenate the small arrays in the same order, and each index will be greater than or equal to 1 and less than or equal to n. The small arrays are numbered from 1 to n in the same order as given in the input. Some of the given small arrays may not be used in big array. Note, that the array is very big. So if you try to build it straightforwardly, you will probably get time or/and memory limit exceeded.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "Python 2",
    "lang_cluster": "Python",
    "difficulty": 2000,
    "file_name": "train_009.jsonl",
    "code_uid": "c25a96faa49e3e48658225110b010057",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"3 4\\n3 1 6 -2\\n2 3 3\\n2 -5 1\\n2 3 1 3\", \"6 1\\n4 0 8 -3 -10\\n8 3 -2 -5 10 8 -9 -5 -4\\n1 0\\n1 -3\\n3 -8 5 6\\n2 9 6\\n1\"]",
    "exec_outcome": "PASSED",
    "source_code": "(n , m) = map(int,raw_input().split())\n\narr = []\n\nfor i in range (n):\n    arr.append(map(int,raw_input().split())[1:])\n\nseq = map(int,raw_input().split())\n\ndef gao(x):\n    ans = - 2 ** 64\n    now = 0\n    for i in range (len(x)):\n        now += x[i]\n        ans = max(ans,now)\n    return ans;\ndef gao2(x):\n    now = x[0]\n    ans = now\n    for i in range(1,len(x)):\n        now = max(x[i] , now + x[i]) \n        ans = max(ans,now)\n    return ans\ndef doit(x):\n    ans = - 2 ** 64\n    now = 0\n    for i in range (len(x) - 1, -1 , -1):\n        now += x[i]\n        ans = max(ans,now)\n    return ans;\n\ndp = []\npre = []\ns = []\naf = []\nbak = []\n\nfor i in range (n):\n    pre.append(doit(arr[i]))\n    s.append(sum(arr[i]))\n    af.append(gao(arr[i]))\n    bak.append(gao2(arr[i]))\ndp.append([sum(arr[seq[0] - 1]),pre[seq[0] - 1]])\n\nfor i in range (1,m):\n    add = max(dp[-1][0],pre[seq[i-1] - 1])\n    dp.append([ add + s[seq[i] - 1] , add + af[seq[i] - 1]  ]  )\n\nans = - 2 ** 64\n\nfor i in range (len(seq)):\n    ans = max(ans,bak[seq[i] - 1])\n\nfor i in range (len(dp)):\n    ans = max(ans,dp[i][0])\n    ans = max(ans,dp[i][1])\n\nprint ans\n",
    "prob_desc_created_at": "1302706800",
    "tags": [
        "dp",
        "greedy",
        "math",
        "implementation",
        "data structures",
        "trees"
    ],
    "hidden_unit_tests": ""
}
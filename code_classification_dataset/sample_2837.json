{
    "prob_desc_time_limit": "4 seconds",
    "prob_desc_sample_outputs": "[\"2\", \"2\"]",
    "src_uid": "9a64ee19cf2d20978870c03311bf6cbf",
    "prob_desc_notes": "NoteGraph from first sample:Graph from second sample:",
    "prob_desc_description": "You are given a set of size $$$m$$$ with integer elements between $$$0$$$ and $$$2^{n}-1$$$ inclusive. Let's build an undirected graph on these integers in the following way: connect two integers $$$x$$$ and $$$y$$$ with an edge if and only if $$$x \\&amp; y = 0$$$. Here $$$\\&amp;$$$ is the bitwise AND operation. Count the number of connected components in that graph.",
    "prob_desc_output_spec": "Print the number of connected components.",
    "prob_desc_input_spec": "In the first line of input there are two integers $$$n$$$ and $$$m$$$ ($$$0 \\le n \\le 22$$$, $$$1 \\le m \\le 2^{n}$$$). In the second line there are $$$m$$$ integers $$$a_1, a_2, \\ldots, a_m$$$ ($$$0 \\le a_{i} &lt; 2^{n}$$$) — the elements of the set. All $$$a_{i}$$$ are distinct.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 2",
    "lang_cluster": "Python",
    "difficulty": 2500,
    "file_name": "train_033.jsonl",
    "code_uid": "08e46f6cf2e865e6bb4993acb797fb70",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"2 3\\n1 2 3\", \"5 5\\n5 19 10 20 12\"]",
    "exec_outcome": "PASSED",
    "source_code": "def main():\n    inp = readnumbers()\n    ii = 0\n\n    n = inp[ii]\n    ii += 1\n    m = inp[ii]\n    ii += 1\n\n    pow2 = 2**n\n    index = [-1]*pow2\n    \n    #coupl = [[] for _ in range(pow2 + m)]\n    for _ in range(m):\n        u = inp[ii]\n        ii += 1\n        index[pow2 - 1 - u] = pow2 + _\n    #    coupl[pow2 - 1 - u].append(pow2 + _)\n    \n\n\n    found = [False]*(pow2 + m)\n    ii = 2\n    ans = 0\n    A = []\n    for _ in range(m):\n        root = pow2 + _\n        ii += 1\n        if found[root]:continue\n        \n        A = [root]\n        found[root] = True\n        for node in A:\n            #for nei in coupl[node]:\n            #    if not found[nei]:\n            #        found[nei] = 1\n            #        A.append(nei)\n            if node < pow2:\n                if index[node]>=0:\n                    nei = index[node]\n                    if not found[nei]:\n                        found[nei] = True\n                        A.append(nei)\n\n                j = 1\n                while j<pow2:\n                    if node&j == 0 and not found[node^j]:\n                        found[node^j] = True\n                        A.append(node^j)\n                    j *= 2\n            else:\n                nei = inp[2 + node - pow2]\n                if not found[nei]:\n                    found[nei] = True\n                    A.append(nei)\n        ans += 1\n    print(ans)\n\n######## Python 2 and 3 footer by Pajenegod and c1729\n\n# Note because cf runs old PyPy3 version which doesn't have the sped up\n# unicode strings, PyPy3 strings will many times be slower than pypy2.\n# There is a way to get around this by using binary strings in PyPy3\n# but its syntax is different which makes it kind of a mess to use.\n\n# So on cf, use PyPy2 for best string performance.\n\npy2 = round(0.5)\nif py2:\n    from future_builtins import ascii, filter, hex, map, oct, zip\n    range = xrange\n\nimport os, sys\nfrom io import IOBase, BytesIO\n\nBUFSIZE = 8192\nclass FastIO(BytesIO):\n    newlines = 0\n\n    def __init__(self, file):\n        self._file = file\n        self._fd = file.fileno()\n        self.writable = \"x\" in file.mode or \"w\" in file.mode\n        self.write = super(FastIO, self).write if self.writable else None\n\n    def _fill(self):\n        s = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n        self.seek((self.tell(), self.seek(0,2), super(FastIO, self).write(s))[0])\n        return s\n\n    def read(self):\n        while self._fill(): pass\n        return super(FastIO,self).read()\n\n    def readline(self):\n        while self.newlines == 0:\n            s = self._fill(); self.newlines = s.count(b\"\\n\") + (not s)\n        self.newlines -= 1\n        return super(FastIO, self).readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.getvalue())\n            self.truncate(0), self.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        if py2:\n            self.write = self.buffer.write\n            self.read = self.buffer.read\n            self.readline = self.buffer.readline\n        else:\n            self.write = lambda s:self.buffer.write(s.encode('ascii'))\n            self.read = lambda:self.buffer.read().decode('ascii')\n            self.readline = lambda:self.buffer.readline().decode('ascii')\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip('\\r\\n')\n\n# Cout implemented in Python\nimport sys\nclass ostream:\n    def __lshift__(self,a):\n        sys.stdout.write(str(a))\n        return self\ncout = ostream()\nendl = '\\n'\n\n# Read all remaining integers in stdin, type is given by optional argument, this is fast\ndef readnumbers(zero = 0):\n    conv = ord if py2 else lambda x:x\n    A = []; numb = zero; sign = 1; i = 0; s = sys.stdin.buffer.read()\n    try:\n        while True:\n            if s[i] >= b'0' [0]:\n                numb = 10 * numb + conv(s[i]) - 48\n            elif s[i] == b'-' [0]: sign = -1\n            elif s[i] != b'\\r' [0]:\n                A.append(sign*numb)\n                numb = zero; sign = 1\n            i += 1\n    except:pass\n    if s and s[-1] >= b'0' [0]:\n        A.append(sign*numb)\n    return A\n\nif __name__== \"__main__\":\n  main()\n",
    "prob_desc_created_at": "1527608100",
    "tags": [
        "dsu",
        "bitmasks",
        "graphs",
        "dfs and similar"
    ],
    "hidden_unit_tests": ""
}
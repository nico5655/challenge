{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"1110\", \"1010010\", \"1000000000000000001010010\", \"0\"]",
    "src_uid": "8ddccfaf362b19d50647bfb6ad421953",
    "prob_desc_notes": "NoteFor each of the testcases $$$1$$$ to $$$3$$$, $$$A = \\{2^3,2^1,2^2\\} = \\{8,2,4\\}$$$ and $$$E=8\\wedge 2\\wedge 4$$$.For the first testcase, there is only one possible valid unambiguous expression $$$E' = 8\\oplus 2\\oplus 4 = 14 = (1110)_2$$$.For the second testcase, there are three possible valid unambiguous expressions $$$E'$$$:   $$$8\\oplus 2\\oplus 4 = 14$$$  $$$8^2\\oplus 4 = 64\\oplus 4= 68$$$  $$$8\\oplus 2^4 = 8\\oplus 16= 24$$$  XOR of the values of all of these is $$$14\\oplus 68\\oplus 24 = 82 = (1010010)_2$$$.For the third testcase, there are four possible valid unambiguous expressions $$$E'$$$:   $$$8\\oplus 2\\oplus 4 = 14$$$  $$$8^2\\oplus 4 = 64\\oplus 4= 68$$$  $$$8\\oplus 2^4 = 8\\oplus 16= 24$$$  $$$(8^2)^4 = 64^4 = 2^{24} = 16777216$$$  XOR of the values of all of these is $$$14\\oplus 68\\oplus 24\\oplus 16777216 = 16777298 = (1000000000000000001010010)_2$$$.For the fourth testcase, $$$A=\\{2,2\\}$$$ and $$$E=2\\wedge 2$$$. The only possible valid unambiguous expression $$$E' = 2\\oplus 2 = 0 = (0)_2$$$.",
    "prob_desc_description": "The symbol $$$\\wedge$$$ is quite ambiguous, especially when used without context. Sometimes it is used to denote a power ($$$a\\wedge b = a^b$$$) and sometimes it is used to denote the XOR operation ($$$a\\wedge b=a\\oplus b$$$). You have an ambiguous expression $$$E=A_1\\wedge A_2\\wedge A_3\\wedge\\ldots\\wedge A_n$$$. You can replace each $$$\\wedge$$$ symbol with either a $$$\\texttt{Power}$$$ operation or a $$$\\texttt{XOR}$$$ operation to get an unambiguous expression $$$E'$$$.The value of this expression $$$E'$$$ is determined according to the following rules:   All $$$\\texttt{Power}$$$ operations are performed before any $$$\\texttt{XOR}$$$ operation. In other words, the $$$\\texttt{Power}$$$ operation takes precedence over $$$\\texttt{XOR}$$$ operation. For example, $$$4\\;\\texttt{XOR}\\;6\\;\\texttt{Power}\\;2=4\\oplus (6^2)=4\\oplus 36=32$$$.  Consecutive powers are calculated from left to right. For example, $$$2\\;\\texttt{Power}\\;3 \\;\\texttt{Power}\\;4 = (2^3)^4 = 8^4 = 4096$$$. You are given an array $$$B$$$ of length $$$n$$$ and an integer $$$k$$$. The array $$$A$$$ is given by $$$A_i=2^{B_i}$$$ and the expression $$$E$$$ is given by $$$E=A_1\\wedge A_2\\wedge A_3\\wedge\\ldots\\wedge A_n$$$. You need to find the XOR of the values of all possible unambiguous expressions $$$E'$$$ which can be obtained from $$$E$$$ and has at least $$$k$$$ $$$\\wedge$$$ symbols used as $$$\\texttt{XOR}$$$ operation. Since the answer can be very large, you need to find it modulo $$$2^{2^{20}}$$$. Since this number can also be very large, you need to print its binary representation without leading zeroes. If the answer is equal to $$$0$$$, print $$$0$$$.",
    "prob_desc_output_spec": "Print a single line containing a binary string without leading zeroes denoting the answer to the problem. If the answer is equal to $$$0$$$, print $$$0$$$.",
    "prob_desc_input_spec": "The first line of input contains two integers $$$n$$$ and $$$k$$$ $$$(1\\leq n\\leq 2^{20}, 0\\leq k &lt; n)$$$. The second line of input contains $$$n$$$ integers $$$B_1,B_2,\\ldots,B_n$$$ $$$(1\\leq B_i &lt; 2^{20})$$$.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3",
    "lang_cluster": "Python",
    "difficulty": 2500,
    "file_name": "train_096.jsonl",
    "code_uid": "3eb509acff1a5ce7f568c1452db8bdb4",
    "prob_desc_memory_limit": "512 megabytes",
    "prob_desc_sample_inputs": "[\"3 2\\n3 1 2\", \"3 1\\n3 1 2\", \"3 0\\n3 1 2\", \"2 1\\n1 1\"]",
    "exec_outcome": "PASSED",
    "source_code": "import sys, os, io\r\ninput = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline\r\n\r\ndef f(u, v):\r\n    m = u.bit_length()\r\n    dp0, dp1 = [0] * 2, [0] * 2\r\n    dp0[0] = 1\r\n    for i in range(m - 1, -1, -1):\r\n        ndp0, ndp1 = [0] * 2, [0] * 2\r\n        c = u & pow2[i]\r\n        d = v & pow2[i]\r\n        if c and d:\r\n            ndp0[0] = dp0[0]\r\n            ndp0[1] = dp0[1]\r\n            ndp1[0] = dp0[0] + 2 * dp1[0] \r\n            ndp1[1] = dp0[1] + 2 * dp1[1]\r\n        elif c:\r\n            ndp0[0] = dp0[0]\r\n            ndp0[1] = dp0[1]\r\n            ndp1[0] = 2 * dp1[0]\r\n            ndp1[1] = 2 * dp1[1]\r\n        elif d:\r\n            ndp0[1] = dp0[0] + dp0[1]\r\n            ndp1[0] = dp0[0] + dp1[0]\r\n            ndp1[1] = dp0[1] + dp1[0] + 2 * dp1[1]\r\n        else:\r\n            ndp0[0] = dp0[0]\r\n            ndp0[1] = dp0[1]\r\n            ndp1[0] = dp1[0]\r\n            ndp1[1] = dp1[0] + 2 * dp1[1]\r\n        dp0, dp1 = ndp0, ndp1\r\n    return v + 3 - (dp0[1] + dp1[1])\r\n\r\nn, k = map(int, input().split())\r\nb = list(map(int, input().split()))\r\nif n == 1:\r\n    ans = \"1\" + \"0\" * b[0]\r\n    sys.stdout.write(ans)\r\n    exit()\r\npow2 = [1]\r\nfor _ in range(20):\r\n    pow2.append(2 * pow2[-1])\r\nl = pow2[20]\r\nans = [0] * l\r\ny = []\r\nu, c = n - 2, 2\r\nfor _ in range(25):\r\n    u -= 1\r\n    v = u - max(k - c, 0)\r\n    y.append(f(u, v) % 2)\r\nfor i in range(n):\r\n    u, c = n - 2, 2\r\n    for j in range(i, min(i + 25, n)):\r\n        u -= 1\r\n        if j == 0 or j == n - 1:\r\n            u += 1\r\n            c -= 1\r\n        if i == j:\r\n            x = b[j]\r\n        elif b[j] > 20:\r\n            break\r\n        else:\r\n            x *= pow2[b[j]]\r\n        if x >= l or u < k - c:\r\n            break\r\n        if 0 < i <= n - 25:\r\n            ans[x] ^= y[j - i]\r\n        else:\r\n            v = u - max(k - c, 0)\r\n            ans[x] ^= f(u, v) % 2\r\nwhile len(ans) > 1 and not ans[-1]:\r\n    ans.pop()\r\nans.reverse()\r\nsys.stdout.write(\"\".join(map(str, ans)))",
    "prob_desc_created_at": "1651329300",
    "tags": [
        "bitmasks",
        "combinatorics",
        "math",
        "number theory"
    ],
    "hidden_unit_tests": ""
}
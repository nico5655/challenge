{
    "prob_desc_time_limit": "3 seconds",
    "prob_desc_sample_outputs": "[\"2\\n0\\n1\", \"0\\n0\\n2\\n0\\n0\\n2\\n1\\n0\\n1\\n1\"]",
    "src_uid": "a3e89153f98c139d7e84f2307b128b24",
    "prob_desc_notes": "NoteThe following is an explanation of the first example.    The graph in the first example. Here is one possible walk for the first query:$$$$$$1 \\overset{5}{\\rightarrow} 3 \\overset{3}{\\rightarrow} 2 \\overset{1}{\\rightarrow} 1 \\overset{5}{\\rightarrow} 3 \\overset{1}{\\rightarrow} 4 \\overset{2}{\\rightarrow} 5.$$$$$$The array of weights is $$$w=[5,3,1,5,1,2]$$$. Now if we take the bitwise AND of every prefix of this array, we get the set $$$\\{5,1,0\\}$$$. The MEX of this set is $$$2$$$. We cannot get a walk with a smaller length (as defined in the statement).",
    "prob_desc_description": "There is an undirected, connected graph with $$$n$$$ vertices and $$$m$$$ weighted edges. A walk from vertex $$$u$$$ to vertex $$$v$$$ is defined as a sequence of vertices $$$p_1,p_2,\\ldots,p_k$$$ (which are not necessarily distinct) starting with $$$u$$$ and ending with $$$v$$$, such that $$$p_i$$$ and $$$p_{i+1}$$$ are connected by an edge for $$$1 \\leq i &lt; k$$$.We define the length of a walk as follows: take the ordered sequence of edges and write down the weights on each of them in an array. Now, write down the bitwise AND of every nonempty prefix of this array. The length of the walk is the MEX of all these values.More formally, let us have $$$[w_1,w_2,\\ldots,w_{k-1}]$$$ where $$$w_i$$$ is the weight of the edge between $$$p_i$$$ and $$$p_{i+1}$$$. Then the length of the walk is given by $$$\\mathrm{MEX}(\\{w_1,\\,w_1\\&amp; w_2,\\,\\ldots,\\,w_1\\&amp; w_2\\&amp; \\ldots\\&amp; w_{k-1}\\})$$$, where $$$\\&amp;$$$ denotes the bitwise AND operation.Now you must process $$$q$$$ queries of the form u v. For each query, find the minimum possible length of a walk from $$$u$$$ to $$$v$$$.The MEX (minimum excluded) of a set is the smallest non-negative integer that does not belong to the set. For instance:   The MEX of $$$\\{2,1\\}$$$ is $$$0$$$, because $$$0$$$ does not belong to the set.  The MEX of $$$\\{3,1,0\\}$$$ is $$$2$$$, because $$$0$$$ and $$$1$$$ belong to the set, but $$$2$$$ does not.  The MEX of $$$\\{0,3,1,2\\}$$$ is $$$4$$$ because $$$0$$$, $$$1$$$, $$$2$$$ and $$$3$$$ belong to the set, but $$$4$$$ does not. ",
    "prob_desc_output_spec": "For each query, print one line containing a single integer — the answer to the query.",
    "prob_desc_input_spec": "The first line contains two integers $$$n$$$ and $$$m$$$ ($$$2 \\leq n \\leq 10^5$$$; $$$n-1 \\leq m \\leq \\min{\\left(\\frac{n(n-1)}{2},10^5\\right)}$$$). Each of the next $$$m$$$ lines contains three integers $$$a$$$, $$$b$$$, and $$$w$$$ ($$$1 \\leq a, b \\leq n$$$, $$$a \\neq b$$$; $$$0 \\leq w &lt; 2^{30}$$$) indicating an undirected edge between vertex $$$a$$$ and vertex $$$b$$$ with weight $$$w$$$. The input will not contain self-loops or duplicate edges, and the provided graph will be connected. The next line contains a single integer $$$q$$$ ($$$1 \\leq q \\leq 10^5$$$). Each of the next $$$q$$$ lines contains two integers $$$u$$$ and $$$v$$$ ($$$1 \\leq u, v \\leq n$$$, $$$u \\neq v$$$), the description of each query.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3-64",
    "lang_cluster": "Python",
    "difficulty": 2200,
    "file_name": "train_110.jsonl",
    "code_uid": "2dc6d518f26630ddb8c7a847b998cd3c",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"6 7\\n1 2 1\\n2 3 3\\n3 1 5\\n4 5 2\\n5 6 4\\n6 4 6\\n3 4 1\\n3\\n1 5\\n1 2\\n5 3\", \"9 8\\n1 2 5\\n2 3 11\\n3 4 10\\n3 5 10\\n5 6 2\\n5 7 1\\n7 8 5\\n7 9 5\\n10\\n5 7\\n2 5\\n7 1\\n6 4\\n5 2\\n7 6\\n4 1\\n6 2\\n4 7\\n2 8\"]",
    "exec_outcome": "PASSED",
    "source_code": "import sys\r\nimport os\r\nfrom io import BytesIO, IOBase\r\n\r\n# region fastio\r\nBUFSIZE = 8192\r\n \r\nclass FastIO(IOBase):\r\n    newlines = 0\r\n \r\n    def __init__(self, file):\r\n        self._fd = file.fileno()\r\n        self.buffer = BytesIO()\r\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\r\n        self.write = self.buffer.write if self.writable else None\r\n \r\n    def read(self):\r\n        while True:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            if not b:\r\n                break\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines = 0\r\n        return self.buffer.read()\r\n \r\n    def readline(self):\r\n        while self.newlines == 0:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            self.newlines = b.count(b\"\\n\") + (not b)\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines -= 1\r\n        return self.buffer.readline()\r\n \r\n    def flush(self):\r\n        if self.writable:\r\n            os.write(self._fd, self.buffer.getvalue())\r\n            self.buffer.truncate(0), self.buffer.seek(0)\r\n \r\nclass IOWrapper(IOBase):\r\n    def __init__(self, file):\r\n        self.buffer = FastIO(file)\r\n        self.flush = self.buffer.flush\r\n        self.writable = self.buffer.writable\r\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\r\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\r\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\r\n\r\nif sys.version_info[0] < 3:\r\n    sys.stdin = BytesIO(os.read(0, os.fstat(0).st_size))\r\nelse:\r\n    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\r\n\r\nfile = sys.stdin\r\nif os.environ.get('USER') == \"loic\":\r\n    file = open(\"data.in\")\r\n    \r\nline = lambda: file.readline().split()\r\nui = lambda: int(line()[0])\r\nti = lambda: map(int,line())\r\nli = lambda: list(ti())\r\n\r\n#######################################################################\r\n\r\nclass DSU:\r\n    def __init__(self, limit):\r\n        self.link = [-1]*limit\r\n        self.sz = [1]*limit\r\n        self.even = [False] * limit\r\n\r\n    def find(self,u):\r\n        root = u\r\n        par = u\r\n        while par != -1:\r\n            root = par\r\n            par = self.link[par]\r\n         \r\n        par = u\r\n        while par != root:\r\n            self.link[par] = root\r\n            par = self.link[par]\r\n              \r\n        return root\r\n    \r\n    ''' return True if u and v were not in same group, false otherwise '''\r\n    def union(self,u,v):\r\n        root_u = self.find(u)\r\n        root_v = self.find(v)\r\n        if root_u == root_v:\r\n            return False\r\n        rank_u = self.sz[root_u]\r\n        rank_v = self.sz[root_v]\r\n        if rank_u < rank_v:\r\n            self.link[root_u] = root_v\r\n            self.sz[root_v] += self.sz[root_u]\r\n        else:\r\n            self.link[root_v] = root_u\r\n            self.sz[root_u] += self.sz[root_v]\r\n        return True\r\n    \r\n    ''' return size of the component containing u '''\r\n    def size(self,u):\r\n        return self.sz[self.find(u)]\r\n\r\ndef solve():\r\n    \r\n    dsu_zero = [DSU(N) for _ in range(30)]\r\n    dsu_one = [DSU(N) for _ in range(30)]\r\n    \r\n    for j in range(30):\r\n        zero = dsu_zero[j]\r\n        one = dsu_one[j]\r\n        for u,v,w in E:\r\n            if w >> j & 1:\r\n                zero.union(u,v)\r\n                if j > 0 and w & 1:\r\n                    one.union(u,v)\r\n    \r\n    even = [False] * N\r\n    for u,v,w in E:\r\n        if not w & 1:\r\n            even[u] = True\r\n            even[v] = True\r\n\r\n    link = [False] * N\r\n    for j in range(1,30):\r\n        dsu = dsu_one[j]\r\n        for u,v,w in E:\r\n            if not w & 1:\r\n                root_u = dsu.find(u)\r\n                dsu.even[root_u] = True\r\n                root_v = dsu.find(v)\r\n                dsu.even[root_v] = True\r\n                \r\n    for j in range(1,30):\r\n        dsu = dsu_one[j]\r\n        for n in range(N):\r\n            if not link[n] and dsu.even[dsu.find(n)]:\r\n                link[n] = True\r\n    \r\n    def mex(u,v):\r\n        for j in range(30):\r\n            dsu = dsu_zero[j]\r\n            if dsu.find(u) == dsu.find(v):\r\n                return 0\r\n        if link[u]:\r\n            return 1\r\n        if even[u]:\r\n            return 1\r\n        return 2\r\n    \r\n    res = []\r\n    for u,v in Q:\r\n        res.append(mex(u,v))\r\n            \r\n    return \"\\n\".join(str(v) for v in res)\r\n\r\nfor test in range(1,1+1):\r\n    N,M = ti()\r\n    \r\n    E = []\r\n    for _ in range(M):\r\n        u,v,w = ti()\r\n        u -= 1\r\n        v -= 1\r\n        E.append((u,v,w))\r\n    \r\n    Q = []\r\n    for _ in range(ui()):\r\n        u,v = ti()\r\n        u -= 1\r\n        v -= 1\r\n        Q.append((u,v))\r\n    \r\n    print(solve())\r\n    \r\nfile.close()",
    "prob_desc_created_at": "1650206100",
    "tags": [
        "bitmasks",
        "brute force",
        "constructive algorithms",
        "dfs and similar",
        "dsu",
        "graphs"
    ],
    "hidden_unit_tests": ""
}
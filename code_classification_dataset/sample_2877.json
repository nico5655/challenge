{
    "prob_desc_time_limit": "1 second",
    "prob_desc_sample_outputs": "[\"2 1 3 \\n3 1 2 5 4 \\n-1\\n1 2 6 3 4 5 \\n1 2 4 3\"]",
    "src_uid": "d3580f1d7406740acfc4f4343d1844e8",
    "prob_desc_notes": null,
    "prob_desc_description": "Yeah, we failed to make up a New Year legend for this problem.A permutation of length $$$n$$$ is an array of $$$n$$$ integers such that every integer from $$$1$$$ to $$$n$$$ appears in it exactly once. An element $$$y$$$ of permutation $$$p$$$ is reachable from element $$$x$$$ if $$$x = y$$$, or $$$p_x = y$$$, or $$$p_{p_x} = y$$$, and so on. The decomposition of a permutation $$$p$$$ is defined as follows: firstly, we have a permutation $$$p$$$, all elements of which are not marked, and an empty list $$$l$$$. Then we do the following: while there is at least one not marked element in $$$p$$$, we find the leftmost such element, list all elements that are reachable from it in the order they appear in $$$p$$$, mark all of these elements, then cyclically shift the list of those elements so that the maximum appears at the first position, and add this list as an element of $$$l$$$. After all elements are marked, $$$l$$$ is the result of this decomposition.For example, if we want to build a decomposition of $$$p = [5, 4, 2, 3, 1, 7, 8, 6]$$$, we do the following:  initially $$$p = [5, 4, 2, 3, 1, 7, 8, 6]$$$ (bold elements are marked), $$$l = []$$$;  the leftmost unmarked element is $$$5$$$; $$$5$$$ and $$$1$$$ are reachable from it, so the list we want to shift is $$$[5, 1]$$$; there is no need to shift it, since maximum is already the first element;  $$$p = [\\textbf{5}, 4, 2, 3, \\textbf{1}, 7, 8, 6]$$$, $$$l = [[5, 1]]$$$;  the leftmost unmarked element is $$$4$$$, the list of reachable elements is $$$[4, 2, 3]$$$; the maximum is already the first element, so there's no need to shift it;  $$$p = [\\textbf{5}, \\textbf{4}, \\textbf{2}, \\textbf{3}, \\textbf{1}, 7, 8, 6]$$$, $$$l = [[5, 1], [4, 2, 3]]$$$;  the leftmost unmarked element is $$$7$$$, the list of reachable elements is $$$[7, 8, 6]$$$; we have to shift it, so it becomes $$$[8, 6, 7]$$$;  $$$p = [\\textbf{5}, \\textbf{4}, \\textbf{2}, \\textbf{3}, \\textbf{1}, \\textbf{7}, \\textbf{8}, \\textbf{6}]$$$, $$$l = [[5, 1], [4, 2, 3], [8, 6, 7]]$$$;  all elements are marked, so $$$[[5, 1], [4, 2, 3], [8, 6, 7]]$$$ is the result. The New Year transformation of a permutation is defined as follows: we build the decomposition of this permutation; then we sort all lists in decomposition in ascending order of the first elements (we don't swap the elements in these lists, only the lists themselves); then we concatenate the lists into one list which becomes a new permutation. For example, the New Year transformation of $$$p = [5, 4, 2, 3, 1, 7, 8, 6]$$$ is built as follows:  the decomposition is $$$[[5, 1], [4, 2, 3], [8, 6, 7]]$$$;  after sorting the decomposition, it becomes $$$[[4, 2, 3], [5, 1], [8, 6, 7]]$$$;  $$$[4, 2, 3, 5, 1, 8, 6, 7]$$$ is the result of the transformation. We call a permutation good if the result of its transformation is the same as the permutation itself. For example, $$$[4, 3, 1, 2, 8, 5, 6, 7]$$$ is a good permutation; and $$$[5, 4, 2, 3, 1, 7, 8, 6]$$$ is bad, since the result of transformation is $$$[4, 2, 3, 5, 1, 8, 6, 7]$$$.Your task is the following: given $$$n$$$ and $$$k$$$, find the $$$k$$$-th (lexicographically) good permutation of length $$$n$$$.",
    "prob_desc_output_spec": "For each test case, print the answer to it as follows: if the number of good permutations of length $$$n$$$ is less than $$$k$$$, print one integer $$$-1$$$; otherwise, print the $$$k$$$-th good permutation on $$$n$$$ elements (in lexicographical order).",
    "prob_desc_input_spec": "The first line contains one integer $$$t$$$ ($$$1 \\le t \\le 1000$$$) â€” the number of test cases. Then the test cases follow. Each test case is represented by one line containing two integers $$$n$$$ and $$$k$$$ ($$$1 \\le n \\le 50$$$, $$$1 \\le k \\le 10^{18}$$$).",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "Python 3",
    "lang_cluster": "Python",
    "difficulty": 2700,
    "file_name": "train_034.jsonl",
    "code_uid": "0176aa76831798538a414696ed6635b4",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"5\\n3 3\\n5 15\\n4 13\\n6 8\\n4 2\"]",
    "exec_outcome": "PASSED",
    "source_code": "#!/usr/bin/python3\n\nfrom math import factorial as fact\n\nN = 55\nc = [1]\nfor i in range(N):\n\tc.append(fact(i))\ndp = [0] * N\ndp[0] = 1\nfor i in range(1, N):\n\tfor j in range(i):\n\t\tdp[i] += dp[j] * c[i - j - 1]\n\ndef get_kth_cycle(n, k):\n\tif n == 1:\n\t\treturn [1]\n\tans = [-1] * n\n\tans[0] = n - 1\n\tfin = [i for i in range(n)]\n\tfin[0] = n - 1\n\tinit = [i for i in range(n)]\n\tinit[n - 1] = 0\n\tused = [False] * n\n\tused[n - 1] = True\n\tfor i in range(1, n - 1):\n\t\tj = 0\n\t\tcur = fact(n - i - 2)\n\t\twhile True:\n\t\t\twhile used[j] or (i < n - 1 and j == init[i]):\n\t\t\t\tj += 1\n\t\t\tif k > cur:\n\t\t\t\tk -= cur\n\t\t\t\tj += 1\n\t\t\telse:\n\t\t\t\tfin[init[i]] = fin[j]\n\t\t\t\tinit[fin[j]] = init[i]\n\t\t\t\tans[i] = j\n\t\t\t\tused[j] = True\n\t\t\t\tbreak\n\tans[-1] = init[-1]\n\treturn [x + 1 for x in ans]\n\ndef f(n, k):\n\tif n == 0:\n\t\tassert k == 1\n\t\treturn []\n\tcl = 1\n\twhile c[cl - 1] * dp[n - cl] < k:\n\t\tk -= c[cl - 1] * dp[n - cl]\n\t\tcl += 1\n\trest = f(n - cl, (k - 1) % dp[n - cl] + 1)\n\trest = [x + cl for x in rest]\n\tk = (k - 1) // dp[n - cl] + 1\n\treturn get_kth_cycle(cl, k) + rest\n\ndef solve():\n\tn, k = map(int, input().split())\n\tif k > dp[n]:\n\t\tprint(-1)\n\t\treturn\n\tprint(*f(n, k))\n\ndef main():\n\tt = int(input())\n\twhile t > 0:\n\t\tt -= 1\n\t\tsolve()\n\nmain()\n",
    "prob_desc_created_at": "1577457600",
    "tags": [
        "dp",
        "combinatorics"
    ],
    "hidden_unit_tests": ""
}
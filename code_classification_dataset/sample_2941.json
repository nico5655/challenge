{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"b\", \"Az\", \"tFrg4\", \"AB\"]",
    "src_uid": "bb6e2f728e1c7e24d86c9352740dea38",
    "prob_desc_notes": "NoteIn the first example during the first operation both letters 'a' are removed, so the string becomes \"bc\". During the second operation the letter 'c' (on the second position) is removed, and the string becomes \"b\".In the second example during the first operation Petya removes '0' from the second position. After that the string becomes \"Az\". During the second operations the string doesn't change.",
    "prob_desc_description": "Petya has a string of length n consisting of small and large English letters and digits.He performs m operations. Each operation is described with two integers l and r and a character c: Petya removes from the string all characters c on positions between l and r, inclusive. It's obvious that the length of the string remains the same or decreases after each operation.Find how the string will look like after Petya performs all m operations.",
    "prob_desc_output_spec": "Print the string Petya will obtain after performing all m operations. If the strings becomes empty after all operations, print an empty line.",
    "prob_desc_input_spec": "The first string contains two integers n and m (1 ≤ n, m ≤ 2·105) — the length of the string and the number of operations. The second line contains the string of length n, consisting of small and large English letters and digits. Positions in the string are enumerated from 1. Each of the next m lines contains two integers l and r (1 ≤ l ≤ r), followed by a character c, which is a small or large English letter or a digit. This line describes one operation. It is guaranteed that r doesn't exceed the length of the string s before current operation.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 2",
    "lang_cluster": "Python",
    "difficulty": 2100,
    "file_name": "train_036.jsonl",
    "code_uid": "ed8497e60d221c421f3dbee1f5052a0b",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"4 2\\nabac\\n1 3 a\\n2 2 c\", \"3 2\\nA0z\\n1 3 0\\n1 1 z\", \"10 4\\nagtFrgF4aF\\n2 5 g\\n4 9 F\\n1 5 4\\n1 7 a\", \"9 5\\naAAaBBccD\\n1 4 a\\n5 6 c\\n2 3 B\\n4 4 D\\n2 3 A\"]",
    "exec_outcome": "PASSED",
    "source_code": "from collections import defaultdict\nimport sys\ninput = raw_input\nrange = xrange\n \ndef lower_bound(A, x):\n    a = 0\n    b = len(A)\n    while a < b:\n        c = (a + b) >> 1\n        if A[c] < x:\n            a = c + 1\n        else:\n            b = c\n    return a\n \ndef upper_bound(A, x):\n    a = 0\n    b = len(A)\n    while a < b:\n        c = (a + b) >> 1\n        if A[c] <= x:\n            a = c + 1\n        else:\n            b = c\n    return a\n \n \nclass FenwickTree:\n    def __init__(self, x):\n        self.bit = []\n        self.build(x)\n    \n    def build(self, x):\n        \"\"\"transform x into a BIT\"\"\" \n        self.bit[:] = x\n        bit = self.bit\n        size = self.size = len(x)\n        for i in range(size):\n            j = i | (i + 1)\n            if j < size:\n                bit[j] += bit[i]\n \n    def update(self, idx, x):\n        \"\"\"updates bit[idx] += x\"\"\"\n        while idx < self.size:\n            self.bit[idx] += x\n            idx |= idx + 1\n \n    def __call__(self, end):\n        \"\"\"calc sum(bit[:end])\"\"\"\n        x = 0\n        while end:\n            x += self.bit[end - 1]\n            end &= end - 1\n        return x\n \n    def find_kth(self, k):\n        \"\"\"Find largest idx such that sum(bit[:idx]) <= k\"\"\"\n        idx = -1\n        for d in reversed(range(self.size.bit_length())):\n            right_idx = idx + (1 << d)\n            if right_idx < self.size and self.bit[right_idx] <= k:\n                idx = right_idx\n                k -= self.bit[idx]\n        return idx + 1, k\n \n \nblock_size = 700\nclass blocksorter:\n    def __init__(self):\n        self.macro = []\n        self.micros = [[]]\n        self.micro_size = [0]\n        self.fenwick = FenwickTree([])\n        self.size = 0\n        # Cache last prev_count(i) call\n        self.cached_i = 0\n        self.cached_size = 0\n        # Cache _lower_bound(x)\n        self.cached_x = None\n        self.cached_index = (-1,0)\n \n    def lower_bound(self, x):\n        i,j = self._lower_bound(x)\n        return self.prev_count(i) + j\n    \n    def upper_bound(self, x):\n        i = upper_bound(self.macro, x)\n        i -= i and self.micro_size[i - 1] and x < self.micros[i - 1][-1]\n        return self.prev_count(i) + upper_bound(self.micros[i], x)\n \n    def insert(self, x):\n        i,j = self._lower_bound(x)\n        self.micros[i].insert(j, x)\n        self.size += 1\n        self.micro_size[i] += 1\n        self.fenwick.update(i, 1)\n        self.cached_size += i < self.cached_i\n        if len(self.micros[i]) >= block_size:\n            self.cached_index = (-1, 0)\n            self.cached_i += i < self.cached_i\n            \n            self.micros[i : i + 1] = self.micros[i][:block_size >> 1], self.micros[i][block_size >> 1:]\n            self.micro_size[i : i + 1] = block_size >> 1, block_size >> 1\n            self.fenwick.size = 0\n            self.macro [i : i + 1] = self.micros[i][0], self.micros[i + 1][0]\n            if len(self.micros) == len(self.macro):\n                self.macro.pop()\n    \n    def remove(self, x):\n        i,j = self._lower_bound(x)\n        self._delete(i,j)\n    \n    def __delitem__(self, k):\n        i,j = self.find_kth(k)\n        self._delete(i,j)\n\n    def __getitem__(self, k):\n        i,j = self.find_kth(k)\n        return self.micros[i][j]\n    \n    def __len__(self):\n        return self.size\n \n    def __contains__(self, x):\n        i,j = self._lower_bound(x)\n        return j < len(self.micros[i]) and self.micros[i][j] == x\n    \n    # Internal functions\n    def find_kth(self, k):\n        if k < 0:\n            k += self.size\n        if k < self.cached_size:\n            self.cached_i -= 1\n            self.cached_size -= self.micro_size[self.cached_i]\n        elif self.cached_size + self.micro_size[self.cached_i] <= k:\n            self.cached_size += self.micro_size[self.cached_i]\n            self.cached_i += 1\n\n        if k < self.cached_size or self.cached_size + self.micro_size[self.cached_i] <= k:\n            if self.fenwick.size == 0:\n                self.fenwick.build(self.micro_size)\n            self.cached_i,j = self.fenwick.find_kth(k)\n            \n            if j < self.micro_size[self.cached_i]:\n                self.cached_size = k - j\n            else:\n                self.cached_i -= 1\n                self.cached_size = k - self.micro_size[i - 1] - 1\n        return self.cached_i, k - self.cached_size\n \n    def prev_count(self, i):\n        if i == self.cached_i:\n            return self.cached_size\n        if i < 10:\n            self.cached_size = 0\n            for j in range(i):\n                self.cached_size += self.micro_size[j]\n        elif len(self.micro_size) - i < 10:\n            self.cached_size = self.size\n            for j in range(i, len(self.micros)):\n                self.cached_size -= self.micro_size[j]\n        elif -10 < self.cached_i - i < 10:\n            for j in range(i, self.cached_i):\n                self.cached_size -= self.micro_size[j]\n            for j in range(self.cached_i, i):\n                self.cached_size += self.micro_size[j]\n        else:\n            if self.fenwick.size == 0:\n                self.fenwick.build(self.micro_size)\n            self.cached_size = self.fenwick(i)\n        self.cached_i = i\n        return self.cached_size\n \n    def _lower_bound(self, x):\n        if self.cached_index[0] >= 0 and self.cached_x == x:\n            return self.cached_index\n        i = lower_bound(self.macro, x)\n        i -= i and self.micro_size[i - 1] and x <= self.micros[i - 1][-1]\n        j = lower_bound(self.micros[i], x)\n        self.cached_x = x\n        self.cached_index = (i,j)\n        return i, j\n \n    def _delete(self, i, j):\n        del self.micros[i][j]\n        self.size -= 1\n        self.micro_size[i] -= 1\n        self.fenwick.update(i, -1)\n        if i == self.cached_index[0] and j < self.cached_index[1]:\n            self.cached_index = (i, self.cached_index[1] - 1)\n        self.cached_size -= i < self.cached_i\n        if 1 < i + 1 < len(self.micro_size) and self.micro_size[i - 1] + self.micro_size[i] + self.micro_size[i + 1] < block_size:\n            self.cached_index = (-1, 0)\n            if self.cached_i == i:\n                self.cached_size -= self.micro_size[i - 1]\n            elif self.cached_i == i + 1:\n                self.cached_size -= self.micro_size[i - 1] + self.micro_size[i]\n            self.cached_i -= (i <= self.cached_i) + (i < self.cached_i)\n            \n            self.micros[i - 1] += self.micros[i]\n            self.micros[i - 1] += self.micros[i + 1]\n            self.micro_size[i - 1] += self.micro_size[i] + self.micro_size[i + 1]\n            del self.macro[i - 1: i + 1], self.micros[i: i + 2], self.micro_size[i: i + 2]\n            self.fenwick.size = 0\n \ninp = sys.stdin.read().split(); ii = 0\nn = int(inp[ii]); ii += 1\nm = int(inp[ii]); ii += 1\nS = inp[ii]; ii += 1\n \nB = blocksorter()\nBc = defaultdict(lambda : blocksorter())\nfor i in range(n):\n    B.insert(i)\n    Bc[S[i]].insert(i)\n \nfor _ in range(m):\n    l = int(inp[ii]) - 1; ii += 1\n    r = int(inp[ii]) - 1; ii += 1\n    c = inp[ii]; ii += 1\n \n    Bcc = Bc[c]\n \n    L = B[l]\n    R = B[r]\n\n    k = Bcc.lower_bound(L)\n    while k < len(Bcc) and Bcc[k] <= R:\n        B.remove(Bcc[k])\n        del Bcc[k]\n    \nprint ''.join(S[i] for b in B.micros for i in b)\n",
    "prob_desc_created_at": "1513492500",
    "tags": [
        "data structures",
        "strings"
    ],
    "hidden_unit_tests": ""
}
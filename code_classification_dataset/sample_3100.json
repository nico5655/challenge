{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"0 4\", \"-1 -1\\n3 3\\n3 2\", \"-1 -1\\n-1 -1\\n-1 -1\\n-1 -1\"]",
    "src_uid": "c3f4dde88504b829f2b18439ebe32305",
    "prob_desc_notes": null,
    "prob_desc_description": "Motorist Kojiro spent 10 years saving up for his favorite car brand, Furrari. Finally Kojiro's dream came true! Kojiro now wants to get to his girlfriend Johanna to show off his car to her.Kojiro wants to get to his girlfriend, so he will go to her along a coordinate line. For simplicity, we can assume that Kojiro is at the point f of a coordinate line, and Johanna is at point e. Some points of the coordinate line have gas stations. Every gas station fills with only one type of fuel: Regular-92, Premium-95 or Super-98. Thus, each gas station is characterized by a pair of integers ti and xi — the number of the gas type and its position.One liter of fuel is enough to drive for exactly 1 km (this value does not depend on the type of fuel). Fuels of three types differ only in quality, according to the research, that affects the lifetime of the vehicle motor. A Furrari tank holds exactly s liters of fuel (regardless of the type of fuel). At the moment of departure from point f Kojiro's tank is completely filled with fuel Super-98. At each gas station Kojiro can fill the tank with any amount of fuel, but of course, at no point in time, the amount of fuel in the tank can be more than s liters. Note that the tank can simultaneously have different types of fuel. The car can moves both left and right.To extend the lifetime of the engine Kojiro seeks primarily to minimize the amount of fuel of type Regular-92. If there are several strategies to go from f to e, using the minimum amount of fuel of type Regular-92, it is necessary to travel so as to minimize the amount of used fuel of type Premium-95.Write a program that can for the m possible positions of the start fi minimize firstly, the amount of used fuel of type Regular-92 and secondly, the amount of used fuel of type Premium-95.",
    "prob_desc_output_spec": "Print exactly m lines. The i-th of them should contain two integers — the minimum amount of gas of type Regular-92 and type Premium-95, if Kojiro starts at point fi. First you need to minimize the first value. If there are multiple ways to do it, you need to also minimize the second value. If there is no way to get to Johanna from point fi, the i-th line should look like that \"-1 -1\" (two numbers minus one without the quotes).",
    "prob_desc_input_spec": "The first line of the input contains four positive integers e, s, n, m (1 ≤ e, s ≤ 109, 1 ≤ n, m ≤ 2·105) — the coordinate of the point where Johanna is, the capacity of a Furrari tank, the number of gas stations and the number of starting points.  Next n lines contain two integers each ti, xi (1 ≤ ti ≤ 3,  - 109 ≤ xi ≤ 109), representing the type of the i-th gas station (1 represents Regular-92, 2 — Premium-95 and 3 — Super-98) and the position on a coordinate line of the i-th gas station. Gas stations don't necessarily follow in order from left to right. The last line contains m integers fi ( - 109 ≤ fi &lt; e). Start positions don't necessarily follow in order from left to right. No point of the coordinate line contains more than one gas station. It is possible that some of points fi or point e coincide with a gas station.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "Python 2",
    "lang_cluster": "Python",
    "difficulty": 2800,
    "file_name": "train_042.jsonl",
    "code_uid": "891e7db9dd46577bd03b3b8abdfd3d5e",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"8 4 1 1\\n2 4\\n0\", \"9 3 2 3\\n2 3\\n1 6\\n-1 0 1\", \"20 9 2 4\\n1 5\\n2 10\\n-1 0 1 2\"]",
    "exec_outcome": "PASSED",
    "source_code": "#!/usr/bin/env python\nfrom sys import stdin as cin\n\ndef read_input():\n    e, s, n, m = map(int, next(cin).split())\n    txs = [map(int, next(cin).split()) for _ in range(n)]\n    fs = map(int, next(cin).split())\n\n    txs = [(t, e-x) for t,x in txs if e>x]\n    fs = [e-f for f in fs]\n\n    return s, txs, fs\n\n\ndef solve_positive(capacity, gas_stations, starts):\n    segments = [ [0, 0], [3, capacity] ]\n    for gs in sorted(gas_stations, key=lambda e: e[1]):\n        if gs[1] > segments[-1][1]: # this and all further gas stations are unreachable\n            break\n        while gs[0] >= segments[-1][0] and gs[1] <= segments[-2][1]: # last gas station useless\n            segments.pop()\n        if gs[0] > segments[-1][0]: # new gas station is better than previous one\n            segments[-1][1] = gs[1]\n        segments.append([gs[0], gs[1]+capacity])\n\n    cnt = [0] * 4\n    answer = {}\n    seg_it = iter(segments)\n    seg = next(seg_it)\n    seg_start = 0\n    try:\n        for start in sorted(starts):\n            while start > seg[1]:\n                cnt[seg[0]] += seg[1] - seg_start\n                seg_start = seg[1]\n                seg = next(seg_it)\n            answer[start] = cnt[:]\n            answer[start][seg[0]] += start - seg_start\n    except StopIteration: pass\n\n    return answer\n\n\ndef main():\n    capacity, gas_stations, starts = read_input()\n\n    answer = solve_positive(capacity, gas_stations, starts)\n\n    return [answer.get(start, [-1]*4) for start in starts]\n\n\nprint '\\n'.join(map('{0[1]} {0[2]}'.format, main()))\n",
    "prob_desc_created_at": "1443430800",
    "tags": [
        "dp",
        "greedy"
    ],
    "hidden_unit_tests": ""
}
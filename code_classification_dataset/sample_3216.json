{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"1 2 0\", \"43 42 41 1337 1336\", \"4 3 2 1 2\"]",
    "src_uid": "48c8ce45ab38a382dc52db1e59be234f",
    "prob_desc_notes": null,
    "prob_desc_description": "You are given a directed acyclic graph (a directed graph that does not contain cycles) of $$$n$$$ vertices and $$$m$$$ arcs. The $$$i$$$-th arc leads from the vertex $$$x_i$$$ to the vertex $$$y_i$$$ and has the weight $$$w_i$$$.Your task is to select an integer $$$a_v$$$ for each vertex $$$v$$$, and then write a number $$$b_i$$$ on each arcs $$$i$$$ such that $$$b_i = a_{x_i} - a_{y_i}$$$. You must select the numbers so that:  all $$$b_i$$$ are positive;  the value of the expression $$$\\sum \\limits_{i = 1}^{m} w_i b_i$$$ is the lowest possible. It can be shown that for any directed acyclic graph with non-negative $$$w_i$$$, such a way to choose numbers exists.",
    "prob_desc_output_spec": "Print $$$n$$$ integers $$$a_1$$$, $$$a_2$$$, ..., $$$a_n$$$ ($$$0 \\le a_v \\le 10^9$$$), which must be written on the vertices so that all $$$b_i$$$ are positive, and the value of the expression $$$\\sum \\limits_{i = 1}^{m} w_i b_i$$$ is the lowest possible. If there are several answers, print any of them. It can be shown that the answer always exists, and at least one of the optimal answers satisfies the constraints $$$0 \\le a_v \\le 10^9$$$.",
    "prob_desc_input_spec": "The first line contains two integers $$$n$$$ and $$$m$$$ ($$$2 \\le n \\le 18$$$; $$$0 \\le m \\le \\dfrac{n(n - 1)}{2}$$$). Then $$$m$$$ lines follow, the $$$i$$$-th of them contains three integers $$$x_i$$$, $$$y_i$$$ and $$$w_i$$$ ($$$1 \\le x_i, y_i \\le n$$$, $$$1 \\le w_i \\le 10^5$$$, $$$x_i \\ne y_i$$$) â€” the description of the $$$i$$$-th arc. It is guaranteed that the lines describe $$$m$$$ arcs of a directed acyclic graph without multiple arcs between the same pair of vertices.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3",
    "lang_cluster": "Python",
    "difficulty": 2600,
    "file_name": "train_047.jsonl",
    "code_uid": "c4e0a7fa0d9ff0c6153f616078f138bb",
    "prob_desc_memory_limit": "1024 megabytes",
    "prob_desc_sample_inputs": "[\"3 2\\n2 1 4\\n1 3 2\", \"5 4\\n1 2 1\\n2 3 1\\n1 3 6\\n4 5 8\", \"5 5\\n1 2 1\\n2 3 1\\n3 4 1\\n1 5 1\\n5 4 10\"]",
    "exec_outcome": "PASSED",
    "source_code": "from heapq import heappush, heappop\nclass MinCostFlow:\n    INF = 10**18\n\n    def __init__(self, N):\n        self.N = N\n        self.G = [[] for i in range(N)]\n\n    def add_edge(self, fr, to, cap, cost):\n        forward = [to, cap, cost, None]\n        backward = forward[3] = [fr, 0, -cost, forward]\n        self.G[fr].append(forward)\n        self.G[to].append(backward)\n\n    def flow(self, s, t, f):\n        N = self.N; G = self.G\n        INF = MinCostFlow.INF\n\n        res = 0\n        H = [0]*N\n        prv_v = [0]*N\n        prv_e = [None]*N\n\n        d0 = [INF]*N\n        dist = [INF]*N\n\n        while f:\n            dist[:] = d0\n            dist[s] = 0\n            que = [(0, s)]\n\n            while que:\n                c, v = heappop(que)\n                if dist[v] < c:\n                    continue\n                r0 = dist[v] + H[v]\n                for e in G[v]:\n                    w, cap, cost, _ = e\n                    if cap > 0 and r0 + cost - H[w] < dist[w]:\n                        dist[w] = r = r0 + cost - H[w]\n                        prv_v[w] = v; prv_e[w] = e\n                        heappush(que, (r, w))\n            if dist[t] == INF:\n                return None\n\n            for i in range(N):\n                H[i] += dist[i]\n\n            d = f; v = t\n            while v != s:\n                d = min(d, prv_e[v][1])\n                v = prv_v[v]\n            f -= d\n            res += d * H[t]\n            v = t\n            while v != s:\n                e = prv_e[v]\n                e[1] -= d\n                e[3][1] += d\n                v = prv_v[v]\n        return res\n\nclass UnionFindVerSize():\n    def __init__(self, N):\n        self._parent = [n for n in range(0, N)]\n        self._size = [1] * N\n        self.group = N\n\n    def find_root(self, x):\n        if self._parent[x] == x: return x\n        self._parent[x] = self.find_root(self._parent[x])\n        stack = [x]\n        while self._parent[stack[-1]]!=stack[-1]:\n            stack.append(self._parent[stack[-1]])\n        for v in stack:\n            self._parent[v] = stack[-1]\n        return self._parent[x]\n\n    def unite(self, x, y):\n        gx = self.find_root(x)\n        gy = self.find_root(y)\n        if gx == gy: return\n\n        self.group -= 1\n\n        if self._size[gx] < self._size[gy]:\n            self._parent[gx] = gy\n            self._size[gy] += self._size[gx]\n        else:\n            self._parent[gy] = gx\n            self._size[gx] += self._size[gy]\n\n    def get_size(self, x):\n        return self._size[self.find_root(x)]\n\n    def is_same_group(self, x, y):\n        return self.find_root(x) == self.find_root(y)\n\nn,m = map(int,input().split())\n\nG = MinCostFlow(n+2)\ncoef = [0 for i in range(n)]\nedge = []\nfor _ in range(m):\n    x,y,b = map(int,input().split())\n    G.add_edge(y,x,10**18,-1)\n    coef[x-1] += b\n    coef[y-1] -= b\n    edge.append((x,y))\n\ns = 0\nfor i in range(n):\n    if coef[i]<0:\n        G.add_edge(0,i+1,-coef[i],0)\n        s -= coef[i]\n    elif coef[i]>0:\n        G.add_edge(i+1,n+1,coef[i],0)\n\n#G.add_edge(0,n+1,10**18,0)\n\nf = G.flow(0,n+1,s)\n#print(-f)\n\nEdge = [[] for i in range(n)]\nuse = [False]*m\nuf = UnionFindVerSize(n)\nfor i in range(m):\n    u,v = edge[i]\n    for e in G.G[u]:\n        to = e[0]\n        if to==v and e[1]:\n            Edge[v-1].append((u-1,1))\n            Edge[u-1].append((v-1,-1))\n            use[i] = True\n            uf.unite(u-1,v-1)\n\n\nedge = [(edge[i][0],edge[i][1]) for i in range(m) if not use[i]]\nfor u,v in edge:\n    if not uf.is_same_group(u-1,v-1):\n        Edge[v-1].append((u-1,1))\n        Edge[u-1].append((v-1,-1))\n        uf.unite(u-1,v-1)\n\nused_1 = [False]*n\nused_2 = [False]*n\nlazy = [0 for i in range(n)]\na = [0 for i in range(n)]\ndef dfs(v,pv):\n    lazy[v] = min(lazy[v],a[v])\n    for nv,c in Edge[v]:\n        if not used_1[nv]:\n            used_1[nv] = True\n            a[nv] = a[v] + c\n            dfs(nv,v)\n            lazy[v] = min(lazy[v],lazy[nv])\n\ndef add(v,pv,ff):\n    a[v] += ff\n    for nv,c in Edge[v]:\n        if not used_2[nv]:\n            used_2[nv] = True\n            add(nv,v,ff)\n\nfor i in range(n):\n    if not used_1[i]:\n        used_1[i] = True\n        dfs(i,-1)\n        used_2[i] = True\n        add(i,-1,-lazy[i]+1)\n        #print(used_1)\n        #print(lazy)\n\nprint(*a)\n",
    "prob_desc_created_at": "1602407100",
    "tags": [
        "dp",
        "graphs",
        "flows",
        "bitmasks",
        "math",
        "dfs and similar"
    ],
    "hidden_unit_tests": ""
}
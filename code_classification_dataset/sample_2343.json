{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"3\", \"1\", \"1\", \"2\"]",
    "src_uid": "1436a01f6638a59d844fc5df93850f11",
    "prob_desc_notes": "NoteIn the first testcase, Vasya can jump in the following way: $$$1 \\rightarrow 2 \\rightarrow 4 \\rightarrow 5$$$.In the second and third testcases, we can reach last skyscraper in one jump.Sequence of jumps in the fourth testcase: $$$1 \\rightarrow 3 \\rightarrow 5$$$.",
    "prob_desc_description": "There are $$$n$$$ beautiful skyscrapers in New York, the height of the $$$i$$$-th one is $$$h_i$$$. Today some villains have set on fire first $$$n - 1$$$ of them, and now the only safety building is $$$n$$$-th skyscraper.Let's call a jump from $$$i$$$-th skyscraper to $$$j$$$-th ($$$i &lt; j$$$) discrete, if all skyscrapers between are strictly lower or higher than both of them. Formally, jump is discrete, if $$$i &lt; j$$$ and one of the following conditions satisfied:   $$$i + 1 = j$$$  $$$\\max(h_{i + 1}, \\ldots, h_{j - 1}) &lt; \\min(h_i, h_j)$$$  $$$\\max(h_i, h_j) &lt; \\min(h_{i + 1}, \\ldots, h_{j - 1})$$$. At the moment, Vasya is staying on the first skyscraper and wants to live a little longer, so his goal is to reach $$$n$$$-th skyscraper with minimal count of discrete jumps. Help him with calcualting this number.",
    "prob_desc_output_spec": "Print single number $$$k$$$ — minimal amount of discrete jumps. We can show that an answer always exists.",
    "prob_desc_input_spec": "The first line contains a single integer $$$n$$$ ($$$2 \\le n \\le 3 \\cdot 10^5$$$) — total amount of skyscrapers. The second line contains $$$n$$$ integers $$$h_1, h_2, \\ldots, h_n$$$ ($$$1 \\le h_i \\le 10^9$$$) — heights of skyscrapers.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3",
    "lang_cluster": "Python",
    "difficulty": 2200,
    "file_name": "train_020.jsonl",
    "code_uid": "e46aff7a2bded971952b8abed9dbf1ed",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"5\\n1 3 1 4 5\", \"4\\n4 2 2 4\", \"2\\n1 1\", \"5\\n100 1 100 1 100\"]",
    "exec_outcome": "PASSED",
    "source_code": "# by the authority of GOD     author: manhar singh sachdev #\n\nimport os,sys\nfrom io import BytesIO, IOBase\n\ndef main():\n    n = int(input())\n    h = list(map(int,input().split()))\n    max_st = [-1]*n\n    min_st = [-1]*n\n    for i in range(n-2,-1,-1):\n        if h[i]>=h[i+1]:\n            min_st[i] = i+1\n        else:\n            x = min_st[i+1]\n            while x != -1 and h[i] < h[x]:\n                x = min_st[x]\n            min_st[i] = x\n        if h[i]<=h[i+1]:\n            max_st[i] = i+1\n        else:\n            x = max_st[i+1]\n            while x != -1 and h[i] > h[x]:\n                x = max_st[x]\n            max_st[i] = x\n    max_st1 = [-1]*n\n    min_st1 = [-1]*n\n    for i in range(1,n):\n        if h[i]>=h[i-1]:\n            min_st1[i] = i-1\n        else:\n            x = min_st1[i-1]\n            while x != -1 and h[i] < h[x]:\n                x = min_st1[x]\n            min_st1[i] = x\n        if h[i]<=h[i-1]:\n            max_st1[i] = i-1\n        else:\n            x = max_st1[i-1]\n            while x != -1 and h[i] > h[x]:\n                x = max_st1[x]\n            max_st1[i] = x\n    #print(min_st,max_st,max_st1,min_st1)\n    rishta = [[] for _ in range(n)]\n    for i,val in enumerate(min_st):\n        if val != -1:\n            rishta[i].append(val)\n            rishta[val].append(i)\n    for i,val in enumerate(min_st1):\n        if val != -1:\n            rishta[i].append(val)\n            rishta[val].append(i)\n    for i,val in enumerate(max_st):\n        if val != -1:\n            rishta[i].append(val)\n            rishta[val].append(i)\n    for i,val in enumerate(max_st1):\n        if val != -1:\n            rishta[i].append(val)\n            rishta[val].append(i)\n    lst = [10**10]*n\n    lst[0] = 0\n    for i in range(n-1):\n        lst[i+1] = min(lst[i+1],lst[i]+1)\n        for x in rishta[i]:\n            if x > i:\n                lst[x] = min(lst[x],lst[i]+1)\n    print(lst[-1])\n\n#Fast IO Region\nBUFSIZE = 8192\nclass FastIO(IOBase):\n    newlines = 0\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nif __name__ == '__main__':\n    main()",
    "prob_desc_created_at": "1599575700",
    "tags": [
        "dp",
        "data structures",
        "graphs"
    ],
    "hidden_unit_tests": ""
}
{
    "prob_desc_time_limit": "1 second",
    "prob_desc_sample_outputs": "[\"1\\n3\", \"2\\n3 4\", \"0\"]",
    "src_uid": "f046fc902b22fdbc3b1ec9cb4f411179",
    "prob_desc_notes": "NoteIn the first test, $$$p=2$$$.  If $$$x \\le 2$$$, there are no valid permutations for Yuzu. So $$$f(x)=0$$$ for all $$$x \\le 2$$$. The number $$$0$$$ is divisible by $$$2$$$, so all integers $$$x \\leq 2$$$ are not good.  If $$$x = 3$$$, $$$\\{1,2,3\\}$$$ is the only valid permutation for Yuzu. So $$$f(3)=1$$$, so the number $$$3$$$ is good.  If $$$x = 4$$$, $$$\\{1,2,3\\} , \\{1,3,2\\} , \\{2,1,3\\} , \\{2,3,1\\}$$$ are all valid permutations for Yuzu. So $$$f(4)=4$$$, so the number $$$4$$$ is not good.  If $$$x \\ge 5$$$, all $$$6$$$ permutations are valid for Yuzu. So $$$f(x)=6$$$ for all $$$x \\ge 5$$$, so all integers $$$x \\ge 5$$$ are not good. So, the only good number is $$$3$$$.In the third test, for all positive integers $$$x$$$ the value $$$f(x)$$$ is divisible by $$$p = 3$$$.",
    "prob_desc_description": "This is the easy version of the problem. The difference between versions is the constraints on $$$n$$$ and $$$a_i$$$. You can make hacks only if all versions of the problem are solved.First, Aoi came up with the following idea for the competitive programming problem:Yuzu is a girl who collecting candies. Originally, she has $$$x$$$ candies. There are also $$$n$$$ enemies numbered with integers from $$$1$$$ to $$$n$$$. Enemy $$$i$$$ has $$$a_i$$$ candies.Yuzu is going to determine a permutation $$$P$$$. A permutation is an array consisting of $$$n$$$ distinct integers from $$$1$$$ to $$$n$$$ in arbitrary order. For example, $$$\\{2,3,1,5,4\\}$$$ is a permutation, but $$$\\{1,2,2\\}$$$ is not a permutation ($$$2$$$ appears twice in the array) and $$$\\{1,3,4\\}$$$ is also not a permutation (because $$$n=3$$$ but there is the number $$$4$$$ in the array).After that, she will do $$$n$$$ duels with the enemies with the following rules:  If Yuzu has equal or more number of candies than enemy $$$P_i$$$, she wins the duel and gets $$$1$$$ candy. Otherwise, she loses the duel and gets nothing.  The candy which Yuzu gets will be used in the next duels. Yuzu wants to win all duels. How many valid permutations $$$P$$$ exist?This problem was easy and wasn't interesting for Akari, who is a friend of Aoi. And Akari made the following problem from the above idea:Let's define $$$f(x)$$$ as the number of valid permutations for the integer $$$x$$$.You are given $$$n$$$, $$$a$$$ and a prime number $$$p \\le n$$$. Let's call a positive integer $$$x$$$ good, if the value $$$f(x)$$$ is not divisible by $$$p$$$. Find all good integers $$$x$$$.Your task is to solve this problem made by Akari.",
    "prob_desc_output_spec": "In the first line, print the number of good integers $$$x$$$. In the second line, output all good integers $$$x$$$ in the ascending order. It is guaranteed that the number of good integers $$$x$$$ does not exceed $$$10^5$$$.",
    "prob_desc_input_spec": "The first line contains two integers $$$n$$$, $$$p$$$ $$$(2 \\le p \\le n \\le 2000)$$$. It is guaranteed, that the number $$$p$$$ is prime (it has exactly two divisors $$$1$$$ and $$$p$$$). The second line contains $$$n$$$ integers $$$a_1, a_2, \\ldots, a_n$$$ $$$(1 \\le a_i \\le 2000)$$$.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3",
    "lang_cluster": "Python",
    "difficulty": 1900,
    "file_name": "train_001.jsonl",
    "code_uid": "d5c42d3f633256749816436a710ad52a",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"3 2\\n3 4 5\", \"4 3\\n2 3 5 6\", \"4 3\\n9 1 1 1\"]",
    "exec_outcome": "PASSED",
    "source_code": "def func(length, prime):\n    nums = sorted(map(int, input().split()))\n    mini = max(nums[0], nums[-1]-length+1)\n\n    xs = list(range(mini, min(mini+length, nums[-1]+1)))\n    L = len(xs)  # candidates, 0~L-length\n\n    idxs = [0] * length\n    for i in range(L-1, -1, -1):\n        if xs[i] == nums[-1]:\n            idxs[-1] = length-i\n            break\n\n    for i in range(length-2, -1, -1):\n        diff = nums[i+1]-nums[i]\n        idxs[i] = min(length, idxs[i+1]+diff)\n\n    for i in range(length):\n        idxs[i] -= (length-1-i)\n    \n    from collections import defaultdict\n    num2i = defaultdict(set)\n\n    bad = [False] * (length+1)\n    for i in range(prime, length+1, prime):\n        bad[i] = True\n\n    flag = False\n    for i, n in enumerate(idxs):\n        if n == i+1:\n            if bad[n]:\n                flag = True\n                break\n        else:\n            num2i[n].add(i)\n\n    res = []\n    incri = 0\n    for x in xs:\n        if flag:\n            break\n        if not any((k+incri)%prime==0 for k in num2i):\n            res.append(x)\n        incri += 1\n        for k in list(num2i.keys()):\n            v = num2i[k]\n            if k+incri-1 in v:\n                v.remove(k+incri-1)\n                if (k+incri)%prime ==0:\n                    flag = True\n                    break\n                if not v:\n                    num2i.pop(k)\n\n    print(len(res))\n    print(\" \".join(map(str, res)) if res else \"\")\n\n\n# cases = int(input())\nfor i in range(1):\n    n, k = map(int, input().split())\n    func(n, k)",
    "prob_desc_created_at": "1593610500",
    "tags": [
        "combinatorics",
        "number theory",
        "math",
        "sortings",
        "binary search",
        "brute force"
    ],
    "hidden_unit_tests": ""
}
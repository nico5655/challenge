{
    "prob_desc_time_limit": "1 second",
    "prob_desc_sample_outputs": "[\"-1\\n1\\n1\\n-1\\n2\\n0\"]",
    "src_uid": "4754dd329ec5a01d4d101951656bf66a",
    "prob_desc_notes": "NoteIn the first query, $$$l = 3, r = 4$$$, subarray = $$$[3, 3]$$$. We can apply operation only to the subarrays of length $$$1$$$, which won't change the array; hence it is impossible to make all elements equal to $$$0$$$.In the second query, $$$l = 4, r = 6$$$, subarray = $$$[3, 1, 2]$$$. We can choose the whole subarray $$$(L = 4, R = 6)$$$ and replace all elements by their XOR $$$(3 \\oplus 1 \\oplus 2) = 0$$$, making the subarray $$$[0, 0, 0]$$$.In the fifth query, $$$l = 1, r = 6$$$, subarray = $$$[3, 0, 3, 3, 1, 2]$$$. We can make the operations as follows:   Choose $$$L = 4, R = 6$$$, making the subarray $$$[3, 0, 3, 0, 0, 0]$$$.  Choose $$$L = 1, R = 5$$$, making the subarray $$$[0, 0, 0, 0, 0, 0]$$$. ",
    "prob_desc_description": "You are given an array $$$a$$$ of $$$n$$$ integers $$$a_1, a_2, a_3, \\ldots, a_n$$$.You have to answer $$$q$$$ independent queries, each consisting of two integers $$$l$$$ and $$$r$$$.   Consider the subarray $$$a[l:r]$$$ $$$=$$$ $$$[a_l, a_{l+1}, \\ldots, a_r]$$$. You can apply the following operation to the subarray any number of times (possibly zero)-   Choose two integers $$$L$$$, $$$R$$$ such that $$$l \\le L \\le R \\le r$$$ and $$$R - L + 1$$$ is odd.  Replace each element in the subarray from $$$L$$$ to $$$R$$$ with the XOR of the elements in the subarray $$$[L, R]$$$.   The answer to the query is the minimum number of operations required to make all elements of the subarray $$$a[l:r]$$$ equal to $$$0$$$ or $$$-1$$$ if it is impossible to make all of them equal to $$$0$$$. You can find more details about XOR operation here.",
    "prob_desc_output_spec": "For each query, output a single integer  — the answer to that query.",
    "prob_desc_input_spec": "The first line contains two integers $$$n$$$ and $$$q$$$ $$$(1 \\le n, q \\le 2 \\cdot 10^5)$$$  — the length of the array $$$a$$$ and the number of queries. The next line contains $$$n$$$ integers $$$a_1, a_2, \\ldots, a_n$$$ $$$(0 \\le a_i \\lt 2^{30})$$$  — the elements of the array $$$a$$$. The $$$i$$$-th of the next $$$q$$$ lines contains two integers $$$l_i$$$ and $$$r_i$$$ $$$(1 \\le l_i \\le r_i \\le n)$$$  — the description of the $$$i$$$-th query.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3-64",
    "lang_cluster": "Python",
    "difficulty": 1900,
    "file_name": "train_087.jsonl",
    "code_uid": "2f53f1871ae62fc45c0f80af4319aebd",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"7 6\\n3 0 3 3 1 2 3\\n3 4\\n4 6\\n3 7\\n5 6\\n1 6\\n2 2\"]",
    "exec_outcome": "PASSED",
    "source_code": "#from math import ceil, floor #, gcd, log, factorial, comb, perm,\r\n#log10, log2, log, sin, asin, tan, atan, radians\r\n#from heapq import heappop,heappush,heapify #heappop(hq), heapify(list)\r\nfrom collections import defaultdict as dd\r\n#mydd=dd(list) for .append\r\n#from collections import deque as dq #deque  e.g. myqueue=dq(list)\r\n#append/appendleft/appendright/pop/popleft\r\nfrom bisect import bisect as bis #a=[1,3,4,6,7,8] #bis(a,5)-->3\r\n#import bisect #bisect.bisect_left(a,4)-->2 #bisect.bisect(a,4)-->3\r\n#import statistics as stat  # stat.median(a), mode, mean\r\n#from itertools import permutations(p,r)#combinations(p,r)\r\n#combinations_with_replacement#combinations(p,r) gives r-length tuples,\r\n#in sorted order, with repeated elements#product gives outer product combos\r\nimport sys\r\ninput = sys.stdin.readline\r\n#print = sys.stdout.write\r\n#sys.setrecursionlimit(100000) #default is 1000 \r\n############ ---- Input Functions ---- ############\r\ndef inp():\r\n    return(int(input()))\r\ndef inlt():\r\n    return(list(map(int,input().split())))   #.split(','), default is space\r\n#list([0,*map(int,input().split(\" \"))]) # pad a zero to avoid zero indexing\r\ndef insr():\r\n    s = input()\r\n    return(list(s[:len(s) - 1]))\r\n####################################################\r\nt=1\r\n#t = int(input())\r\nfor tc in range(t):\r\n    n,q=map(int, input().split())\r\n    a=inlt()\r\n    ppa=[0]\r\n    psa=[0]\r\n    for i in a:\r\n        psa.append(psa[-1]^i)\r\n        ppa.append(ppa[-1]+i)\r\n    occ1=dd(list)\r\n    occ2=dd(list)\r\n    for i in range(1,n+1):\r\n        if i%2:\r\n            occ1[psa[i]].append(i)\r\n        else:\r\n            occ2[psa[i]].append(i)\r\n    for i in range(q):\r\n        l,r=map(int,input().split())\r\n        #if i==417 and n==200000:print(str(l)+'_'+str(r)+'_'+'*'.join(map(str,a[l-1:r])));continue\r\n        if ppa[r]==ppa[l-1]:\r\n            print(0)\r\n        elif (r-l)%2: # nasty if even range, use occ1/occ2 to track odd/even indices of psa values\r\n            if psa[r]==psa[l-1]:\r\n                if l%2:\r\n                    ind=bis(occ1[psa[l-1]],l-1)\r\n                    if ind>=len(occ1[psa[l-1]]):\r\n                        j=n+1\r\n                    else:\r\n                        j=occ1[psa[l-1]][ind]\r\n                else:\r\n                    ind=bis(occ2[psa[l-1]],l-1)\r\n                    if ind>=len(occ2[psa[l-1]]):\r\n                        j=n+1\r\n                    else:\r\n                        j=occ2[psa[l-1]][ind]\r\n                if j<r:\r\n                    if a[l-1]==0 or a[r-1]==0:\r\n                        print(1)\r\n                    else:\r\n                        print(2)\r\n                else:\r\n                    print(-1)\r\n            else:\r\n                print(-1)\r\n        elif psa[r]^psa[l-1]==0:\r\n            print(1)\r\n        else:\r\n            print(-1)\r\n#print(*ans,sep=' ')##print(\"{:.3f}\".format(ans)+\"%\")\r\n#:b binary :% eg print(\"{:6.2%}\".format(ans))\r\n#print(\" \".join(str(i) for i in ans))\r\n#print(\" \".join(map(str,ans))) #seems faster\r\n#print(a[0] if a else 0)\r\n#prefixsum a=[a1...an] #psa=[0]*(n+1)\r\n#for i in range(n): psa[i+1]=psa[i]+a[i]\r\n#sum[:ax]=psa[x+1] e.g. sum 1st 5 items in psa[5]\r\n#ASCII<->number ord('f')=102 chr(102)='f'\r\n#def binary_search(li, val, lb, ub):\r\n#    while ((ub-lb)>1):\r\n#        mid = (lb + ub) // 2\r\n#        if li[mid] >= val:\r\n#            ub = mid\r\n#        else:\r\n#            lb = mid\r\n#    return lb+1 #return index of elements <val in li\r\n#def binary_search(li, val, lb, ub):\r\n#    ans = -1\r\n#    while (lb <= ub):\r\n#        mid = (lb + ub) // 2\r\n#        if li[mid] > val:\r\n#            ub = mid - 1\r\n#        elif val > li[mid]:\r\n#            lb = mid + 1\r\n#        else:\r\n#            ans = mid  # return index\r\n#            break\r\n#    return ans\r\n##########\r\n#def pref(li):\r\n#    pref_sum = [0]\r\n#    for i in li:\r\n#        pref_sum.append(pref_sum[-1] + i)\r\n#    return pref_sum\r\n##########\r\n#def suff(li):\r\n#    suff_sum = [0]\r\n#    for i in range(len(li)-1,-1,-1):\r\n#        suff_sum.insert(0,suff_sum[0] + li[i])\r\n#    return suff_sum\r\n#############\r\n#def maxSubArraySumI(arr): #Kadane's algorithm with index\r\n#    max_till_now=arr[0];max_ending=0;size=len(arr)\r\n#    start=0;end=0;s=0\r\n#    for i in range(0, size):\r\n#        max_ending = max_ending + arr[i]\r\n#        if max_till_now < max_ending:\r\n#            max_till_now=max_ending\r\n#            start=s;end=i\r\n#        if max_ending<0:\r\n#            max_ending=0\r\n#            s=i+1\r\n#    return max_till_now,start,end\r\n############# avoid max for 2 elements - slower than direct if\r\n#def maxSubArraySum(arr): #Kadane's algorithm\r\n#    max_till_now=arr[0];max_ending=0;size=len(arr)\r\n#    for i in range(0, size):\r\n#        max_ending = max_ending + arr[i]\r\n#        if max_till_now < max_ending:max_till_now=max_ending\r\n#        if max_ending<0:max_ending=0\r\n#    return max_till_now\r\n#############\r\n#def findbits(x):\r\n#    tmp=[]\r\n#    while x>0:tmp.append(x%2);x//=2\r\n#    tmp.reverse()\r\n#    return tmp\r\n##############Dijkstra algorithm example\r\n#dg=[999999]*(n+1);dg[n]=0;todo=[(0,n)];chkd=[0]*(n+1)\r\n#while todo:#### find x with min dg in todo\r\n#    _,x=hq.heappop(todo)\r\n#    if chkd[x]:continue\r\n#    for i in coming[x]:going[i]-=1\r\n#    for i in coming[x]:\r\n#        tmp=1+dg[x]+going[i]\r\n#        if tmp<dg[i]:dg[i]=tmp;hq.heappush(todo,(dg[i],i))   \r\n#    chkd[x]=1\r\n################ \r\n# adj swaps to match 2 binary strings: sum_{i=1}^n(abs(diff in i-th prefix sums))\r\n###############\r\n##s=[2, 3, 1, 4, 5, 3]\r\n##sorted(range(len(s)), key=lambda k: s[k])\r\n##gives sorted indices [2, 0, 1, 5, 3, 4]\r\n##m= [[3, 4, 6], [2, 4, 8], [2, 3, 4], [1, 2, 3], [7, 6, 7], [1, 8, 2]]\r\n##m.sort(reverse=True,key=lambda k:k[2]) #sorts m according to 3rd elements\r\n#import bisect  #li = [1, 3, 4, 4, 4, 6, 7]#sorted li, use b search, so log(n)\r\n#bisect.bisect(li,4)-->5 #bisect.bisect_left(li,4)-->2\r\n###############\r\n##def chkprime(x):\r\n##    if x==2 or x==3:return True\r\n##    if x%2==0 or x<2:return False\r\n##    for i in range(3,int(x**0.5)+1,2):\r\n##        if x%i==0:return False\r\n##    return True\r\n############### prime factoring functions\r\n##def pfactors(n):\r\n##    f=[];d=3\r\n##    while n%2==0:f.append(2);n//=2\r\n##    while d*d<=n:\r\n##        while n%d==0:f.append(d);n//=d\r\n##        d+=2\r\n##    if n>1:f.append(n)\r\n##    return f\r\n############################## check equivalence under rotation O(n)\r\n##def cyclic_equiv(u,v):\r\n##    n,i,j=len(u),0,0\r\n##    if n!=len(v):return False\r\n##    while i<n and j<n:\r\n##        k=1\r\n##        while k<=n and u[(i+k)%n]==v[(j+k)%n]:k+=1\r\n##        if k>n:return True\r\n##        if u[(i+k)%n]>v[(j+k)%n]:\r\n##            i+=k\r\n##        else:\r\n##            j+=k\r\n##    return False\r\n",
    "prob_desc_created_at": "1667572500",
    "tags": [
        "binary search",
        "bitmasks",
        "constructive algorithms",
        "data structures"
    ],
    "hidden_unit_tests": ""
}
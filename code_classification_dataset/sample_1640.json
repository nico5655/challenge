{
    "prob_desc_time_limit": "1 second",
    "prob_desc_sample_outputs": "[\"1 4\", \"3 3\", \"1 6\"]",
    "src_uid": "e65b974a85067500f20b316275dc5821",
    "prob_desc_notes": "NoteIn the first example, possible assignments for each minimum and maximum are described in picture below. Of course, there are multiple possible assignments for each minimum and maximum.   In the second example, possible assignments for each minimum and maximum are described in picture below. The $$$f$$$ value of valid assignment of this tree is always $$$3$$$.   In the third example, possible assignments for each minimum and maximum are described in picture below. Of course, there are multiple possible assignments for each minimum and maximum.   ",
    "prob_desc_description": "You have unweighted tree of $$$n$$$ vertices. You have to assign a positive weight to each edge so that the following condition would hold:  For every two different leaves $$$v_{1}$$$ and $$$v_{2}$$$ of this tree, bitwise XOR of weights of all edges on the simple path between $$$v_{1}$$$ and $$$v_{2}$$$ has to be equal to $$$0$$$. Note that you can put very large positive integers (like $$$10^{(10^{10})}$$$).It's guaranteed that such assignment always exists under given constraints. Now let's define $$$f$$$ as the number of distinct weights in assignment.  In this example, assignment is valid, because bitwise XOR of all edge weights between every pair of leaves is $$$0$$$. $$$f$$$ value is $$$2$$$ here, because there are $$$2$$$ distinct edge weights($$$4$$$ and $$$5$$$). In this example, assignment is invalid, because bitwise XOR of all edge weights between vertex $$$1$$$ and vertex $$$6$$$ ($$$3, 4, 5, 4$$$) is not $$$0$$$. What are the minimum and the maximum possible values of $$$f$$$ for the given tree? Find and print both.",
    "prob_desc_output_spec": "Print two integers — the minimum and maximum possible value of $$$f$$$ can be made from valid assignment of given tree. Note that it's always possible to make an assignment under given constraints.",
    "prob_desc_input_spec": "The first line contains integer $$$n$$$ ($$$3 \\le n \\le 10^{5}$$$) — the number of vertices in given tree. The $$$i$$$-th of the next $$$n-1$$$ lines contains two integers $$$a_{i}$$$ and $$$b_{i}$$$ ($$$1 \\le a_{i} \\lt b_{i} \\le n$$$) — it means there is an edge between $$$a_{i}$$$ and $$$b_{i}$$$. It is guaranteed that given graph forms tree of $$$n$$$ vertices.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3",
    "lang_cluster": "Python",
    "difficulty": 1800,
    "file_name": "train_011.jsonl",
    "code_uid": "a41ce4f441f3b40ccf75e76627d50ab2",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"6\\n1 3\\n2 3\\n3 4\\n4 5\\n5 6\", \"6\\n1 3\\n2 3\\n3 4\\n4 5\\n4 6\", \"7\\n1 2\\n2 7\\n3 4\\n4 7\\n5 6\\n6 7\"]",
    "exec_outcome": "PASSED",
    "source_code": "# by the authority of GOD     author: manhar singh sachdev #\n\nimport os, sys\nfrom io import BytesIO, IOBase\nfrom collections import defaultdict\n\ndef main():\n    n = int(input())\n    path = defaultdict(set)\n    parent = [0]*(n+1)\n    for _ in range(n-1):\n        a,b = map(int,input().split())\n        path[a].add(b)\n        path[b].add(a)\n    root = -1\n    z = [0]*(n+1)\n    for i in path:\n        if len(path[i])>1:\n            root = i\n        else:\n            x = path[i].pop()\n            parent[x] += 1\n            path[i].add(x)\n            z[i] = 1\n    st = [root]\n    ans = 1\n    while len(st):\n        if not len(path[st[-1]]):\n            x = st.pop()\n            if len(st):\n                z[st[-1]] |= (3^z[x])\n                if z[st[-1]] == 3:\n                    ans = 3\n                    break\n            continue\n        i = path[st[-1]].pop()\n        path[i].remove(st[-1])\n        st.append(i)\n    ans1 = n-1\n    for i in parent:\n        ans1 -= max(0,(i-1))\n    print(ans,ans1)\n\n# Fast IO Region\nBUFSIZE = 8192\nclass FastIO(IOBase):\n    newlines = 0\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nif __name__ == '__main__':\n    main()",
    "prob_desc_created_at": "1586700300",
    "tags": [
        "constructive algorithms",
        "greedy",
        "bitmasks",
        "trees"
    ],
    "hidden_unit_tests": ""
}
{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"3\\n1 2 3 \\n0\"]",
    "src_uid": "fe58bdfcef01e3f53745e46c65cbec17",
    "prob_desc_notes": "NoteFor the first query, the given sequence itself is monotone triples free.For the second query, it can be shown that there is no subsequence $$$b$$$ with length greater than $$$2$$$ such that $$$b$$$ is monotone triples free.",
    "prob_desc_description": "Given a sequence of integers $$$a$$$ of length $$$n$$$, a tuple $$$(i,j,k)$$$ is called monotone triples if   $$$1 \\le i&lt;j&lt;k\\le n$$$;  $$$a_i \\le a_j \\le a_k$$$ or $$$a_i \\ge a_j \\ge a_k$$$ is satisfied. For example, $$$a=[5,3,4,5]$$$, then $$$(2,3,4)$$$ is monotone triples for sequence $$$a$$$ while $$$(1,3,4)$$$ is not.Bob is given a sequence of integers $$$a$$$ of length $$$n$$$ in a math exam. The exams itself contains questions of form $$$L, R$$$, for each of them he is asked to find any subsequence $$$b$$$ with size greater than $$$2$$$ (i.e. $$$|b| \\ge 3$$$) of sequence $$$a_L, a_{L+1},\\ldots, a_{R}$$$.Recall that an sequence $$$b$$$ is a subsequence of sequence $$$a$$$ if $$$b$$$ can be obtained by deletion of several (possibly zero, or all) elements.However, he hates monotone stuff, and he wants to find a subsequence free from monotone triples. Besides, he wants to find one subsequence with the largest length among all subsequences free from monotone triples for every query.Please help Bob find out subsequences meeting the above constraints.",
    "prob_desc_output_spec": "For each query, output $$$0$$$ if there is no subsequence $$$b$$$ satisfying the constraints mentioned in the legend. You can print the empty line after but that's not mandatory. Otherwise, output one integer $$$k$$$ ($$$k &gt; 2$$$) denoting the length of sequence $$$b$$$, then output $$$k$$$ integers $$$i_1, i_2, \\ldots, i_k$$$ ($$$L \\le i_1 &lt; i_2&lt;\\ldots&lt;i_k\\le R$$$) satisfying that $$$b_j = a_{i_j}$$$ for $$$1 \\le j \\le k$$$. If there are multiple answers with the maximum length, print any of them.",
    "prob_desc_input_spec": "The first line contains two integers $$$n$$$, $$$q$$$ ($$$3 \\le n \\le 2 \\cdot 10^5$$$, $$$1 \\le q \\le 2 \\cdot 10^5$$$) â€” the length of sequence $$$a$$$ and the number of queries. The second line contains $$$n$$$ integers $$$a_1,a_2,\\ldots, a_n$$$ ($$$1 \\le a_i \\le 10^{9}$$$), representing the sequence $$$a$$$. Then each of the following $$$q$$$ lines contains two integers $$$L$$$, $$$R$$$ ($$$1 \\le L,R \\le n$$$, $$$R-L\\ge 2$$$).",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3",
    "lang_cluster": "Python",
    "difficulty": 3100,
    "file_name": "train_068.jsonl",
    "code_uid": "6bfb66e5e96bb387e5a81eb943650f98",
    "prob_desc_memory_limit": "512 megabytes",
    "prob_desc_sample_inputs": "[\"6 2\\n3 1 4 1 5 9\\n1 3\\n4 6\"]",
    "exec_outcome": "PASSED",
    "source_code": "import sys\nimport io, os\ninput = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline\nfrom operator import itemgetter\nimport bisect\n\nn,q=map(int,input().split())\nA=[-1]+list(map(int,input().split()))\nQ=[list(map(int,input().split()))+[i] for i in range(q)]\n\nQ.sort(key=itemgetter(1))\nQ_ind=0\n\nANS1=[-1000,-1000,-1000,-1000]\nANS2=[-1000,-1000,-1000]\nANS3=[-1000,-1000,-1000]\nANS=[[0]]*q\n\nIncrease=[-1]\nDecrease=[-1]\nIncrease2=[-1]\nDecrease2=[-1]\n\nNo_inclast=[-1]*(n+1)\nNo_declast=[-1]*(n+1)\nInc_next=[-1]*(n+1)\nDec_next=[-1]*(n+1)\n\nLEN=n\n\nBIT=[0]*(LEN+1)\n\ndef update(v,w):\n    while v<=LEN:\n        BIT[v]+=w\n        v+=(v&(-v))\n\ndef getvalue(v):\n    ANS=0\n    while v!=0:\n        ANS+=BIT[v]\n        v-=(v&(-v))\n    return ANS\n\ndef bisect_on_BIT(x):\n\n    if x<=0:\n        return 0\n    \n    ANS=0\n    h=1<<(LEN.bit_length()-1)\n    while h>0:\n        if ANS+h<=LEN and BIT[ANS+h]<x:\n            x-=BIT[ANS+h]\n            ANS+=h\n        h//=2\n\n    return ANS+1\n\nNo_incdeclist=[0]*n\n\nfor i in range(1,n+1):\n    No_inc=-1\n    No_dec=-1\n    \n    while Increase[-1]!=-1 and A[i]<A[Increase[-1]]:\n        ind=Increase.pop()\n        if Increase2[-1]==ind:\n            Increase2.pop()\n\n        No_incdeclist[ind]+=1\n\n        if No_incdeclist[ind]==2:\n            update(ind,1)\n\n        if No_inc==-1:\n            No_inc=ind\n\n    while Increase2[-1]!=-1 and A[i]==A[Increase2[-1]]:\n        Increase2.pop()\n\n    Increase.append(i)\n    Increase2.append(i)\n        \n    if No_inc!=-1:\n        No_inclast[i]=No_inc\n        if Inc_next[No_inc]==-1:\n            Inc_next[No_inc]=i\n    else:\n        No_inclast[i]=No_inclast[i-1]\n        \n\n    while Decrease[-1]!=-1 and A[i]>A[Decrease[-1]]:\n        ind=Decrease.pop()\n        if Decrease2[-1]==ind:\n            Decrease2.pop()\n        \n        No_incdeclist[ind]+=1\n\n        if No_incdeclist[ind]==2:\n            update(ind,1)\n\n        if No_dec==-1:\n            No_dec=ind\n\n    while Decrease2[-1]!=-1 and A[i]==A[Decrease2[-1]]:\n        Decrease2.pop()\n\n    Decrease.append(i)\n    Decrease2.append(i)\n\n    if No_dec!=-1:\n        No_declast[i]=No_dec\n        if Dec_next[No_dec]==-1:\n            Dec_next[No_dec]=i\n    else:\n        No_declast[i]=No_declast[i-1]\n\n    MININD=min(Increase2[-2],Decrease2[-2])\n    \n    if MININD>1:\n        MIN=bisect_on_BIT(getvalue(MININD))\n\n        x=Increase[bisect.bisect_left(Increase,MIN)]\n        y=Decrease[bisect.bisect_left(Decrease,MIN)]\n                \n        if MIN>0 and ANS1[0]<MIN and A[x]<A[i] and A[y]>A[i]:\n\n            if x>y:\n                x,y=y,x\n                \n            ANS1=[MIN,x,y,i]\n\n    n_inc=No_inclast[i]\n    mid=Inc_next[n_inc]\n    \n    if n_inc>0 and A[mid]<A[i] and ANS2[0]<n_inc:\n        ANS2=[n_inc,mid,i]\n\n    n_dec=No_declast[i]\n    mid=Dec_next[n_dec]\n     \n    if n_dec>0 and A[mid]>A[i] and ANS3[0]<n_dec:\n        ANS3=[n_dec,mid,i]\n                \n    while Q_ind<q and Q[Q_ind][1]==i:\n        l,r,qu=Q[Q_ind]\n\n        if ANS1[0]>=l:\n            ANS[qu]=ANS1\n        elif ANS2[0]>=l:\n            ANS[qu]=ANS2\n        elif ANS3[0]>=l:\n            ANS[qu]=ANS3\n        Q_ind+=1\n\n    #print(Increase,Decrease,inclast,declast,No_inclast,No_declast)\n    #print(ANS1,ANS2,ANS3)\n    #print()\n\nfor x in ANS:\n    if x==[0]:\n        sys.stdout.write(str(0)+\"\\n\")\n    else:\n        sys.stdout.write(str(len(x))+\"\\n\")\n        sys.stdout.write(\" \".join(map(str,x))+\"\\n\")\n\n    \n    \n",
    "prob_desc_created_at": "1585661700",
    "tags": [
        "data structures"
    ],
    "hidden_unit_tests": ""
}
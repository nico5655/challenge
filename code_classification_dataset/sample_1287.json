{
    "prob_desc_time_limit": "1 second",
    "prob_desc_sample_outputs": "[\"-100 1\\n1 1 1 -1\"]",
    "src_uid": "d5e09a8fb7eeeba9a41daa2b565866ba",
    "prob_desc_notes": "NoteFor the first door Naruto can use energies $$$[-100, 1]$$$. The required equality does indeed hold: $$$1 \\cdot (-100) + 100 \\cdot 1 = 0$$$.For the second door Naruto can use, for example, energies $$$[1, 1, 1, -1]$$$. The required equality also holds: $$$1 \\cdot 1 + 2 \\cdot 1 + 3 \\cdot 1 + 6 \\cdot (-1) = 0$$$.",
    "prob_desc_description": "Naruto has sneaked into the Orochimaru's lair and is now looking for Sasuke. There are $$$T$$$ rooms there. Every room has a door into it, each door can be described by the number $$$n$$$ of seals on it and their integer energies $$$a_1$$$, $$$a_2$$$, ..., $$$a_n$$$. All energies $$$a_i$$$ are nonzero and do not exceed $$$100$$$ by absolute value. Also, $$$n$$$ is even.In order to open a door, Naruto must find such $$$n$$$ seals with integer energies $$$b_1$$$, $$$b_2$$$, ..., $$$b_n$$$ that the following equality holds: $$$a_{1} \\cdot b_{1} + a_{2} \\cdot b_{2} + ... + a_{n} \\cdot b_{n} = 0$$$. All $$$b_i$$$ must be nonzero as well as $$$a_i$$$ are, and also must not exceed $$$100$$$ by absolute value. Please find required seals for every room there.",
    "prob_desc_output_spec": "For each door print a space separated sequence of nonzero integers $$$b_1$$$, $$$b_2$$$, ..., $$$b_n$$$ ($$$|b_{i}| \\leq 100$$$, $$$b_{i} \\neq 0$$$) denoting the seals that can open the door. If there are multiple valid answers, print any. It can be proven that at least one answer always exists.",
    "prob_desc_input_spec": "The first line contains the only integer $$$T$$$ ($$$1 \\leq T \\leq 1000$$$) standing for the number of rooms in the Orochimaru's lair. The other lines contain descriptions of the doors. Each description starts with the line containing the only even integer $$$n$$$ ($$$2 \\leq n \\leq 100$$$) denoting the number of seals. The following line contains the space separated sequence of nonzero integers $$$a_1$$$, $$$a_2$$$, ..., $$$a_n$$$ ($$$|a_{i}| \\leq 100$$$, $$$a_{i} \\neq 0$$$) denoting the energies of seals.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3",
    "lang_cluster": "Python",
    "difficulty": 800,
    "file_name": "train_007.jsonl",
    "code_uid": "bc963f8d964bd813df4b93b899aabd32",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"2\\n2\\n1 100\\n4\\n1 2 3 6\"]",
    "exec_outcome": "PASSED",
    "source_code": "import os\nimport heapq\nimport sys,threading\nimport math\nimport bisect\nimport operator\nfrom collections import defaultdict\nsys.setrecursionlimit(10**5)\nfrom io import BytesIO, IOBase\ndef gcd(a,b):\n    if b==0:\n\n        return a\n    else:\n        return gcd(b,a%b)\ndef power(x, p,m):\n    res = 1\n    while p:\n        if p & 1:\n            res = (res * x) % m\n        x = (x * x) % m\n        p >>= 1\n    return res\ndef inar():\n    return [int(k) for k in input().split()]\n\ndef lcm(num1,num2):\n    return (num1*num2)//gcd(num1,num2)\n\ndef main():\n    t=int(input())\n    for _ in range(t):\n        n=int(input())\n        arr=inar()\n        ans=[]\n\n        for i in range(0,n,2):\n            two=arr[i+1]\n            one=arr[i]\n            if (one>0 and two>0) or (one<0 and two<0):\n                two=-1*(abs(two))\n                ans.append(two)\n                ans.append(abs(one))\n            else:\n                ans.append(abs(two))\n                ans.append(abs(one))\n        print(*ans)\n\n\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nif __name__ == \"__main__\":\n    main()\n    #threadin.Thread(target=main).start()\n",
    "prob_desc_created_at": "1603623900",
    "tags": [
        "math"
    ],
    "hidden_unit_tests": ""
}
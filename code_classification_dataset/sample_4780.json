{
    "prob_desc_time_limit": "3 seconds",
    "prob_desc_sample_outputs": "[\"3\\n3\\n15\\n15\\n332103349\\n99224487\"]",
    "src_uid": "81efc64bba6d5a667e453260b83640e9",
    "prob_desc_notes": "NoteIn the first test case, the robot has the opportunity to clean the dirty cell every second. Using the geometric distribution, we can find out that with the success rate of $$$25\\%$$$, the expected number of tries to clear the dirty cell is $$$\\frac 1 {0.25} = 4$$$. But because the first moment the robot has the opportunity to clean the cell is before the robot starts moving, the answer is $$$3$$$.  Illustration for the first example. The blue arc is the robot. The red star is the target dirt cell. The purple square is the initial position of the robot. Each second the robot has an opportunity to clean a row and a column, denoted by yellow stripes. In the second test case, the board size and the position are different, but the robot still has the opportunity to clean the dirty cell every second, and it has the same probability of cleaning. Therefore the answer is the same as in the first example.  Illustration for the second example. The third and the fourth case are almost the same. The only difference is that the position of the dirty cell and the robot are swapped. But the movements in both cases are identical, hence the same result.",
    "prob_desc_description": "The statement of this problem shares a lot with problem A. The differences are that in this problem, the probability is introduced, and the constraint is different.A robot cleaner is placed on the floor of a rectangle room, surrounded by walls. The floor consists of $$$n$$$ rows and $$$m$$$ columns. The rows of the floor are numbered from $$$1$$$ to $$$n$$$ from top to bottom, and columns of the floor are numbered from $$$1$$$ to $$$m$$$ from left to right. The cell on the intersection of the $$$r$$$-th row and the $$$c$$$-th column is denoted as $$$(r,c)$$$. The initial position of the robot is $$$(r_b, c_b)$$$.In one second, the robot moves by $$$dr$$$ rows and $$$dc$$$ columns, that is, after one second, the robot moves from the cell $$$(r, c)$$$ to $$$(r + dr, c + dc)$$$. Initially $$$dr = 1$$$, $$$dc = 1$$$. If there is a vertical wall (the left or the right walls) in the movement direction, $$$dc$$$ is reflected before the movement, so the new value of $$$dc$$$ is $$$-dc$$$. And if there is a horizontal wall (the upper or lower walls), $$$dr$$$ is reflected before the movement, so the new value of $$$dr$$$ is $$$-dr$$$.Each second (including the moment before the robot starts moving), the robot cleans every cell lying in the same row or the same column as its position. There is only one dirty cell at $$$(r_d, c_d)$$$. The job of the robot is to clean that dirty cell. After a lot of testings in problem A, the robot is now broken. It cleans the floor as described above, but at each second the cleaning operation is performed with probability $$$\\frac p {100}$$$ only, and not performed with probability $$$1 - \\frac p {100}$$$. The cleaning or not cleaning outcomes are independent each second.Given the floor size $$$n$$$ and $$$m$$$, the robot's initial position $$$(r_b, c_b)$$$ and the dirty cell's position $$$(r_d, c_d)$$$, find the expected time for the robot to do its job.It can be shown that the answer can be expressed as an irreducible fraction $$$\\frac x y$$$, where $$$x$$$ and $$$y$$$ are integers and $$$y \\not \\equiv 0 \\pmod{10^9 + 7} $$$. Output the integer equal to $$$x \\cdot y^{-1} \\bmod (10^9 + 7)$$$. In other words, output such an integer $$$a$$$ that $$$0 \\le a &lt; 10^9 + 7$$$ and $$$a \\cdot y \\equiv x \\pmod {10^9 + 7}$$$.",
    "prob_desc_output_spec": "For each test case, print a single integer — the expected time for the robot to clean the dirty cell, modulo $$$10^9 + 7$$$.",
    "prob_desc_input_spec": "Each test contains multiple test cases. The first line contains the number of test cases $$$t$$$ ($$$1 \\le t \\le 10$$$). Description of the test cases follows. A test case consists of only one line, containing $$$n$$$, $$$m$$$, $$$r_b$$$, $$$c_b$$$, $$$r_d$$$, $$$c_d$$$, and $$$p$$$ ($$$4 \\le n \\cdot m \\le 10^5$$$, $$$n, m \\ge 2$$$, $$$1 \\le r_b, r_d \\le n$$$, $$$1 \\le c_b, c_d \\le m$$$, $$$1 \\le p \\le 99$$$) — the sizes of the room, the initial position of the robot, the position of the dirt cell and the probability of cleaning in percentage.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3-64",
    "lang_cluster": "Python",
    "difficulty": 2300,
    "file_name": "train_106.jsonl",
    "code_uid": "c74a21d33761d54b09b23d24f8972064",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"6\\n2 2 1 1 2 1 25\\n3 3 1 2 2 2 25\\n10 10 1 1 10 10 75\\n10 10 10 10 1 1 75\\n5 5 1 3 2 2 10\\n97 98 3 5 41 43 50\"]",
    "exec_outcome": "PASSED",
    "source_code": "import os,sys\r\nfrom io import BytesIO, IOBase\r\n\r\nfrom collections import defaultdict,deque,Counter\r\nfrom bisect import bisect_left,bisect_right\r\nfrom heapq import heappush,heappop\r\nfrom functools import lru_cache\r\nfrom itertools import accumulate\r\nimport math\r\n\r\n# Fast IO Region\r\nBUFSIZE = 8192\r\nclass FastIO(IOBase):\r\n    newlines = 0\r\n    def __init__(self, file):\r\n        self._fd = file.fileno()\r\n        self.buffer = BytesIO()\r\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\r\n        self.write = self.buffer.write if self.writable else None\r\n    def read(self):\r\n        while True:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            if not b:\r\n                break\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines = 0\r\n        return self.buffer.read()\r\n    def readline(self):\r\n        while self.newlines == 0:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            self.newlines = b.count(b\"\\n\") + (not b)\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines -= 1\r\n        return self.buffer.readline()\r\n    def flush(self):\r\n        if self.writable:\r\n            os.write(self._fd, self.buffer.getvalue())\r\n            self.buffer.truncate(0), self.buffer.seek(0)\r\nclass IOWrapper(IOBase):\r\n    def __init__(self, file):\r\n        self.buffer = FastIO(file)\r\n        self.flush = self.buffer.flush\r\n        self.writable = self.buffer.writable\r\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\r\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\r\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\r\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\r\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\r\n\r\n# for _ in range(int(input())):\r\n#     n = int(input())\r\n#     a = list(map(int, input().split(' ')))\r\n\r\n# for _ in range(int(input())):\r\n#     def solve():\r\n#         n, m, rb, cb, rd, cd = list(map(int, input().split(' ')))\r\n#         dr = dc = 1\r\n#         ans = 0\r\n#         if rb == rd or cb == cd:\r\n#             print(0)\r\n#             return\r\n#         while rb != rd and cb != cd:\r\n#             if dr == dc == 1:\r\n#                 while rb != rd and cb != cd and 1 <= rb < n and 1 <= cb < m:\r\n#                     rb += 1\r\n#                     cb += 1\r\n#                     ans += 1\r\n#                 if rb == rd or cb == cd:\r\n#                     print(ans)\r\n#                     return\r\n#                 if rb == n:\r\n#                     dr = -1\r\n#                 if cb == m:\r\n#                     dc = -1\r\n#             elif dr == 1 and dc == -1:\r\n#                 while rb != rd and cb != cd and 1 <= rb < n and 1 < cb <= m:\r\n#                     rb += 1\r\n#                     cb -= 1\r\n#                     ans += 1\r\n#                 if rb == rd or cb == cd:\r\n#                     print(ans)\r\n#                     return\r\n#                 if rb == n:\r\n#                     dr = -1\r\n#                 if cb == 1:\r\n#                     dc = 1\r\n#             elif dr == -1 and dc == 1:\r\n#                 while rb != rd and cb != cd and 1 < rb <= n and 1 <= cb < m:\r\n#                     rb -= 1\r\n#                     cb += 1\r\n#                     ans += 1\r\n#                 if rb == rd or cb == cd:\r\n#                     print(ans)\r\n#                     return\r\n#                 if rb == 1:\r\n#                     dr = 1\r\n#                 if cb == m:\r\n#                     dc = -1\r\n#             else:\r\n#                 while rb != rd and cb != cd and 1 < rb <= n and 1 < cb <= m:\r\n#                     rb -= 1\r\n#                     cb -= 1\r\n#                     ans += 1\r\n#                 if rb == rd or cb == cd:\r\n#                     print(ans)\r\n#                     return\r\n#                 if rb == 1:\r\n#                     dr = 1\r\n#                 if cb == 1:\r\n#                     dc = 1\r\n#     solve()\r\n\r\n# for _ in range(int(input())):\r\n#     n = int(input())\r\n#     a = [list(map(int, input().split(' '))) for _ in range(n)]\r\n#     a.sort(key = lambda x : x[1] - x[0])\r\n#     vis = set()\r\n#     for i in range(n):\r\n#         l, r = a[i]\r\n#         for i in range(l, r + 1):\r\n#             if i not in vis:\r\n#                 print(l, r, i)\r\n#                 vis.add(i)\r\n#     print()\r\n\r\n# for _ in range(int(input())):\r\n#     n = int(input())\r\n#     a = list(map(int, input().split(' ')))\r\n#     def check(mid):\r\n#         b = a[:]\r\n#         for i in range(n - 1, 1, -1):\r\n#             if b[i] < mid:\r\n#                 return False\r\n#             r = min(a[i], b[i] - mid)\r\n#             r //= 3\r\n#             b[i] -= 3 * r\r\n#             b[i - 1] += r\r\n#             b[i - 2] += 2 * r\r\n#         return min(b) >= mid\r\n\r\n#     l, r = 1, 10 ** 9\r\n#     while l <= r:\r\n#         mid = (l + r) // 2\r\n#         if check(mid):\r\n#             l = mid + 1\r\n#         else:\r\n#             r = mid - 1\r\n#     print(r)\r\n\r\nmod = 10 ** 9 + 7\r\nfor _ in range(int(input())):\r\n    def solve():\r\n        n, m, rb, cb, rd, cd, p = list(map(int, input().split(' ')))\r\n        dr = dc = 1\r\n        ans = 0\r\n        tmp = []\r\n        vis = set()\r\n        if rb == n:\r\n            dr = -1\r\n        if cb == m:\r\n            dc = -1\r\n        if rb == rd or cb == cd:\r\n            tmp.append(0)\r\n            vis.add((rb, cb, dr, dc))\r\n        ok = True\r\n        while ok: \r\n            if dr == dc == 1:\r\n                while 1 <= rb < n and 1 <= cb < m:\r\n                    rb += 1\r\n                    cb += 1\r\n                    ans += 1\r\n                    if rb == n:\r\n                        dr = -1\r\n                    if cb == m:\r\n                        dc = -1\r\n                    if rb == rd or cb == cd:\r\n                        if (rb, cb, dr, dc) in vis:\r\n                            T = ans - tmp[0]\r\n                            ok = False\r\n                            break\r\n                        tmp.append(ans)\r\n                        vis.add((rb, cb, dr, dc))\r\n                \r\n            elif dr == 1 and dc == -1:\r\n                while 1 <= rb < n and 1 < cb <= m:\r\n                    rb += 1\r\n                    cb -= 1\r\n                    ans += 1\r\n                    if rb == n:\r\n                        dr = -1\r\n                    if cb == 1:\r\n                        dc = 1\r\n                    if rb == rd or cb == cd:\r\n                        if (rb, cb, dr, dc) in vis:\r\n                            T = ans - tmp[0]\r\n                            ok = False\r\n                            break\r\n                        tmp.append(ans)\r\n                        vis.add((rb, cb, dr, dc))\r\n                \r\n            elif dr == -1 and dc == 1:\r\n                while 1 < rb <= n and 1 <= cb < m:\r\n                    rb -= 1\r\n                    cb += 1\r\n                    ans += 1\r\n                    if rb == 1:\r\n                        dr = 1\r\n                    if cb == m:\r\n                        dc = -1\r\n                    if rb == rd or cb == cd:\r\n                        if (rb, cb, dr, dc) in vis:\r\n                            T = ans - tmp[0]\r\n                            ok = False\r\n                            break\r\n                        tmp.append(ans)\r\n                        vis.add((rb, cb, dr, dc))\r\n                \r\n            else:\r\n                while 1 < rb <= n and 1 < cb <= m:\r\n                    rb -= 1\r\n                    cb -= 1\r\n                    ans += 1\r\n                    if rb == 1:\r\n                        dr = 1\r\n                    if cb == 1:\r\n                        dc = 1\r\n                    if rb == rd or cb == cd:\r\n                        if (rb, cb, dr, dc) in vis:\r\n                            T = ans - tmp[0]\r\n                            ok = False\r\n                            break\r\n                        tmp.append(ans)\r\n                        vis.add((rb, cb, dr, dc))\r\n                \r\n\r\n        l = len(tmp)\r\n        res = 0\r\n        p = p * pow(100, mod - 2, mod) % mod\r\n        q = (1 - p) % mod\r\n        power = [1] * 100005\r\n        for i in range(1, 100005):\r\n             power[i] = power[i - 1] * q % mod\r\n        for i in range(l):\r\n            res += tmp[i] * p * power[i] * pow(1 - power[l], mod - 2, mod) + T * p * power[i + l] * pow((1 - power[l]) * (1 - power[l]) % mod, mod - 2, mod)\r\n            res %= mod\r\n        # print(tmp,T)\r\n        # print(l, T)\r\n        # print(tmp[-100:])\r\n        print(res % mod)\r\n    solve()\r\n",
    "prob_desc_created_at": "1640698500",
    "tags": [
        "implementation",
        "math",
        "probabilities"
    ],
    "hidden_unit_tests": ""
}
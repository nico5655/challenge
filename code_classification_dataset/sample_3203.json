{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"2\", \"2\"]",
    "src_uid": "8b6f93cf2a41445649e0cbfc471541b6",
    "prob_desc_notes": "NoteThe figure above shows the first sample test. In the first sample we should make both columns magic. The dragon figure represents the basilisk and the binoculars represent the person who will enter the Chamber of secrets. The black star shows the place where the person will be petrified. Yellow lines represent basilisk gaze moving through columns.",
    "prob_desc_description": "\"The Chamber of Secrets has been opened again\" — this news has spread all around Hogwarts and some of the students have been petrified due to seeing the basilisk. Dumbledore got fired and now Harry is trying to enter the Chamber of Secrets. These aren't good news for Lord Voldemort. The problem is, he doesn't want anybody to be able to enter the chamber. The Dark Lord is going to be busy sucking life out of Ginny.The Chamber of Secrets is an n × m rectangular grid in which some of the cells are columns. A light ray (and a basilisk's gaze) passes through the columns without changing its direction. But with some spell we can make a column magic to reflect the light ray (or the gaze) in all four directions when it receives the ray. This is shown in the figure below.   The left light ray passes through a regular column, and the right ray — through the magic column.  The basilisk is located at the right side of the lower right cell of the grid and is looking to the left (in the direction of the lower left cell). According to the legend, anyone who meets a basilisk's gaze directly dies immediately. But if someone meets a basilisk's gaze through a column, this person will get petrified. We know that the door to the Chamber is located on the left side of the upper left corner of the grid and anyone who wants to enter will look in the direction of its movement (in the direction of the upper right cell) from that position.   This figure illustrates the first sample test.  Given the dimensions of the chamber and the location of regular columns, Lord Voldemort has asked you to find the minimum number of columns that we need to make magic so that anyone who wants to enter the chamber would be petrified or just declare that it's impossible to secure the chamber.",
    "prob_desc_output_spec": "Print the minimum number of columns to make magic or -1 if it's impossible to do.",
    "prob_desc_input_spec": "The first line of the input contains two integer numbers n and m (2 ≤ n, m ≤ 1000). Each of the next n lines contains m characters. Each character is either \".\" or \"#\" and represents one cell of the Chamber grid. It's \".\" if the corresponding cell is empty and \"#\" if it's a regular column.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3",
    "lang_cluster": "Python",
    "difficulty": 1800,
    "file_name": "train_046.jsonl",
    "code_uid": "846db9eac699b9882890086f90425a6e",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"3 3\\n.#.\\n...\\n.#.\", \"4 3\\n##.\\n...\\n.#.\\n.#.\"]",
    "exec_outcome": "PASSED",
    "source_code": "import os\nimport sys\nfrom io import BytesIO, IOBase\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n##########################################################\nimport math\nimport bisect\n\nmod = 998244353\n# for _ in range(int(input())):\nfrom collections import Counter\n# sys.setrecursionlimit(10**6)\n# dp=[[-1 for i in range(n+5)]for j in range(cap+5)]\n# arr= list(map(int, input().split()))\n# n,l= map(int, input().split())\n# arr= list(map(int, input().split()))\n# for _ in range(int(input())):\n# n=int(input())\n# for _ in range(int(input())):\nimport bisect\nfrom heapq import *\nfrom collections import defaultdict,deque\n\nn,m=map(int, input().split())\ng=[[] for i in range(n+m)]\nfor i in range(n):\n    s=input()\n    for j,x in enumerate(s):\n        if x==\"#\":\n            g[i].append(n+j)\n            g[n+j].append(i)\nq=deque([0])\ndis=[10**9]*(n+m)\ndis[0]=0\nwhile q:\n    node=q.popleft()\n    for i in g[node]:\n        if dis[i]>dis[node]+1:\n\n            dis[i]=dis[node]+1\n            q.append(i)\nprint(-1 if dis[n-1]==10**9 else dis[n-1])\n\n\n\n\n\n\n# ls=list(map(int, input().split()))\n# d=defaultdict(list)\n#for _ in range(int(input())):\n#import math\n#print(math.factorial(20)//200)\n# n=int(input())\n\n    # n,k= map(int, input().split())\n\n    # arr=list(map(int, input().split()))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
    "prob_desc_created_at": "1333724400",
    "tags": [
        "dfs and similar",
        "shortest paths"
    ],
    "hidden_unit_tests": ""
}
{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"2\", \"7\"]",
    "src_uid": "e82b6958c45ff4b2c269cebe043d49de",
    "prob_desc_notes": "NoteIn the first test case, two good subsequences — $$$[a_1, a_2, a_3]$$$ and $$$[a_2, a_3]$$$.In the second test case, seven good subsequences — $$$[a_1, a_2, a_3, a_4], [a_1, a_2], [a_1, a_3], [a_1, a_4], [a_2, a_3], [a_2, a_4]$$$ and $$$[a_3, a_4]$$$.",
    "prob_desc_description": "The sequence of integers $$$a_1, a_2, \\dots, a_k$$$ is called a good array if $$$a_1 = k - 1$$$ and $$$a_1 &gt; 0$$$. For example, the sequences $$$[3, -1, 44, 0], [1, -99]$$$ are good arrays, and the sequences $$$[3, 7, 8], [2, 5, 4, 1], [0]$$$ — are not.A sequence of integers is called good if it can be divided into a positive number of good arrays. Each good array should be a subsegment of sequence and each element of the sequence should belong to exactly one array. For example, the sequences $$$[2, -3, 0, 1, 4]$$$, $$$[1, 2, 3, -3, -9, 4]$$$ are good, and the sequences $$$[2, -3, 0, 1]$$$, $$$[1, 2, 3, -3 -9, 4, 1]$$$ — are not.For a given sequence of numbers, count the number of its subsequences that are good sequences, and print the number of such subsequences modulo 998244353.",
    "prob_desc_output_spec": "In the single line output one integer — the number of subsequences of the original sequence that are good sequences, taken modulo 998244353.",
    "prob_desc_input_spec": "The first line contains the number $$$n~(1 \\le n \\le 10^3)$$$ — the length of the initial sequence. The following line contains $$$n$$$ integers $$$a_1, a_2, \\dots, a_n~(-10^9 \\le a_i \\le 10^9)$$$ — the sequence itself.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3",
    "lang_cluster": "Python",
    "difficulty": 1900,
    "file_name": "train_005.jsonl",
    "code_uid": "55217bb2806f04beb7d63c32a37d4aa4",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"3\\n2 1 1\", \"4\\n1 1 1 1\"]",
    "exec_outcome": "PASSED",
    "source_code": "import os\nimport sys\nfrom io import BytesIO, IOBase\n# region fastio\n\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n# ------------------------------\n\nfrom math import factorial\nfrom collections import Counter, defaultdict\nfrom heapq import heapify, heappop, heappush\n\ndef RL(): return map(int, sys.stdin.readline().rstrip().split())\ndef RLL(): return list(map(int, sys.stdin.readline().rstrip().split()))\ndef N(): return int(input())\ndef comb(n, m): return factorial(n) / (factorial(m) * factorial(n - m)) if n >= m else 0\ndef perm(n, m): return factorial(n) // (factorial(n - m)) if n >= m else 0\ndef mdis(x1, y1, x2, y2): return abs(x1 - x2) + abs(y1 - y2)\ndef ctd(chr): return ord(chr)-ord(\"a\")\nmod = 998244353\nINF = float('inf')\n\n# ------------------------------\n\ndef main():\n    n = N()\n    arr = RLL()\n\n    cb = [[0]*(n+1) for _ in range(n+1)]\n\n    for i in range(n+1):\n        for j in range(i+1):\n            if j==0 or j==n:\n                cb[i][j] = 1\n            else:\n                cb[i][j] = (cb[i-1][j]+cb[i-1][j-1])%mod\n\n    dp = [0]*(n+1)\n    dp[-1] = 1\n\n    for i in range(n-1, -1, -1):\n        for j in range(i+1, n+1):\n            if j-1-i>=arr[i] and arr[i]>0:\n                dp[i] += (cb[j-1-i][arr[i]]*dp[j])%mod\n\n    res = 0\n    for i in dp[:-1]:\n        res+=i%mod\n    print(res%mod)\n\n    # 0, 1, 2, 3\n    # 2, 2, 1\n    # 3,\n    # i, j-1) j\nif __name__ == \"__main__\":\n    main()\n\n",
    "prob_desc_created_at": "1530110100",
    "tags": [
        "dp",
        "combinatorics"
    ],
    "hidden_unit_tests": ""
}
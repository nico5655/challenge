{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"4\\n3\\n0\"]",
    "src_uid": "ac12faea4962613651afdc0b29537ef5",
    "prob_desc_notes": "NoteFor the first test case, here is an optimal series of passes Pekora can take. (The bolded numbers are the positions that Pekora jumps into during these passes.)  $$$[1,4,\\textbf{2},2,\\textbf{2},2,\\textbf{2}]$$$  $$$[1,\\textbf{4},1,2,1,\\textbf{2},1]$$$  $$$[1,\\textbf{3},1,2,\\textbf{1},\\textbf{1},\\textbf{1}]$$$  $$$[1,\\textbf{2},1,\\textbf{2},1,\\textbf{1},\\textbf{1}]$$$ For the second test case, the optimal series of passes is show below.  $$$[\\textbf{2},3]$$$  $$$[1,\\textbf{3}]$$$  $$$[1,\\textbf{2}]$$$ For the third test case, all $$$S_i$$$ are already equal to $$$1$$$.",
    "prob_desc_description": "There is a trampoline park with $$$n$$$ trampolines in a line. The $$$i$$$-th of which has strength $$$S_i$$$.Pekora can jump on trampolines in multiple passes. She starts the pass by jumping on any trampoline of her choice. If at the moment Pekora jumps on trampoline $$$i$$$, the trampoline will launch her to position $$$i + S_i$$$, and $$$S_i$$$ will become equal to $$$\\max(S_i-1,1)$$$. In other words, $$$S_i$$$ will decrease by $$$1$$$, except of the case $$$S_i=1$$$, when $$$S_i$$$ will remain equal to $$$1$$$. If there is no trampoline in position $$$i + S_i$$$, then this pass is over. Otherwise, Pekora will continue the pass by jumping from the trampoline at position $$$i + S_i$$$ by the same rule as above.Pekora can't stop jumping during the pass until she lands at the position larger than $$$n$$$ (in which there is no trampoline). Poor Pekora!Pekora is a naughty rabbit and wants to ruin the trampoline park by reducing all $$$S_i$$$ to $$$1$$$. What is the minimum number of passes she needs to reduce all $$$S_i$$$ to $$$1$$$?",
    "prob_desc_output_spec": "For each test case, output a single integer — the minimum number of passes Pekora needs to do to reduce all $$$S_i$$$ to $$$1$$$.",
    "prob_desc_input_spec": "The first line contains a single integer $$$t$$$ ($$$1 \\le t \\le 500$$$) — the number of test cases. The first line of each test case contains a single integer $$$n$$$ ($$$1 \\leq n \\leq 5000$$$) — the number of trampolines. The second line of each test case contains $$$n$$$ integers $$$S_1, S_2, \\dots, S_n$$$ ($$$1 \\le S_i \\le 10^9$$$), where $$$S_i$$$ is the strength of the $$$i$$$-th trampoline. It's guaranteed that the sum of $$$n$$$ over all test cases doesn't exceed $$$5000$$$.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3-64",
    "lang_cluster": "Python",
    "difficulty": 1700,
    "file_name": "train_095.jsonl",
    "code_uid": "bf1e8d1b6c336d16868d147e98037461",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"3\\n7\\n1 4 2 2 2 2 2\\n2\\n2 3\\n5\\n1 1 1 1 1\"]",
    "exec_outcome": "PASSED",
    "source_code": "#Don't stalk me, don't stop me, from making submissions at high speed. If you don't trust me,\r\nimport sys\r\n#then trust me, don't waste your time not trusting me. I don't plagiarise, don't fantasize,\r\nimport os\r\n#just let my hard work synthesize my rating. Don't be sad, just try again, everyone fails\r\nfrom io import BytesIO, IOBase\r\nBUFSIZE = 8192\r\n#every now and then. Just keep coding, just keep working and you'll keep progressing at speed-\r\n# -forcing.\r\nclass FastIO(IOBase):\r\n    newlines = 0\r\n    def __init__(self, file):\r\n        self._fd = file.fileno()\r\n        self.buffer = BytesIO()\r\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\r\n        self.write = self.buffer.write if self.writable else None\r\n    def read(self):\r\n        while True:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            if not b:\r\n                break\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines = 0\r\n        return self.buffer.read()\r\n    def readline(self):\r\n        while self.newlines == 0:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            self.newlines = b.count(b\"\\n\") + (not b)\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines -= 1\r\n        return self.buffer.readline()\r\n    def flush(self):\r\n        if self.writable:\r\n            os.write(self._fd, self.buffer.getvalue())\r\n            self.buffer.truncate(0), self.buffer.seek(0)\r\nclass IOWrapper(IOBase):\r\n    def __init__(self, file):\r\n        self.buffer = FastIO(file)\r\n        self.flush = self.buffer.flush\r\n        self.writable = self.buffer.writable\r\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\r\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\r\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\r\n#code by _Frust(CF)/Frust(AtCoder)\r\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\r\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\r\nfrom os import path\r\nif(path.exists('input.txt')):\r\n    sys.stdin = open(\"input.txt\",\"r\")\r\n    sys.stdout = open(\"output.txt\",\"w\")\r\n    input = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\r\nimport math\r\nimport heapq as hq\r\n\r\ndef find(x):\r\n    if x>=n: return x\r\n    if par[x]!=x:\r\n        par[x]=find(par[x])\r\n    return par[x]\r\n\r\n\r\ndef union(x, y):\r\n    parx=find(x)\r\n    pary=find(y)\r\n\r\n    if parx!=pary:\r\n        par[x]=pary\r\n\r\n    return\r\n\r\n\r\n\r\nfor _ in range(int(input())):\r\n    n=int(input())\r\n    l1=[int(i) for i in input().split()]\r\n\r\n    par=[i for i in range(n)]\r\n    for i in range(n-1, -1, -1):\r\n        if l1[i]==1:\r\n            par[i]=(find(par[i+1]) if i+1<n else n)\r\n    # print(l1)\r\n    ops=0\r\n    for i in range(n):\r\n        if l1[i]>1:\r\n            ops+=(l1[i]-1)\r\n            for j in range(min(i+l1[i], n-1), i+1, -1):\r\n                while j<n:\r\n                    if l1[j]==1:\r\n                        j=find(j)\r\n                    else:\r\n                        if l1[j]+j<n:\r\n                            newj=find(j+l1[j])\r\n                            l1[j]=(l1[j]-1 if l1[j]>1 else 1)\r\n                            if l1[j]==1:\r\n                                union(j, j+1)\r\n                        else:\r\n                            newj=j+l1[j]\r\n                            l1[j]=(l1[j]-1 if l1[j]>1 else 1)\r\n                            if l1[j]==1:\r\n                                union(j, j+1)\r\n                        j=newj\r\n    print(ops)\r\n\r\n\r\n\r\n\r\n\r\n    \r\n\r\n",
    "prob_desc_created_at": "1614519300",
    "tags": [
        "brute force",
        "data structures",
        "dp",
        "greedy",
        "implementation"
    ],
    "hidden_unit_tests": ""
}
{
    "prob_desc_time_limit": "1 second",
    "prob_desc_sample_outputs": "[\"2\\n2 1\\n3 1\\n-1\\n0\\n6\\n1 4\\n1 4\\n1 5\\n1 5\\n2 5\\n2 5\"]",
    "src_uid": "accfbd68b9723abf4cd29846e80835ec",
    "prob_desc_notes": "NoteIn the first example, we do the following operations:  $$$i = 2$$$, $$$j = 1$$$: $$$[1, 2, 3, 4] \\rightarrow [2, 1, 3, 4]$$$;  $$$i = 3$$$, $$$j = 1$$$: $$$[2, 1, 3, 4] \\rightarrow [3, 1, 2, 4]$$$; In the second example, it's impossible to make two arrays equal.",
    "prob_desc_description": "AquaMoon and Cirno are playing an interesting game with arrays. Cirno has prepared two arrays $$$a$$$ and $$$b$$$, both consist of $$$n$$$ non-negative integers. AquaMoon can perform the following operation an arbitrary number of times (possibly zero):  She chooses two indices $$$i$$$ and $$$j$$$ ($$$1 \\le i, j \\le n$$$), then decreases the $$$i$$$-th element of array $$$a$$$ by $$$1$$$, and increases the $$$j$$$-th element of array $$$a$$$ by $$$1$$$. The resulting values at $$$i$$$-th and $$$j$$$-th index of array $$$a$$$ are $$$a_i - 1$$$ and $$$a_j + 1$$$, respectively. Each element of array $$$a$$$ must be non-negative after each operation. If $$$i = j$$$ this operation doesn't change the array $$$a$$$. AquaMoon wants to make some operations to make arrays $$$a$$$ and $$$b$$$ equal. Two arrays $$$a$$$ and $$$b$$$ are considered equal if and only if $$$a_i = b_i$$$ for all $$$1 \\leq i \\leq n$$$.Help AquaMoon to find a sequence of operations that will solve her problem or find, that it is impossible to make arrays $$$a$$$ and $$$b$$$ equal.Please note, that you don't have to minimize the number of operations.",
    "prob_desc_output_spec": "For each test case print \"-1\" on the only line if it is impossible to make two arrays equal with some sequence of operations. Otherwise, print an integer $$$m$$$ ($$$0 \\leq m \\leq 100$$$) in the first line — the number of operations. Then print $$$m$$$ lines, each line consists of two integers $$$i$$$ and $$$j$$$ — the indices you choose for the operation. It can be proven that if it is possible to make two arrays equal with some sequence of operations, there exists a sequence with $$$m \\leq 100$$$. If there are multiple possible solutions, you can print any.",
    "prob_desc_input_spec": "The input consists of multiple test cases. The first line contains a single integer $$$t$$$ ($$$1 \\leq t \\leq 100$$$) — the number of test cases. The first line of each test case contains a single integer $$$n$$$ ($$$1 \\leq n \\leq 100$$$). The second line of each test case contains $$$n$$$ integers $$$a_1, a_2, \\dots, a_n$$$ ($$$0 \\leq a_i \\leq 100$$$). The sum of all $$$a_i$$$ does not exceed $$$100$$$. The third line of each test case contains $$$n$$$ integers $$$b_1, b_2, \\dots, b_n$$$ ($$$0 \\leq b_i \\leq 100$$$). The sum of all $$$b_i$$$ does not exceed $$$100$$$.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "Python 3",
    "lang_cluster": "Python",
    "difficulty": 800,
    "file_name": "train_086.jsonl",
    "code_uid": "8ecbf9c143e622a3db76bf66f5f71fbb",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"4\\n4\\n1 2 3 4\\n3 1 2 4\\n2\\n1 3\\n2 1\\n1\\n0\\n0\\n5\\n4 3 2 1 0\\n0 1 2 3 4\"]",
    "exec_outcome": "PASSED",
    "source_code": "\r\n#i -> +1, j-> -1\r\ndef function(a,b):\r\n    #nombre de transformation\r\n    m=0\r\n    #garde en mémorie quel case de modifié\r\n    op_i=[]\r\n    op_j=[]\r\n    #on modifie le tableau a pour obtenir b\r\n    if sum(a)!=sum(b):\r\n        print(-1)\r\n    elif a==b:\r\n        print(0)\r\n    else:\r\n        while a!=b:\r\n                x=0\r\n                while a[x]==b[x]:\r\n                    x+=1\r\n                if a[x]<=b[x]and x<=n:\r\n                    y=x\r\n                    while a[y]<=b[y]:\r\n                        y+=1\r\n                    op_i.append(y+1)\r\n                    a[y]-=1\r\n                    op_j.append(x+1)\r\n                    a[x]+=1\r\n                else:\r\n                    y=x\r\n                    while a[y]>=b[y] and y<n and y!=n-1:\r\n                        y+=1\r\n                    op_i.append(x+1)\r\n                    a[x]-=1\r\n                    op_j.append(y+1)\r\n                    a[y]+=1\r\n                m+=1\r\n        print(m)\r\n        for i in range(m):\r\n            print(op_i[i],end=\" \")\r\n            print(op_j[i])\r\n\r\nt=int(input())\r\nfor i in range(t):\r\n    n=int(input())\r\n    a = list(map(int, input().split()))\r\n    b = list(map(int, input().split()))\r\n    #nombre de transformation\r\n    m=0\r\n    #garde en mémorie quel case de modifié\r\n    op_i=[]\r\n    op_j=[]\r\n    #on modifie le tableau a pour obtenir b\r\n    if sum(a)!=sum(b):\r\n        print(-1)\r\n    elif a==b:\r\n        print(0)\r\n    else:\r\n        while a!=b:\r\n                x=0\r\n                while a[x]==b[x]:\r\n                    x+=1\r\n                if a[x]<=b[x]and x<=n:\r\n                    y=x\r\n                    while a[y]<=b[y]:\r\n                        y+=1\r\n                    op_i.append(y+1)\r\n                    a[y]-=1\r\n                    op_j.append(x+1)\r\n                    a[x]+=1\r\n                else:\r\n                    y=x\r\n                    while a[y]>=b[y] and y<n and y!=n-1:\r\n                        y+=1\r\n                    op_i.append(x+1)\r\n                    a[x]-=1\r\n                    op_j.append(y+1)\r\n                    a[y]+=1\r\n                m+=1\r\n        print(m)\r\n        for i in range(m):\r\n            print(op_i[i],end=\" \")\r\n            print(op_j[i])\r\n",
    "prob_desc_created_at": "1626012300",
    "tags": [
        "brute force",
        "greedy"
    ],
    "hidden_unit_tests": ""
}
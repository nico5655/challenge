{
    "prob_desc_time_limit": "3 seconds",
    "prob_desc_sample_outputs": "[\"17\", \"2\", \"-1\"]",
    "src_uid": "539db10759f7b6c032b91e56c8f7e307",
    "prob_desc_notes": null,
    "prob_desc_description": "Everything is great about Ilya's city, except the roads. The thing is, the only ZooVille road is represented as n holes in a row. We will consider the holes numbered from 1 to n, from left to right.Ilya is really keep on helping his city. So, he wants to fix at least k holes (perharps he can fix more) on a single ZooVille road. The city has m building companies, the i-th company needs ci money units to fix a road segment containing holes with numbers of at least li and at most ri. The companies in ZooVille are very greedy, so, if they fix a segment containing some already fixed holes, they do not decrease the price for fixing the segment. Determine the minimum money Ilya will need to fix at least k holes.",
    "prob_desc_output_spec": "Print a single integer — the minimum money Ilya needs to fix at least k holes.  If it is impossible to fix at least k holes, print -1. Please, do not use the %lld specifier to read or write 64-bit integers in С++. It is preferred to use the cin, cout streams or the %I64d specifier.",
    "prob_desc_input_spec": "The first line contains three integers n, m, k (1 ≤ n ≤ 300, 1 ≤ m ≤ 105, 1 ≤ k ≤ n). The next m lines contain the companies' description. The i-th line contains three integers li, ri, ci (1 ≤ li ≤ ri ≤ n, 1 ≤ ci ≤ 109).",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3",
    "lang_cluster": "Python",
    "difficulty": 2100,
    "file_name": "train_077.jsonl",
    "code_uid": "46db0cdaf1f71eecbaa4286245a23b07",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"10 4 6\\n7 9 11\\n6 9 13\\n7 7 7\\n3 5 6\", \"10 7 1\\n3 4 15\\n8 9 8\\n5 6 8\\n9 10 6\\n1 4 2\\n1 4 10\\n8 10 13\", \"10 1 9\\n5 10 14\"]",
    "exec_outcome": "PASSED",
    "source_code": "\"\"\"\n#If FastIO not needed, used this and don't forget to strip\n#import sys, math\n#input = sys.stdin.readline\n\"\"\"\n\nimport os\nimport sys\nfrom io import BytesIO, IOBase\nimport heapq as h \nfrom bisect import bisect_left, bisect_right\n\nfrom types import GeneratorType\nBUFSIZE = 8192\nclass FastIO(IOBase):\n    newlines = 0\n \n    def __init__(self, file):\n        import os\n        self.os = os\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n \n    def read(self):\n        while True:\n            b = self.os.read(self._fd, max(self.os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n \n    def readline(self):\n        while self.newlines == 0:\n            b = self.os.read(self._fd, max(self.os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n \n    def flush(self):\n        if self.writable:\n            self.os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n \n \nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n \n \nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nfrom collections import defaultdict as dd, deque as dq\nimport math, string\n\ndef getInts():\n    return [int(s) for s in input().split()]\n\ndef getInt():\n    return int(input())\n\ndef getStrs():\n    return [s for s in input().split()]\n\ndef getStr():\n    return input()\n\ndef listStr():\n    return list(input())\n\nMOD = 10**9+7\n\n\"\"\"\nmin cost to fix 1 hole is the min cost of any segment\nmin cost to fix 2 holes is the min cost of all segments length >= 2, or the min cost of two distinct segments length 1\nmin cost to fix K holes is the min cost of all segments length >= K, or the min cost of fixing K-1 segments + the min cost of any other segment \n\nWhat is the cost of filling interval [L,R]? \n\"\"\"\n\nfrom bisect import bisect_left\n\ndef solve():\n    N, M, K = getInts()\n    costs = []\n    cost = [[float('inf') for R in range(N+1)] for L in range(N+1)]\n    for m in range(M):\n        L, R, C = getInts()\n        L -= 1\n        costs.append((L,R,C))\n        cost[L][R] = min(cost[L][R], C)\n    for L in range(N+1):\n        for R in range(1,N+1):\n            cost[R][L] = min(cost[R][L], cost[R-1][L])\n    dp = [[10**18 for R in range(N+1)] for L in range(N+1)]\n    #print(cost)\n    for i in range(N):\n        dp[i][0] = 0\n        for j in range(i+1):\n            if dp[i][j] < 10**18:\n                dp[i+1][j] = min(dp[i+1][j], dp[i][j])\n                for k in range(i+1,N+1):\n                    dp[k][j+k-i] = min(dp[k][j+k-i],dp[i][j]+cost[i][k])\n    ans = 10**18\n    #print(dp)\n    ans = dp[N][K]\n            \n    return ans if ans < 10**18 else -1\n    \n#for _ in range(getInt()):\nprint(solve())\n    #solve()",
    "prob_desc_created_at": "1369927800",
    "tags": [
        "dp"
    ],
    "hidden_unit_tests": ""
}
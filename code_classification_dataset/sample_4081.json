{
    "prob_desc_time_limit": "3 seconds",
    "prob_desc_sample_outputs": "[\"2\\n0\\n7\"]",
    "src_uid": "bed2d2e4a33bf133f7e9d5ebc1557c3e",
    "prob_desc_notes": null,
    "prob_desc_description": "You are given two arrays $$$a$$$ and $$$b$$$, consisting of $$$n$$$ integers each.Let's define a function $$$f(a, b)$$$ as follows:   let's define an array $$$c$$$ of size $$$n$$$, where $$$c_i = a_i \\oplus b_i$$$ ($$$\\oplus$$$ denotes bitwise XOR);  the value of the function is $$$c_1 \\mathbin{\\&amp;} c_2 \\mathbin{\\&amp;} \\cdots \\mathbin{\\&amp;} c_n$$$ (i.e. bitwise AND of the entire array $$$c$$$). Find the maximum value of the function $$$f(a, b)$$$ if you can reorder the array $$$b$$$ in an arbitrary way (leaving the initial order is also an option).",
    "prob_desc_output_spec": "For each test case print one integer — the maximum value of the function $$$f(a, b)$$$ if you can reorder the array $$$b$$$ in an arbitrary way.",
    "prob_desc_input_spec": "The first line contains one integer $$$t$$$ ($$$1 \\le t \\le 10^4$$$) — the number of test cases. The first line of each test case contains one integer $$$n$$$ ($$$1 \\le n \\le 10^5$$$) — the size of arrays $$$a$$$ and $$$b$$$. The second line contains $$$n$$$ integers $$$a_1, a_2, \\dots, a_n$$$ ($$$0 \\le a_i &lt; 2^{30}$$$). The third line contains $$$n$$$ integers $$$b_1, b_2, \\dots, b_n$$$ ($$$0 \\le b_i &lt; 2^{30}$$$). The sum of $$$n$$$ over all test cases does not exceed $$$10^5$$$.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3-64",
    "lang_cluster": "Python",
    "difficulty": 1800,
    "file_name": "train_090.jsonl",
    "code_uid": "1526f433bce6ac756acdad1d51f3839f",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"3\\n\\n5\\n\\n1 0 0 3 3\\n\\n2 3 2 1 0\\n\\n3\\n\\n1 1 1\\n\\n0 0 3\\n\\n8\\n\\n0 1 2 3 4 5 6 7\\n\\n7 6 5 4 3 2 1 0\"]",
    "exec_outcome": "PASSED",
    "source_code": "#!/usr/bin/env python3\nimport sys\ninput = sys.stdin.readline  # to read input quickly\n\n# available on Google, AtCoder Python3, not available on Codeforces\n# import numpy as np\n# import scipy\n\nm9 = 10**9 + 7  # 998244353\nyes, no = \"YES\", \"NO\"\n# d4 = [(1,0),(0,1),(-1,0),(0,-1)]\n# d8 = [(1,0),(1,1),(0,1),(-1,1),(-1,0),(-1,-1),(0,-1),(1,-1)]\n# d6 = [(2,0),(1,1),(-1,1),(-2,0),(-1,-1),(1,-1)]  # hexagonal layout\nMAXINT = sys.maxsize\ne18 = 10**18 + 10\n\n# if testing locally, print to terminal with a different color\nOFFLINE_TEST = False\nCHECK_OFFLINE_TEST = True\n# CHECK_OFFLINE_TEST = False  # uncomment this on Codechef\nif CHECK_OFFLINE_TEST:\n    import getpass\n    OFFLINE_TEST = getpass.getuser() == \"htong\"\n\ndef log(*args):\n    if CHECK_OFFLINE_TEST and OFFLINE_TEST:\n        print('\\033[36m', *args, '\\033[0m', file=sys.stderr)\n\ndef solve(*args):\n    # screen input\n    if OFFLINE_TEST:\n        log(\"----- solving ------\")\n        log(*args)\n        log(\"----- ------- ------\")\n    return solve_(*args)\n\ndef read_matrix(rows):\n    return [list(map(int,input().split())) for _ in range(rows)]\n\ndef read_strings(rows):\n    return [input().strip() for _ in range(rows)]\n\ndef minus_one(arr):\n    return [x-1 for x in arr]\n\ndef minus_one_matrix(mrr):\n    return [[x-1 for x in row] for row in mrr]\n\n# ---------------------------- template ends here ----------------------------\n\n\ndef solve_(arr, brr, n):\n    # your solution here\n\n    res = []\n\n    pools = [(arr, brr),]\n\n    for i in range(30,-1,-1):\n        # log(pools)\n        topmask = 2**i\n        onemask = topmask - 1\n    \n        fail = False\n        for ar,br in pools:\n            assert len(ar) == len(br)\n            acount = sum(x&topmask > 0 for x in ar)\n            bcount = sum(x&topmask > 0 for x in br)\n            # log(acount, bcount, len(ar))\n            if acount + bcount != len(ar):\n                fail = True\n        \n        if fail:\n            res.append(0)\n            pools = [\n                ([x&onemask for x in ar], [x&onemask for x in br]) \n                for ar, br in pools\n            ]\n\n        else:\n            new_pools = []\n            res.append(1)\n            for ar,br in pools:\n                ar0 = [a for a in ar if not a&topmask]\n                ar1 = [a^topmask for a in ar if a&topmask]\n                br0 = [b for b in br if not b&topmask]\n                br1 = [b^topmask for b in br if b&topmask]\n                if ar0:\n                    new_pools.append((ar0, br1))\n                if ar1:\n                    new_pools.append((ar1, br0))\n            pools = new_pools\n\n    log(res)\n\n    return int(\"\".join(str(x) for x in res),2)\n\n\n# for case_num in [0]:  # no loop over test case\n# for case_num in range(100):  # if the number of test cases is specified\nfor case_num in range(int(input())):\n\n    # read line as an integer\n    n = int(input())\n\n    # read line as a string\n    # srr = input().strip()\n\n    # read one line and parse each word as a string\n    # arr = input().split()\n\n    # read one line and parse each word as an integer\n    # a,b,c = list(map(int,input().split()))\n    arr = list(map(int,input().split()))\n    brr = list(map(int,input().split()))\n    # arr = minus_one(arr)\n\n    # read multiple rows\n    # arr = read_strings(k)  # and return as a list of str\n    # mrr = read_matrix(k)  # and return as a list of list of int\n    # mrr = minus_one_matrix(mrr)\n\n    res = solve(arr, brr, n)  # include input here\n\n    # print length if applicable\n    # print(len(res))\n\n    # parse result\n    # res = \" \".join(str(x) for x in res)\n    # res = \"\\n\".join(str(x) for x in res)\n    # res = \"\\n\".join(\" \".join(str(x) for x in row) for row in res)\n\n    # print result\n    # print(\"Case #{}: {}\".format(case_num+1, res))   # Google and Facebook - case number required\n\n    print(res)\n",
    "prob_desc_created_at": "1661610900",
    "tags": [
        "bitmasks",
        "dfs and similar",
        "divide and conquer",
        "greedy",
        "sortings"
    ],
    "hidden_unit_tests": ""
}
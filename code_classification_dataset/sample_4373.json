{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"4 1 5\\n1 2 2\\n1000000000 1 1\\n6 6 10\"]",
    "src_uid": "a07c199ca02f0abaab6c73efdb2a5b2d",
    "prob_desc_notes": "NoteFor the first test case, the best choice is $$$a=4$$$, $$$l=1$$$, $$$r=5$$$, and the game would go as follows.   Marian starts with one dollar.  After the first round, he ends up with $$$2$$$ dollars because the numbers coincide with the chosen one.  After the second round, he ends up with $$$4$$$ dollars because the numbers coincide again.  After the third round, he ends up with $$$2$$$ dollars because he guesses $$$4$$$ even though $$$3$$$ is the correct choice.  After the fourth round, he ends up with $$$4$$$ dollars again.  In the final round, he ends up $$$8$$$ dollars because he again guessed correctly. There are many possible answers for the second test case, but it can be proven that Marian will not end up with more than $$$2$$$ dollars, so any choice with $$$l = r$$$ with the appropriate $$$a$$$ is acceptable.",
    "prob_desc_description": "Marian is at a casino. The game at the casino works like this.Before each round, the player selects a number between $$$1$$$ and $$$10^9$$$. After that, a dice with $$$10^9$$$ faces is rolled so that a random number between $$$1$$$ and $$$10^9$$$ appears. If the player guesses the number correctly their total money is doubled, else their total money is halved. Marian predicted the future and knows all the numbers $$$x_1, x_2, \\dots, x_n$$$ that the dice will show in the next $$$n$$$ rounds. He will pick three integers $$$a$$$, $$$l$$$ and $$$r$$$ ($$$l \\leq r$$$). He will play $$$r-l+1$$$ rounds (rounds between $$$l$$$ and $$$r$$$ inclusive). In each of these rounds, he will guess the same number $$$a$$$. At the start (before the round $$$l$$$) he has $$$1$$$ dollar.Marian asks you to determine the integers $$$a$$$, $$$l$$$ and $$$r$$$ ($$$1 \\leq a \\leq 10^9$$$, $$$1 \\leq l \\leq r \\leq n$$$) such that he makes the most money at the end.Note that during halving and multiplying there is no rounding and there are no precision errors. So, for example during a game, Marian could have money equal to $$$\\dfrac{1}{1024}$$$, $$$\\dfrac{1}{128}$$$, $$$\\dfrac{1}{2}$$$, $$$1$$$, $$$2$$$, $$$4$$$, etc. (any value of $$$2^t$$$, where $$$t$$$ is an integer of any sign).",
    "prob_desc_output_spec": "For each test case, output three integers $$$a$$$, $$$l$$$, and $$$r$$$ such that Marian makes the most amount of money gambling with his strategy. If there are multiple answers, you may output any of them.",
    "prob_desc_input_spec": "The first line contains a single integer $$$t$$$ ($$$1 \\leq t \\leq 100$$$) — the number of test cases. The first line of each test case contains a single integer $$$n$$$ ($$$1 \\leq n \\leq 2\\cdot 10^5$$$) — the number of rounds. The second line of each test case contains $$$n$$$ integers $$$x_1, x_2, \\dots, x_n$$$ ($$$1 \\leq x_i \\leq 10^9$$$), where $$$x_i$$$ is the number that will fall on the dice in the $$$i$$$-th round. It is guaranteed that the sum of $$$n$$$ over all test cases does not exceed $$$2\\cdot10^5$$$.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3-64",
    "lang_cluster": "Python",
    "difficulty": 1700,
    "file_name": "train_096.jsonl",
    "code_uid": "cefedd04c6e37082f0e70005a9833e24",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"4\\n\\n5\\n\\n4 4 3 4 4\\n\\n5\\n\\n11 1 11 1 11\\n\\n1\\n\\n1000000000\\n\\n10\\n\\n8 8 8 9 9 6 6 9 6 6\"]",
    "exec_outcome": "PASSED",
    "source_code": "#!/usr/bin/env python3\r\nimport sys\r\nimport math, random\r\nimport functools, itertools, collections, heapq, bisect\r\nfrom collections import Counter, defaultdict, deque\r\ninput = sys.stdin.readline  # to read input quickly\r\n\r\n# available on Google, AtCoder Python3, not available on Codeforces\r\n# import numpy as np\r\n# import scipy\r\n\r\nm9 = 10**9 + 7  # 998244353\r\nyes, no = \"YES\", \"NO\"\r\n# d4 = [(1,0),(0,1),(-1,0),(0,-1)]\r\n# d8 = [(1,0),(1,1),(0,1),(-1,1),(-1,0),(-1,-1),(0,-1),(1,-1)]\r\n# d6 = [(2,0),(1,1),(-1,1),(-2,0),(-1,-1),(1,-1)]  # hexagonal layout\r\nMAXINT = sys.maxsize\r\ne18 = 10**18 + 10\r\n\r\n# if testing locally, print to terminal with a different color\r\nCHECK_OFFLINE_TEST = True\r\n# CHECK_OFFLINE_TEST = False  # uncomment this on Codechef\r\nif CHECK_OFFLINE_TEST:\r\n    import getpass\r\n    OFFLINE_TEST = getpass.getuser() == \"htong\"\r\n\r\ndef log(*args):\r\n    if CHECK_OFFLINE_TEST and OFFLINE_TEST:\r\n        print('\\033[36m', *args, '\\033[0m', file=sys.stderr)\r\n\r\ndef solve(*args):\r\n    # screen input\r\n    if OFFLINE_TEST:\r\n        log(\"----- solving ------\")\r\n        log(*args)\r\n        log(\"----- ------- ------\")\r\n    return solve_(*args)\r\n\r\ndef read_matrix(rows):\r\n    return [list(map(int,input().split())) for _ in range(rows)]\r\n\r\ndef read_strings(rows):\r\n    return [input().strip() for _ in range(rows)]\r\n\r\ndef minus_one(arr):\r\n    return [x-1 for x in arr]\r\n\r\ndef minus_one_matrix(mrr):\r\n    return [[x-1 for x in row] for row in mrr]\r\n\r\n# ---------------------------- template ends here ----------------------------\r\n\r\n\r\n\r\n\r\ndef solve_(arr):\r\n    # your solution here\r\n    \r\n    g = defaultdict(list)\r\n    for i,x in enumerate(arr):\r\n        g[str(x)].append(i)\r\n    \r\n    maxres = 0\r\n    ares = arr[0]\r\n    lres = 0\r\n    rres = 0\r\n\r\n    # log(g)\r\n\r\n    for element in g:\r\n        # brr = [ for i,x in enumerate(brr)]\r\n\r\n        # log(element, brr)\r\n\r\n        minprev = 10**10\r\n        left = 0\r\n        for i,x in enumerate(g[element]):\r\n            val,right = (2*i-x,x)\r\n            if val - minprev > maxres:\r\n                maxres = val - minprev\r\n                ares = element\r\n                lres = left\r\n                rres = right\r\n\r\n            if val < minprev:\r\n                minprev = val\r\n                left = right\r\n\r\n    log(maxres)\r\n\r\n    return ares, lres+1, rres+1\r\n\r\n\r\n# for case_num in [0]:  # no loop over test case\r\n# for case_num in range(100):  # if the number of test cases is specified\r\nfor case_num in range(int(input())):\r\n\r\n    # read line as an integer\r\n    k = int(input())\r\n\r\n    # read line as a string\r\n    # srr = input().strip()\r\n\r\n    # read one line and parse each word as a string\r\n    # arr = input().split()\r\n\r\n    # read one line and parse each word as an integer\r\n    # a,b,c = list(map(int,input().split()))\r\n    arr = list(map(int,input().split()))\r\n    # arr = minus_one(arr)\r\n\r\n    # read multiple rows\r\n    # arr = read_strings(k)  # and return as a list of str\r\n    # mrr = read_matrix(k)  # and return as a list of list of int\r\n    # mrr = minus_one_matrix(mrr)\r\n\r\n    res = solve(arr)  # include input here\r\n\r\n    # print length if applicable\r\n    # print(len(res))\r\n\r\n    # parse result\r\n    res = \" \".join(str(x) for x in res)\r\n    # res = \"\\n\".join(str(x) for x in res)\r\n    # res = \"\\n\".join(\" \".join(str(x) for x in row) for row in res)\r\n\r\n    # print result\r\n    # print(\"Case #{}: {}\".format(case_num+1, res))   # Google and Facebook - case number required\r\n\r\n    print(res)\r\n",
    "prob_desc_created_at": "1655217300",
    "tags": [
        "data structures",
        "dp",
        "greedy",
        "math"
    ],
    "hidden_unit_tests": ""
}
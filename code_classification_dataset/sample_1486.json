{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"Yes\\nNo\\nYes\", \"No\\nYes\\nYes\\nYes\\nNo\\nNo\"]",
    "src_uid": "eb5c93620709436493b2e560a63dbb02",
    "prob_desc_notes": "NoteIn the first sample, in the first and third queries, the substring is \"a\", which has itself as an irreducible anagram since two or more non-empty strings cannot be put together to obtain \"a\". On the other hand, in the second query, the substring is \"aaa\", which has no irreducible anagrams: its only anagram is itself, and we may choose $$$s_1 = $$$ \"a\", $$$s_2 = $$$ \"aa\", $$$t_1 = $$$ \"a\", $$$t_2 = $$$ \"aa\" to show that it is a reducible anagram.In the second query of the second sample, the substring is \"abb\", which has, for example, \"bba\" as an irreducible anagram.",
    "prob_desc_description": "Let's call two strings $$$s$$$ and $$$t$$$ anagrams of each other if it is possible to rearrange symbols in the string $$$s$$$ to get a string, equal to $$$t$$$.Let's consider two strings $$$s$$$ and $$$t$$$ which are anagrams of each other. We say that $$$t$$$ is a reducible anagram of $$$s$$$ if there exists an integer $$$k \\ge 2$$$ and $$$2k$$$ non-empty strings $$$s_1, t_1, s_2, t_2, \\dots, s_k, t_k$$$ that satisfy the following conditions:  If we write the strings $$$s_1, s_2, \\dots, s_k$$$ in order, the resulting string will be equal to $$$s$$$;  If we write the strings $$$t_1, t_2, \\dots, t_k$$$ in order, the resulting string will be equal to $$$t$$$;  For all integers $$$i$$$ between $$$1$$$ and $$$k$$$ inclusive, $$$s_i$$$ and $$$t_i$$$ are anagrams of each other. If such strings don't exist, then $$$t$$$ is said to be an irreducible anagram of $$$s$$$. Note that these notions are only defined when $$$s$$$ and $$$t$$$ are anagrams of each other.For example, consider the string $$$s = $$$ \"gamegame\". Then the string $$$t = $$$ \"megamage\" is a reducible anagram of $$$s$$$, we may choose for example $$$s_1 = $$$ \"game\", $$$s_2 = $$$ \"gam\", $$$s_3 = $$$ \"e\" and $$$t_1 = $$$ \"mega\", $$$t_2 = $$$ \"mag\", $$$t_3 = $$$ \"e\":  On the other hand, we can prove that $$$t = $$$ \"memegaga\" is an irreducible anagram of $$$s$$$.You will be given a string $$$s$$$ and $$$q$$$ queries, represented by two integers $$$1 \\le l \\le r \\le |s|$$$ (where $$$|s|$$$ is equal to the length of the string $$$s$$$). For each query, you should find if the substring of $$$s$$$ formed by characters from the $$$l$$$-th to the $$$r$$$-th has at least one irreducible anagram.",
    "prob_desc_output_spec": "For each query, print a single line containing \"Yes\" (without quotes) if the corresponding substring has at least one irreducible anagram, and a single line containing \"No\" (without quotes) otherwise.",
    "prob_desc_input_spec": "The first line contains a string $$$s$$$, consisting of lowercase English characters ($$$1 \\le |s| \\le 2 \\cdot 10^5$$$). The second line contains a single integer $$$q$$$ ($$$1 \\le q \\le 10^5$$$)  — the number of queries. Each of the following $$$q$$$ lines contain two integers $$$l$$$ and $$$r$$$ ($$$1 \\le l \\le r \\le |s|$$$), representing a query for the substring of $$$s$$$ formed by characters from the $$$l$$$-th to the $$$r$$$-th.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 2",
    "lang_cluster": "Python",
    "difficulty": 1800,
    "file_name": "train_009.jsonl",
    "code_uid": "078e2b1bd212b0b2a8f2e42a6264f933",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"aaaaa\\n3\\n1 1\\n2 4\\n5 5\", \"aabbbbbbc\\n6\\n1 2\\n2 4\\n2 2\\n1 9\\n5 7\\n3 5\"]",
    "exec_outcome": "PASSED",
    "source_code": "#!/usr/bin/env pypy\nfrom __future__ import division, print_function\n\nimport os\nimport sys\nfrom __builtin__ import xrange as range\nfrom cStringIO import StringIO\nfrom future_builtins import ascii, filter, hex, map, oct, zip\nfrom io import IOBase\n\nimport __pypy__\n\nfrom collections import Counter\n\ndef main():\n    s = input()\n    n = len(s)\n    segtrees = [SegmentTree([0] * n, 0, lambda x, y: x + y) for _ in range(26)]\n    for i, si in enumerate(s):\n        segtrees[ord(si) - ord('a')][i] += 1\n    \n\n    q = int(input())\n    for _ in range(q):\n        l, r = map(int, input().split())\n        if l == r:\n            print(\"Yes\")\n            continue\n\n        if s[l - 1] != s[r - 1]:\n            print(\"Yes\")\n            continue\n\n        cnt = 0\n        for i in range(26):\n            if segtrees[i].query(l - 1, r):\n                cnt += 1\n                if cnt == 3:\n                    break\n        if cnt == 3:\n            print(\"Yes\")\n        else:\n            print(\"No\")\n\n\nclass SegmentTree:\n    def __init__(self, data, default=0, func=max):\n        \"\"\"initialize the segment tree with data\"\"\"\n        self._default = default\n        self._func = func\n        self._len = len(data)\n        self._size = _size = 1 << (self._len - 1).bit_length()\n\n        self.data = [default] * (2 * _size)\n        self.data[_size:_size + self._len] = data\n        for i in reversed(range(_size)):\n            self.data[i] = func(self.data[i + i], self.data[i + i + 1])\n\n    def __delitem__(self, idx):\n        self[idx] = self._default\n\n    def __getitem__(self, idx):\n        return self.data[idx + self._size]\n\n    def __setitem__(self, idx, value):\n        idx += self._size\n        self.data[idx] = value\n        idx >>= 1\n        while idx:\n            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])\n            idx >>= 1\n\n    def __len__(self):\n        return self._len\n\n    def query(self, start, stop):\n        start += self._size\n        stop += self._size\n\n        res = self._default\n        while start < stop:\n            if start & 1:\n                res = self._func(res, self.data[start])\n                start += 1\n            if stop & 1:\n                stop -= 1\n                res = self._func(res, self.data[stop])\n            start >>= 1\n            stop >>= 1\n        return res\n\n    def __repr__(self):\n        return \"SegmentTree({0})\".format(self.data)\n\n\n\n# region fastio\n\nBUFSIZE = 8192\n\n\nclass FastI(IOBase):\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self._buffer = StringIO()\n        self.newlines = 0\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(\"\\n\") + (not b)\n            ptr = self._buffer.tell()\n            self._buffer.seek(0, 2), self._buffer.write(b), self._buffer.seek(ptr)\n        self.newlines -= 1\n        return self._buffer.readline()\n\n\nclass FastO(IOBase):\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self._buffer = __pypy__.builders.StringBuilder()\n        self.write = lambda s: self._buffer.append(s)\n\n    def flush(self):\n        os.write(self._fd, self._buffer.build())\n        self._buffer = __pypy__.builders.StringBuilder()\n\n\ndef print(*args, **kwargs):\n    sep, file = kwargs.pop(\"sep\", \" \"), kwargs.pop(\"file\", sys.stdout)\n    at_start = True\n    for x in args:\n        if not at_start:\n            file.write(sep)\n        file.write(str(x))\n        at_start = False\n    file.write(kwargs.pop(\"end\", \"\\n\"))\n    if kwargs.pop(\"flush\", False):\n        file.flush()\n\n\nsys.stdin, sys.stdout = FastI(sys.stdin), FastO(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n# endregion\n\nif __name__ == \"__main__\":\n    main()\n",
    "prob_desc_created_at": "1580652300",
    "tags": [
        "constructive algorithms",
        "two pointers",
        "data structures",
        "binary search",
        "strings"
    ],
    "hidden_unit_tests": ""
}
{
    "prob_desc_time_limit": "4 seconds",
    "prob_desc_sample_outputs": "[\"14\", \"131\"]",
    "src_uid": "db8855495d22c26296351fe310281df2",
    "prob_desc_notes": "NoteIn the first example, it's optimal to rearrange the elements of the given array in the following order: $$$[6, \\, 2, \\, 2, \\, 2, \\, 3, \\, 1]$$$:$$$$$$\\operatorname{gcd}(a_1) + \\operatorname{gcd}(a_1, \\, a_2) + \\operatorname{gcd}(a_1, \\, a_2, \\, a_3) + \\operatorname{gcd}(a_1, \\, a_2, \\, a_3, \\, a_4) + \\operatorname{gcd}(a_1, \\, a_2, \\, a_3, \\, a_4, \\, a_5) + \\operatorname{gcd}(a_1, \\, a_2, \\, a_3, \\, a_4, \\, a_5, \\, a_6) = 6 + 2 + 2 + 2 + 1 + 1 = 14.$$$$$$ It can be shown that it is impossible to get a better answer.In the second example, it's optimal to rearrange the elements of a given array in the following order: $$$[100, \\, 10, \\, 10, \\, 5, \\, 1, \\, 3, \\, 3, \\, 7, \\, 42, \\, 54]$$$.",
    "prob_desc_description": "This is the hard version of the problem. The only difference is maximum value of $$$a_i$$$.Once in Kostomuksha Divan found an array $$$a$$$ consisting of positive integers. Now he wants to reorder the elements of $$$a$$$ to maximize the value of the following function: $$$$$$\\sum_{i=1}^n \\operatorname{gcd}(a_1, \\, a_2, \\, \\dots, \\, a_i),$$$$$$ where $$$\\operatorname{gcd}(x_1, x_2, \\ldots, x_k)$$$ denotes the greatest common divisor of integers $$$x_1, x_2, \\ldots, x_k$$$, and $$$\\operatorname{gcd}(x) = x$$$ for any integer $$$x$$$.Reordering elements of an array means changing the order of elements in the array arbitrary, or leaving the initial order.Of course, Divan can solve this problem. However, he found it interesting, so he decided to share it with you.",
    "prob_desc_output_spec": "Output the maximum value of the function that you can get by reordering elements of the array $$$a$$$.",
    "prob_desc_input_spec": "The first line contains a single integer $$$n$$$ ($$$1 \\leq n \\leq 10^5$$$) — the size of the array $$$a$$$. The second line contains $$$n$$$ integers $$$a_{1}, \\, a_{2}, \\, \\dots, \\, a_{n}$$$ ($$$1 \\le a_{i} \\le 2 \\cdot 10^7$$$) — the array $$$a$$$.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3-64",
    "lang_cluster": "Python",
    "difficulty": 2300,
    "file_name": "train_098.jsonl",
    "code_uid": "7736a2859ec0cf55791414e12971808e",
    "prob_desc_memory_limit": "1024 megabytes",
    "prob_desc_sample_inputs": "[\"6\\n2 3 1 2 6 2\", \"10\\n5 7 10 3 1 10 100 3 42 54\"]",
    "exec_outcome": "PASSED",
    "source_code": "''' D2. Divan and Kostomuksha (hard version)\nhttps://codeforces.com/contest/1614/problem/D2\n'''\n \nimport io, os, sys\ninput = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline  # decode().strip() if str\noutput = sys.stdout.write\n \nINF = float('inf')\n \ndef sieve(N):\n    '''return all primes in [2..N] in O(N)'''\n    primes = []\n    mpf = [0]*(N+1)  # min prime factor\n    for i in range(2, N+1):\n        if mpf[i] == 0:\n            primes.append(i)\n            mpf[i] = i\n        for p in primes:\n            if p*i > N or p > mpf[i]: break  # mpf[p*i] <= mpf[i] < p\n            mpf[p*i] = p                     # once per composite number\n    return primes, mpf\n \n \n# https://codeforces.com/contest/1614/submission/137008425\n \ndef solve(N, A):\n\tMAX = max(A)\n\tprimes, mpf = sieve(MAX + 1)\n \n\t# F[a] = all unique prime factors of a\n\tF = {}\n\tdef get_factors(a):\n\t\tif a in F: return F[a]\n\t\tfacs = []\n\t\twhile a > 1:\n\t\t\tfacs.append(mpf[a])\n\t\t\twhile facs[-1] == mpf[a]: a //= mpf[a] \n\t\treturn facs\n\n\t# C[f] = num elements in A divisible by f\n\t# think of primes as axes and numbers as points with coordinates = powers of primes\n\t# for each possible factor f, want to calc how many points a in A have all coordinates >= f\n\tC = [0]*(MAX+1)\n\tfor a in A: C[a] += 1\n \n\t# i.e. for each point a, want to increment count for each b inside the cube 0..a\n\t# to ensure a increments each b once and only once, there has to be a unique counting path from a to b\n\t# the below procedure traverses each axis one by one, hence ensures unique paths\n\t# note that the order of primes/axes are therefore not important\n\t# it's easiest to visualize a 2D lattice (2 primes)\n\tfor p in primes:\n\t\tfor a in range(MAX//p, 0, -1):\n\t\t\tC[a] += C[a*p]\n \n\t# let g[i]=gcd(a[1]..a[i]) for i=1..N\n\t# then g[1], g[2]...., g[N] is non-increasing, g[i] % g[i+1] == 0\n\t# want to max SUM_i g[i]\n \n\t# dp(g, p) = max gcd sum from this point onward where\n\t# * g is the next gcd\n\t# * p numbers already placed\n\t# * memo[g] = dp(f, C[g]) over all factors f of g\n\t#   --> max gcd sum onwards after choosing g as first gcd\n\tdef dp(g, p=0, memo={}):\n\t\tif g == 1: return N-p\n\t\tif g not in memo:\n\t\t\tfacs = get_factors(g)\n\t\t\tmemo[g] = max(dp(g//f, C[g], memo) for f in facs)\n\t\t\n\t\t# note previous p numbers are all multiples of g\n\t\t# so there are C[g]-p multiples of g left to place\n\t\treturn memo[g] + g*(C[g]-p)\n \n\t# try each possible g[1]\n\tres = max(dp(a) for a in A)\n\n \n\treturn res\n \n \ndef main():\n\tN = int(input())\n\tA = list(map(int, input().split()))\n\tout = solve(N, A)\n\toutput(f'{out}\\n')\n \n \nif __name__ == '__main__':\n\tmain()\n \n ",
    "prob_desc_created_at": "1637925300",
    "tags": [
        "dp",
        "number theory"
    ],
    "hidden_unit_tests": ""
}
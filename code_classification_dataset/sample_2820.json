{
    "prob_desc_time_limit": "3 seconds",
    "prob_desc_sample_outputs": "[\"3 2 1\", \"6 5 5 5 4 1\"]",
    "src_uid": "c8e71b942fac5c99c041ce032fbb9e4c",
    "prob_desc_notes": "NoteIn the first test:  If there are no bombs, $$$A$$$ is equal to $$$\\{1, 2, 3\\}$$$ at the end of the process, so the cost of the configuration is $$$3$$$.  If there is one bomb in position $$$1$$$, $$$A$$$ is equal to $$$\\{1, 2\\}$$$ at the end of the process, so the cost of the configuration is $$$2$$$;  If there are two bombs in positions $$$1$$$ and $$$2$$$, $$$A$$$ is equal to $$$\\{1\\}$$$ at the end of the process, so the cost of the configuration is $$$1$$$. In the second test:Let's consider the process for $$$i = 4$$$. There are three bombs on positions $$$q_1 = 5$$$, $$$q_2 = 2$$$, and $$$q_3 = 1$$$.At the beginning, $$$A = \\{\\}$$$.  Operation $$$1$$$: Add $$$p_1 = 2$$$ to $$$A$$$, so $$$A$$$ is equal to $$$\\{2\\}$$$. There exists a bomb in position $$$1$$$, so we should delete the largest element from $$$A$$$. $$$A$$$ is equal to $$$\\{\\}$$$.  Operation $$$2$$$: Add $$$p_2 = 3$$$ to $$$A$$$, so $$$A$$$ is equal to $$$\\{3\\}$$$. There exists a bomb in position $$$2$$$, so we should delete the largest element from $$$A$$$. $$$A$$$ is equal to $$$\\{\\}$$$.  Operation $$$3$$$: Add $$$p_3 = 6$$$ to $$$A$$$, so $$$A$$$ is equal to $$$\\{6\\}$$$. There is no bomb in position $$$3$$$, so we do nothing.  Operation $$$4$$$: Add $$$p_4 = 1$$$ to $$$A$$$, so $$$A$$$ is equal to $$$\\{1, 6\\}$$$. There is no bomb in position $$$4$$$, so we do nothing.  Operation $$$5$$$: Add $$$p_5 = 5$$$ to $$$A$$$, so $$$A$$$ is equal to $$$\\{1, 5, 6\\}$$$. There exists a bomb in position $$$5$$$, so we delete the largest element from $$$A$$$. Now, $$$A$$$ is equal to $$$\\{1, 5\\}$$$.  Operation $$$6$$$: Add $$$p_6 = 4$$$ to $$$A$$$, so $$$A$$$ is equal to $$$\\{1, 4, 5\\}$$$. There is no bomb in position $$$6$$$, so we do nothing. In the end, we have $$$A = \\{1, 4, 5\\}$$$, so the cost of the configuration is equal to $$$5$$$.",
    "prob_desc_description": "You are given a permutation, $$$p_1, p_2, \\ldots, p_n$$$.Imagine that some positions of the permutation contain bombs, such that there exists at least one position without a bomb.For some fixed configuration of bombs, consider the following process. Initially, there is an empty set, $$$A$$$.For each $$$i$$$ from $$$1$$$ to $$$n$$$: Add $$$p_i$$$ to $$$A$$$.  If the $$$i$$$-th position contains a bomb, remove the largest element in $$$A$$$.After the process is completed, $$$A$$$ will be non-empty. The cost of the configuration of bombs equals the largest element in $$$A$$$.You are given another permutation, $$$q_1, q_2, \\ldots, q_n$$$.For each $$$1 \\leq i \\leq n$$$, find the cost of a configuration of bombs such that there exists a bomb in positions $$$q_1, q_2, \\ldots, q_{i-1}$$$. For example, for $$$i=1$$$, you need to find the cost of a configuration without bombs, and for $$$i=n$$$, you need to find the cost of a configuration with bombs in positions $$$q_1, q_2, \\ldots, q_{n-1}$$$.",
    "prob_desc_output_spec": "Print $$$n$$$ space-separated integers, such that the $$$i$$$-th of them equals the cost of a configuration of bombs in positions $$$q_1, q_2, \\ldots, q_{i-1}$$$.",
    "prob_desc_input_spec": "The first line contains a single integer, $$$n$$$ ($$$2 \\leq n \\leq 300\\,000$$$). The second line contains $$$n$$$ distinct integers $$$p_1, p_2, \\ldots, p_n$$$ ($$$1 \\leq p_i \\leq n)$$$. The third line contains $$$n$$$ distinct integers $$$q_1, q_2, \\ldots, q_n$$$ ($$$1 \\leq q_i \\leq n)$$$.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3",
    "lang_cluster": "Python",
    "difficulty": 2400,
    "file_name": "train_032.jsonl",
    "code_uid": "117f3cf10448a4cbb93813b546e71fb0",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"3\\n3 2 1\\n1 2 3\", \"6\\n2 3 6 1 5 4\\n5 2 1 4 6 3\"]",
    "exec_outcome": "PASSED",
    "source_code": "import sys\ninput = sys.stdin.readline\n\nN=int(input())\nP=list(map(int,input().split()))\nQ=list(map(int,input().split()))\n\nseg_el=1<<(N.bit_length()) # Segment treeの台の要素数\nSEG=[0]*(2*seg_el) # 1-indexedなので、要素数2*seg_el.Segment treeの初期値で初期化\nLAZY=[0]*(2*seg_el) # 1-indexedなので、要素数2*seg_el.Segment treeの初期値で初期化\n\ndef indexes(L,R): # 遅延伝搬すべきノードのリストを下から上の順に返す. （つまり, updateやgetvaluesで見るノードより上にあるノードたち）\n    INDLIST=[]\n\n    R-=1\n    \n    L>>=1\n    R>>=1\n\n    while L!=R:\n        if L>R:\n            INDLIST.append(L)\n            L>>=1\n        else:\n            INDLIST.append(R)\n            R>>=1\n\n    while L!=0:\n        INDLIST.append(L)\n        L>>=1\n\n    return INDLIST\n        \n\ndef adds(l,r,x): # 区間[l,r)を +x 更新\n        \n    L=l+seg_el\n    R=r+seg_el\n\n    L//=(L & (-L))\n    R//=(R & (-R))\n\n    UPIND=indexes(L,R)\n    \n    for ind in UPIND[::-1]: # 遅延伝搬. 上から更新していく. （ただし, 今回はうまくやるとこの部分を省ける. addはクエリの順番によらないので. addではなく, updateの場合必要）\n        if LAZY[ind]!=0:\n            plus_lazy=LAZY[ind]\n            \n            SEG[ind<<1]+=plus_lazy\n            SEG[1+(ind<<1)]+=plus_lazy\n            \n            LAZY[ind<<1]+=plus_lazy\n            LAZY[1+(ind<<1)]+=plus_lazy\n            \n            LAZY[ind]=0\n    \n    while L!=R:\n        if L > R:\n            SEG[L]+=x\n            LAZY[L]+=x\n            L+=1\n            L//=(L & (-L))\n\n        else:\n            R-=1\n            SEG[R]+=x\n            LAZY[R]+=x\n            R//=(R & (-R))\n\n    for ind in UPIND:\n        SEG[ind]=min(SEG[ind<<1],SEG[1+(ind<<1)]) # 最初の遅延伝搬を省いた場合, ここを変える\n        \ndef getvalues(l,r): # 区間[l,r)に関するminを調べる\n\n    L=l+seg_el\n    R=r+seg_el\n\n    L//=(L & (-L))\n    R//=(R & (-R))\n\n    UPIND=indexes(L,R)\n    \n    for ind in UPIND[::-1]: # 遅延伝搬\n        if LAZY[ind]!=0:\n            plus_lazy=LAZY[ind]\n            \n            SEG[ind<<1]+=plus_lazy\n            SEG[1+(ind<<1)]+=plus_lazy\n            \n            LAZY[ind<<1]+=plus_lazy\n            LAZY[1+(ind<<1)]+=plus_lazy\n            \n            LAZY[ind]=0\n            \n    ANS=1<<31\n\n    while L!=R:\n        if L > R:\n            ANS=min(ANS , SEG[L])\n            L+=1\n            L//=(L & (-L))\n\n        else:\n            R-=1\n            ANS=min(ANS , SEG[R])\n            R//=(R & (-R))\n\n    return ANS\n\nfrom operator import itemgetter\nNOW=0\nP_INV=sorted([(p,i) for i,p in enumerate(P)],key=itemgetter(0),reverse=True)\nadds(P_INV[NOW][1],N,1)\n\nANS=[NOW]\nfor q in Q[:-1]:\n    adds(q-1,N,-1)\n    while True:\n        if getvalues(0,seg_el-1)<getvalues(N-1,N):\n            ANS.append(NOW)\n            break\n        else:\n            NOW+=1\n            adds(P_INV[NOW][1],N,1)\n\n    #print([getvalues(i,i+1) for i in range(N)],q,NOW)\n\nprint(*[N-a for a in ANS])\n",
    "prob_desc_created_at": "1584628500",
    "tags": [
        "data structures",
        "two pointers"
    ],
    "hidden_unit_tests": ""
}
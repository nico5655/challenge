{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"0\\n1\\n1\\n4\\n6\"]",
    "src_uid": "2592836c1457efda9ad333524abfdf56",
    "prob_desc_notes": "NoteThe following are illustrations of constructed graphs in example test cases.    the constructed graph in test case 1     the constructed graph in test case 2     the constructed graph in test case 3     the constructed graph in test case 4     the constructed graph in test case 5 ",
    "prob_desc_description": "A permutation is an array consisting of $$$n$$$ distinct integers from $$$1$$$ to $$$n$$$ in arbitrary order. For example, $$$[2,3,1,5,4]$$$ is a permutation, but $$$[1,2,2]$$$ is not a permutation ($$$2$$$ appears twice in the array) and $$$[1,3,4]$$$ is also not a permutation ($$$n=3$$$ but there is $$$4$$$ in the array).You are given a permutation of $$$1,2,\\dots,n$$$, $$$[a_1,a_2,\\dots,a_n]$$$. For integers $$$i$$$, $$$j$$$ such that $$$1\\le i&lt;j\\le n$$$, define $$$\\operatorname{mn}(i,j)$$$ as $$$\\min\\limits_{k=i}^j a_k$$$, and define $$$\\operatorname{mx}(i,j)$$$ as $$$\\max\\limits_{k=i}^j a_k$$$.Let us build an undirected graph of $$$n$$$ vertices, numbered $$$1$$$ to $$$n$$$. For every pair of integers $$$1\\le i&lt;j\\le n$$$, if $$$\\operatorname{mn}(i,j)=a_i$$$ and $$$\\operatorname{mx}(i,j)=a_j$$$ both holds, or $$$\\operatorname{mn}(i,j)=a_j$$$ and $$$\\operatorname{mx}(i,j)=a_i$$$ both holds, add an undirected edge of length $$$1$$$ between vertices $$$i$$$ and $$$j$$$.In this graph, find the length of the shortest path from vertex $$$1$$$ to vertex $$$n$$$. We can prove that $$$1$$$ and $$$n$$$ will always be connected via some path, so a shortest path always exists.",
    "prob_desc_output_spec": "For each test case, print a single line containing one integer â€” the length of the shortest path from $$$1$$$ to $$$n$$$.",
    "prob_desc_input_spec": "Each test contains multiple test cases. The first line contains the number of test cases $$$t$$$ ($$$1 \\le t \\le 5\\cdot 10^4$$$). Description of the test cases follows. The first line of each test case contains one integer $$$n$$$ ($$$1\\le n\\le 2.5\\cdot 10^5$$$). The second line of each test case contains $$$n$$$ integers $$$a_1$$$, $$$a_2$$$, $$$\\ldots$$$, $$$a_n$$$ ($$$1\\le a_i\\le n$$$). It's guaranteed that $$$a$$$ is a permutation of $$$1$$$, $$$2$$$, $$$\\dots$$$, $$$n$$$. It is guaranteed that the sum of $$$n$$$ over all test cases does not exceed $$$5\\cdot 10^5$$$.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3-64",
    "lang_cluster": "Python",
    "difficulty": 1900,
    "file_name": "train_105.jsonl",
    "code_uid": "f700448f3517c5d29f0748198a763a40",
    "prob_desc_memory_limit": "512 megabytes",
    "prob_desc_sample_inputs": "[\"5\\n\\n1\\n\\n1\\n\\n2\\n\\n1 2\\n\\n5\\n\\n1 4 2 3 5\\n\\n5\\n\\n2 1 5 3 4\\n\\n10\\n\\n7 4 8 1 6 10 3 5 2 9\"]",
    "exec_outcome": "PASSED",
    "source_code": "from sys import stdin, stdout\r\ninput, print = stdin.readline, stdout.write\r\n \r\ndef main():\r\n  for _ in range(int(input())):\r\n    \r\n    maxval = int(input())\r\n    seq = [int(x) for x in input().split()] + [-1]\r\n    \r\n    cur = 0\r\n    steps = 0\r\n    pointer = 0\r\n    tempval = 0\r\n    tempdex = 0\r\n    iters = 1\r\n    \r\n    toggle = False\r\n    if (seq[1] > seq[0]):\r\n      toggle = True\r\n    \r\n    visited = [0 for x in seq] + [-1]\r\n    visited[0] = -1\r\n    minunused = 1 \r\n    maxunused = maxval\r\n    \r\n    if (seq[cur] == maxunused):\r\n      maxunused -= 1 \r\n    if (seq[cur] == minunused):\r\n      minunused += 1\r\n    visited[seq[cur]] = 1\r\n    \r\n    while (cur < len(seq) - 2):\r\n      \r\n      if (not toggle):\r\n        \r\n        tempval = seq[pointer]\r\n        tempdex = pointer\r\n        \r\n        while (True):\r\n          pointer += 1\r\n          if (seq[pointer] == -1 or seq[pointer] > seq[cur]):\r\n            break\r\n          visited[seq[pointer]] = 1\r\n          if (seq[pointer] < tempval):\r\n            tempval = seq[pointer]\r\n            tempdex = pointer\r\n          if (tempval == minunused):\r\n            visited[tempval] = 1\r\n            while(visited[minunused] == 1):\r\n              minunused += 1\r\n            while(visited[maxunused] == 1):\r\n              maxunused -= 1\r\n            break\r\n        \r\n        steps += 1\r\n        cur = tempdex\r\n        if (seq[pointer] == -1):\r\n          pointer = cur + 1\r\n        visited[seq[pointer]] = 1\r\n        toggle = not toggle\r\n        \r\n      else:\r\n        \r\n        tempval = seq[pointer]\r\n        tempdex = pointer\r\n        \r\n        while (True):\r\n          pointer += 1\r\n          if (seq[pointer] == -1 or seq[pointer] < seq[cur]):\r\n            break\r\n          if (seq[pointer] > tempval):\r\n            tempval = seq[pointer]\r\n            tempdex = pointer\r\n          visited[seq[pointer]] = 1\r\n          if (tempval == maxunused):\r\n            visited[tempval] = 1\r\n            while(visited[minunused] == 1):\r\n              minunused += 1\r\n            while(visited[maxunused] == 1):\r\n              maxunused -= 1\r\n            break\r\n        \r\n        steps += 1\r\n        cur = tempdex\r\n        if (seq[pointer] == -1):\r\n          pointer = cur + 1\r\n        visited[seq[pointer]] = 1\r\n        toggle = not toggle\r\n      \r\n    print(str(steps)+\"\\n\")\r\n \r\nmain()",
    "prob_desc_created_at": "1656167700",
    "tags": [
        "binary search",
        "constructive algorithms",
        "data structures",
        "divide and conquer",
        "greedy",
        "shortest paths"
    ],
    "hidden_unit_tests": ""
}
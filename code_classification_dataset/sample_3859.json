{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"3\\n1 5 4\", \"-1\"]",
    "src_uid": "9f13d3d0266b46e4201ea6a2378d1b71",
    "prob_desc_notes": "NoteConsider the examples above.In the first example, the group of spiders is illustrated on the picture below:  We choose the two-legged, the ten-legged and the $$$16$$$-legged spiders. It's not hard to see that each pair may weave a web with enough durability, as $$$2 \\oplus 10 = 8 \\ge 8$$$, $$$2 \\oplus 16 = 18 \\ge 8$$$ and $$$10 \\oplus 16 = 26 \\ge 8$$$.This is not the only way, as you can also choose, for example, the spiders with indices $$$3$$$, $$$4$$$, and $$$6$$$.In the second example, no pair of spiders can weave the web with durability $$$1024$$$ or more, so the answer is $$$-1$$$.",
    "prob_desc_description": "Binary Spiders are species of spiders that live on Mars. These spiders weave their webs to defend themselves from enemies.To weave a web, spiders join in pairs. If the first spider in pair has $$$x$$$ legs, and the second spider has $$$y$$$ legs, then they weave a web with durability $$$x \\oplus y$$$. Here, $$$\\oplus$$$ means bitwise XOR.Binary Spiders live in large groups. You observe a group of $$$n$$$ spiders, and the $$$i$$$-th spider has $$$a_i$$$ legs.When the group is threatened, some of the spiders become defenders. Defenders are chosen in the following way. First, there must be at least two defenders. Second, any pair of defenders must be able to weave a web with durability at least $$$k$$$. Third, there must be as much defenders as possible.Scientists have researched the behaviour of Binary Spiders for a long time, and now they have a hypothesis that they can always choose the defenders in an optimal way, satisfying the conditions above. You need to verify this hypothesis on your group of spiders. So, you need to understand how many spiders must become defenders. You are not a Binary Spider, so you decided to use a computer to solve this problem.",
    "prob_desc_output_spec": "In the first line, print a single integer $$$\\ell$$$ ($$$2 \\le \\ell \\le n$$$), the maximum possible amount of defenders. In the second line, print $$$\\ell$$$ integers $$$b_i$$$, separated by a single space ($$$1 \\le b_i \\le n$$$) — indices of spiders that will become defenders. If there exists more than one way to choose the defenders, print any of them. Unfortunately, it may appear that it's impossible to choose the defenders. In this case, print a single integer $$$-1$$$.",
    "prob_desc_input_spec": "The first line contains two integers $$$n$$$ and $$$k$$$ ($$$2 \\le n \\le 3\\cdot10^5$$$, $$$0 \\le k \\le 2^{30} - 1$$$), the amount of spiders in the group and the minimal allowed durability of a web. The second line contains $$$n$$$ integers $$$a_i$$$ ($$$0 \\le a_i \\le 2^{30}-1$$$) — the number of legs the $$$i$$$-th spider has.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3-64",
    "lang_cluster": "Python",
    "difficulty": 2300,
    "file_name": "train_085.jsonl",
    "code_uid": "a81fe9e0c138b0bd7a50f1db754766ac",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"6 8\\n2 8 4 16 10 14\", \"6 1024\\n1 2 3 1 4 0\"]",
    "exec_outcome": "PASSED",
    "source_code": "import sys\r\nimport os\r\nfrom io import BytesIO, IOBase\r\nfrom _collections import defaultdict\r\nfrom random import randrange\r\n\r\n# region fastio\r\nBUFSIZE = 8192\r\n \r\nclass FastIO(IOBase):\r\n    newlines = 0\r\n \r\n    def __init__(self, file):\r\n        self._fd = file.fileno()\r\n        self.buffer = BytesIO()\r\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\r\n        self.write = self.buffer.write if self.writable else None\r\n \r\n    def read(self):\r\n        while True:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            if not b:\r\n                break\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines = 0\r\n        return self.buffer.read()\r\n \r\n    def readline(self):\r\n        while self.newlines == 0:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            self.newlines = b.count(b\"\\n\") + (not b)\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines -= 1\r\n        return self.buffer.readline()\r\n \r\n    def flush(self):\r\n        if self.writable:\r\n            os.write(self._fd, self.buffer.getvalue())\r\n            self.buffer.truncate(0), self.buffer.seek(0)\r\n \r\nclass IOWrapper(IOBase):\r\n    def __init__(self, file):\r\n        self.buffer = FastIO(file)\r\n        self.flush = self.buffer.flush\r\n        self.writable = self.buffer.writable\r\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\r\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\r\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\r\n\r\nif sys.version_info[0] < 3:\r\n    sys.stdin = BytesIO(os.read(0, os.fstat(0).st_size))\r\nelse:\r\n    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\r\n\r\nf = sys.stdin\r\nif os.environ.get('USER') == \"loic\":\r\n    f = open(\"data.in\")\r\n    \r\nline = lambda: f.readline().split()\r\nui = lambda: int(line()[0])\r\nti = lambda: map(int,line())\r\nli = lambda: list(ti())\r\n\r\n#######################################################################\r\n\r\ndef max_xor_of_pair(arr):\r\n    m = 0\r\n    mask = 0\r\n    s = set()\r\n    d = {}\r\n    pair = (-1,-1)\r\n     \r\n    for i in range(30, -1, -1):\r\n        mask |= (1 << i)\r\n        tmp = m | (1 << i)\r\n     \r\n        for a in arr:\r\n            pref = a & mask\r\n            s.add(pref)\r\n#             d[pref] = a\r\n \r\n        for pref in s:\r\n            if tmp ^ pref in s:\r\n                m = tmp\r\n#                 pair = (d[pref], d[tmp ^ pref])\r\n                break\r\n                 \r\n        s.clear()\r\n        \r\n    return m,pair\r\n\r\ndef solve():\r\n    \r\n    if K == 0:\r\n        return str(N) + \"\\n\" + \" \".join(map(str,range(1,N+1)))\r\n    \r\n    pref = defaultdict(list)\r\n    msb = len(bin(K)) - 2\r\n    for a in A:\r\n        val = a >> msb\r\n        pref[val].append(a)\r\n    \r\n    res = []\r\n    for l in pref.values():\r\n        if len(l) == 1:\r\n            res.extend(l)\r\n        else:\r\n            m,pair = max_xor_of_pair(l)\r\n            if m >= K:\r\n#                 res.append(pair[0])\r\n#                 res.append(pair[1])\r\n                s = set(l)\r\n                for val in s:\r\n                    if val ^ m in s:\r\n                        res += [val,val^m]\r\n                        break\r\n            else:\r\n                res.append(l[0])\r\n                \r\n    if len(res) < 2:\r\n        return str(-1)\r\n    \r\n    mp = {v:i for i,v in enumerate(A)}\r\n    \r\n    return str(len(res)) + \"\\n\" + \" \".join(str(mp[v]+1) for v in res)\r\n\r\nfor test in range(1,1+1):\r\n    N,K = ti()\r\n    A = li()\r\n    \r\n    print(solve())\r\n    \r\nf.close()",
    "prob_desc_created_at": "1641989100",
    "tags": [
        "bitmasks",
        "data structures",
        "implementation",
        "math",
        "sortings",
        "trees"
    ],
    "hidden_unit_tests": ""
}
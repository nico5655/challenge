{
    "prob_desc_time_limit": "3 seconds",
    "prob_desc_sample_outputs": "[\"2\\n6 3\\n0\\n\\n3\\n4 1 7 \\n2\\n1 4\", \"6\\n18 11 12 1 6 21 \\n1\\n1 \\n1\\n3 \\n1\\n2 \\n1\\n6 \\n0\\n\\n1\\n4 \\n0\\n\\n1\\n1 \\n2\\n1 11\"]",
    "src_uid": "9f8660190134606194cdd8db891a3d46",
    "prob_desc_notes": "NoteIn the first example, answers are:  \"onetwone\",  \"testme\" — Polycarp likes it, there is nothing to remove,  \"oneoneone\",  \"twotwo\". In the second example, answers are:   \"onetwonetwooneooonetwooo\",  \"two\",  \"one\",  \"twooooo\",  \"ttttwo\",  \"ttwwoo\" — Polycarp likes it, there is nothing to remove,  \"ooone\",  \"onnne\" — Polycarp likes it, there is nothing to remove,  \"oneeeee\",  \"oneeeeeeetwooooo\". ",
    "prob_desc_description": "You are given a non-empty string $$$s=s_1s_2\\dots s_n$$$, which consists only of lowercase Latin letters. Polycarp does not like a string if it contains at least one string \"one\" or at least one string \"two\" (or both at the same time) as a substring. In other words, Polycarp does not like the string $$$s$$$ if there is an integer $$$j$$$ ($$$1 \\le j \\le n-2$$$), that $$$s_{j}s_{j+1}s_{j+2}=$$$\"one\" or $$$s_{j}s_{j+1}s_{j+2}=$$$\"two\".For example:  Polycarp does not like strings \"oneee\", \"ontwow\", \"twone\" and \"oneonetwo\" (they all have at least one substring \"one\" or \"two\"),  Polycarp likes strings \"oonnee\", \"twwwo\" and \"twnoe\" (they have no substrings \"one\" and \"two\"). Polycarp wants to select a certain set of indices (positions) and remove all letters on these positions. All removals are made at the same time.For example, if the string looks like $$$s=$$$\"onetwone\", then if Polycarp selects two indices $$$3$$$ and $$$6$$$, then \"onetwone\" will be selected and the result is \"ontwne\".What is the minimum number of indices (positions) that Polycarp needs to select to make the string liked? What should these positions be?",
    "prob_desc_output_spec": "Print an answer for each test case in the input in order of their appearance. The first line of each answer should contain $$$r$$$ ($$$0 \\le r \\le |s|$$$) — the required minimum number of positions to be removed, where $$$|s|$$$ is the length of the given line. The second line of each answer should contain $$$r$$$ different integers — the indices themselves for removal in any order. Indices are numbered from left to right from $$$1$$$ to the length of the string. If $$$r=0$$$, then the second line can be skipped (or you can print empty). If there are several answers, print any of them.",
    "prob_desc_input_spec": "The first line of the input contains an integer $$$t$$$ ($$$1 \\le t \\le 10^4$$$) — the number of test cases in the input. Next, the test cases are given. Each test case consists of one non-empty string $$$s$$$. Its length does not exceed $$$1.5\\cdot10^5$$$. The string $$$s$$$ consists only of lowercase Latin letters. It is guaranteed that the sum of lengths of all lines for all input data in the test does not exceed $$$1.5\\cdot10^6$$$.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "Python 3",
    "lang_cluster": "Python",
    "difficulty": 1400,
    "file_name": "train_005.jsonl",
    "code_uid": "08cebcfb29f7a688e412b2f8c1b69ba5",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"4\\nonetwone\\ntestme\\noneoneone\\ntwotwo\", \"10\\nonetwonetwooneooonetwooo\\ntwo\\none\\ntwooooo\\nttttwo\\nttwwoo\\nooone\\nonnne\\noneeeee\\noneeeeeeetwooooo\"]",
    "exec_outcome": "PASSED",
    "source_code": "from heapq import heappush,heappop,heapify\nfrom collections import deque,defaultdict,Counter\nimport itertools\nfrom itertools import permutations,combinations\nimport sys\nimport bisect\nimport string\nimport math\nimport time\n#import random\ndef I():\n    return int(input())\ndef MI():\n    return map(int,input().split())\ndef LI():\n    return [int(i) for i in input().split()]\ndef LI_():\n    return [int(i)-1 for i in input().split()]\ndef StoI():\n    return [ord(i)-97 for i in input()]\ndef ItoS(nn):\n    return chr(nn+97)\ndef GI(V,E,Directed=False,index=0):\n    org_inp=[]\n    g=[[] for i in range(n)]\n    for i in range(E):\n        inp=LI()\n        org_inp.append(inp)\n        if index==0:\n            inp[0]-=1\n            inp[1]-=1\n        if len(inp)==2:\n            a,b=inp\n            g[a].append(b)\n            if not Directed:\n                g[b].append(a)\n        elif len(inp)==3:\n            a,b,c=inp\n            aa=(inp[0],inp[2])\n            bb=(inp[1],inp[2])\n            g[a].append(bb)\n            if not Directed:\n                g[b].append(aa)\n    return g,org_inp\ndef show(*inp,end='\\n'):\n    if show_flg:\n        print(*inp,end=end)\nYN=['Yes','No']\nmo=10**9+7\ninf=float('inf')\nl_alp=string.ascii_lowercase\nu_alp=string.ascii_uppercase\n\n#sys.setrecursionlimit(10**5)\ninput=lambda: sys.stdin.readline().rstrip()\n\nshow_flg=False\nshow_flg=True\n\nt=I()\n\nfor _ in range(t):\n    s=input()\n    n=len(s)\n    \n    \n    '''\n    import random\n    K=list('twone')+['two','one','twone']*3+['o']*5\n    n=50\n    s=''.join([K[random.randint(0,18)] for i in range(n)])\n    s+=['two','one','twone'][random.randint(0,2)]\n    n=len(s)\n    '''\n    ans=[]\n    i=0\n    while i<n:\n        \n        if s[i]=='o':\n            if i<n-1 and s[i+1]=='n':\n                if i<n-2 and s[i+2]=='e':\n                    ans+=[i+1 +1]\n        elif s[i]=='t':\n            if i<n-1 and s[i+1]=='w':\n                if i<n-2 and s[i+2]=='o':\n                    if i<n-3 and s[i+3]=='n':\n                        if i<n-4 and s[i+4]=='e':\n                            ans+=[i+2 +1]\n                            i=i+4\n                        else:\n                            ans+=[i+1 +1]\n                            i=i+1\n                    else:\n                        ans+=[i+1 +1]\n                        i=i+1\n\n        i+=1\n    \n    print(len(ans))\n    print(*ans)\n\n'''\n    tmp=''\n    for i in range(len(s)):\n        if i+1 not in ans:\n            tmp+=s[i]\n        else:\n            tmp+=' '\n    if 'two' in ''.join(tmp.split()) or 'one' in ''.join(tmp.split()):\n        print('Error')\n        show(tmp)\n        show(s)\n    #show(s,tmp)\n'''",
    "prob_desc_created_at": "1576321500",
    "tags": [
        "dp",
        "greedy"
    ],
    "hidden_unit_tests": ""
}
{
    "prob_desc_time_limit": "1 second",
    "prob_desc_sample_outputs": "[\"YES\", \"NO\", \"YES\"]",
    "src_uid": "ad5b878298adea8742c36e2e119780f9",
    "prob_desc_notes": "NoteIn the first sample, we can cut the edge $$$(1, 2)$$$, and the tree will be split into $$$2$$$ trees of sizes $$$1$$$ and $$$2$$$ correspondently. Any tree of size $$$2$$$ is a Fib-tree, as it can be split into $$$2$$$ trees of size $$$1$$$.In the second sample, no matter what edge we cut, the tree will be split into $$$2$$$ trees of sizes $$$1$$$ and $$$4$$$. As $$$4$$$ isn't $$$F_k$$$ for any $$$k$$$, it's not Fib-tree.In the third sample, here is one possible order of cutting the edges so that all the trees in the process are Fib-trees: $$$(1, 3), (1, 2), (4, 5), (3, 4)$$$. ",
    "prob_desc_description": "Let $$$F_k$$$ denote the $$$k$$$-th term of Fibonacci sequence, defined as below: $$$F_0 = F_1 = 1$$$ for any integer $$$n \\geq 0$$$, $$$F_{n+2} = F_{n+1} + F_n$$$You are given a tree with $$$n$$$ vertices. Recall that a tree is a connected undirected graph without cycles.We call a tree a Fib-tree, if its number of vertices equals $$$F_k$$$ for some $$$k$$$, and at least one of the following conditions holds: The tree consists of only $$$1$$$ vertex; You can divide it into two Fib-trees by removing some edge of the tree. Determine whether the given tree is a Fib-tree or not.",
    "prob_desc_output_spec": "Print \"YES\" if the given tree is a Fib-tree, or \"NO\" otherwise. You can print your answer in any case. For example, if the answer is \"YES\", then the output \"Yes\" or \"yeS\" will also be considered as correct answer.",
    "prob_desc_input_spec": "The first line of the input contains a single integer $$$n$$$ ($$$1 \\leq n \\leq 2 \\cdot 10^5$$$) â€” the number of vertices in the tree. Then $$$n-1$$$ lines follow, each of which contains two integers $$$u$$$ and $$$v$$$ ($$$1\\leq u,v \\leq n$$$, $$$u \\neq v$$$), representing an edge between vertices $$$u$$$ and $$$v$$$. It's guaranteed that given edges form a tree.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3",
    "lang_cluster": "Python",
    "difficulty": 2400,
    "file_name": "train_095.jsonl",
    "code_uid": "195e22700f190f2cd4d81a027aece074",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"3\\n1 2\\n2 3\", \"5\\n1 2\\n1 3\\n1 4\\n1 5\", \"5\\n1 3\\n1 2\\n4 5\\n3 4\"]",
    "exec_outcome": "PASSED",
    "source_code": "def main():\r\n    n = int(input())\r\n    graph = [[] for _ in range(n+1)]\r\n    parent = [-1 for _ in range(n+1)]\r\n    for _ in range(n-1):\r\n        x,y = map(int, input().split(' '))\r\n        graph[x].append(y)\r\n        graph[y].append(x)\r\n    \r\n    digraph = [[] for _ in range(n+1)]\r\n    stack = [1]\r\n    count_order = []\r\n    while stack:\r\n        cur = stack.pop()\r\n        count_order.append(cur)\r\n        for adj in graph[cur]:\r\n            if parent[cur] == adj:\r\n                continue\r\n            stack.append(adj)\r\n            parent[adj] = cur\r\n            digraph[cur].append(adj)\r\n\r\n    count = [1 for _ in range(n+1)]\r\n    while count_order:\r\n        cur = count_order.pop()\r\n        for child in digraph[cur]:\r\n            count[cur] += count[child]\r\n\r\n    fib_numbers = [1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946, 17711, 28657, 46368, 75025, 121393, 196418]\r\n    fib_d = {val : i for i, val in enumerate(fib_numbers)}\r\n    fin = [0 for _ in range(n+1)]\r\n\r\n    def rec(cur_root, total_nodes):\r\n        if total_nodes <= 3:\r\n            return True\r\n        elif total_nodes not in fib_d:\r\n            return False \r\n\r\n        fib_idx = fib_d[total_nodes]\r\n        search_vals = [fib_numbers[fib_idx-1], fib_numbers[fib_idx-2]]\r\n\r\n        cut_node = -1\r\n        stack = [cur_root]\r\n        while stack:\r\n            cur_node = stack.pop()\r\n            if count[cur_node] in search_vals:\r\n                cut_node = cur_node\r\n                fin[cut_node] = True\r\n                break\r\n            for adj in digraph[cur_node]:\r\n                if not fin[adj]:\r\n                    stack.append(adj)\r\n        if cut_node == -1:\r\n            return False\r\n        \r\n        cut_node_count = count[cut_node]\r\n\r\n        # propagate update upwards\r\n        cur_parent = parent[cut_node]\r\n        while cur_parent != -1:\r\n            count[cur_parent] -= cut_node_count\r\n            cur_parent = parent[cur_parent]\r\n        parent[cut_node] = -1\r\n\r\n        if count[cur_root] <= count[cut_node]:\r\n            try1 = rec(cur_root, count[cur_root])\r\n            if try1:\r\n                return rec(cut_node, count[cut_node])\r\n        else:\r\n            try1 = rec(cut_node, count[cut_node])\r\n            if try1:\r\n                return rec(cur_root, count[cur_root])\r\n        return False\r\n\r\n    print(\"YES\" if rec(1, n) else \"NO\")\r\n\r\n# region fastio\r\nimport os\r\nimport sys\r\nfrom io import BytesIO, IOBase\r\nBUFSIZE = 8192\r\n \r\nclass FastIO(IOBase):\r\n    newlines = 0\r\n \r\n    def __init__(self, file):\r\n        self._fd = file.fileno()\r\n        self.buffer = BytesIO()\r\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\r\n        self.write = self.buffer.write if self.writable else None\r\n \r\n    def read(self):\r\n        while True:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            if not b:\r\n                break\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines = 0\r\n        return self.buffer.read()\r\n \r\n    def readline(self):\r\n        while self.newlines == 0:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            self.newlines = b.count(b\"\\n\") + (not b)\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines -= 1\r\n        return self.buffer.readline()\r\n \r\n    def flush(self):\r\n        if self.writable:\r\n            os.write(self._fd, self.buffer.getvalue())\r\n            self.buffer.truncate(0), self.buffer.seek(0)\r\n \r\n \r\nclass IOWrapper(IOBase):\r\n    def __init__(self, file):\r\n        self.buffer = FastIO(file)\r\n        self.flush = self.buffer.flush\r\n        self.writable = self.buffer.writable\r\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\r\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\r\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\r\n \r\n \r\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\r\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\r\n \r\n# endregion\r\n \r\nif __name__ == \"__main__\":\r\n    main()",
    "prob_desc_created_at": "1614519300",
    "tags": [
        "brute force",
        "dfs and similar",
        "divide and conquer",
        "number theory",
        "trees"
    ],
    "hidden_unit_tests": ""
}
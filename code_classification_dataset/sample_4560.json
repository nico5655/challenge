{
    "prob_desc_time_limit": "1 second",
    "prob_desc_sample_outputs": "[\"6\", \"21\", \"240\"]",
    "src_uid": "d5be4e2cd91df0cd8866d46a979be4b1",
    "prob_desc_notes": "NoteIn the first example our budget is too low to move machine $$$(*,~2)$$$, but we can move both machines $$$(+,~1)$$$ to the beginning of the chain. So the final chain will be $$$(+,~1)$$$ $$$(+,~1)$$$ $$$(*,~2)$$$. If the workpiece with the value $$$1$$$ is supplied to the first machine, its value will be changed in the following way: $$$1, 2, 3, 6$$$.In the second example we can move only one machine. Let's move machine $$$(+,~2)$$$ to the beginning of the chain. The final chain will be $$$(+,~2)$$$ $$$(*,~2)$$$ $$$(+,~1)$$$ $$$(*,~3)$$$. The value of the workpiece will be changed in the following way: $$$1, 3, 6, 7, 21$$$.In the third example we can place machine $$$(*,~4)$$$ before the machine $$$(*,~5)$$$, and move machine $$$(+,~3)$$$ to the beginning of the chain. The final chain will be $$$(+,~3)$$$ $$$(*,~2)$$$ $$$(+,~1)$$$ $$$(+,~1)$$$ $$$(+,~1)$$$ $$$(+,~1)$$$ $$$(*,~4)$$$ $$$(*,~5)$$$. The value of the workpiece will be changed in the following way: $$$1, 4, 8, 9, 10, 11, 12, 48, 240$$$.",
    "prob_desc_description": "You have been invited as a production process optimization specialist to some very large company. The company has $$$n$$$ machines at its factory, standing one behind another in the production chain. Each machine can be described in one of the following two ways: $$$(+,~a_i)$$$ or $$$(*,~a_i)$$$.If a workpiece with the value $$$x$$$ is supplied to the machine of kind $$$(+,~a_i)$$$, then the output workpiece has value $$$x + a_i$$$.If a workpiece with the value $$$x$$$ is supplied to the machine of kind $$$(*,~a_i)$$$, then the output workpiece has value $$$x \\cdot a_i$$$.The whole production process is as follows. The workpiece with the value $$$1$$$ is supplied to the first machine, then the workpiece obtained after the operation of the first machine is supplied to the second machine, then the workpiece obtained after the operation of the second machine is supplied to the third machine, and so on. The company is not doing very well, so now the value of the resulting product does not exceed $$$2 \\cdot 10^9$$$.The directors of the company are not satisfied with the efficiency of the production process and have given you a budget of $$$b$$$ coins to optimize it.To optimize production you can change the order of machines in the chain. Namely, by spending $$$p$$$ coins, you can take any machine of kind $$$(+,~a_i)$$$ and move it to any place in the chain without changing the order of other machines. Also, by spending $$$m$$$ coins, you can take any machine of kind $$$(*,~a_i)$$$ and move it to any place in the chain.What is the maximum value of the resulting product that can be achieved if the total cost of movements that are made should not exceed $$$b$$$ coins?",
    "prob_desc_output_spec": "Print one integer — the maximum value of the resulting product that can be achieved if the total cost of movements that are made does not exceed $$$b$$$ coins.",
    "prob_desc_input_spec": "The first line contains four integers $$$n$$$, $$$b$$$, $$$p$$$ and $$$m$$$ ($$$1 \\le n \\le 10^6$$$, $$$1 \\le b, p, m \\le 10^9$$$) — the number of machine at the factory, your budget and costs of movements of both kinds of machines. Each of the following $$$n$$$ lines contains description of a machine. The description begins with one of the following characters: \"+\" or \"*\", that denotes the kind of the machine. Then an integer $$$a_i$$$ follows ($$$1 \\le a_i \\le 2 \\cdot 10^9$$$). It's guaranteed that the current value of the resulting product does not exceed $$$2 \\cdot 10^9$$$.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3-64",
    "lang_cluster": "Python",
    "difficulty": 3300,
    "file_name": "train_100.jsonl",
    "code_uid": "e465ef77094942af9d079754ba84fd17",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"3 2 1 3\\n* 2\\n+ 1\\n+ 1\", \"4 2 2 2\\n* 2\\n+ 1\\n* 3\\n+ 2\", \"8 2 1 1\\n* 2\\n+ 1\\n* 4\\n+ 1\\n+ 1\\n+ 1\\n* 5\\n+ 3\"]",
    "exec_outcome": "PASSED",
    "source_code": "from bisect import bisect\r\n\r\nimport sys\r\ninput = sys.stdin.readline\r\n\r\nn, b, p, m = map(int, input().split())\r\n\r\n\r\nadds = []\r\ncurr = []\r\nmults = []\r\n\r\ni = 0\r\nfor _ in range(n):\r\n    t, v = input().split()\r\n    v = int(v)\r\n    \r\n    if t == '*':\r\n        if v == 1:\r\n            continue\r\n        curr.sort()\r\n\r\n        adds.append(curr)\r\n        mults.append(v)\r\n        curr = []\r\n    else:\r\n        curr.append(v)\r\n        \r\ncurr.sort()\r\nadds.append(curr)\r\n\r\npref = []\r\nfor l in adds:  \r\n    np = [0]\r\n    for v in l[::-1]:\r\n        np.append(v + np[-1])\r\n    pref.append(np)\r\n\r\ny = len(mults)\r\nun_m = sorted(set(mults))\r\nz = len(un_m)\r\nct_m = [0] * z\r\nfor v in mults:\r\n    for i in range(z):\r\n        if un_m[i] == v:\r\n            ct_m[i] += 1\r\n\r\nfrom itertools import product\r\nposs = []\r\n\r\nassert len(adds) == y + 1\r\n\r\nfor tup in product(*[range(ct + 1) for ct in ct_m]):\r\n    rem_adds = (b - m * sum(tup))//p\r\n    \r\n    if rem_adds < 0:\r\n        continue\r\n\r\n    d = {}\r\n    for i in range(z):\r\n        d[un_m[i]] = tup[i]\r\n\r\n    end = 1\r\n    used = [0] * y\r\n\r\n    for i in range(y):\r\n        if d[mults[i]]:\r\n            used[i] = 1\r\n            d[mults[i]] -= 1\r\n            end *= mults[i]\r\n\r\n    seg_mult = [1]\r\n    for i in range(y - 1, -1, -1):\r\n        if used[i] == 0:\r\n            seg_mult.append(seg_mult[-1] * mults[i])\r\n        else:\r\n            seg_mult.append(seg_mult[-1])\r\n    seg_mult.reverse()\r\n\r\n    exc = [seg_mult[0] - v for v in seg_mult]\r\n\r\n    init_tot = 0\r\n    for j in range(y + 1):\r\n        if exc[j] != 0:\r\n            init_tot += len(adds[j])\r\n\r\n    lo = 0 #Ct value provided >= lo >= rem_adds\r\n    hi = 10 ** 18 + 100 #Too high\r\n    while hi - lo > 1:\r\n        mid = lo + (hi - lo) // 2\r\n\r\n        tot = init_tot\r\n        for j in range(y + 1):\r\n            if exc[j] == 0:\r\n                continue\r\n            \r\n            limit = (mid - 1) // exc[j]\r\n\r\n            #ct = len(adds[j]) - bisect(adds[j], limit - 1)\r\n            #tot += ct\r\n\r\n            diff = bisect(adds[j], limit)\r\n            tot -= diff\r\n            #print(mid, j, diff) \r\n\r\n        if tot >= rem_adds:\r\n            lo = mid\r\n        else:\r\n            hi = mid\r\n\r\n    tot = seg_mult[0]\r\n    ct = 0\r\n    for j in range(y + 1):\r\n        tot += pref[j][-1] * seg_mult[j]\r\n\r\n        if exc[j] == 0:\r\n            continue\r\n        \r\n        limit = (lo - 1) // exc[j]\r\n\r\n        s_ct = len(adds[j]) - bisect(adds[j], limit)\r\n\r\n        tot += pref[j][s_ct] * exc[j]\r\n        ct += s_ct\r\n\r\n    if lo != 0:\r\n        assert ct >= rem_adds\r\n        tot -= lo * (ct - rem_adds)\r\n\r\n    #print(tup, lo, tot, end)\r\n    poss.append(tot * end)\r\n    #break\r\n    \r\n\r\n\r\n\r\n\r\nprint(max(poss))\r\n\r\n    \r\n",
    "prob_desc_created_at": "1666511400",
    "tags": [
        "binary search",
        "brute force",
        "greedy"
    ],
    "hidden_unit_tests": ""
}
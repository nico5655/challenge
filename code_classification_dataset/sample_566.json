{
    "prob_desc_time_limit": "1 second",
    "prob_desc_sample_outputs": "[\"YES\\n1 4\\nYES\\n1 3\\nNO\\nYES\\n1 3\\nYES\\n1 2\"]",
    "src_uid": "776a06c14c6fa3ef8664eec0b4d50824",
    "prob_desc_notes": "NoteIn the first test case, $$$[4]$$$ is a subsequence of $$$[10, 8, 6, 4]$$$ and $$$[1, 2, 3, 4, 5]$$$. This array has length $$$1$$$, it is the smallest possible length of a subsequence of both $$$a$$$ and $$$b$$$.In the third test case, no non-empty subsequences of both $$$[3]$$$ and $$$[2]$$$ exist, so the answer is \"NO\".",
    "prob_desc_description": "You are given two arrays of integers $$$a_1,\\ldots,a_n$$$ and $$$b_1,\\ldots,b_m$$$.Your task is to find a non-empty array $$$c_1,\\ldots,c_k$$$ that is a subsequence of $$$a_1,\\ldots,a_n$$$, and also a subsequence of $$$b_1,\\ldots,b_m$$$. If there are multiple answers, find one of the smallest possible length. If there are still multiple of the smallest possible length, find any. If there are no such arrays, you should report about it.A sequence $$$a$$$ is a subsequence of a sequence $$$b$$$ if $$$a$$$ can be obtained from $$$b$$$ by deletion of several (possibly, zero) elements. For example, $$$[3,1]$$$ is a subsequence of $$$[3,2,1]$$$ and $$$[4,3,1]$$$, but not a subsequence of $$$[1,3,3,7]$$$ and $$$[3,10,4]$$$.",
    "prob_desc_output_spec": "For each test case, output \"YES\" if a solution exists, or \"NO\" otherwise. If the answer is \"YES\", on the next line output an integer $$$k$$$ ($$$1\\le k\\le 1000$$$)  — the length of the array, followed by $$$k$$$ integers $$$c_1,\\ldots,c_k$$$ ($$$1\\le c_i\\le 1000$$$)  — the elements of the array. If there are multiple solutions with the smallest possible $$$k$$$, output any.",
    "prob_desc_input_spec": "The first line contains a single integer $$$t$$$ ($$$1\\le t\\le 1000$$$)  — the number of test cases. Next $$$3t$$$ lines contain descriptions of test cases. The first line of each test case contains two integers $$$n$$$ and $$$m$$$ ($$$1\\le n,m\\le 1000$$$)  — the lengths of the two arrays. The second line of each test case contains $$$n$$$ integers $$$a_1,\\ldots,a_n$$$ ($$$1\\le a_i\\le 1000$$$)  — the elements of the first array. The third line of each test case contains $$$m$$$ integers $$$b_1,\\ldots,b_m$$$ ($$$1\\le b_i\\le 1000$$$)  — the elements of the second array. It is guaranteed that the sum of $$$n$$$ and the sum of $$$m$$$ across all test cases does not exceed $$$1000$$$ ($$$\\sum\\limits_{i=1}^t n_i, \\sum\\limits_{i=1}^t m_i\\le 1000$$$).",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 2",
    "lang_cluster": "Python",
    "difficulty": 800,
    "file_name": "train_002.jsonl",
    "code_uid": "b643883c6f3eab38bc68be89a0ea18ce",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"5\\n4 5\\n10 8 6 4\\n1 2 3 4 5\\n1 1\\n3\\n3\\n1 1\\n3\\n2\\n5 3\\n1000 2 2 2 3\\n3 1 5\\n5 5\\n1 2 3 4 5\\n1 2 3 4 5\"]",
    "exec_outcome": "PASSED",
    "source_code": "from __future__ import division, print_function\n \nimport os,sys\nfrom io import BytesIO, IOBase\n \nif sys.version_info[0] < 3:\n    from __builtin__ import xrange as range\n    from future_builtins import ascii, filter, hex, map, oct, zip\n \n \ndef ii():  return int(input())\ndef si():  return input()\ndef mi():  return map(int,input().split(\" \"))\ndef msi(): return map(str,input().split(\" \"))\ndef li():  return list(mi())\n \ndef dmain():\n    sys.setrecursionlimit(1000000)\n    threading.stack_size(1024000)\n    thread = threading.Thread(target=main)\n    thread.start()\n    \nimport math\ndef getSum(n): \n    sum = 0\n    while(n > 0): \n        sum += int(n%10) \n        n = int(n/10) \n  \n    return sum\n\ndef isPowerOfTwo (x): return (x and (not(x & (x - 1))) )\n \ndef gcd(x, y):\n    while y:\n        x, y = y, x % y\n    return x\ndef egcd(a, b):  \n    if a == 0 :   \n        return b, 0, 1\n    gcd, x1, y1 = egcd(b%a, a)\n    x = y1 - (b//a) * x1  \n    y = x1  \n     \n    return gcd, x, y \n    \ndef checkPrime(n) : # Check Prime Number or not \n    if (n <= 1) : return False\n    if (n <= 3) : return True\n    if (n % 2 == 0 or n % 3 == 0) : return False\n    i = 5\n    while(i * i <= n) : \n        if (n % i == 0 or n % (i + 2) == 0) : \n            return False\n        i = i + 6\n    return True\ndef fib(n):\n    if n==0:\n        return (0,1)\n    p=fib(n>>1)\n    c=p[0]*(2*p[1]-p[0])\n    d=p[0]*p[0]+p[1]*p[1]\n    if (n&1):\n        return c+2*d \n    else:\n        return c+d \ndef read():\n    sys.stdin = open('input.txt', 'r')  \ndef powLog(x,y):\n    res=1\n    while y>0:\n        if y&1:\n            res=res*x\n        x=x*x\n        y>>=1\n    return res\ndef main():\n    for _ in range(ii()):\n        n,m=mi()\n        a=list(set(li()))\n        b=list(set(li()))\n        flag,ans=0,-1\n        for i in range(len(a)):\n            if a[i] in b:\n                flag=1\n                ans=a[i]\n                break\n        if flag==1:\n            print(\"YES\")\n            print(1,ans)\n        else:\n            print(\"NO\")\n\n        \n# region fastio\n# template taken from https://github.com/cheran-senthil/PyRival/blob/master/templates/template.py\n \nBUFSIZE = 8192\n \n \nclass FastIO(IOBase):\n    newlines = 0\n \n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n \n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n \n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n \n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n \n \nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n \n \ndef print(*args, **kwargs):\n    \"\"\"Prints the values to a stream, or to sys.stdout by default.\"\"\"\n    sep, file = kwargs.pop(\"sep\", \" \"), kwargs.pop(\"file\", sys.stdout)\n    at_start = True\n    for x in args:\n        if not at_start:\n            file.write(sep)\n        file.write(str(x))\n        at_start = False\n    file.write(kwargs.pop(\"end\", \"\\n\"))\n    if kwargs.pop(\"flush\", False):\n        file.flush()\n \n \nif sys.version_info[0] < 3:\n    sys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)\nelse:\n    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\n \ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n \n# endregion\n \n \nif __name__ == \"__main__\":\n    #read()\n    main()\n    #dmain()\n \n# Comment Read()",
    "prob_desc_created_at": "1595342100",
    "tags": [
        "brute force"
    ],
    "hidden_unit_tests": ""
}
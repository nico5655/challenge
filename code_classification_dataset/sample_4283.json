{
    "prob_desc_time_limit": "4 seconds",
    "prob_desc_sample_outputs": "[\"9\\n2\\n154\"]",
    "src_uid": "e27ffab64e694b9d612fe100f4c503b8",
    "prob_desc_notes": "NoteHere is the graph in the first test case in the sample input:  Ela can ask the Wiring Wizard to use his spell on wire with the index of $$$7$$$, which is connecting machines $$$2$$$ and $$$3$$$. Then, since the machine $$$8$$$ is connected to machine $$$3$$$, the Wiring Wizard can disconnect wire $$$7$$$ from machine $$$3$$$ and connect it to machine $$$8$$$ in $$$3$$$ microseconds (weight of wire $$$3$$$).After that, the package can be sent from machine $$$1$$$ to machine $$$8$$$ in $$$6$$$ microseconds. Therefore, the answer is $$$3 + 6 = 9$$$ microseconds.Here is the graph in the third test case in the sample input:  ",
    "prob_desc_description": "  Ela needs to send a large package from machine $$$1$$$ to machine $$$n$$$ through a network of machines. Currently, with the network condition, she complains that the network is too slow and the package can't arrive in time. Luckily, a Wiring Wizard offered her a helping hand.The network can be represented as an undirected connected graph with $$$n$$$ nodes, each node representing a machine. $$$m$$$ wires are used to connect them. Wire $$$i$$$ is used to connect machines $$$u_i$$$ and $$$v_i$$$, and has a weight $$$w_i$$$. The aforementioned large package, if going through wire $$$i$$$, will move from machine $$$u_i$$$ to machine $$$v_i$$$ (or vice versa) in exactly $$$w_i$$$ microseconds. The Wiring Wizard can use his spell an arbitrary number of times. For each spell, he will choose the wire of index $$$i$$$, connecting machine $$$u_i$$$ and $$$v_i$$$, and rewire it following these steps:  Choose one machine that is connected by this wire. Without loss of generality, let's choose $$$v_i$$$.  Choose a machine that is currently connecting to $$$v_i$$$ (including $$$u_i$$$), call it $$$t_i$$$. Disconnect the wire indexed $$$i$$$ from $$$v_i$$$, then using it to connect $$$u_i$$$ and $$$t_i$$$. The rewiring of wire $$$i$$$ will takes $$$w_i$$$ microseconds, and the weight of the wire will not change after this operation. After a rewiring, a machine might have some wire connect it with itself. Also, the Wiring Wizard has warned Ela that rewiring might cause temporary disconnections between some machines, but Ela just ignores it anyway. Her mission is to send the large package from machine $$$1$$$ to machine $$$n$$$ as fast as possible. Note that the Wizard can use his spell on a wire zero, one, or many times. To make sure the network works seamlessly while transferring the large package, once the package starts transferring from machine $$$1$$$, the Wiring Wizard cannot use his spell to move wires around anymore.Ela wonders, with the help of the Wiring Wizard, what is the least amount of time needed to transfer the large package from machine $$$1$$$ to $$$n$$$.",
    "prob_desc_output_spec": "For each test case, output one integer denotes the least amount of time needed to transfer the large package from machine $$$1$$$ to $$$n$$$.",
    "prob_desc_input_spec": "Each test contains multiple test cases. The first line contains the number of test cases $$$t$$$ ($$$1 \\le t \\le 100$$$). The description of the test cases follows. The first line contains $$$n$$$ and $$$m$$$ ($$$2 \\le n \\le 500$$$, $$$n - 1 \\le m \\le 250 000$$$), the number of nodes and number of wires, respectively. For the next $$$m$$$ lines, $$$i$$$-th line will contains $$$u_i$$$, $$$v_i$$$ and $$$w_i$$$ ($$$1 \\le u_i, v_i \\le n$$$, $$$1 \\le w_i \\le 10^9$$$) - the indices 2 machines that are connected by the $$$i$$$-th edge and the weight of it. It is guaranteed that the sum of $$$n$$$ over all test cases does not exceed $$$500$$$ and the sum of $$$m$$$ over all test cases does not exceed $$$250 000$$$. The graph in each test case is guaranteed to be connected, no self-loops, but it can contain multiple edges.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3-64",
    "lang_cluster": "Python",
    "difficulty": 2200,
    "file_name": "train_094.jsonl",
    "code_uid": "11c86225db41e0e520fa12c70ed9396a",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"3\\n\\n8 9\\n\\n1 2 3\\n\\n6 4 5\\n\\n3 5 6\\n\\n6 1 3\\n\\n7 4 4\\n\\n3 8 4\\n\\n2 3 3\\n\\n7 8 5\\n\\n4 5 2\\n\\n4 5\\n\\n1 2 1\\n\\n2 4 1\\n\\n3 4 1\\n\\n3 1 1\\n\\n1 3 2\\n\\n8 8\\n\\n4 6 92\\n\\n7 1 65\\n\\n6 5 43\\n\\n6 7 96\\n\\n4 3 74\\n\\n4 8 54\\n\\n7 4 99\\n\\n2 5 22\"]",
    "exec_outcome": "PASSED",
    "source_code": "from collections import defaultdict, deque\r\nimport sys,os,io\r\ninput = sys.stdin.readline\r\n \r\nfrom heapq import heappop, heappush\r\n \r\n \r\ndef dijkstra(graph, start):\r\n    \"\"\" \r\n        Uses Dijkstra's algortihm to find the shortest path from node start\r\n        to all other nodes in a directed weighted graph.\r\n    \"\"\"\r\n    n = len(graph)\r\n    dist, parents = [float(\"inf\")] * n, [-1] * n\r\n    dist[start] = 0\r\n \r\n    queue = [(0, start)]\r\n    while queue:\r\n        path_len, v = heappop(queue)\r\n        if path_len == dist[v]:\r\n            for w, edge_len in graph[v]:\r\n                if edge_len + path_len < dist[w]:\r\n                    dist[w], parents[w] = edge_len + path_len, v\r\n                    heappush(queue, (edge_len + path_len, w))\r\n \r\n    return dist, parents\r\n \r\nfor _ in range (int(input())):\r\n    n,m = [int(i) for i in input().split()]\r\n    g = [[] for i in range (n)]\r\n    edge = defaultdict(lambda: float('inf'))\r\n    for __ in range (m):\r\n        u,v,w = [int(i) for i in input().split()]\r\n        u,v = u-1,v-1\r\n        g[u].append([v,1])\r\n        g[v].append([u,1])\r\n        edge[(u,v)] = min(edge[(u,v)], w)\r\n        edge[(v,u)] = min(edge[(u,v)], w)\r\n \r\n    dist_1, __ = dijkstra(g, 0)\r\n    dist_n, __ = dijkstra(g, n-1)\r\n    g.append([])\r\n    for i in range (n):\r\n        g[-1].append([i, dist_1[i]+dist_n[i]])\r\n    t_dist, __ = dijkstra(g, n)\r\n    \r\n    ans = float('inf')\r\n    for u,v in edge:\r\n        w = edge[(u,v)]\r\n        d1 = min(dist_1[u]+dist_n[v], dist_1[v]+dist_n[u]) + 1\r\n        d2 = min(t_dist[u], t_dist[v]) + 2\r\n        ans = min(ans, min(d1,d2)*w)\r\n    print(ans)\r\n",
    "prob_desc_created_at": "1665153300",
    "tags": [
        "brute force",
        "dp",
        "graphs",
        "greedy",
        "implementation",
        "shortest paths"
    ],
    "hidden_unit_tests": ""
}
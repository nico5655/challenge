{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"Yes\\n2 1\\n1 3 \\n2 \\nYes\\n1 2\\n2 \\n1 3 \\nNo\\nNo\"]",
    "src_uid": "f91197e474bdc3f2b881d556a330e36b",
    "prob_desc_notes": "NoteIn the first test case, we can select the first and the third resident as a jury. Both of them are not acquaintances with a second cat, so we can select it as a contestant.In the second test case, we can select the second resident as a jury. He is not an acquaintances with a first and a third cat, so they can be selected as contestants.In the third test case, the only resident is acquaintances with the only cat, so they can't be in the contest together. So it's not possible to make a contest with at least one jury and at least one cat.In the fourth test case, each resident is acquaintances with every cat, so it's again not possible to make a contest with at least one jury and at least one cat.",
    "prob_desc_description": "In the Catowice city next weekend the cat contest will be held. However, the jury members and the contestants haven't been selected yet. There are $$$n$$$ residents and $$$n$$$ cats in the Catowice, and each resident has exactly one cat living in his house. The residents and cats are numbered with integers from $$$1$$$ to $$$n$$$, where the $$$i$$$-th cat is living in the house of $$$i$$$-th resident.Each Catowice resident is in friendship with several cats, including the one living in his house. In order to conduct a contest, at least one jury member is needed and at least one cat contestant is needed. Of course, every jury member should know none of the contestants. For the contest to be successful, it's also needed that the number of jury members plus the number of contestants is equal to $$$n$$$.Please help Catowice residents to select the jury and the contestants for the upcoming competition, or determine that it's impossible to do.",
    "prob_desc_output_spec": "For every test case print:   \"No\", if it's impossible to select the jury and contestants.  Otherwise print \"Yes\".In the second line print two integers $$$j$$$ and $$$p$$$ ($$$1 \\le j$$$, $$$1 \\le p$$$, $$$j + p = n$$$) — the number of jury members and the number of contest participants.In the third line print $$$j$$$ distinct integers from $$$1$$$ to $$$n$$$, the indices of the residents forming a jury.In the fourth line print $$$p$$$ distinct integers from $$$1$$$ to $$$n$$$, the indices of the cats, which will participate in the contest.In case there are several correct answers, print any of them. ",
    "prob_desc_input_spec": "The first line contains an integer $$$t$$$ ($$$1 \\le t \\le 100\\,000$$$), the number of test cases. Then description of $$$t$$$ test cases follow, where each description is as follows: The first line contains integers $$$n$$$ and $$$m$$$ ($$$1 \\le n \\le m \\le 10^6$$$), the number of Catowice residents and the number of friendship pairs between residents and cats. Each of the next $$$m$$$ lines contains integers $$$a_i$$$ and $$$b_i$$$ ($$$1 \\le a_i, b_i \\le n$$$), denoting that $$$a_i$$$-th resident is acquaintances with $$$b_i$$$-th cat. It's guaranteed that each pair of some resident and some cat is listed at most once. It's guaranteed, that for every $$$i$$$ there exists a pair between $$$i$$$-th resident and $$$i$$$-th cat. Different test cases are separated with an empty line. It's guaranteed, that the sum of $$$n$$$ over all test cases is at most $$$10^6$$$ and that the sum of $$$m$$$ over all test cases is at most $$$10^6$$$.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 2",
    "lang_cluster": "Python",
    "difficulty": 2400,
    "file_name": "train_054.jsonl",
    "code_uid": "2d74438d128084b4838c6352e62d534f",
    "prob_desc_memory_limit": "512 megabytes",
    "prob_desc_sample_inputs": "[\"4\\n3 4\\n1 1\\n2 2\\n3 3\\n1 3\\n\\n3 7\\n1 1\\n1 2\\n1 3\\n2 2\\n3 1\\n3 2\\n3 3\\n\\n1 1\\n1 1\\n\\n2 4\\n1 1\\n1 2\\n2 1\\n2 2\"]",
    "exec_outcome": "PASSED",
    "source_code": "import os\nimport sys\nfrom atexit import register\nfrom io import BytesIO\nsys.stdin = BytesIO(os.read(0, os.fstat(0).st_size))\nsys.stdout = BytesIO()\nregister(lambda: os.write(1, sys.stdout.getvalue()))\ninput = lambda: sys.stdin.readline().rstrip('\\r\\n')\n \ndef add(dic,k,v):\n    if not dic.has_key(k):\n        dic[k] = v\n    else:\n        dic[k] += v\n \ndef main():\n  t = int(input())\n  for _ in range(t):\n    n,m = map(int,input().split(\" \"))\n    pairs = []\n    for i in range(m):\n        a,b = map(int,input().split(\" \"))\n        if a == b:\n            continue\n        pairs.append((a,b))\n    space = input()\n    if n == 1:\n        print \"No\"\n        continue\n \n    edges = {}\n \n    low = [-1]*(n+1)\n    dfn = [-1]*(n+1)\n    visited = [0]*(n+1)\n    for i in range(1,n+1):\n        add(edges,i,[])\n    for a,b in pairs:\n        add(edges,a,[b])\n \n    cnt     = 1\n    stack   = []\n    trace   = []\n    res     = []\n    tmp     = []\n    for i in range(1,n+1):\n        if  visited[i]:\n            continue\n        visited[i] = 1\n        stack.append(i)\n        while stack:\n            #print \"stack\",stack,\"trace\",trace\n            node = stack[-1]\n            if visited[node] == 2:\n                stack.pop()\n                continue\n            visited[node] = 1\n            flag = True\n            if dfn[node] == -1:\n                trace.append(node)\n                dfn[node] = cnt\n                low[node] = cnt\n                cnt += 1\n                flag = False\n            for nb in edges[node]:\n                if flag and dfn[nb]>dfn[node]:\n                    low[node] = min(low[node],low[nb])\n                elif not visited[nb]:\n                   # visited[nb] = 1\n                    stack.append(nb)\n                elif visited[nb] == 1:\n                    low[node] = min(low[node],dfn[nb])\n                #print node,nb,low[node]\n            #if node == 4:\n                #print low[node],visited\n            #if flag:\n            #    print \"node\",node, low[node],dfn[node]\n            if flag and low[node] == dfn[node]:\n                tmp = []\n                while trace[-1]!=node:\n                    nt = trace.pop()\n                    tmp.append(nt)\n                    visited[nt] = 2\n                visited[node] = 2\n                tmp.append(trace.pop())\n                res.append(tmp)\n                stack.pop()\n            elif flag:\n                stack.pop()\n    #print res\n    if  len(res) == 1:\n        print \"No\"\n    else:\n        print \"Yes\"\n        print len(res[0]),n-len(res[0])\n        print \" \".join(map(str,res[0]))\n        ss = [0]*(n+1)\n        for i in res[0]:\n            ss[i] = 1\n        other = []\n        for i in range(1,n+1):\n            if ss[i] == 0:\n                other.append(i)\n        print \" \".join(map(str,other))\n\nmain()\n\n",
    "prob_desc_created_at": "1571562300",
    "tags": [
        "graph matchings",
        "dfs and similar",
        "graphs",
        "2-sat"
    ],
    "hidden_unit_tests": ""
}
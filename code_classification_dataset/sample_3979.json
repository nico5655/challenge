{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"YES\\nNO\\nYES\\nNO\"]",
    "src_uid": "1bacc1a9f8b2d586ee8d59e3c46cfcf3",
    "prob_desc_notes": "NoteIn the first test case, $$$\\underline{00000} \\rightarrow \\underline{000}11 \\rightarrow 00111$$$ is one of the possible sequences of string changes.In the second test case, it can be shown that it is impossible to have the string $$$f$$$ at the end.",
    "prob_desc_description": "Nezzar has a binary string $$$s$$$ of length $$$n$$$ that he wants to share with his best friend, Nanako. Nanako will spend $$$q$$$ days inspecting the binary string. At the same time, Nezzar wants to change the string $$$s$$$ into string $$$f$$$ during these $$$q$$$ days, because it looks better.It is known that Nanako loves consistency so much. On the $$$i$$$-th day, Nanako will inspect a segment of string $$$s$$$ from position $$$l_i$$$ to position $$$r_i$$$ inclusive. If the segment contains both characters '0' and '1', Nanako becomes unhappy and throws away the string.After this inspection, at the $$$i$$$-th night, Nezzar can secretly change strictly less than half of the characters in the segment from $$$l_i$$$ to $$$r_i$$$ inclusive, otherwise the change will be too obvious.Now Nezzar wonders, if it is possible to avoid Nanako being unhappy and at the same time have the string become equal to the string $$$f$$$ at the end of these $$$q$$$ days and nights.",
    "prob_desc_output_spec": "For each test case, print \"YES\" on the single line if it is possible to avoid Nanako being unhappy and have the string $$$f$$$ at the end of $$$q$$$ days and nights. Otherwise, print \"NO\". You can print each letter in any case (upper or lower).",
    "prob_desc_input_spec": "The first line contains a single integer $$$t$$$ ($$$1 \\le t \\le 2 \\cdot 10^5$$$) — the number of test cases. The first line of each test case contains two integers $$$n,q$$$ ($$$1 \\le n \\le 2 \\cdot 10^5$$$, $$$0 \\le q \\le 2 \\cdot 10^5$$$). The second line of each test case contains a binary string $$$s$$$ of length $$$n$$$. The third line of each test case contains a binary string $$$f$$$ of length $$$n$$$. Then $$$q$$$ lines follow, $$$i$$$-th of them contains two integers $$$l_i,r_i$$$ ($$$1 \\le l_i \\le r_i \\le n$$$)  — bounds of the segment, that Nanako will inspect on the $$$i$$$-th day. It is guaranteed that the sum of $$$n$$$ for all test cases doesn't exceed $$$2 \\cdot 10^5$$$, and the sum of $$$q$$$ for all test cases doesn't exceed $$$2 \\cdot 10^5$$$.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3",
    "lang_cluster": "Python",
    "difficulty": 1900,
    "file_name": "train_088.jsonl",
    "code_uid": "5576be42a44f030cadf4f1b29cb06785",
    "prob_desc_memory_limit": "512 megabytes",
    "prob_desc_sample_inputs": "[\"4\\n5 2\\n00000\\n00111\\n1 5\\n1 3\\n2 1\\n00\\n01\\n1 2\\n10 6\\n1111111111\\n0110001110\\n1 10\\n5 9\\n7 10\\n1 7\\n3 5\\n6 10\\n5 2\\n10000\\n11000\\n2 5\\n1 3\"]",
    "exec_outcome": "PASSED",
    "source_code": "\r\n#from bisect import *\r\n#from collections import *\r\n#from math import gcd,ceil,sqrt,floor,inf\r\n#from heapq import *\r\n#from itertools import *\r\n#from operator import add,mul,sub,xor,truediv,floordiv\r\n#from functools import *\r\n\r\n#------------------------------------------------------------------------\r\nimport os\r\nimport sys\r\n\r\nfrom io import BytesIO, IOBase\r\n# region fastio\r\n \r\nBUFSIZE = 8192\r\n \r\nclass FastIO(IOBase):\r\n    newlines = 0\r\n \r\n    def __init__(self, file):\r\n        self._fd = file.fileno()\r\n        self.buffer = BytesIO()\r\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\r\n        self.write = self.buffer.write if self.writable else None\r\n \r\n    def read(self):\r\n        while True:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            if not b:\r\n                break\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines = 0\r\n        return self.buffer.read()\r\n \r\n    def readline(self):\r\n        while self.newlines == 0:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            self.newlines = b.count(b\"\\n\") + (not b)\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines -= 1\r\n        return self.buffer.readline()\r\n \r\n    def flush(self):\r\n        if self.writable:\r\n            os.write(self._fd, self.buffer.getvalue())\r\n            self.buffer.truncate(0), self.buffer.seek(0)\r\n \r\n \r\nclass IOWrapper(IOBase):\r\n    def __init__(self, file):\r\n        self.buffer = FastIO(file)\r\n        self.flush = self.buffer.flush\r\n        self.writable = self.buffer.writable\r\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\r\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\r\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\r\n \r\n \r\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\r\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\r\n \r\n\r\n#------------------------------------------------------------------------\r\ndef RL(): return map(int, sys.stdin.readline().split())\r\ndef RLL(): return list(map(int, sys.stdin.readline().split()))\r\ndef N(): return int(input())\r\n#------------------------------------------------------------------------\r\n\r\n\r\nclass SMT:\r\n    def __init__(self,arr):\r\n        self.n=len(arr)-1\r\n        l=(n-1).bit_length()\r\n        self.arr=[0]*(1<<(l+1))\r\n        self.lazy=[-1]*(1<<(l+1))\r\n        def Build(l,r,rt):\r\n            if l==r:\r\n                self.arr[rt]=arr[l]\r\n                return\r\n            m=(l+r)>>1\r\n            Build(l,m,rt<<1)\r\n            Build(m+1,r,rt<<1|1)\r\n            self.pushup(rt)\r\n        Build(1,self.n,1)\r\n \r\n    def pushup(self,rt):\r\n        self.arr[rt]=self.arr[rt<<1]+self.arr[rt<<1|1]\r\n \r\n    def pushdown(self,rt,ln,rn):#lr,rn表区间数字数\r\n        if self.lazy[rt]!=-1:\r\n            self.lazy[rt<<1]=self.lazy[rt]\r\n            self.lazy[rt<<1|1]=self.lazy[rt]\r\n            self.arr[rt<<1]=self.lazy[rt]*ln\r\n            self.arr[rt<<1|1]=self.lazy[rt]*rn\r\n            self.lazy[rt]=-1\r\n            \r\n    def update(self,L,R,c,l=1,r=None,rt=1):#L,R表示操作区间\r\n        if r==None: r=self.n\r\n        if L<=l and r<=R:\r\n            self.arr[rt]=c*(r-l+1)\r\n            self.lazy[rt]=c\r\n            return\r\n        m=(l+r)>>1\r\n        self.pushdown(rt,m-l+1,r-m)\r\n        if L<=m: self.update(L,R,c,l,m,rt<<1)\r\n        if R>m: self.update(L,R,c,m+1,r,rt<<1|1)\r\n        self.pushup(rt)\r\n \r\n    def query(self,L,R,l=1,r=None,rt=1):\r\n        if r==None: r=self.n\r\n        if L<=l and R>=r:\r\n            return self.arr[rt]\r\n        m=(l+r)>>1\r\n        self.pushdown(rt,m-l+1,r-m)\r\n        ans=0\r\n        if L<=m: ans+=self.query(L,R,l,m,rt<<1)\r\n        if R>m: ans+=self.query(L,R,m+1,r,rt<<1|1)\r\n        return ans\r\n    \r\n    def dfs(self,t,l=1,r=None,rt=1):\r\n        if r==None: r=self.n\r\n        if l==r:\r\n            return t[l-1]==self.arr[rt]\r\n        m=(l+r)>>1\r\n        self.pushdown(rt,m-l+1,r-m)\r\n        return self.dfs(t,l,m,rt<<1) and self.dfs(t,m+1,r,rt<<1|1)\r\n\r\n\r\nt=N()\r\nfor i in range(t):\r\n    n,q=RL()\r\n    s=input()\r\n    f=input()\r\n    s=[int(ch) for ch in s]\r\n    f=[0]+[int(ch) for ch in f]\r\n    smt=SMT(f)\r\n    ans=True\r\n    l=[0]*q\r\n    r=[0]*q\r\n    for i in range(q):\r\n        l[i],r[i]=RL()\r\n    for i in range(q-1,-1,-1):\r\n        leng=r[i]-l[i]+1\r\n        cur=smt.query(l[i],r[i])\r\n        if cur*2==leng:\r\n            ans=False\r\n            break\r\n        elif cur*2<leng:\r\n            smt.update(l[i],r[i],0)\r\n        else:\r\n            smt.update(l[i],r[i],1)\r\n    ans=ans and smt.dfs(s)\r\n    ans=\"YES\" if ans else \"NO\"\r\n    print(ans)\r\n            \r\n",
    "prob_desc_created_at": "1611844500",
    "tags": [
        "data structures",
        "greedy"
    ],
    "hidden_unit_tests": ""
}
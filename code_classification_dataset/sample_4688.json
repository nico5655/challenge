{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"? 1\\n\\n? 1\\n\\n? 3\\n\\n? 3\\n\\n! 1 1 2 2 3\"]",
    "src_uid": "cb05d81d82d16ac3fdf8ec33e69d5ae8",
    "prob_desc_notes": "NoteIn the example, there is only one test case. In the test case, there are $$$n = 5$$$ vertices with vertices $$$1, 2, 3, 4$$$ of degree $$$2$$$ and vertex $$$5$$$ of degree $$$0$$$. It is obvious that vertex $$$5$$$ is isolated, i.e., it does not connect to any other vertices. A possible interaction is shown in the sample input and output, where $$$4$$$ \"?\" queries are made on vertex $$$1$$$ twice and vertex $$$3$$$ twice. According to the responses to these queries, we know that each of vertex $$$1$$$ and vertex $$$3$$$ connects to two vertices $$$2$$$ and $$$4$$$. A possible solution is shown in the sample output, where vertex $$$1$$$ and vertex $$$2$$$ are colored by $$$1$$$, vertex $$$3$$$ and vertex $$$4$$$ are colored by $$$2$$$, and vertex $$$5$$$ is colored by $$$3$$$. It can be seen that this solution satisfies the required conditions as follows.   For color $$$c = 1$$$, vertex $$$1$$$ and vertex $$$2$$$ are connected. Moreover, $$$n_1 = 2$$$ and $$$s_1 = d_1 + d_2 = 2 + 2 = 4 \\leq n_1^2 = 2^2 = 4$$$;  For color $$$c = 2$$$, vertex $$$3$$$ and vertex $$$4$$$ are connected. Moreover, $$$n_2 = 2$$$ and $$$s_2 = d_3 + d_4 = 2 + 2 = 4 \\leq n_2^2 = 2^2 = 4$$$;  For color $$$c = 3$$$, there is only one vertex (vertex $$$5$$$) colored by $$$3$$$. Moreover, $$$n_3 = 1$$$ and $$$s_3 = d_5 = 0 \\leq n_3^2 = 1^2 = 1$$$. ",
    "prob_desc_description": "This is an interactive problem.Given a simple undirected graph with $$$n$$$ vertices numbered from $$$1$$$ to $$$n$$$, your task is to color all the vertices such that for every color $$$c$$$, the following conditions hold:   The set of vertices with color $$$c$$$ is connected;  $$$s_c \\leq n_c^2$$$, where $$$n_c$$$ is the number of vertices with color $$$c$$$, and $$$s_c$$$ is the sum of degrees of vertices with color $$$c$$$.  It can be shown that there always exists a way to color all the vertices such that the above conditions hold. Initially, you are only given the number $$$n$$$ of vertices and the degree of each vertex. In each query, you can choose a vertex $$$u$$$. As a response, you will be given the $$$k$$$-th edge incident to $$$u$$$, if this is the $$$k$$$-th query on vertex $$$u$$$. You are allowed to make at most $$$n$$$ queries.An undirected graph is simple if it does not contain multiple edges or self-loops.The degree of a vertex is the number of edges incident to it. A set $$$S$$$ of vertices is connected if for every two different vertices $$$u, v \\in S$$$, there is a path, which only passes through vertices in $$$S$$$, that connects $$$u$$$ and $$$v$$$. That is, there is a sequence of edges $$$(u_1, v_1), (u_2, v_2), \\dots, (u_k, v_k)$$$ with $$$k \\geq 1$$$ such that   $$$u_1 = u$$$, $$$v_k = v$$$, and $$$v_i = u_{i+1}$$$ for every $$$1 \\leq i &lt; k$$$; and  $$$u_k \\in S$$$ and $$$v_k \\in S$$$ for every $$$1 \\leq i \\leq k$$$.  Especially, a set containing only one vertex is connected. ",
    "prob_desc_output_spec": null,
    "prob_desc_input_spec": null,
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3-64",
    "lang_cluster": "Python",
    "difficulty": 2400,
    "file_name": "train_103.jsonl",
    "code_uid": "8fd5b46a429162dd5685afd63a984f45",
    "prob_desc_memory_limit": "512 megabytes",
    "prob_desc_sample_inputs": "[\"1\\n5\\n2 2 2 2 0\\n\\n2\\n\\n4\\n\\n2\\n\\n4\"]",
    "exec_outcome": "PASSED",
    "source_code": "#!/usr/bin/env python3\nimport sys, getpass\nimport math, random\nimport functools, itertools, collections, heapq, bisect\nfrom collections import Counter, defaultdict, deque\ninput = sys.stdin.readline  # to read input quickly\n\n# available on Google, AtCoder Python3, not available on Codeforces\n# import numpy as np\n# import scipy\n\nm9 = 10**9 + 7  # 998244353\n# d4 = [(1,0),(0,1),(-1,0),(0,-1)]\n# d8 = [(1,0),(1,1),(0,1),(-1,1),(-1,0),(-1,-1),(0,-1),(1,-1)]\n# d6 = [(2,0),(1,1),(-1,1),(-2,0),(-1,-1),(1,-1)]  # hexagonal layout\nMAXINT = sys.maxsize\ne18 = 10**18 + 10\n\n# if testing locally, print to terminal with a different color\nOFFLINE_TEST = getpass.getuser() == \"htong\"\n# OFFLINE_TEST = False  # codechef does not allow getpass\ndef log(*args):\n    if OFFLINE_TEST:\n        print('\\033[36m', *args, '\\033[0m', file=sys.stderr)\n\n# ---------------------------- template ends here ----------------------------\n\ndef query(pos):\n    print(\"? {}\".format(pos+1), flush=True)\n    response = int(input()) - 1\n    assert response >= 0\n    return response\n\ndef alert(arr):\n    print(\"! {}\".format(\" \".join(str(x) for x in arr)), flush=True)\n\n# -----------------------------------------------------------------------------\n\nclass DisjointSet:\n    # github.com/not522/ac-library-python/blob/master/atcoder/dsu.py\n\n    def __init__(self, n: int = 0) -> None:\n        if n > 0:  # constant size DSU\n            self.parent_or_size = [-1]*n\n        else:\n            self.parent_or_size = defaultdict(lambda: -1)\n\n    def union(self, a: int, b: int) -> int:\n        x = self.find(a)\n        y = self.find(b)\n\n        if x == y:\n            return x\n\n        if -self.parent_or_size[x] < -self.parent_or_size[y]:\n            x, y = y, x\n\n        self.parent_or_size[x] += self.parent_or_size[y]\n        self.parent_or_size[y] = x\n\n        return x\n\n    def find(self, a: int) -> int:\n        parent = self.parent_or_size[a]\n        while parent >= 0:\n            if self.parent_or_size[parent] < 0:\n                return parent\n            self.parent_or_size[a], a, parent = (\n                self.parent_or_size[parent],\n                self.parent_or_size[parent],\n                self.parent_or_size[self.parent_or_size[parent]]\n            )\n        return a\n\n    def size(self, a: int) -> int:\n        return -self.parent_or_size[self.find(a)]\n\nimport random\n# get highest degree\n# get adjacent nodes\n# if nodes is in previous group, join\n\nfor case_num in range(int(input())):\n\n    # read line as an integer\n    n = int(input())\n\n    # read line as a string\n    # srr = input().strip()\n\n    # read one line and parse each word as a string\n    # lst = input().split()\n\n    ds = DisjointSet(n)\n    for i in range(n):\n        ds.find(i)\n    # read one line and parse each word as an integer\n    # a,b,c = list(map(int,input().split()))\n    degrees = list(map(int,input().split()))\n\n    taken = set()\n    arr = [(x,i) for i,x in enumerate(degrees)]\n    # random.shuffle(arr)\n    arr.sort()\n    # arr.reverse()\n\n    # log(arr)\n    query_cnt = 0\n\n    while arr:\n        x,cur = arr.pop()\n        if cur in taken:\n            continue\n        taken.add(cur)\n        for _ in range(x):\n            nex = query(cur)\n            query_cnt += 1\n            ds.union(cur, nex)\n            if nex in taken:\n                break\n            taken.add(nex)\n\n    assert query_cnt <= n\n\n    for i in range(n):\n        ldr = ds.find(i)\n\n    cntr = 1\n    val_to_cntr = {}\n    for i in range(n):\n        ldr = ds.find(i)\n        if ldr not in val_to_cntr:\n            val_to_cntr[ldr] = cntr\n            cntr += 1\n\n    res = [-1 for _ in range(n)]\n    for i in range(n):\n        res[i] = val_to_cntr[ds.find(i)]\n\n    assert max(res) <= n\n    assert min(res) >= 1\n\n    cnt_nodes = defaultdict(int)\n    cnt_edges = defaultdict(int)\n    for i,x in enumerate(res):\n        cnt_nodes[x] += 1\n        cnt_edges[x] += degrees[i]\n    \n    for i in cnt_nodes.keys():\n        assert cnt_edges[i] <= cnt_nodes[i]**2\n\n    alert(res)\n\n    # -----------------------------------------------------------------------------\n\n    # your code here\nsys.exit()\n",
    "prob_desc_created_at": "1664548500",
    "tags": [
        "constructive algorithms",
        "dsu",
        "graphs",
        "greedy",
        "interactive",
        "shortest paths",
        "trees"
    ],
    "hidden_unit_tests": ""
}
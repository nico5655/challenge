{
    "prob_desc_time_limit": "3 seconds",
    "prob_desc_sample_outputs": "[\"2 3 5 6 9 1 7 8\", \"1 2 3 4 5 6 7 9\", \"5 6 1 2 3\"]",
    "src_uid": "816144eab0f54e7d51375fd5fcd74717",
    "prob_desc_notes": null,
    "prob_desc_description": "Recently personal training sessions have finished in the Berland State University Olympiad Programmer Training Centre. By the results of these training sessions teams are composed for the oncoming team contest season. Each team consists of three people. All the students of the Centre possess numbers from 1 to 3n, and all the teams possess numbers from 1 to n. The splitting of students into teams is performed in the following manner: while there are people who are not part of a team, a person with the best total score is chosen among them (the captain of a new team), this person chooses for himself two teammates from those who is left according to his list of priorities. The list of every person's priorities is represented as a permutation from the rest of 3n - 1 students who attend the centre, besides himself.You are given the results of personal training sessions which are a permutation of numbers from 1 to 3n, where the i-th number is the number of student who has won the i-th place. No two students share a place. You are also given the arrangement of the already formed teams in the order in which they has been created. Your task is to determine the list of priorities for the student number k. If there are several priority lists, choose the lexicographically minimal one.",
    "prob_desc_output_spec": "Print 3n - 1 numbers — the lexicographically smallest list of priorities for the student number k.  The lexicographical comparison is performed by the standard &lt; operator in modern programming languages. The list a is lexicographically less that the list b if exists such an i (1 ≤ i ≤ 3n), that ai &lt; bi, and for any j (1 ≤ j &lt; i) aj = bj. Note, that the list 1 9 10 is lexicographically less than the list 1 10 9. That is, the comparison of lists is different from the comparison of lines.",
    "prob_desc_input_spec": "The first line contains an integer n (1 ≤ n ≤ 105) which is the number of resulting teams. The second line contains 3n space-separated integers from 1 to 3n which are the results of personal training sessions. It is guaranteed that every student appears in the results exactly once. Then follow n lines each containing three integers from 1 to 3n — each line describes the members of a given team. The members of one team can be listed in any order, but the teams themselves are listed in the order in which they were created. It is guaranteed that the arrangement is correct, that is that every student is a member of exactly one team and those teams could really be created from the given results using the method described above. The last line contains number k (1 ≤ k ≤ 3n) which is the number of a student for who the list of priorities should be found.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "Python 3",
    "lang_cluster": "Python",
    "difficulty": 2000,
    "file_name": "train_028.jsonl",
    "code_uid": "cb978f2dabbe9d8b003a24eaa8f4b1e5",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"3\\n5 4 1 2 6 3 7 8 9\\n5 6 2\\n9 3 4\\n1 7 8\\n4\", \"3\\n5 4 1 2 6 3 7 8 9\\n5 6 2\\n9 3 4\\n1 7 8\\n8\", \"2\\n4 1 3 2 5 6\\n4 6 5\\n1 2 3\\n4\"]",
    "exec_outcome": "PASSED",
    "source_code": "import sys\n\nI = lambda: int(input())\nRL = readline = lambda: sys.stdin.readline().strip('\\n')\nRM = readmap  = lambda x = int: map(x,readline().split(' '))\n\ndef f(l,x):\n    if x==l[0]: return l[1],l[2]\n    if x==l[1]: return l[0],l[2]\n    if x==l[2]: return l[0],l[1]\n    return -1\n\ndef delrank(x):\n    global pre,nxt\n    prex,nxtx = pre[x],nxt[x]\n    nxt[prex] = nxtx\n    pre[nxtx] = prex\n\nn = I()\nN = 3*n\nrank = [*RM()]+[N+1]\ntris = [tuple(RM()) for i in range(n)]\nk    = I()\npre,nxt = list(range(N+2)), list(range(N+2))\ntemp0 = 0\nfor i in range(N+1):\n    temp1 = rank[i]\n    pre[temp1],nxt[temp0] = temp0,temp1\n    temp0 = temp1\n\nfor ind,tri in enumerate(tris):\n    leader = nxt[0]\n    x,y = f(tri,leader)\n    if k in tri:\n        if leader != k:\n            l = [i for i in range(1,N+1) if i!=k]\n        else:\n            #condition here is element in l3 should be after max(x,y)\n            #so sort l1+l2 first cut the portion after max(x,y) and add\n            #it to l3 and sort the new l3\n            l1 = [i for tri in tris[:ind] for i in tri]\n            l2 = [x,y]\n            l3 = [i for tri in tris[ind+1:] for i in tri]\n            l0 = sorted(l1 + l2)\n            ind = l0.index(max(x,y))\n            l = l0[:ind+1] + sorted(l0[ind+1:]+l3)\n            #print(leader,l1,l2,l3)\n        print(' '.join([str(i) for i in l]))\n        sys.exit(0)\n    for i in tri: delrank(i)\n\n'''\n7\n4 19 14 8 21 16 2 18 1 15 3 17 13 5 6 10 9 7 12 11 20\n4 19 10\n14 8 3\n21 17 9\n16 6 12\n2 13 20\n18 1 7\n15 5 11\n21\n'''\nquit()\n#E  Shortest Path\ndef rec(u,v):\n    '''to recursivley visit the edge previous to this edge'''\n    if v:  rec(pre[u][v],u);print(v,end=' ')\n\nfrom collections import deque\nn,m,k = RM()\nadj  = [[] for i in range(n+1)]\ndist = [[int(1e9)]*(n+1) for i in range(n+1)]\npre  = [[0]*(n+1)        for i in range(n+1)]\nbad  = set()\nfor _ in range(m):\n    x,y = RM()\n    adj[x].append(y)\n    adj[y].append(x)\n\nfor _ in range(k):  bad.add(tuple(RM()))\n\ndist[0][1] = 0\nq = deque([(0,1)])\nwhile q:\n    u,v = q.popleft()\n    d   = dist[u][v] + 1\n    for w in adj[v]:\n        if d<dist[v][w] and  not (u,v,w) in bad:\n            dist[v][w] = d\n            pre[v][w] = u\n            q.append((v,w))\n            if w == n:\n                print(d)\n                rec(v,w)\n                print()\n                sys.exit(0)\nprint(-1)\n",
    "prob_desc_created_at": "1297440000",
    "tags": [
        "constructive algorithms",
        "implementation",
        "greedy"
    ],
    "hidden_unit_tests": ""
}
{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"3\\n1\\n2\", \"5\\n2\\n5\\n2\\n6\"]",
    "src_uid": "7a79c60749ee13c69284ba8fe34b63b3",
    "prob_desc_notes": null,
    "prob_desc_description": "You are given a string $$$s$$$ consisting of lowercase Latin letters and $$$q$$$ queries for this string.Recall that the substring $$$s[l; r]$$$ of the string $$$s$$$ is the string $$$s_l s_{l + 1} \\dots s_r$$$. For example, the substrings of \"codeforces\" are \"code\", \"force\", \"f\", \"for\", but not \"coder\" and \"top\".There are two types of queries:   $$$1~ pos~ c$$$ ($$$1 \\le pos \\le |s|$$$, $$$c$$$ is lowercase Latin letter): replace $$$s_{pos}$$$ with $$$c$$$ (set $$$s_{pos} := c$$$);  $$$2~ l~ r$$$ ($$$1 \\le l \\le r \\le |s|$$$): calculate the number of distinct characters in the substring $$$s[l; r]$$$. ",
    "prob_desc_output_spec": "For each query of the second type print the answer for it — the number of distinct characters in the required substring in this query.",
    "prob_desc_input_spec": "The first line of the input contains one string $$$s$$$ consisting of no more than $$$10^5$$$ lowercase Latin letters. The second line of the input contains one integer $$$q$$$ ($$$1 \\le q \\le 10^5$$$) — the number of queries. The next $$$q$$$ lines contain queries, one per line. Each query is given in the format described in the problem statement. It is guaranteed that there is at least one query of the second type.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 2",
    "lang_cluster": "Python",
    "difficulty": 1600,
    "file_name": "train_053.jsonl",
    "code_uid": "737312580cade9d3004d249eba1acaf1",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"abacaba\\n5\\n2 1 4\\n1 4 b\\n1 5 b\\n2 4 6\\n2 1 7\", \"dfcbbcfeeedbaea\\n15\\n1 6 e\\n1 4 b\\n2 6 14\\n1 7 b\\n1 12 c\\n2 6 8\\n2 1 6\\n1 7 c\\n1 2 f\\n1 10 a\\n2 7 9\\n1 10 a\\n1 14 b\\n1 1 f\\n2 1 11\"]",
    "exec_outcome": "PASSED",
    "source_code": "#!/usr/bin/env pypy\nfrom __future__ import division, print_function\nfrom collections import defaultdict, Counter, deque\nfrom future_builtins import ascii, filter, hex, map, oct, zip\nfrom itertools import imap as map, izip as zip\nfrom __builtin__ import xrange as range\nfrom math import ceil\nfrom _continuation import continulet\nfrom cStringIO import StringIO\nfrom io import IOBase\nimport __pypy__\nfrom bisect import bisect, insort, bisect_left, bisect_right\nimport sys\nimport os\nimport re\ninf = float('inf')\nmod = int(1e9) + 7\nmod_ = 998244353\nN = int(1e5 + 5)\n\n'''\nCheck for special cases (n=1)\nOne wrong submission = 10 mins penalty!\ndo smth instead of nothing and stay organized\n'''\n\ns, n = [None]*2\nt = [[0]*26 for i in range(4*N)]\n\ndef combine(v):\n\tglobal t\n\tfor i in range(26):\n\t\tt[v][i] = t[2*v][i] + t[2*v+1][i]\n\ndef build(v, tl, tr):\n\tif tl == tr:\n\t\tt[v][ord(s[tl])-ord('a')] += 1\n\telse:\n\t\ttm = (tl + tr)//2\n\t\tbuild(2*v, tl, tm)\n\t\tbuild(2*v+1, tm+1, tr)\n\t\tcombine(v)\n\ndef update(v, tl, tr, pos, new_val):\n\tif tl == tr:\n\t\tt[v] = [0]*26\n\t\tt[v][ord(new_val)-ord('a')] += 1\n\telse:\n\t\ttm = (tl + tr)//2\n\t\tif pos <= tm:\n\t\t\tupdate(2*v, tl, tm, pos, new_val)\n\t\telse:\n\t\t\tupdate(2*v+1, tm+1, tr, pos, new_val)\n\t\tcombine(v)\n\ndef query(v, tl, tr, l, r):\n\tif l > tr or r < tl:\n\t\treturn [0]*26\n\tif l <= tl and tr <= r:\n\t\treturn t[v]\n\ttm = (tl + tr)//2\n\tans1 = query(2*v, tl, tm, l, r)\n\tans2 = query(2*v+1, tm+1, tr, l, r)\n\tret = [0]*26\n\tfor i in range(26):\n\t\tret[i] = ans1[i] + ans2[i]\n\treturn ret\n\ndef main():\n\tglobal s, n\n\ts = input()\n\tn = len(s)\n\tbuild(1, 0, n-1)\n\tfor _ in range(int(input())):\n\t\tarr = input().split()\n\t\tif arr[0] == '1':\n\t\t\tpos, c = arr[1:]\n\t\t\tpos = int(pos)\n\t\t\tupdate(1, 0, n-1, pos-1, c)\n\t\telse:\n\t\t\tl, r = map(int, arr[1:])\n\t\t\ttemp = query(1, 0, n-1, l-1, r-1)\n\t\t\tans = 0\n\t\t\tfor ele in temp:\n\t\t\t\tans += int(ele > 0)\n\t\t\tprint(ans)\n \nBUFSIZE = 8192\nclass FastI(IOBase):\n\tdef __init__(self, file):\n\t\tself._fd = file.fileno()\n\t\tself._buffer = StringIO()\n\t\tself.newlines = 0\n \n\tdef read(self):\n\t\twhile True:\n\t\t\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n\t\t\tif not b:\n\t\t\t\tbreak\n\t\t\tptr = self.buffer.tell()\n\t\t\tself.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n\t\tself.newlines = 0\n\t\treturn self.buffer.read()\n \n\tdef readline(self):\n\t\twhile self.newlines == 0:\n\t\t\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n\t\t\tself.newlines = b.count(\"\\n\") + (not b)\n\t\t\tptr = self._buffer.tell()\n\t\t\tself._buffer.seek(0, 2), self._buffer.write(\n\t\t\t\tb), self._buffer.seek(ptr)\n\t\tself.newlines -= 1\n\t\treturn self._buffer.readline()\nclass FastO(IOBase):\n\tdef __init__(self, file):\n\t\tself._fd = file.fileno()\n\t\tself._buffer = __pypy__.builders.StringBuilder()\n\t\tself.write = lambda s: self._buffer.append(s)\n \n\tdef flush(self):\n\t\tos.write(self._fd, self._buffer.build())\n\t\tself._buffer = __pypy__.builders.StringBuilder()\ndef print(*args, **kwargs):\n\tsep, file = kwargs.pop(\"sep\", \" \"), kwargs.pop(\"file\", sys.stdout)\n\tat_start = True\n\tfor x in args:\n\t\tif not at_start:\n\t\t\tfile.write(sep)\n\t\tfile.write(str(x))\n\t\tat_start = False\n\tfile.write(kwargs.pop(\"end\", \"\\n\"))\n\tif kwargs.pop(\"flush\", False):\n\t\tfile.flush()\ndef gcd(x, y):\n\twhile y:\n\t\tx, y = y, x % y\n\treturn x\nsys.stdin, sys.stdout = FastI(sys.stdin), FastO(sys.stdout)\ndef input(): return sys.stdin.readline().rstrip(\"\\r\\n\")\nif __name__ == \"__main__\":\n\tdef bootstrap(cont):\n\t\tcall, arg = cont.switch()\n\t\twhile True:\n\t\t\tcall, arg = cont.switch(to=continulet(\n\t\t\t\tlambda _, f, args: f(*args), call, arg))\n\tcont = continulet(bootstrap)\n\tcont.switch()\n\tmain()",
    "prob_desc_created_at": "1569940500",
    "tags": [
        "data structures"
    ],
    "hidden_unit_tests": ""
}
{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"1\", \"6\", \"4\", \"-1\"]",
    "src_uid": "6c5cf702d85ff25cf9e7bfd16534197d",
    "prob_desc_notes": "NoteIn the first test case, the optimal strategy is as follows:   Red chooses to color the subtrees of nodes $$$2$$$ and $$$3$$$.  Blue chooses to color the subtree of node $$$4$$$.  At the end of this process, nodes $$$2$$$ and $$$3$$$ are red, node $$$4$$$ is blue, and node $$$1$$$ is white. The score of the game is $$$1 \\cdot (2 - 1) = 1$$$.In the second test case, the optimal strategy is as follows:   Red chooses to color the subtree of node $$$4$$$. This colors both nodes $$$4$$$ and $$$5$$$.  Blue does not have any options, so nothing is colored blue.  At the end of this process, nodes $$$4$$$ and $$$5$$$ are red, and nodes $$$1$$$, $$$2$$$ and $$$3$$$ are white. The score of the game is $$$3 \\cdot (2 - 0) = 6$$$.For the third test case:  The score of the game is $$$4 \\cdot (2 - 1) = 4$$$.",
    "prob_desc_description": "Two players, Red and Blue, are at it again, and this time they're playing with crayons! The mischievous duo is now vandalizing a rooted tree, by coloring the nodes while playing their favorite game.The game works as follows: there is a tree of size $$$n$$$, rooted at node $$$1$$$, where each node is initially white. Red and Blue get one turn each. Red goes first. In Red's turn, he can do the following operation any number of times:   Pick any subtree of the rooted tree, and color every node in the subtree red.  However, to make the game fair, Red is only allowed to color $$$k$$$ nodes of the tree. In other words, after Red's turn, at most $$$k$$$ of the nodes can be colored red.Then, it's Blue's turn. Blue can do the following operation any number of times:   Pick any subtree of the rooted tree, and color every node in the subtree blue. However, he's not allowed to choose a subtree that contains a node already colored red, as that would make the node purple and no one likes purple crayon.  Note: there's no restriction on the number of nodes Blue can color, as long as he doesn't color a node that Red has already colored.After the two turns, the score of the game is determined as follows: let $$$w$$$ be the number of white nodes, $$$r$$$ be the number of red nodes, and $$$b$$$ be the number of blue nodes. The score of the game is $$$w \\cdot (r - b)$$$.Red wants to maximize this score, and Blue wants to minimize it. If both players play optimally, what will the final score of the game be?",
    "prob_desc_output_spec": "Print one integer — the resulting score if both Red and Blue play optimally.",
    "prob_desc_input_spec": "The first line contains two integers $$$n$$$ and $$$k$$$ ($$$2 \\le n \\le 2 \\cdot 10^5$$$; $$$1 \\le k \\le n$$$) — the number of vertices in the tree and the maximum number of red nodes. Next $$$n - 1$$$ lines contains description of edges. The $$$i$$$-th line contains two space separated integers $$$u_i$$$ and $$$v_i$$$ ($$$1 \\le u_i, v_i \\le n$$$; $$$u_i \\neq v_i$$$) — the $$$i$$$-th edge of the tree. It's guaranteed that given edges form a tree.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3",
    "lang_cluster": "Python",
    "difficulty": 2400,
    "file_name": "train_100.jsonl",
    "code_uid": "535b2792a219d2a75a8872e852b573ca",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"4 2\\n1 2\\n1 3\\n1 4\", \"5 2\\n1 2\\n2 3\\n3 4\\n4 5\", \"7 2\\n1 2\\n1 3\\n4 2\\n3 5\\n6 3\\n6 7\", \"4 1\\n1 2\\n1 3\\n1 4\"]",
    "exec_outcome": "PASSED",
    "source_code": "import sys\r\ninput = sys.stdin.buffer.readline\r\nn, k = [*map(int, input().split())]\r\nd = [[] for i in range(n)]\r\np, h, l, v = [0]*n, [-1]*n, [0]*n, [0]*n\r\nfor _ in range(n-1):\r\n    a, b = [int(i)-1 for i in input().split()]\r\n    d[a].append(b)\r\n    d[b].append(a)\r\nq, p[0] = [0], -1\r\nleaves = []\r\nwhile q:\r\n    q1 = []\r\n    for i in q:\r\n        for j in d[i]:\r\n            if j != p[i]:\r\n                q1.append(j)\r\n                p[j] = i\r\n                if len(d[j]) == 1: leaves.append(j)\r\n    q = q1\r\nfor i in leaves[::-1]:\r\n    c, x = 0, i\r\n    while x != -1 and h[x] < c: h[x] = c; c+=1; l[x]=i; x=p[x];\r\nt = sorted(list(range(n)), key=lambda x: h[x], reverse=True)\r\nr = nb = 0\r\nfor i in t:\r\n    if not v[i]:\r\n        r += 1\r\n        nb += h[i]+1\r\n        v[i] = 1\r\n        x = l[i]\r\n        while not v[x]: v[x] = 1; x = p[x]\r\n    if r == k: break\r\nrr = max((nb-i)*(i+nb-n) for i in range(r, k+1))\r\nrl = min((nb-k+i)*(k+nb-n+i) for i in range(max(n-nb-k+1,1)))\r\nprint(rr if n-nb < k else rl)",
    "prob_desc_created_at": "1640356500",
    "tags": [
        "data structures",
        "dfs and similar",
        "games",
        "graphs",
        "greedy",
        "math",
        "sortings",
        "trees"
    ],
    "hidden_unit_tests": ""
}
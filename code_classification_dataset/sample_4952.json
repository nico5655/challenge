{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"2 2\\n1 4\\n2 1\\n0 1\\n1 1\\n0 1\\n8 1\\n3 6\"]",
    "src_uid": "904af5d6a9d84b7b7b7ff8d63e6f0254",
    "prob_desc_notes": "NoteThe first test case is explained in the statement.In the second case, it is enough to cut any of the four occurrences.In the third case, string $$$s$$$ is the concatenation of two strings $$$t =$$$ \"xyz\", so there is a unique optimal sequence of $$$2$$$ moves.In the fourth and sixth cases, the string $$$s$$$ initially contains no occurrences of the string $$$t$$$.In the fifth case, the string $$$s$$$ contains exactly one occurrence of the string $$$t$$$.",
    "prob_desc_description": "You are given two non-empty strings $$$s$$$ and $$$t$$$, consisting of Latin letters.In one move, you can choose an occurrence of the string $$$t$$$ in the string $$$s$$$ and replace it with dots.Your task is to remove all occurrences of the string $$$t$$$ in the string $$$s$$$ in the minimum number of moves, and also calculate how many different sequences of moves of the minimum length exist.Two sequences of moves are considered different if the sets of indices at which the removed occurrences of the string $$$t$$$ in $$$s$$$ begin differ. For example, the sets $$$\\{1, 2, 3\\}$$$ and $$$\\{1, 2, 4\\}$$$ are considered different, the sets $$$\\{2, 4, 6\\}$$$ and $$$\\{2, 6\\}$$$ — too, but sets $$$\\{3, 5\\}$$$ and $$$\\{5, 3\\}$$$ — not.For example, let the string $$$s =$$$ \"abababacababa\" and the string $$$t =$$$ \"aba\". We can remove all occurrences of the string $$$t$$$ in $$$2$$$ moves by cutting out the occurrences of the string $$$t$$$ at the $$$3$$$th and $$$9$$$th positions. In this case, the string $$$s$$$ is an example of the form \"ab...bac...ba\". It is also possible to cut occurrences of the string $$$t$$$ at the $$$3$$$th and $$$11$$$th positions. There are two different sequences of minimum length moves.Since the answer can be large, output it modulo $$$10^9 + 7$$$.",
    "prob_desc_output_spec": "For each test case print two integers — the minimum number of moves and the number of different optimal sequences, modulo $$$10^9 + 7$$$.",
    "prob_desc_input_spec": "The first line of the input contains a single integer $$$q$$$ ($$$1 \\le q \\le 50$$$) — the number of test cases. The descriptions of the sets follow. The first line of each set contains a non-empty string $$$s$$$ ($$$1 \\le |s| \\le 500$$$) consisting of lowercase Latin letters. The second line of each set contains a non-empty string $$$t$$$ ($$$1 \\le |t| \\le 500$$$) consisting of lowercase Latin letters. It is guaranteed that the sum of string lengths $$$s$$$ over all test cases does not exceed $$$500$$$. Similarly, it is guaranteed that the sum of string lengths $$$t$$$ over all test cases does not exceed $$$500$$$.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "Python 3",
    "lang_cluster": "Python",
    "difficulty": 2100,
    "file_name": "train_110.jsonl",
    "code_uid": "765919fc9120fae0599ea4a5e2b713c2",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"8\\n\\nabababacababa\\n\\naba\\n\\nddddddd\\n\\ndddd\\n\\nxyzxyz\\n\\nxyz\\n\\nabc\\n\\nabcd\\n\\nabacaba\\n\\nabaca\\n\\nabc\\n\\ndef\\n\\naaaaaaaa\\n\\na\\n\\naaaaaaaa\\n\\naa\"]",
    "exec_outcome": "PASSED",
    "source_code": "from typing import List, Dict, Set, Sequence, Tuple, Deque, AnyStr, Optional\r\n# from sortedcontainers import SortedDict, SortedSet, SortedList\r\nfrom collections import deque, Counter, OrderedDict\r\nimport bisect\r\n\r\ncase_num = int(input())\r\nfor case_index in range(case_num):\r\n    s = input()\r\n    t = input()\r\n    t_indexes = []  # 记录t在s中出现的起点索引的位置\r\n    for i in range(len(s)):\r\n        if s[i:i + len(t)] == t:\r\n            t_indexes.append(i)\r\n    if len(t_indexes) == 0:\r\n        print('0 1')\r\n        continue\r\n    if len(t) == 1:\r\n        print(f'{len(t_indexes)} 1')\r\n        continue\r\n    dp1 = [0 for i in range(len(t_indexes) + 1)]  # dp[i]表示从t_indexes[i]开始（包括）且t_indexes[i]处的t被删去时的最少操作次数\r\n    min1 = 1000000  # 总体的最少操作次数\r\n    for i in range(len(t_indexes) - 1, -1, -1):\r\n        j = bisect.bisect_left(t_indexes, t_indexes[i] + len(t))  # 因为t_indexes[i]要被删去，那么，接下来可能要被删去的就是t_indexes[j]处开始的t\r\n        dp1[i] = 100000000\r\n        if j >= len(t_indexes):\r\n            dp1[i] = 1\r\n        else:\r\n            l = bisect.bisect_left(t_indexes, t_indexes[j] + len(t))  # 从t_indexes[j]开始到t_indexes[l]（不包括）为止，必须有一个t被删去\r\n            for k in range(j, l):  # 遍历j，l间被删去的t，选择其中最小的，就是i开始且删除i时的最少操作次数\r\n                dp1[i] = min(dp1[i], 1 + dp1[k])\r\n        if t_indexes[i] - t_indexes[0] < len(\r\n                t):  # 当当前s中的索引t_indexes[i]已经和最小的t的索引t_indexes[0]相差小于len(t)时，说明再往前已经没有t可以删了，可以更新min1了\r\n            min1 = min(min1, dp1[i])\r\n    dp2 = [[0 for i in range(len(t_indexes) + 1)] for j in\r\n           range(len(t_indexes) + 1)]  # dp2[i][j]表示从t_indexes[i]开始（包括）且t_indexes[i]处的t被删去且总删除次数为j时的删除方式种数\r\n    dp2[len(t_indexes)][0] = 1\r\n    for i in range(len(t_indexes) - 1, -1, -1):\r\n        j = bisect.bisect_left(t_indexes, t_indexes[i] + len(t))  # 同dp1计算时中j的作用\r\n        if j >= len(t_indexes):\r\n            dp2[i][1] = 1\r\n            continue\r\n        # 只需要计算t_indexes[i]开始的最少删除次数时的操作种数，因为如果从当前索引开始的删除次数不是最少的，且总体删除次数最少时用到了当前这种方式，那么可以选择当前索引开始的最少删除次数，使总体删除次数更少，就矛盾了\r\n        l = bisect.bisect_left(t_indexes, t_indexes[j] + len(t))  # 同dp1计算时的l的作用\r\n        dp2[i][dp1[i]] = sum(dp2[k][dp1[i] - 1] for k in range(j, l)) % 1000000007\r\n    # print(min1)\r\n    # print(t_indexes)\r\n    # print(dp1)\r\n    # print(dp2)\r\n    ans = 0\r\n    for i in range(len(t_indexes)):\r\n        if t_indexes[i] - t_indexes[0] >= len(t):\r\n            break\r\n        ans = (ans + dp2[i][min1]) % 1000000007\r\n    print(f'{min1} {ans}')\r\n",
    "prob_desc_created_at": "1662993300",
    "tags": [
        "combinatorics",
        "dp",
        "hashing",
        "strings",
        "two pointers"
    ],
    "hidden_unit_tests": ""
}
{
    "prob_desc_time_limit": "3 seconds",
    "prob_desc_sample_outputs": "[\"69\\n359\\n573672453\"]",
    "src_uid": "178222a468f37615ee260fc9d2944aec",
    "prob_desc_notes": "NoteIn the first test case, the minimum total amount of ingredients is $$$69$$$. In fact, the amounts of ingredients $$$1, 2, 3, 4$$$ of a valid potion are $$$16, 12, 9, 32$$$, respectively. The potion is valid because   Ingredients $$$3$$$ and $$$2$$$ have a ratio of $$$9 : 12 = 3 : 4$$$;  Ingredients $$$1$$$ and $$$2$$$ have a ratio of $$$16 : 12 = 4 : 3$$$;  Ingredients $$$1$$$ and $$$4$$$ have a ratio of $$$16 : 32 = 2 : 4$$$. In the second test case, the amounts of ingredients $$$1, 2, 3, 4, 5, 6, 7, 8$$$ in the potion that minimizes the total amount of ingredients are $$$60, 60, 24, 48, 32, 60, 45, 30$$$.",
    "prob_desc_description": "Alice's potion making professor gave the following assignment to his students: brew a potion using $$$n$$$ ingredients, such that the proportion of ingredient $$$i$$$ in the final potion is $$$r_i &gt; 0$$$ (and $$$r_1 + r_2 + \\cdots + r_n = 1$$$).He forgot the recipe, and now all he remembers is a set of $$$n-1$$$ facts of the form, \"ingredients $$$i$$$ and $$$j$$$ should have a ratio of $$$x$$$ to $$$y$$$\" (i.e., if $$$a_i$$$ and $$$a_j$$$ are the amounts of ingredient $$$i$$$ and $$$j$$$ in the potion respectively, then it must hold $$$a_i/a_j = x/y$$$), where $$$x$$$ and $$$y$$$ are positive integers. However, it is guaranteed that the set of facts he remembers is sufficient to uniquely determine the original values $$$r_i$$$.He decided that he will allow the students to pass the class as long as they submit a potion which satisfies all of the $$$n-1$$$ requirements (there may be many such satisfactory potions), and contains a positive integer amount of each ingredient.Find the minimum total amount of ingredients needed to make a potion which passes the class. As the result can be very large, you should print the answer modulo $$$998\\,244\\,353$$$.",
    "prob_desc_output_spec": "For each test case, print the minimum total amount of ingredients needed to make a potion which passes the class, modulo $$$998\\,244\\,353$$$.",
    "prob_desc_input_spec": "The first line contains a single integer $$$t$$$ ($$$1 \\le t \\le 10^4$$$) — the number of test cases. The first line of each test case contains a single integer $$$n$$$ ($$$2 \\le n \\le 2 \\cdot 10^5$$$). Each of the next $$$n-1$$$ lines contains four integers $$$i, j, x, y$$$ ($$$1 \\le i, j \\le n$$$, $$$i\\not=j$$$, $$$1\\le x, y \\le n$$$) — ingredients $$$i$$$ and $$$j$$$ should have a ratio of $$$x$$$ to $$$y$$$. It is guaranteed that the set of facts is sufficient to uniquely determine the original values $$$r_i$$$. It is also guaranteed that the sum of $$$n$$$ for all test cases does not exceed $$$2 \\cdot 10^5$$$.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3-64",
    "lang_cluster": "Python",
    "difficulty": 2100,
    "file_name": "train_105.jsonl",
    "code_uid": "f864ea0f151158a8a3758358b843cd0a",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"3\\n4\\n3 2 3 4\\n1 2 4 3\\n1 4 2 4\\n8\\n5 4 2 3\\n6 4 5 4\\n1 3 5 2\\n6 8 2 1\\n3 5 3 4\\n3 2 2 5\\n6 7 4 3\\n17\\n8 7 4 16\\n9 17 4 5\\n5 14 13 12\\n11 1 17 14\\n6 13 8 9\\n2 11 3 11\\n4 17 7 2\\n17 16 8 6\\n15 5 1 14\\n16 7 1 10\\n12 17 13 10\\n11 16 7 2\\n10 11 6 4\\n13 17 14 6\\n3 11 15 8\\n15 6 12 8\"]",
    "exec_outcome": "PASSED",
    "source_code": "import heapq\r\nimport math\r\nimport os\r\nimport sys\r\nfrom array import array\r\nfrom bisect import bisect_left, bisect_right\r\nfrom collections import defaultdict, deque, Counter\r\nfrom fractions import Fraction\r\nfrom io import IOBase, BytesIO\r\nfrom itertools import groupby, accumulate\r\nfrom sys import stdin\r\nfrom typing import Optional\r\nfrom functools import lru_cache\r\n\r\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\r\nprint = lambda d: sys.stdout.write(str(d)+\"\\n\")\r\ndef read_int_list(): return list(map(int, input().split()))\r\ndef read_int_tuple(): return tuple(map(int, input().split()))\r\ndef read_int(): return int(input())\r\n\r\nfrom types import GeneratorType\r\ndef bootstrap(f, stack=[]):\r\n    def wrappedfunc(*args, **kwargs):\r\n        if stack: return f(*args, **kwargs)\r\n        to = f(*args, **kwargs)\r\n        while True:\r\n            if type(to) is GeneratorType:\r\n                stack.append(to)\r\n                to = next(to)\r\n            else:\r\n                stack.pop()\r\n                if not stack: break\r\n                to = stack[-1].send(to)\r\n        return to\r\n    return wrappedfunc\r\n\r\n\r\n\r\n### CODE HERE\r\n\r\n# f = open('inputs', 'r')\r\n# def input(): return f.readline().rstrip(\"\\r\\n\")\r\n\r\n# import sys\r\n# sys.setrecursionlimit(999999)\r\n\r\nMOD, N = 998244353, 200000\r\n\r\ninv = [0] * (N + 1); inv[1] = 1\r\nfor i in range(2, N + 1): inv[i] = (MOD - MOD // i) * inv[MOD % i] % MOD\r\n\r\nfact = [{} for _ in range(N + 1)]\r\n\r\nfor i in range(2, N + 1):\r\n    if len(fact[i]) > 0: continue\r\n    j = i\r\n    while j <= N:\r\n        for k in range(j, N + 1, j):\r\n            if i not in fact[k]:  fact[k][i] = 0\r\n            fact[k][i] += 1\r\n        j = j * i\r\n\r\ndef solve():\r\n    n = read_int()\r\n    d = [[] for _ in range(n + 1)]\r\n    for _ in range(n - 1):\r\n        u, v, a, b = read_int_tuple()\r\n        d[u].append((v, b, a))\r\n        d[v].append((u, a, b))\r\n    numer = [1 for _ in range(n + 1)]\r\n    lcm_book = [0] * (n + 1)\r\n\r\n    @bootstrap\r\n    def dfs(u, f, frac):\r\n        for v, a, b in d[u]:\r\n            if v == f: continue\r\n            numer[v] = numer[u] * a * inv[b] % MOD\r\n\r\n            for p, cnt in fact[a].items():\r\n                frac[p] += cnt\r\n            for p, cnt in fact[b].items():\r\n                frac[p] -= cnt\r\n                lcm_book[p] = min(lcm_book[p], frac[p])\r\n            yield  dfs(v, u, frac)\r\n            for p, cnt in fact[a].items():\r\n                frac[p] -= cnt\r\n            for p, cnt in fact[b].items():\r\n                frac[p] += cnt\r\n        yield None\r\n\r\n    dfs(1, 0, [0] * (n + 1))\r\n\r\n    res = sum(numer[i] for i in range(1, n + 1)) % MOD\r\n    for p, cnt in enumerate(lcm_book):\r\n        if cnt >= 0: continue\r\n        res = res * pow(p, -cnt, MOD) % MOD\r\n\r\n    print(res)\r\n\r\nfor _ in range(read_int()):\r\n    solve()",
    "prob_desc_created_at": "1647764100",
    "tags": [
        "dfs and similar",
        "math",
        "number theory",
        "trees"
    ],
    "hidden_unit_tests": ""
}
{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"1 1\\n1 0\", \"0 1 1\\n1 1 1\"]",
    "src_uid": "5d2e7f35583f4f3f087e5d010833c08d",
    "prob_desc_notes": "Note1. In the first sample: c1 = 1, c2 = 1, so an = an - 1 + an - 2  (mod 2). Thus the sequence will be:so its period equals 3 = 22 - 1.2. In the second sample: c1 = 0, c2 = 1, c3 = 1, so an = an - 2 + an - 3  (mod 2). Thus our sequence is:and its period equals 7 = 23 - 1.Periods are colored.",
    "prob_desc_description": "A sequence a0, a1, ... is called a recurrent binary sequence, if each term ai (i = 0, 1, ...) is equal to 0 or 1 and there exist coefficients  such that an = c1·an - 1 + c2·an - 2 + ... + ck·an - k (mod 2),  for all n ≥ k. Assume that not all of ci are zeros.Note that such a sequence can be uniquely recovered from any k-tuple {as, as + 1, ..., as + k - 1} and so it is periodic. Moreover, if a k-tuple contains only zeros, then the sequence contains only zeros, so this case is not very interesting. Otherwise the minimal period of the sequence is not greater than 2k - 1, as k-tuple determines next element, and there are 2k - 1 non-zero k-tuples. Let us call a sequence long if its minimal period is exactly 2k - 1. Your task is to find a long sequence for a given k, if there is any.",
    "prob_desc_output_spec": "If there is no long sequence for a given k, output \"-1\" (without quotes). Otherwise the first line of the output should contain k integer numbers: c1, c2, ..., ck (coefficients). The second line should contain first k elements of the sequence: a0, a1, ..., ak - 1. All of them (elements and coefficients) should be equal to 0 or 1, and at least one ci has to be equal to 1. If there are several solutions, output any.",
    "prob_desc_input_spec": "Input contains a single integer k (2 ≤ k ≤ 50).",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "Python 2",
    "lang_cluster": "Python",
    "difficulty": 2700,
    "file_name": "train_042.jsonl",
    "code_uid": "1a3661d1c7daba764b43ec8a1d65d646",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"2\", \"3\"]",
    "exec_outcome": "PASSED",
    "source_code": "m={2: '11', 3: '101', 4: '1001', 5: '01001', 6: '100001', 7: '1000001', 8: '01110001', 9: '000100001', 10: '0010000001', 11: '01000000001', 12: '100101000001', 13: '1011000000001', 14: '10101000000001', 15: '100000000000001', 16: '0110100000000001', 17: '00100000000000001', 18: '000000100000000001', 19: '1100100000000000001', 20: '00100000000000000001', 21: '010000000000000000001', 22: '1000000000000000000001', 23: '00001000000000000000001', 24: '101100000000000000000001', 25: '0010000000000000000000001', 26: '11000100000000000000000001', 27: '110010000000000000000000001', 28: '0010000000000000000000000001', 29: '01000000000000000000000000001', 30: '100101000000000000000000000001', 31: '0010000000000000000000000000001', 32: '01000110000000000000000000000001', 33: '000000000000100000000000000000001', 34: '0011000100000000000000000000000001', 35: '01000000000000000000000000000000001', 36: '000000000010000000000000000000000001', 37: '1001010000000000000000000000000000001', 38: '10001100000000000000000000000000000001', 39: '000100000000000000000000000000000000001', 40: '0011100000000000000000000000000000000001', 41: '00100000000000000000000000000000000000001', 42: '001100100000000000000000000000000000000001', 43: '0011010000000000000000000000000000000000001', 44: '01001100000000000000000000000000000000000001', 45: '101100000000000000000000000000000000000000001', 46: '0000011100000000000000000000000000000000000001', 47: '00001000000000000000000000000000000000000000001', 48: '000100101000000000000000000000000000000000000001', 49: '0000000010000000000000000000000000000000000000001', 50: '01110000000000000000000000000000000000000000000001', 51: '101001000000000000000000000000000000000000000000001', 52: '0010000000000000000000000000000000000000000000000001', 53: '11000100000000000000000000000000000000000000000000001', 54: '001001010000000000000000000000000000000000000000000001', 55: '0000000000000000000000010000000000000000000000000000001', 56: '01010010000000000000000000000000000000000000000000000001', 57: '000000100000000000000000000000000000000000000000000000001', 58: '0000000000000000001000000000000000000000000000000000000001', 59: '01010010000000000000000000000000000000000000000000000000001', 60: '100000000000000000000000000000000000000000000000000000000001', 61: '1100100000000000000000000000000000000000000000000000000000001', 62: '00101100000000000000000000000000000000000000000000000000000001', 63: '100000000000000000000000000000000000000000000000000000000000001', 64: '1011000000000000000000000000000000000000000000000000000000000001', 65: '00000000000000000100000000000000000000000000000000000000000000001', 66: '000001011000000000000000000000000000000000000000000000000000000001', 67: '1100100000000000000000000000000000000000000000000000000000000000001', 68: '00000000100000000000000000000000000000000000000000000000000000000001', 69: '010011000000000000000000000000000000000000000000000000000000000000001', 70: '1010100000000000000000000000000000000000000000000000000000000000000001', 71: '00000100000000000000000000000000000000000000000000000000000000000000001'}\n\nk=input()\nprint\" \".join(c for c in m[k])\nprint\" \".join(\"1\" for c in m[k])\n",
    "prob_desc_created_at": "1306077000",
    "tags": [
        "brute force",
        "math",
        "matrices"
    ],
    "hidden_unit_tests": ""
}
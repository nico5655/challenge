{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"1 0 0 2\", \"0 0 0 1 0 2 4\"]",
    "src_uid": "905df05453a12008fc9247ff4d02e7f0",
    "prob_desc_notes": null,
    "prob_desc_description": "You are given two arrays $$$a$$$ and $$$b$$$, both of length $$$n$$$. All elements of both arrays are from $$$0$$$ to $$$n-1$$$.You can reorder elements of the array $$$b$$$ (if you want, you may leave the order of elements as it is). After that, let array $$$c$$$ be the array of length $$$n$$$, the $$$i$$$-th element of this array is $$$c_i = (a_i + b_i) \\% n$$$, where $$$x \\% y$$$ is $$$x$$$ modulo $$$y$$$.Your task is to reorder elements of the array $$$b$$$ to obtain the lexicographically minimum possible array $$$c$$$.Array $$$x$$$ of length $$$n$$$ is lexicographically less than array $$$y$$$ of length $$$n$$$, if there exists such $$$i$$$ ($$$1 \\le i \\le n$$$), that $$$x_i &lt; y_i$$$, and for any $$$j$$$ ($$$1 \\le j &lt; i$$$) $$$x_j = y_j$$$.",
    "prob_desc_output_spec": "Print the lexicographically minimum possible array $$$c$$$. Recall that your task is to reorder elements of the array $$$b$$$ and obtain the lexicographically minimum possible array $$$c$$$, where the $$$i$$$-th element of $$$c$$$ is $$$c_i = (a_i + b_i) \\% n$$$.",
    "prob_desc_input_spec": "The first line of the input contains one integer $$$n$$$ ($$$1 \\le n \\le 2 \\cdot 10^5$$$) â€” the number of elements in $$$a$$$, $$$b$$$ and $$$c$$$. The second line of the input contains $$$n$$$ integers $$$a_1, a_2, \\dots, a_n$$$ ($$$0 \\le a_i &lt; n$$$), where $$$a_i$$$ is the $$$i$$$-th element of $$$a$$$. The third line of the input contains $$$n$$$ integers $$$b_1, b_2, \\dots, b_n$$$ ($$$0 \\le b_i &lt; n$$$), where $$$b_i$$$ is the $$$i$$$-th element of $$$b$$$.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 2",
    "lang_cluster": "Python",
    "difficulty": 1700,
    "file_name": "train_005.jsonl",
    "code_uid": "6ff3dd847bcdd38ed84193dccb09ebf3",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"4\\n0 1 2 1\\n3 2 1 1\", \"7\\n2 5 1 5 3 4 3\\n2 4 3 5 6 5 1\"]",
    "exec_outcome": "PASSED",
    "source_code": "#!/usr/bin/env python\nfrom __future__ import division, print_function\n\nimport os\nimport sys\nfrom io import BytesIO, IOBase\n\nif sys.version_info[0] < 3:\n    from __builtin__ import xrange as range\n    from future_builtins import ascii, filter, hex, map, oct, zip\nelse:\n    _str = str\n    str = lambda x=b\"\": x if type(x) is bytes else _str(x).encode()\n\n\nclass SegmentTree:\n    def __init__(self, data, default=0, func=lambda x, y: max(x, y)):\n        \"\"\"initialize the segment tree with data\"\"\"\n        self._len = _len = len(data)\n        self._size = _size = 1 << (_len - 1).bit_length()\n        self._data = _data = [default] * (2 * _size)\n        self._default = default\n        self._func = func\n        _data[_size:_size + _len] = data\n        for i in reversed(range(_size)):\n            _data[i] = func(_data[2 * i], _data[2 * i + 1])\n\n    def __delitem__(self, key):\n        self[key] = self._default\n\n    def __getitem__(self, key):\n        return self._data[key + self._size]\n\n    def __setitem__(self, key, value):\n        key += self._size\n        self._data[key] = value\n        key >>= 1\n        while key:\n            self._data[key] = self._func(self._data[2 * key], self._data[2 * key + 1])\n            key >>= 1\n\n    def __len__(self):\n        return self._len\n\n    def bisect_left(self, value):\n        i = 1\n        while i < self._size:\n            i = 2 * i + 1 if value > self._data[2 * i] else 2 * i\n        return i - self._size\n\n    def bisect_right(self, value):\n        i = 1\n        while i < self._size:\n            i = 2 * i + 1 if value >= self._data[2 * i] else 2 * i\n        return i - self._size\n\n    bisect = bisect_right\n\n    def query(self, begin, end):\n        begin += self._size\n        end += self._size\n        res = self._default\n\n        while begin < end:\n            if begin & 1:\n                res = self._func(res, self._data[begin])\n                begin += 1\n            if end & 1:\n                end -= 1\n                res = self._func(res, self._data[end])\n            begin >>= 1\n            end >>= 1\n\n        return res\n\n\ndef main():\n    n = int(readline())\n    a = map(int, input().split())\n    b = SegmentTree(sorted(map(int, input().split())), -1)\n\n    start = 0\n    for ai in a:\n        idx = b.bisect_left(n - ai)\n        if b[idx] < n - ai:\n            idx = start\n            while b[idx] == -1:\n                idx += 1\n            start = idx\n        cout << (b[idx] + ai) % n << ' '\n        del b[idx]\n    cout << '\\n'\n\n\n# region template\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._buffer = BytesIO()\n        self._fd = file.fileno()\n        self._writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self._buffer.write if self._writable else None\n\n    def read(self):\n        if self._buffer.tell():\n            return self._buffer.read()\n        return os.read(self._fd, os.fstat(self._fd).st_size)\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self._buffer.tell()\n            self._buffer.seek(0, 2), self._buffer.write(b), self._buffer.seek(ptr)\n        self.newlines -= 1\n        return self._buffer.readline()\n\n    def flush(self):\n        if self._writable:\n            os.write(self._fd, self._buffer.getvalue())\n            self._buffer.truncate(0), self._buffer.seek(0)\n\n\nclass ostream:\n    def __lshift__(self, a):\n        if a is endl:\n            sys.stdout.write(b\"\\n\")\n            sys.stdout.flush()\n        else:\n            sys.stdout.write(str(a))\n        return self\n\n\ndef print(*args, **kwargs):\n    sep, file = kwargs.pop(\"sep\", b\" \"), kwargs.pop(\"file\", sys.stdout)\n    at_start = True\n    for x in args:\n        if not at_start:\n            file.write(sep)\n        file.write(str(x))\n        at_start = False\n    file.write(kwargs.pop(\"end\", b\"\\n\"))\n    if kwargs.pop(\"flush\", False):\n        file.flush()\n\n\nsys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)\ncout, endl = ostream(), object()\n\nreadline = sys.stdin.readline\nreadlist = lambda var=int: [var(n) for n in readline().split()]\ninput = lambda: readline().rstrip(b\"\\r\\n\")\n\n# endregion\n\nif __name__ == \"__main__\":\n    main()\n",
    "prob_desc_created_at": "1556289300",
    "tags": [
        "data structures",
        "binary search",
        "greedy"
    ],
    "hidden_unit_tests": ""
}
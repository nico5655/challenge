{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"aac\\nb\\naba\\ncodeforces\"]",
    "src_uid": "bc2f2b98c50a0165b7204a6d595eec4b",
    "prob_desc_notes": "NoteIn the first test case, such strings $$$t$$$ are suitable: \"aac', \"aab\".In the second test case, such trings $$$t$$$ are suitable: \"a\", \"b\", \"c\".In the third test case, only the string $$$t$$$ equals to \"aba\" is suitable, but the character 'b' can be from the second or third position.",
    "prob_desc_description": "Polycarp wrote on the board a string $$$s$$$ containing only lowercase Latin letters ('a'-'z'). This string is known for you and given in the input.After that, he erased some letters from the string $$$s$$$, and he rewrote the remaining letters in any order. As a result, he got some new string $$$t$$$. You have to find it with some additional information.Suppose that the string $$$t$$$ has length $$$m$$$ and the characters are numbered from left to right from $$$1$$$ to $$$m$$$. You are given a sequence of $$$m$$$ integers: $$$b_1, b_2, \\ldots, b_m$$$, where $$$b_i$$$ is the sum of the distances $$$|i-j|$$$ from the index $$$i$$$ to all such indices $$$j$$$ that $$$t_j &gt; t_i$$$ (consider that 'a'&lt;'b'&lt;...&lt;'z'). In other words, to calculate $$$b_i$$$, Polycarp finds all such indices $$$j$$$ that the index $$$j$$$ contains a letter that is later in the alphabet than $$$t_i$$$ and sums all the values $$$|i-j|$$$.For example, if $$$t$$$ = \"abzb\", then:  since $$$t_1$$$='a', all other indices contain letters which are later in the alphabet, that is: $$$b_1=|1-2|+|1-3|+|1-4|=1+2+3=6$$$;  since $$$t_2$$$='b', only the index $$$j=3$$$ contains the letter, which is later in the alphabet, that is: $$$b_2=|2-3|=1$$$;  since $$$t_3$$$='z', then there are no indexes $$$j$$$ such that $$$t_j&gt;t_i$$$, thus $$$b_3=0$$$;  since $$$t_4$$$='b', only the index $$$j=3$$$ contains the letter, which is later in the alphabet, that is: $$$b_4=|4-3|=1$$$. Thus, if $$$t$$$ = \"abzb\", then $$$b=[6,1,0,1]$$$.Given the string $$$s$$$ and the array $$$b$$$, find any possible string $$$t$$$ for which the following two requirements are fulfilled simultaneously:  $$$t$$$ is obtained from $$$s$$$ by erasing some letters (possibly zero) and then writing the rest in any order;  the array, constructed from the string $$$t$$$ according to the rules above, equals to the array $$$b$$$ specified in the input data. ",
    "prob_desc_output_spec": "Output $$$q$$$ lines: the $$$k$$$-th of them should contain the answer (string $$$t$$$) to the $$$k$$$-th test case. It is guaranteed that an answer to each test case exists. If there are several answers, output any.",
    "prob_desc_input_spec": "The first line contains an integer $$$q$$$ ($$$1 \\le q \\le 100$$$) — the number of test cases in the test. Then $$$q$$$ test cases follow. Each test case consists of three lines:   the first line contains string $$$s$$$, which has a length from $$$1$$$ to $$$50$$$ and consists of lowercase English letters;  the second line contains positive integer $$$m$$$ ($$$1 \\le m \\le |s|$$$), where $$$|s|$$$ is the length of the string $$$s$$$, and $$$m$$$ is the length of the array $$$b$$$;  the third line contains the integers $$$b_1, b_2, \\dots, b_m$$$ ($$$0 \\le b_i \\le 1225$$$).  It is guaranteed that in each test case an answer exists.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3",
    "lang_cluster": "Python",
    "difficulty": 1800,
    "file_name": "train_029.jsonl",
    "code_uid": "ba7308c36e29c279495c29ed4eca4f95",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"4\\nabac\\n3\\n2 1 0\\nabc\\n1\\n0\\nabba\\n3\\n1 0 1\\necoosdcefr\\n10\\n38 13 24 14 11 5 3 24 17 0\"]",
    "exec_outcome": "PASSED",
    "source_code": "#Code by Sounak, IIESTS\n#------------------------------warmup----------------------------\n\nimport os\nimport sys\nimport math\nfrom io import BytesIO, IOBase\nfrom fractions import Fraction\nfrom collections import defaultdict\n \n\nBUFSIZE = 8192\n \n \nclass FastIO(IOBase):\n    newlines = 0\n    \n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n     \n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n \n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n \n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n \n \nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n  \nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n#-------------------game starts now-----------------------------------------------------\nfor ik in range(int(input())):\n    s=list((input()))\n    s.sort(reverse=True)\n    #print(s)\n    d=dict()\n    for i in range(len(s)):\n        if s[i] not in d:\n            d.update({s[i]:1})\n        else:\n            d[s[i]]+=1\n    s=list(set(s))\n    s.sort(reverse=True)\n    n=int(input())\n    ans=['']*n\n    l=list(map(int,input().split()))\n    t=0\n    #print(d)\n    while(max(l)>0):\n      e=[]\n      e1=l.count(0)\n      #print(e1,s[t])\n      while(e1>d[s[t]]):\n          t+=1\n      for i in range(n):\n        if l[i]==0:\n            ans[i]=s[t]\n            l[i]=-1\n            e.append(i)\n      for i in e:\n          for j in range(i-1,-1,-1):\n              if ans[j]=='':\n                  l[j]-=i-j\n          for j in range(i+1,n):\n              if ans[j]=='':\n                  l[j]-=j-i\n      t+=1\n      #print(ans)\n    #print(ans,t)\n    while( l.count(0) > d[s[t]]):\n        t += 1\n    #print(ans)\n    for i in range(n):\n        if ans[i]=='' and l[i]==0:\n            ans[i]=s[t]\n    print(*ans,sep='')",
    "prob_desc_created_at": "1592318100",
    "tags": [
        "constructive algorithms",
        "implementation",
        "sortings",
        "greedy"
    ],
    "hidden_unit_tests": ""
}
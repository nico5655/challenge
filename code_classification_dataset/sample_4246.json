{
    "prob_desc_time_limit": "3 seconds",
    "prob_desc_sample_outputs": "[\"6\\n5\\n375000012\\n500000026\\n958557139\\n0\\n49735962\"]",
    "src_uid": "32ab22abbbce760be53ea8928876431c",
    "prob_desc_notes": "NoteIn the first test case, the entire game has $$$3$$$ turns, and since $$$m = 3$$$, Bob has to add in each of them. Therefore Alice should pick the biggest number she can, which is $$$k = 2$$$, every turn.In the third test case, Alice has a strategy to guarantee a score of $$$\\frac{75}{8} \\equiv 375000012 \\pmod{10^9 + 7}$$$.In the fourth test case, Alice has a strategy to guarantee a score of $$$\\frac{45}{2} \\equiv 500000026 \\pmod{10^9 + 7}$$$.",
    "prob_desc_description": "This is the hard version of the problem. The difference is the constraints on $$$n$$$, $$$m$$$ and $$$t$$$. You can make hacks only if all versions of the problem are solved.Alice and Bob are given the numbers $$$n$$$, $$$m$$$ and $$$k$$$, and play a game as follows:The game has a score that Alice tries to maximize, and Bob tries to minimize. The score is initially $$$0$$$. The game consists of $$$n$$$ turns. Each turn, Alice picks a real number from $$$0$$$ to $$$k$$$ (inclusive) which Bob either adds to or subtracts from the score of the game. But throughout the game, Bob has to choose to add at least $$$m$$$ out of the $$$n$$$ turns.Bob gets to know which number Alice picked before deciding whether to add or subtract the number from the score, and Alice gets to know whether Bob added or subtracted the number for the previous turn before picking the number for the current turn (except on the first turn since there was no previous turn).If Alice and Bob play optimally, what will the final score of the game be?",
    "prob_desc_output_spec": "For each test case output a single integer number — the score of the optimal game modulo $$$10^9 + 7$$$. Formally, let $$$M = 10^9 + 7$$$. It can be shown that the answer can be expressed as an irreducible fraction $$$\\frac{p}{q}$$$, where $$$p$$$ and $$$q$$$ are integers and $$$q \\not \\equiv 0 \\pmod{M}$$$. Output the integer equal to $$$p \\cdot q^{-1} \\bmod M$$$. In other words, output such an integer $$$x$$$ that $$$0 \\le x &lt; M$$$ and $$$x \\cdot q \\equiv p \\pmod{M}$$$.",
    "prob_desc_input_spec": "The first line of the input contains a single integer $$$t$$$ ($$$1 \\le t \\le 10^5$$$) — the number of test cases. The description of test cases follows. Each test case consists of a single line containing the three integers, $$$n$$$, $$$m$$$, and $$$k$$$ ($$$1 \\le m \\le n \\le 10^6, 0 \\le k &lt; 10^9 + 7$$$) — the number of turns, how many of those turns Bob has to add, and the biggest number Alice can choose, respectively. It is guaranteed that the sum of $$$n$$$ over all test cases does not exceed $$$10^6$$$.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3-64",
    "lang_cluster": "Python",
    "difficulty": 2400,
    "file_name": "train_093.jsonl",
    "code_uid": "066d4783637a1bd8ba08968ced234c5f",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"7\\n\\n3 3 2\\n\\n2 1 10\\n\\n6 3 10\\n\\n6 4 10\\n\\n100 1 1\\n\\n4 4 0\\n\\n69 4 20\"]",
    "exec_outcome": "PASSED",
    "source_code": "import sys\r\nimport os\r\nfrom io import BytesIO, IOBase\r\nBUFSIZE = 8192\r\nclass FastIO(IOBase):\r\n    newlines = 0\r\n    def __init__(self, file):\r\n        self._fd = file.fileno()\r\n        self.buffer = BytesIO()\r\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\r\n        self.write = self.buffer.write if self.writable else None\r\n    def read(self):\r\n        while True:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            if not b:\r\n                break\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines = 0\r\n        return self.buffer.read()\r\n    def readline(self):\r\n        while self.newlines == 0:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            self.newlines = b.count(b\"\\n\") + (not b)\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines -= 1\r\n        return self.buffer.readline()\r\n    def flush(self):\r\n        if self.writable:\r\n            os.write(self._fd, self.buffer.getvalue())\r\n            self.buffer.truncate(0), self.buffer.seek(0)\r\nclass IOWrapper(IOBase):\r\n    def __init__(self, file):\r\n        self.buffer = FastIO(file)\r\n        self.flush = self.buffer.flush\r\n        self.writable = self.buffer.writable\r\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\r\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\r\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\r\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\r\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\r\n \r\nMOD=10**9+7\r\nfacts=[1 for _ in range(10**6+1)]\r\nfor i in range(1,10**6+1):\r\n    facts[i]=(facts[i-1]*i)%MOD\r\nfactinvs=[1 for _ in range(10**6+1)]\r\nfactinvs[-1]=pow(facts[-1],MOD-2,MOD)\r\ntemp=factinvs[-1]\r\nfor i in range(10**6,1,-1):\r\n    factinvs[i-1]=(factinvs[i]*i)%MOD\r\npowinvs=[1 for _ in range(10**6+1)]\r\ninv_2=pow(2,MOD-2,MOD)\r\nfor i in range(1,10**6+1):\r\n    powinvs[i]=powinvs[i-1]*inv_2%MOD\r\ndef binom(n,m):\r\n    return facts[n]*factinvs[m]*factinvs[n-m]%MOD\r\ndef solve():\r\n    n,m,k=map(int,input().split())\r\n    if n==m:\r\n        print((m*k)%MOD)\r\n        return\r\n    res=0\r\n    for i in range(1,m+1):\r\n        c=binom(n-i-1,m-i)\r\n        p=powinvs[n-i]\r\n        res+=(c*p*i*k)%MOD\r\n        res%=MOD\r\n    print(res)\r\n \r\nfor _ in range(int(input())):solve()",
    "prob_desc_created_at": "1642862100",
    "tags": [
        "combinatorics",
        "dp",
        "games"
    ],
    "hidden_unit_tests": ""
}
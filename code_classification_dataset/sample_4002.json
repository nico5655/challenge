{
    "prob_desc_time_limit": "3 seconds",
    "prob_desc_sample_outputs": "[\"3\", \"0\"]",
    "src_uid": "3dc14d8d19938d9a5ed8323fe608f581",
    "prob_desc_notes": null,
    "prob_desc_description": "You are given $$$n$$$ segments on a number line, numbered from $$$1$$$ to $$$n$$$. The $$$i$$$-th segments covers all integer points from $$$l_i$$$ to $$$r_i$$$ and has a value $$$w_i$$$.You are asked to select a subset of these segments (possibly, all of them). Once the subset is selected, it's possible to travel between two integer points if there exists a selected segment that covers both of them. A subset is good if it's possible to reach point $$$m$$$ starting from point $$$1$$$ in arbitrary number of moves.The cost of the subset is the difference between the maximum and the minimum values of segments in it. Find the minimum cost of a good subset.In every test there exists at least one good subset.",
    "prob_desc_output_spec": "Print a single integer — the minimum cost of a good subset.",
    "prob_desc_input_spec": "The first line contains two integers $$$n$$$ and $$$m$$$ ($$$1 \\le n \\le 3 \\cdot 10^5$$$; $$$2 \\le m \\le 10^6$$$) — the number of segments and the number of integer points. Each of the next $$$n$$$ lines contains three integers $$$l_i$$$, $$$r_i$$$ and $$$w_i$$$ ($$$1 \\le l_i &lt; r_i \\le m$$$; $$$1 \\le w_i \\le 10^6$$$) — the description of the $$$i$$$-th segment. In every test there exists at least one good subset.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3-64",
    "lang_cluster": "Python",
    "difficulty": 2100,
    "file_name": "train_088.jsonl",
    "code_uid": "5ddb90d6a6d600f3803336cf0ac1b199",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"5 12\\n1 5 5\\n3 4 10\\n4 10 6\\n11 12 5\\n10 12 3\", \"1 10\\n1 10 23\"]",
    "exec_outcome": "PASSED",
    "source_code": "import bisect\r\nimport sys\r\ninput = sys.stdin.readline\r\nfrom collections import defaultdict, deque\r\nfrom itertools import permutations, accumulate\r\nfrom functools import reduce\r\np = print\r\nr = range\r\ndef I(): return int(input())\r\ndef II(): return list(map(int, input().split()))\r\ndef S(): return input()[:-1]\r\ndef M(n): return [list(map(int, input().split())) for ___ in r(n)]\r\ndef pb(b): print('Yes' if b else 'No')\r\ndef INF(): return float('inf')\r\n\r\n\r\nINF = 8 * 10 ** 18\r\nMOD = 998244353\r\nMASK = 32\r\n\r\n\r\n\r\nclass LazySegTree:\r\n    def __init__(self, op, e, mapping, composition, id, n = -1, v= []):\r\n        if(len(v) == 0):\r\n            v = [e] * n\r\n        self.__n = len(v)\r\n        self.__log = (self.__n - 1).bit_length()\r\n        self.__size = 1 << self.__log\r\n        self.__d = [e] * (2 * self.__size)\r\n        self.__lz = [id] * self.__size\r\n        self.__op = op\r\n        self.__e = e\r\n        self.__mapping = mapping\r\n        self.__composition = composition\r\n        self.__id = id\r\n\r\n        for i in range(self.__n):\r\n            self.__d[self.__size + i] = v[i]\r\n        for i in range(self.__size - 1, 0, -1):\r\n            self.__update(i)\r\n\r\n    def __update(self, k):\r\n        self.__d[k] = self.__op(self.__d[2 * k], self.__d[2 * k + 1])\r\n\r\n    def __all_apply(self, k, f):\r\n        self.__d[k] = self.__mapping(f, self.__d[k])\r\n        if(k < self.__size):\r\n            self.__lz[k] = self.__composition(f, self.__lz[k])\r\n\r\n    def __push(self, k):\r\n        self.__all_apply(2 * k, self.__lz[k])\r\n        self.__all_apply(2 * k + 1, self.__lz[k])\r\n        self.__lz[k] = self.__id\r\n\r\n    def set(self, p, x):\r\n        p += self.__size\r\n        for i in range(self.__log, 0, -1):\r\n            self.__push(p >> i)\r\n        self.__d[p] = x\r\n        for i in range(1, self.__log + 1):\r\n            self.__update(p >> i)\r\n\r\n    def get(self, p):\r\n        p += self.__size\r\n        for i in range(self.__log, 0, -1):\r\n            self.__push(p >> i)\r\n        return self.__d[p]\r\n\r\n    def prod(self, l, r):\r\n        if(l == r):\r\n            return self.__e\r\n\r\n        l += self.__size\r\n        r += self.__size\r\n\r\n        for i in range(self.__log, 0, -1):\r\n            if((l >> i) << i) != l:\r\n                self.__push(l >> i)\r\n            if((r >> i) << i) != r:\r\n                self.__push(r >> i)\r\n\r\n        sml = self.__e\r\n        smr = self.__e\r\n        while(l < r):\r\n            if(l & 1):\r\n                sml = self.__op(sml, self.__d[l])\r\n                l += 1\r\n            if(r & 1):\r\n                r -= 1\r\n                smr = self.__op(self.__d[r], smr)\r\n            l //= 2\r\n            r //= 2\r\n\r\n        return self.__op(sml, smr)\r\n\r\n    def all_prod(self):\r\n        return self.__d[1]\r\n\r\n    def apply(self, p, f):\r\n        p += self.__size\r\n        for i in range(self.__log, 0, -1):\r\n            self.__push(p >> i)\r\n        self.__d[p] = self.__mapping(f, self.__d[p])\r\n        for i in range(1, self.__log + 1):\r\n            self.__update(p >> i)\r\n\r\n    def apply_range(self, l, r, f):\r\n        if(l == r):\r\n            return\r\n\r\n        l += self.__size\r\n        r += self.__size\r\n\r\n        for i in range(self.__log, 0, -1):\r\n            if((l >> i) << i) != l:\r\n                self.__push(l >> i)\r\n            if((r >> i) << i) != r:\r\n                self.__push((r - 1) >> i)\r\n\r\n        l2, r2 = l, r\r\n        while(l < r):\r\n            if(l & 1):\r\n                self.__all_apply(l, f)\r\n                l += 1\r\n            if(r & 1):\r\n                r -= 1\r\n                self.__all_apply(r, f)\r\n            l //= 2\r\n            r //= 2\r\n        l, r = l2, r2\r\n\r\n        for i in range(1, self.__log + 1):\r\n            if((l >> i) << i) != l:\r\n                self.__update(l >> i)\r\n            if((r >> i) << i) != r:\r\n                self.__update((r - 1) >> i)\r\n\r\n    def max_right(self, l, g):\r\n        if(l == self.__n):\r\n            return self.__n\r\n        l += self.__size\r\n        for i in range(self.__log, 0, -1):\r\n            self.__push(l >> i)\r\n        sm = self.__e\r\n        while(True):\r\n            while(l % 2 == 0):\r\n                l //= 2\r\n            if(not g(self.__op(sm, self.__d[l]))):\r\n                while(l < self.__size):\r\n                    self.__push(l)\r\n                    l *= 2\r\n                    if(g(self.__op(sm, self.__d[l]))):\r\n                        sm = self.__op(sm, self.__d[l])\r\n                        l += 1\r\n                return l - self.__size\r\n            sm = self.__op(sm, self.__d[l])\r\n            l += 1\r\n            if(l & -l) == l:\r\n                break\r\n        return self.__n\r\n\r\n    def min_left(self, r, g):\r\n        if(r == 0):\r\n            return 0\r\n        r += self.__size\r\n        for i in range(self.__log, 0, -1):\r\n            self.__push((r - 1) >> i)\r\n        sm = self.__e\r\n        while(True):\r\n            r -= 1\r\n            while(r > 1) & (r % 2):\r\n                r //= 2\r\n            if(not g(self.__op(self.__d[r], sm))):\r\n                while(r < self.__size):\r\n                    self.__push(r)\r\n                    r = 2 * r + 1\r\n                    if(g(self.__op(self.__d[r], sm))):\r\n                        sm = self.__op(self.__d[r], sm)\r\n                        r -= 1\r\n                return r + 1 - self.__size\r\n            sm = self.__op(self.__d[r], sm)\r\n            if(r & -r) == r:\r\n                break\r\n        return 0\r\n\r\n    def all_push(self):\r\n        for i in range(1, self.__size):\r\n            self.__push(i)\r\n\r\n    def get_all(self):\r\n        self.all_push()\r\n        return self.__d[self.__size:self.__size + self.__n]\r\n\r\n    def print(self):\r\n        print(list(map(lambda x: divmod(x, (1 << 30)), self.__d)))\r\n        print(self.__lz)\r\n        print('------------------')\r\n\r\ne = INF\r\nid = 0\r\n\r\n\r\ndef op(a, b):\r\n    return min(a, b)\r\n\r\n\r\ndef mapping(f, a):\r\n    return a + f\r\n\r\n\r\ndef composition(f, g):\r\n    return f + g\r\n\r\n# -----------------------------------------------------------------------------------------------------\r\n#\r\n# 　　　　　　　　　　　 ∧＿∧\r\n# 　　　　　 ∧＿∧ 　 （´<_｀ ）　     Welcome to My Coding Space !\r\n# 　　　　 （ ´_ゝ`）　/　 ⌒i        Free Hong Kong !\r\n# 　　　　／　　　＼　 　  |　|       Free Tibet !\r\n# 　　　 /　　 /￣￣￣￣/　|　 |\r\n# 　 ＿_(__ﾆつ/　    ＿/ .| .|＿＿＿＿\r\n# 　 　　　＼/＿＿＿＿/　（u　⊃\r\n#\r\n#     BINARY SEARCH ?\r\n#     CHANGE TO GRAPH?\r\n#     pow(x,-1,q) PLEASE USE [python 3.8.2]\r\n# -----------------------------------------------------------------------------------------------------\r\nn, m = II()\r\nquery = sorted(M(n), key= lambda x: x[2])\r\nfor i in r(n):\r\n    query[i][1] -= 1\r\nseg = LazySegTree(op, e, mapping, composition, id, m, [0]*(m))\r\nhi = 1\r\nlo = 0\r\n#p(query)\r\nseg.apply_range(query[0][0], query[0][1] + 1, 1)\r\n#p(*[seg.get(i) for i in r(m)])\r\nres = INF\r\nwhile lo < n and hi <= n:\r\n    check = seg.prod(1,m)\r\n    if check > 0:\r\n        res = min(res, query[hi-1][2] - query[lo][2])\r\n        seg.apply_range(query[lo][0], query[lo][1] + 1, -1)\r\n        lo += 1\r\n    else:\r\n        if hi >= n:\r\n            break\r\n        seg.apply_range(query[hi][0], query[hi][1] + 1, 1)\r\n        hi += 1\r\n    #p(lo,hi,res)\r\n    #p(*[seg.get(i) for i in r(1,m-1)])\r\np(res)\r\n\r\n",
    "prob_desc_created_at": "1627655700",
    "tags": [
        "data structures",
        "sortings",
        "trees",
        "two pointers"
    ],
    "hidden_unit_tests": ""
}
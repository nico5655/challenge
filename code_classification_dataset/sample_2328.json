{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"4\", \"24000\", \"-1\"]",
    "src_uid": "4dce15ff1446b5af2c5b49ee2d30bbb8",
    "prob_desc_notes": "NoteThe tree corresponding to samples $$$1$$$ and $$$2$$$ are: In sample $$$1$$$, we can choose node $$$1$$$ and $$$k = 4$$$ for a cost of $$$4 \\cdot 1$$$ = $$$4$$$ and select nodes $$${1, 2, 3, 5}$$$, shuffle their digits and get the desired digits in every node.In sample $$$2$$$, we can choose node $$$1$$$ and $$$k = 2$$$ for a cost of $$$10000 \\cdot 2$$$, select nodes $$${1, 5}$$$ and exchange their digits, and similarly, choose node $$$2$$$ and $$$k = 2$$$ for a cost of $$$2000 \\cdot 2$$$, select nodes $$${2, 3}$$$ and exchange their digits to get the desired digits in every node.In sample $$$3$$$, it is impossible to get the desired digits, because there is no node with digit $$$1$$$ initially.",
    "prob_desc_description": "Ashish has a tree consisting of $$$n$$$ nodes numbered $$$1$$$ to $$$n$$$ rooted at node $$$1$$$. The $$$i$$$-th node in the tree has a cost $$$a_i$$$, and binary digit $$$b_i$$$ is written in it. He wants to have binary digit $$$c_i$$$ written in the $$$i$$$-th node in the end.To achieve this, he can perform the following operation any number of times:   Select any $$$k$$$ nodes from the subtree of any node $$$u$$$, and shuffle the digits in these nodes as he wishes, incurring a cost of $$$k \\cdot a_u$$$. Here, he can choose $$$k$$$ ranging from $$$1$$$ to the size of the subtree of $$$u$$$. He wants to perform the operations in such a way that every node finally has the digit corresponding to its target.Help him find the minimum total cost he needs to spend so that after all the operations, every node $$$u$$$ has digit $$$c_u$$$ written in it, or determine that it is impossible.",
    "prob_desc_output_spec": "Print the minimum total cost to make every node reach its target digit, and $$$-1$$$ if it is impossible.",
    "prob_desc_input_spec": "First line contains a single integer $$$n$$$ $$$(1 \\le n \\le 2 \\cdot 10^5)$$$ denoting the number of nodes in the tree. $$$i$$$-th line of the next $$$n$$$ lines contains 3 space-separated integers $$$a_i$$$, $$$b_i$$$, $$$c_i$$$ $$$(1 \\leq a_i \\leq 10^9, 0 \\leq b_i, c_i \\leq 1)$$$  — the cost of the $$$i$$$-th node, its initial digit and its goal digit. Each of the next $$$n - 1$$$ lines contain two integers $$$u$$$, $$$v$$$ $$$(1 \\leq u, v \\leq n, \\text{ } u \\ne v)$$$, meaning that there is an edge between nodes $$$u$$$ and $$$v$$$ in the tree.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3",
    "lang_cluster": "Python",
    "difficulty": 2000,
    "file_name": "train_020.jsonl",
    "code_uid": "70c3b97d4d35c113382d265d2e48e5a4",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"5\\n1 0 1\\n20 1 0\\n300 0 1\\n4000 0 0\\n50000 1 0\\n1 2\\n2 3\\n2 4\\n1 5\", \"5\\n10000 0 1\\n2000 1 0\\n300 0 1\\n40 0 0\\n1 1 0\\n1 2\\n2 3\\n2 4\\n1 5\", \"2\\n109 0 1\\n205 0 1\\n1 2\"]",
    "exec_outcome": "PASSED",
    "source_code": "\"\"\" Python 3 compatibility tools. \"\"\"\nfrom __future__ import division, print_function\nimport itertools\nimport sys, threading\nimport os\nfrom io import BytesIO, IOBase\nfrom types import GeneratorType\n\ndef is_it_local():\n  script_dir = str(os.getcwd()).split('/')\n  username = \"dipta007\"\n  return username in script_dir\n\n\ndef READ(fileName):\n  if is_it_local():\n    sys.stdin = open(f'./{fileName}', 'r')\n\n# region fastio\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n  newlines = 0\n\n  def __init__(self, file):\n    self._fd = file.fileno()\n    self.buffer = BytesIO()\n    self.writable = \"x\" in file.mode or \"r\" not in file.mode\n    self.write = self.buffer.write if self.writable else None\n\n  def read(self):\n    while True:\n      b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n      if not b:\n          break\n      ptr = self.buffer.tell()\n      self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n    self.newlines = 0\n    return self.buffer.read()\n\n  def readline(self):\n    while self.newlines == 0:\n      b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n      self.newlines = b.count(b\"\\n\") + (not b)\n      ptr = self.buffer.tell()\n      self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n    self.newlines -= 1\n    return self.buffer.readline()\n\n  def flush(self):\n    if self.writable:\n      os.write(self._fd, self.buffer.getvalue())\n      self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n  def __init__(self, file):\n    self.buffer = FastIO(file)\n    self.flush = self.buffer.flush\n    self.writable = self.buffer.writable\n    self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n    self.read = lambda: self.buffer.read().decode(\"ascii\")\n    self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nif not is_it_local():\n  sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\n  input = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n# endregion\n\n\ndef input1(type=int):\n  return type(input())\n\n\ndef input2(type=int):\n  [a, b] = list(map(type, input().split()))\n  return a, b\n\n\ndef input3(type=int):\n  [a, b, c] = list(map(type, input().split()))\n  return a, b, c\n\n\ndef input_array(type=int):\n  return list(map(type, input().split()))\n\n\ndef input_string():\n  s = input()\n  return list(s)\n\n##############################################################\n\nadj = {}\nlabel = []\ntarget = []\ncost = []\ndata = []\n\ndef merge(a, b):\n  # node number, zero number, one number, correct, need zero, need one\n  tmp = [a[0] + b[0], a[1] + b[1], a[2] + b[2], a[3] + b[3], a[4] + b[4], a[5] + b[5]]\n  return tmp\n\ndef bootstrap(f, stack=[]):\n  def wrappedfunc(*args, **kwargs):\n    to = f(*args, **kwargs)\n    if stack:\n      return to\n    else:\n      while True:\n        if type(to) is GeneratorType:\n          stack.append(to)\n          to = next(to)\n        else:\n          stack.pop()\n          if not stack:\n              return to\n          to = stack[-1].send(to)\n  return wrappedfunc\n\n@bootstrap\ndef dfs1(u, p):\n  global data, label, target, adj, cost\n  now = [\n    1, \n    1 if label[u] == 0 and label[u] != target[u] else 0, \n    1 if label[u] == 1 and label[u] != target[u] else 0, \n    1 if label[u] == target[u] else 0, \n    1 if target[u] == 0 and label[u] != target[u] else 0, \n    1 if target[u] == 1 and label[u] != target[u] else 0\n  ]\n\n  if p != -1:\n    cost[u] = min(cost[u], cost[p])\n\n  if u in adj:\n    for v in adj[u]:\n      if v != p:\n        tmp = yield dfs1(v, u)\n        now = merge(now, tmp)\n\n  data[u] = now\n  yield now\n\n\nres = 0\n\n@bootstrap\ndef call(u, p):\n  global data, label, target, adj, cost, res\n  \n  f_0, f_1 = 0, 0\n  if u in adj:\n    for v in adj[u]:\n      if v != p:\n        n_0, n_1 = yield call(v, u)\n        f_0 += n_0\n        f_1 += n_1\n\n  now = data[u]\n  can_be_fixed_zero = min(now[4], now[1]) - f_0\n  can_be_fixed_one = min(now[5], now[2]) - f_1\n  not_fixed = can_be_fixed_zero + can_be_fixed_one\n  res += not_fixed * cost[u]\n\n  yield f_0 + can_be_fixed_zero, f_1 + can_be_fixed_one\n\ndef main():\n  global data, label, target, adj, cost\n  n = input1()\n  data = [0 for _ in range(n+4)]\n  label = [0 for _ in range(n+4)]\n  target = [0 for _ in range(n+4)]\n  cost = [0 for _ in range(n+4)]\n\n  z, o, tz, to = 0, 0, 0, 0\n  for i in range(1, n+1):\n    cost[i], label[i], target[i] = input3()\n    z += (label[i] == 0)\n    o += (label[i] == 1)\n\n    tz += (target[i] == 0)\n    to += (target[i] == 1)\n  \n  adj = {}\n  for i in range(n-1):\n    u, v = input2()\n    if u not in adj:\n      adj[u] = []\n    if v not in adj:\n      adj[v] = []\n\n    adj[u].append(v)\n    adj[v].append(u)\n\n\n  if (tz != z or o != to):\n    print(-1)\n    exit()\n  dfs1(1, -1)\n\n  # for i in range(1, n+1):\n  #   print(data[i], cost[i])\n\n  global res\n  res = 0\n  call(1, -1)\n  print(res)\n  pass\n\nif __name__ == '__main__':\n  # sys.setrecursionlimit(2**32//2-1)\n  # threading.stack_size(1 << 27)\n\n  # thread = threading.Thread(target=main)\n  # thread.start()\n  # thread.join()\n  # sys.setrecursionlimit(200004)\n  # READ('in.txt')\n  main()",
    "prob_desc_created_at": "1590935700",
    "tags": [
        "dp",
        "dfs and similar",
        "greedy",
        "trees"
    ],
    "hidden_unit_tests": ""
}
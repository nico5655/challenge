{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"2\", \"23\", \"1\"]",
    "src_uid": "f898d3a58e0ae6ac07d0d14620d47d27",
    "prob_desc_notes": "NoteIn the first example, the strings we are interested in are $$$[1\\, 2\\, 2]$$$ and $$$[2\\, 1\\, 2]$$$. The string $$$[2\\, 2\\, 1]$$$ is lexicographically larger than the string $$$[2\\, 1\\, 2\\, 1]$$$, so we don't count it.In the second example, all strings count except $$$[4\\, 3\\, 2\\, 1]$$$, so the answer is $$$4! - 1 = 23$$$.In the third example, only the string $$$[1\\, 1\\, 1\\, 2]$$$ counts.",
    "prob_desc_description": "While looking at the kitchen fridge, the little boy Tyler noticed magnets with symbols, that can be aligned into a string $$$s$$$.Tyler likes strings, and especially those that are lexicographically smaller than another string, $$$t$$$. After playing with magnets on the fridge, he is wondering, how many distinct strings can be composed out of letters of string $$$s$$$ by rearranging them, so that the resulting string is lexicographically smaller than the string $$$t$$$? Tyler is too young, so he can't answer this question. The alphabet Tyler uses is very large, so for your convenience he has already replaced the same letters in $$$s$$$ and $$$t$$$ to the same integers, keeping that different letters have been replaced to different integers.We call a string $$$x$$$ lexicographically smaller than a string $$$y$$$ if one of the followings conditions is fulfilled:   There exists such position of symbol $$$m$$$ that is presented in both strings, so that before $$$m$$$-th symbol the strings are equal, and the $$$m$$$-th symbol of string $$$x$$$ is smaller than $$$m$$$-th symbol of string $$$y$$$.  String $$$x$$$ is the prefix of string $$$y$$$ and $$$x \\neq y$$$. Because the answer can be too large, print it modulo $$$998\\,244\\,353$$$.",
    "prob_desc_output_spec": "Print a single number — the number of strings lexicographically smaller than $$$t$$$ that can be obtained by rearranging the letters in $$$s$$$, modulo $$$998\\,244\\,353$$$.",
    "prob_desc_input_spec": "The first line contains two integers $$$n$$$ and $$$m$$$ ($$$1 \\le n, m \\le 200\\,000$$$) — the lengths of strings $$$s$$$ and $$$t$$$ respectively. The second line contains $$$n$$$ integers $$$s_1, s_2, s_3, \\ldots, s_n$$$ ($$$1 \\le s_i \\le 200\\,000$$$) — letters of the string $$$s$$$. The third line contains $$$m$$$ integers $$$t_1, t_2, t_3, \\ldots, t_m$$$ ($$$1 \\le t_i \\le 200\\,000$$$) — letters of the string $$$t$$$.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3-64",
    "lang_cluster": "Python",
    "difficulty": 1900,
    "file_name": "train_091.jsonl",
    "code_uid": "ecc14ace4b8f29d14fae45f6e540df95",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"3 4\\n1 2 2\\n2 1 2 1\", \"4 4\\n1 2 3 4\\n4 3 2 1\", \"4 3\\n1 1 1 2\\n1 1 2\"]",
    "exec_outcome": "PASSED",
    "source_code": "from __future__ import print_function\r\n\r\nfrom bisect import bisect_left, bisect_right, insort\r\nfrom collections import Sequence, MutableSequence\r\nfrom functools import wraps\r\nfrom itertools import chain, repeat, starmap\r\nfrom math import log as log_e\r\nimport operator as op\r\nfrom operator import iadd, add\r\nfrom sys import hexversion\r\n\r\nif hexversion < 0x03000000:\r\n    from itertools import izip as zip  \r\n    from itertools import imap as map  \r\n    try:\r\n        from thread import get_ident\r\n    except ImportError:\r\n        from dummy_thread import get_ident\r\nelse:\r\n    from functools import reduce\r\n    try:\r\n        from _thread import get_ident\r\n    except ImportError:\r\n        from _dummy_thread import get_ident \r\nLOAD = 1000\r\n\r\ndef recursive_repr(func):\r\n\r\n    repr_running = set()\r\n\r\n    @wraps(func)\r\n    def wrapper(self):\r\n        key = id(self), get_ident()\r\n\r\n        if key in repr_running:\r\n            return '...'\r\n\r\n        repr_running.add(key)\r\n\r\n        try:\r\n            return func(self)\r\n        finally:\r\n            repr_running.discard(key)\r\n\r\n    return wrapper\r\n\r\nclass SortedList(MutableSequence):\r\n\r\n    def __init__(self, iterable=None):\r\n\r\n        self._len = 0\r\n        self._lists = []\r\n        self._maxes = []\r\n        self._index = []\r\n        self._load = LOAD\r\n        self._half = LOAD >> 1\r\n        self._dual = LOAD << 1\r\n        self._offset = 0\r\n\r\n        if iterable is not None:\r\n            self._update(iterable)\r\n\r\n    def __new__(cls, iterable=None, key=None):\r\n        if key is None:\r\n            return object.__new__(cls)\r\n        else:\r\n            if cls is SortedList:\r\n                return object.__new__(SortedListWithKey)\r\n            else:\r\n                raise TypeError('inherit SortedListWithKey for key argument')\r\n\r\n    @property\r\n    def key(self):\r\n        return None\r\n\r\n    def _reset(self, load):\r\n    \r\n        values = reduce(iadd, self._lists, [])\r\n        self._clear()\r\n        self._load = load\r\n        self._half = load >> 1\r\n        self._dual = load << 1\r\n        self._update(values)\r\n\r\n    def clear(self):\r\n        self._len = 0\r\n        del self._lists[:]\r\n        del self._maxes[:]\r\n        del self._index[:]\r\n\r\n    _clear = clear\r\n\r\n    def add(self, val):\r\n        _lists = self._lists\r\n        _maxes = self._maxes\r\n\r\n        if _maxes:\r\n            pos = bisect_right(_maxes, val)\r\n\r\n            if pos == len(_maxes):\r\n                pos -= 1\r\n                _lists[pos].append(val)\r\n                _maxes[pos] = val\r\n            else:\r\n                insort(_lists[pos], val)\r\n\r\n            self._expand(pos)\r\n        else:\r\n            _lists.append([val])\r\n            _maxes.append(val)\r\n\r\n        self._len += 1\r\n\r\n    def _expand(self, pos):\r\n        _lists = self._lists\r\n        _index = self._index\r\n\r\n        if len(_lists[pos]) > self._dual:\r\n            _maxes = self._maxes\r\n            _load = self._load\r\n\r\n            _lists_pos = _lists[pos]\r\n            half = _lists_pos[_load:]\r\n            del _lists_pos[_load:]\r\n            _maxes[pos] = _lists_pos[-1]\r\n\r\n            _lists.insert(pos + 1, half)\r\n            _maxes.insert(pos + 1, half[-1])\r\n\r\n            del _index[:]\r\n        else:\r\n            if _index:\r\n                child = self._offset + pos\r\n                while child:\r\n                    _index[child] += 1\r\n                    child = (child - 1) >> 1\r\n                _index[0] += 1\r\n\r\n    def update(self, iterable):\r\n        _lists = self._lists\r\n        _maxes = self._maxes\r\n        values = sorted(iterable)\r\n\r\n        if _maxes:\r\n            if len(values) * 4 >= self._len:\r\n                values.extend(chain.from_iterable(_lists))\r\n                values.sort()\r\n                self._clear()\r\n            else:\r\n                _add = self.add\r\n                for val in values:\r\n                    _add(val)\r\n                return\r\n\r\n        _load = self._load\r\n        _lists.extend(values[pos:(pos + _load)]\r\n                      for pos in range(0, len(values), _load))\r\n        _maxes.extend(sublist[-1] for sublist in _lists)\r\n        self._len = len(values)\r\n        del self._index[:]\r\n\r\n    _update = update\r\n\r\n    def __contains__(self, val):\r\n        _maxes = self._maxes\r\n\r\n        if not _maxes:\r\n            return False\r\n\r\n        pos = bisect_left(_maxes, val)\r\n\r\n        if pos == len(_maxes):\r\n            return False\r\n\r\n        _lists = self._lists\r\n        idx = bisect_left(_lists[pos], val)\r\n\r\n        return _lists[pos][idx] == val\r\n\r\n    def discard(self, val):\r\n        _maxes = self._maxes\r\n\r\n        if not _maxes:\r\n            return\r\n\r\n        pos = bisect_left(_maxes, val)\r\n\r\n        if pos == len(_maxes):\r\n            return\r\n\r\n        _lists = self._lists\r\n        idx = bisect_left(_lists[pos], val)\r\n\r\n        if _lists[pos][idx] == val:\r\n            self._delete(pos, idx)\r\n\r\n    def remove(self, val):\r\n        _maxes = self._maxes\r\n\r\n        if not _maxes:\r\n            raise ValueError('{0!r} not in list'.format(val))\r\n\r\n        pos = bisect_left(_maxes, val)\r\n\r\n        if pos == len(_maxes):\r\n            raise ValueError('{0!r} not in list'.format(val))\r\n\r\n        _lists = self._lists\r\n        idx = bisect_left(_lists[pos], val)\r\n\r\n        if _lists[pos][idx] == val:\r\n            self._delete(pos, idx)\r\n        else:\r\n            raise ValueError('{0!r} not in list'.format(val))\r\n\r\n    def _delete(self, pos, idx):\r\n        _lists = self._lists\r\n        _maxes = self._maxes\r\n        _index = self._index\r\n\r\n        _lists_pos = _lists[pos]\r\n\r\n        del _lists_pos[idx]\r\n        self._len -= 1\r\n\r\n        len_lists_pos = len(_lists_pos)\r\n\r\n        if len_lists_pos > self._half:\r\n\r\n            _maxes[pos] = _lists_pos[-1]\r\n\r\n            if _index:\r\n                child = self._offset + pos\r\n                while child > 0:\r\n                    _index[child] -= 1\r\n                    child = (child - 1) >> 1\r\n                _index[0] -= 1\r\n\r\n        elif len(_lists) > 1:\r\n\r\n            if not pos:\r\n                pos += 1\r\n\r\n            prev = pos - 1\r\n            _lists[prev].extend(_lists[pos])\r\n            _maxes[prev] = _lists[prev][-1]\r\n\r\n            del _lists[pos]\r\n            del _maxes[pos]\r\n            del _index[:]\r\n\r\n            self._expand(prev)\r\n\r\n        elif len_lists_pos:\r\n\r\n            _maxes[pos] = _lists_pos[-1]\r\n\r\n        else:\r\n\r\n            del _lists[pos]\r\n            del _maxes[pos]\r\n            del _index[:]\r\n\r\n    def _loc(self, pos, idx):\r\n    \r\n        if not pos:\r\n            return idx\r\n\r\n        _index = self._index\r\n\r\n        if not _index:\r\n            self._build_index()\r\n\r\n        total = 0\r\n\r\n        pos += self._offset\r\n\r\n        while pos:\r\n\r\n            if not pos & 1:\r\n                total += _index[pos - 1]\r\n\r\n            pos = (pos - 1) >> 1\r\n\r\n        return total + idx\r\n\r\n    def _pos(self, idx):\r\n\r\n        if idx < 0:\r\n            last_len = len(self._lists[-1])\r\n\r\n            if (-idx) <= last_len:\r\n                return len(self._lists) - 1, last_len + idx\r\n\r\n            idx += self._len\r\n\r\n            if idx < 0:\r\n                raise IndexError('list index out of range')\r\n        elif idx >= self._len:\r\n            raise IndexError('list index out of range')\r\n\r\n        if idx < len(self._lists[0]):\r\n            return 0, idx\r\n\r\n        _index = self._index\r\n\r\n        if not _index:\r\n            self._build_index()\r\n\r\n        pos = 0\r\n        child = 1\r\n        len_index = len(_index)\r\n\r\n        while child < len_index:\r\n            index_child = _index[child]\r\n\r\n            if idx < index_child:\r\n                pos = child\r\n            else:\r\n                idx -= index_child\r\n                pos = child + 1\r\n\r\n            child = (pos << 1) + 1\r\n\r\n        return (pos - self._offset, idx)\r\n\r\n    def _build_index(self):\r\n    \r\n        row0 = list(map(len, self._lists))\r\n\r\n        if len(row0) == 1:\r\n            self._index[:] = row0\r\n            self._offset = 0\r\n            return\r\n\r\n        head = iter(row0)\r\n        tail = iter(head)\r\n        row1 = list(starmap(add, zip(head, tail)))\r\n\r\n        if len(row0) & 1:\r\n            row1.append(row0[-1])\r\n\r\n        if len(row1) == 1:\r\n            self._index[:] = row1 + row0\r\n            self._offset = 1\r\n            return\r\n\r\n        size = 2 ** (int(log_e(len(row1) - 1, 2)) + 1)\r\n        row1.extend(repeat(0, size - len(row1)))\r\n        tree = [row0, row1]\r\n\r\n        while len(tree[-1]) > 1:\r\n            head = iter(tree[-1])\r\n            tail = iter(head)\r\n            row = list(starmap(add, zip(head, tail)))\r\n            tree.append(row)\r\n\r\n        reduce(iadd, reversed(tree), self._index)\r\n        self._offset = size * 2 - 1\r\n\r\n    def __delitem__(self, idx):\r\n        if isinstance(idx, slice):\r\n            start, stop, step = idx.indices(self._len)\r\n\r\n            if step == 1 and start < stop:\r\n                if start == 0 and stop == self._len:\r\n                    return self._clear()\r\n                elif self._len <= 8 * (stop - start):\r\n                    values = self._getitem(slice(None, start))\r\n                    if stop < self._len:\r\n                        values += self._getitem(slice(stop, None))\r\n                    self._clear()\r\n                    return self._update(values)\r\n\r\n            indices = range(start, stop, step)\r\n\r\n\r\n            if step > 0:\r\n                indices = reversed(indices)\r\n\r\n            _pos, _delete = self._pos, self._delete\r\n\r\n            for index in indices:\r\n                pos, idx = _pos(index)\r\n                _delete(pos, idx)\r\n        else:\r\n            pos, idx = self._pos(idx)\r\n            self._delete(pos, idx)\r\n\r\n    _delitem = __delitem__\r\n\r\n    def __getitem__(self, idx):\r\n        _lists = self._lists\r\n\r\n        if isinstance(idx, slice):\r\n            start, stop, step = idx.indices(self._len)\r\n\r\n            if step == 1 and start < stop:\r\n                if start == 0 and stop == self._len:\r\n                    return reduce(iadd, self._lists, [])\r\n\r\n                start_pos, start_idx = self._pos(start)\r\n\r\n                if stop == self._len:\r\n                    stop_pos = len(_lists) - 1\r\n                    stop_idx = len(_lists[stop_pos])\r\n                else:\r\n                    stop_pos, stop_idx = self._pos(stop)\r\n\r\n                if start_pos == stop_pos:\r\n                    return _lists[start_pos][start_idx:stop_idx]\r\n\r\n                prefix = _lists[start_pos][start_idx:]\r\n                middle = _lists[(start_pos + 1):stop_pos]\r\n                result = reduce(iadd, middle, prefix)\r\n                result += _lists[stop_pos][:stop_idx]\r\n\r\n                return result\r\n\r\n            if step == -1 and start > stop:\r\n                result = self._getitem(slice(stop + 1, start + 1))\r\n                result.reverse()\r\n                return result\r\n\r\n            indices = range(start, stop, step)\r\n            return list(self._getitem(index) for index in indices)\r\n        else:\r\n            if self._len:\r\n                if idx == 0:\r\n                    return _lists[0][0]\r\n                elif idx == -1:\r\n                    return _lists[-1][-1]\r\n            else:\r\n                raise IndexError('list index out of range')\r\n\r\n            if 0 <= idx < len(_lists[0]):\r\n                return _lists[0][idx]\r\n\r\n            len_last = len(_lists[-1])\r\n\r\n            if -len_last < idx < 0:\r\n                return _lists[-1][len_last + idx]\r\n\r\n            pos, idx = self._pos(idx)\r\n            return _lists[pos][idx]\r\n\r\n    _getitem = __getitem__\r\n\r\n    def _check_order(self, idx, val):\r\n        _len = self._len\r\n        _lists = self._lists\r\n\r\n        pos, loc = self._pos(idx)\r\n\r\n        if idx < 0:\r\n            idx += _len\r\n\r\n        if idx > 0:\r\n            idx_prev = loc - 1\r\n            pos_prev = pos\r\n\r\n            if idx_prev < 0:\r\n                pos_prev -= 1\r\n                idx_prev = len(_lists[pos_prev]) - 1\r\n\r\n            if _lists[pos_prev][idx_prev] > val:\r\n                msg = '{0!r} not in sort order at index {1}'.format(val, idx)\r\n                raise ValueError(msg)\r\n\r\n        if idx < (_len - 1):\r\n            idx_next = loc + 1\r\n            pos_next = pos\r\n\r\n            if idx_next == len(_lists[pos_next]):\r\n                pos_next += 1\r\n                idx_next = 0\r\n\r\n            if _lists[pos_next][idx_next] < val:\r\n                msg = '{0!r} not in sort order at index {1}'.format(val, idx)\r\n                raise ValueError(msg)\r\n\r\n    def __setitem__(self, index, value):\r\n        _lists = self._lists\r\n        _maxes = self._maxes\r\n        _check_order = self._check_order\r\n        _pos = self._pos\r\n\r\n        if isinstance(index, slice):\r\n            _len = self._len\r\n            start, stop, step = index.indices(_len)\r\n            indices = range(start, stop, step)\r\n\r\n            values = tuple(value)\r\n\r\n            if step != 1:\r\n                if len(values) != len(indices):\r\n                    raise ValueError(\r\n                        'attempt to assign sequence of size %s'\r\n                        ' to extended slice of size %s'\r\n                        % (len(values), len(indices)))\r\n\r\n\r\n                log = []\r\n                _append = log.append\r\n\r\n                for idx, val in zip(indices, values):\r\n                    pos, loc = _pos(idx)\r\n                    _append((idx, _lists[pos][loc], val))\r\n                    _lists[pos][loc] = val\r\n                    if len(_lists[pos]) == (loc + 1):\r\n                        _maxes[pos] = val\r\n\r\n                try:\r\n                    for idx, _, newval in log:\r\n                        _check_order(idx, newval)\r\n\r\n                except ValueError:\r\n\r\n                    for idx, oldval, _ in log:\r\n                        pos, loc = _pos(idx)\r\n                        _lists[pos][loc] = oldval\r\n                        if len(_lists[pos]) == (loc + 1):\r\n                            _maxes[pos] = oldval\r\n\r\n                    raise\r\n            else:\r\n                if start == 0 and stop == _len:\r\n                    self._clear()\r\n                    return self._update(values)\r\n\r\n                if stop < start:\r\n                    stop = start\r\n\r\n                if values:\r\n\r\n                    alphas = iter(values)\r\n                    betas = iter(values)\r\n                    next(betas)\r\n                    pairs = zip(alphas, betas)\r\n\r\n                    if not all(alpha <= beta for alpha, beta in pairs):\r\n                        raise ValueError('given values not in sort order')\r\n\r\n                    if start and self._getitem(start - 1) > values[0]:\r\n                        message = '{0!r} not in sort order at index {1}'.format(\r\n                            values[0], start)\r\n                        raise ValueError(message)\r\n\r\n                    if stop != _len and self._getitem(stop) < values[-1]:\r\n                        message = '{0!r} not in sort order at index {1}'.format(\r\n                            values[-1], stop)\r\n                        raise ValueError(message)\r\n\r\n                self._delitem(index)\r\n\r\n                _insert = self.insert\r\n                for idx, val in enumerate(values):\r\n                    _insert(start + idx, val)\r\n        else:\r\n            pos, loc = _pos(index)\r\n            _check_order(index, value)\r\n            _lists[pos][loc] = value\r\n            if len(_lists[pos]) == (loc + 1):\r\n                _maxes[pos] = value\r\n\r\n    def __iter__(self):\r\n        return chain.from_iterable(self._lists)\r\n\r\n    def __reversed__(self):\r\n        return chain.from_iterable(map(reversed, reversed(self._lists)))\r\n\r\n    def reverse(self):\r\n    \r\n        raise NotImplementedError('.reverse() not defined')\r\n\r\n    def islice(self, start=None, stop=None, reverse=False):\r\n\r\n    \r\n        _len = self._len\r\n\r\n        if not _len:\r\n            return iter(())\r\n\r\n        start, stop, _ = slice(start, stop).indices(self._len)\r\n\r\n        if start >= stop:\r\n            return iter(())\r\n\r\n        _pos = self._pos\r\n\r\n        min_pos, min_idx = _pos(start)\r\n\r\n        if stop == _len:\r\n            max_pos = len(self._lists) - 1\r\n            max_idx = len(self._lists[-1])\r\n        else:\r\n            max_pos, max_idx = _pos(stop)\r\n\r\n        return self._islice(min_pos, min_idx, max_pos, max_idx, reverse)\r\n\r\n    def _islice(self, min_pos, min_idx, max_pos, max_idx, reverse):\r\n    \r\n        _lists = self._lists\r\n\r\n        if min_pos > max_pos:\r\n            return iter(())\r\n        elif min_pos == max_pos and not reverse:\r\n            return iter(_lists[min_pos][min_idx:max_idx])\r\n        elif min_pos == max_pos and reverse:\r\n            return reversed(_lists[min_pos][min_idx:max_idx])\r\n        elif min_pos + 1 == max_pos and not reverse:\r\n            return chain(_lists[min_pos][min_idx:], _lists[max_pos][:max_idx])\r\n        elif min_pos + 1 == max_pos and reverse:\r\n            return chain(\r\n                reversed(_lists[max_pos][:max_idx]),\r\n                reversed(_lists[min_pos][min_idx:]),\r\n            )\r\n        elif not reverse:\r\n            return chain(\r\n                _lists[min_pos][min_idx:],\r\n                chain.from_iterable(_lists[(min_pos + 1):max_pos]),\r\n                _lists[max_pos][:max_idx],\r\n            )\r\n\r\n        temp = map(reversed, reversed(_lists[(min_pos + 1):max_pos]))\r\n        return chain(\r\n            reversed(_lists[max_pos][:max_idx]),\r\n            chain.from_iterable(temp),\r\n            reversed(_lists[min_pos][min_idx:]),\r\n        )\r\n\r\n    def irange(self, minimum=None, maximum=None, inclusive=(True, True),\r\n               reverse=False):\r\n    \r\n        _maxes = self._maxes\r\n\r\n        if not _maxes:\r\n            return iter(())\r\n\r\n        _lists = self._lists\r\n\r\n\r\n        if minimum is None:\r\n            min_pos = 0\r\n            min_idx = 0\r\n        else:\r\n            if inclusive[0]:\r\n                min_pos = bisect_left(_maxes, minimum)\r\n\r\n                if min_pos == len(_maxes):\r\n                    return iter(())\r\n\r\n                min_idx = bisect_left(_lists[min_pos], minimum)\r\n            else:\r\n                min_pos = bisect_right(_maxes, minimum)\r\n\r\n                if min_pos == len(_maxes):\r\n                    return iter(())\r\n\r\n                min_idx = bisect_right(_lists[min_pos], minimum)\r\n\r\n\r\n        if maximum is None:\r\n            max_pos = len(_maxes) - 1\r\n            max_idx = len(_lists[max_pos])\r\n        else:\r\n            if inclusive[1]:\r\n                max_pos = bisect_right(_maxes, maximum)\r\n\r\n                if max_pos == len(_maxes):\r\n                    max_pos -= 1\r\n                    max_idx = len(_lists[max_pos])\r\n                else:\r\n                    max_idx = bisect_right(_lists[max_pos], maximum)\r\n            else:\r\n                max_pos = bisect_left(_maxes, maximum)\r\n\r\n                if max_pos == len(_maxes):\r\n                    max_pos -= 1\r\n                    max_idx = len(_lists[max_pos])\r\n                else:\r\n                    max_idx = bisect_left(_lists[max_pos], maximum)\r\n\r\n        return self._islice(min_pos, min_idx, max_pos, max_idx, reverse)\r\n\r\n    def __len__(self):\r\n        return self._len\r\n\r\n    def bisect_left(self, val):\r\n        _maxes = self._maxes\r\n\r\n        if not _maxes:\r\n            return 0\r\n\r\n        pos = bisect_left(_maxes, val)\r\n\r\n        if pos == len(_maxes):\r\n            return self._len\r\n\r\n        idx = bisect_left(self._lists[pos], val)\r\n\r\n        return self._loc(pos, idx)\r\n\r\n    def bisect_right(self, val):\r\n\r\n        _maxes = self._maxes\r\n\r\n        if not _maxes:\r\n            return 0\r\n\r\n        pos = bisect_right(_maxes, val)\r\n\r\n        if pos == len(_maxes):\r\n            return self._len\r\n\r\n        idx = bisect_right(self._lists[pos], val)\r\n\r\n        return self._loc(pos, idx)\r\n\r\n    bisect = bisect_right\r\n    _bisect_right = bisect_right\r\n\r\n    def count(self, val):\r\n        _maxes = self._maxes\r\n\r\n        if not _maxes:\r\n            return 0\r\n\r\n        pos_left = bisect_left(_maxes, val)\r\n\r\n        if pos_left == len(_maxes):\r\n            return 0\r\n\r\n        _lists = self._lists\r\n        idx_left = bisect_left(_lists[pos_left], val)\r\n        pos_right = bisect_right(_maxes, val)\r\n\r\n        if pos_right == len(_maxes):\r\n            return self._len - self._loc(pos_left, idx_left)\r\n\r\n        idx_right = bisect_right(_lists[pos_right], val)\r\n\r\n        if pos_left == pos_right:\r\n            return idx_right - idx_left\r\n\r\n        right = self._loc(pos_right, idx_right)\r\n        left = self._loc(pos_left, idx_left)\r\n\r\n        return right - left\r\n\r\n    def copy(self):\r\n        return self.__class__(self)\r\n\r\n    __copy__ = copy\r\n\r\n    def append(self, val):\r\n        _lists = self._lists\r\n        _maxes = self._maxes\r\n\r\n        if not _maxes:\r\n            _maxes.append(val)\r\n            _lists.append([val])\r\n            self._len = 1\r\n            return\r\n\r\n        pos = len(_lists) - 1\r\n\r\n        if val < _lists[pos][-1]:\r\n            msg = '{0!r} not in sort order at index {1}'.format(val, self._len)\r\n            raise ValueError(msg)\r\n\r\n        _maxes[pos] = val\r\n        _lists[pos].append(val)\r\n        self._len += 1\r\n        self._expand(pos)\r\n\r\n    def extend(self, values):\r\n        _lists = self._lists\r\n        _maxes = self._maxes\r\n        _load = self._load\r\n\r\n        if not isinstance(values, list):\r\n            values = list(values)\r\n\r\n        if not values:\r\n            return\r\n\r\n        if any(values[pos - 1] > values[pos]\r\n               for pos in range(1, len(values))):\r\n            raise ValueError('given sequence not in sort order')\r\n\r\n        offset = 0\r\n\r\n        if _maxes:\r\n            if values[0] < _lists[-1][-1]:\r\n                msg = '{0!r} not in sort order at index {1}'.format(values[0], self._len)\r\n                raise ValueError(msg)\r\n\r\n            if len(_lists[-1]) < self._half:\r\n                _lists[-1].extend(values[:_load])\r\n                _maxes[-1] = _lists[-1][-1]\r\n                offset = _load\r\n\r\n        len_lists = len(_lists)\r\n\r\n        for idx in range(offset, len(values), _load):\r\n            _lists.append(values[idx:(idx + _load)])\r\n            _maxes.append(_lists[-1][-1])\r\n\r\n        _index = self._index\r\n\r\n        if len_lists == len(_lists):\r\n            len_index = len(_index)\r\n            if len_index > 0:\r\n                len_values = len(values)\r\n                child = len_index - 1\r\n                while child:\r\n                    _index[child] += len_values\r\n                    child = (child - 1) >> 1\r\n                _index[0] += len_values\r\n        else:\r\n            del _index[:]\r\n\r\n        self._len += len(values)\r\n\r\n    def insert(self, idx, val):\r\n        _len = self._len\r\n        _lists = self._lists\r\n        _maxes = self._maxes\r\n\r\n        if idx < 0:\r\n            idx += _len\r\n        if idx < 0:\r\n            idx = 0\r\n        if idx > _len:\r\n            idx = _len\r\n\r\n        if not _maxes:\r\n            _maxes.append(val)\r\n            _lists.append([val])\r\n            self._len = 1\r\n            return\r\n\r\n        if not idx:\r\n            if val > _lists[0][0]:\r\n                msg = '{0!r} not in sort order at index {1}'.format(val, 0)\r\n                raise ValueError(msg)\r\n            else:\r\n                _lists[0].insert(0, val)\r\n                self._expand(0)\r\n                self._len += 1\r\n                return\r\n\r\n        if idx == _len:\r\n            pos = len(_lists) - 1\r\n            if _lists[pos][-1] > val:\r\n                msg = '{0!r} not in sort order at index {1}'.format(val, _len)\r\n                raise ValueError(msg)\r\n            else:\r\n                _lists[pos].append(val)\r\n                _maxes[pos] = _lists[pos][-1]\r\n                self._expand(pos)\r\n                self._len += 1\r\n                return\r\n\r\n        pos, idx = self._pos(idx)\r\n        idx_before = idx - 1\r\n        if idx_before < 0:\r\n            pos_before = pos - 1\r\n            idx_before = len(_lists[pos_before]) - 1\r\n        else:\r\n            pos_before = pos\r\n\r\n        before = _lists[pos_before][idx_before]\r\n        if before <= val <= _lists[pos][idx]:\r\n            _lists[pos].insert(idx, val)\r\n            self._expand(pos)\r\n            self._len += 1\r\n        else:\r\n            msg = '{0!r} not in sort order at index {1}'.format(val, idx)\r\n            raise ValueError(msg)\r\n\r\n    def pop(self, idx=-1):\r\n        if not self._len:\r\n            raise IndexError('pop index out of range')\r\n\r\n        _lists = self._lists\r\n\r\n        if idx == 0:\r\n            val = _lists[0][0]\r\n            self._delete(0, 0)\r\n            return val\r\n\r\n        if idx == -1:\r\n            pos = len(_lists) - 1\r\n            loc = len(_lists[pos]) - 1\r\n            val = _lists[pos][loc]\r\n            self._delete(pos, loc)\r\n            return val\r\n\r\n        if 0 <= idx < len(_lists[0]):\r\n            val = _lists[0][idx]\r\n            self._delete(0, idx)\r\n            return val\r\n\r\n        len_last = len(_lists[-1])\r\n\r\n        if -len_last < idx < 0:\r\n            pos = len(_lists) - 1\r\n            loc = len_last + idx\r\n            val = _lists[pos][loc]\r\n            self._delete(pos, loc)\r\n            return val\r\n\r\n        pos, idx = self._pos(idx)\r\n        val = _lists[pos][idx]\r\n        self._delete(pos, idx)\r\n\r\n        return val\r\n\r\n    def index(self, val, start=None, stop=None):\r\n    \r\n        _len = self._len\r\n\r\n        if not _len:\r\n            raise ValueError('{0!r} is not in list'.format(val))\r\n\r\n        if start is None:\r\n            start = 0\r\n        if start < 0:\r\n            start += _len\r\n        if start < 0:\r\n            start = 0\r\n\r\n        if stop is None:\r\n            stop = _len\r\n        if stop < 0:\r\n            stop += _len\r\n        if stop > _len:\r\n            stop = _len\r\n\r\n        if stop <= start:\r\n            raise ValueError('{0!r} is not in list'.format(val))\r\n\r\n        _maxes = self._maxes\r\n        pos_left = bisect_left(_maxes, val)\r\n\r\n        if pos_left == len(_maxes):\r\n            raise ValueError('{0!r} is not in list'.format(val))\r\n\r\n        _lists = self._lists\r\n        idx_left = bisect_left(_lists[pos_left], val)\r\n\r\n        if _lists[pos_left][idx_left] != val:\r\n            raise ValueError('{0!r} is not in list'.format(val))\r\n\r\n        stop -= 1\r\n        left = self._loc(pos_left, idx_left)\r\n\r\n        if start <= left:\r\n            if left <= stop:\r\n                return left\r\n        else:\r\n            right = self._bisect_right(val) - 1\r\n\r\n            if start <= right:\r\n                return start\r\n\r\n        raise ValueError('{0!r} is not in list'.format(val))\r\n\r\n    def __add__(self, that):\r\n        \r\n        values = reduce(iadd, self._lists, [])\r\n        values.extend(that)\r\n        return self.__class__(values)\r\n\r\n    def __iadd__(self, that):\r\n\r\n        self._update(that)\r\n        return self\r\n\r\n    def __mul__(self, that):\r\n\r\n        values = reduce(iadd, self._lists, []) * that\r\n        return self.__class__(values)\r\n\r\n    def __imul__(self, that):\r\n\r\n        values = reduce(iadd, self._lists, []) * that\r\n        self._clear()\r\n        self._update(values)\r\n        return self\r\n\r\n    def _make_cmp(self, seq_op, doc):\r\n        def comparer(self, that):\r\n            if not isinstance(that, Sequence):\r\n                return NotImplemented\r\n\r\n            self_len = self._len\r\n            len_that = len(that)\r\n\r\n            if self_len != len_that:\r\n                if seq_op is op.eq:\r\n                    return False\r\n                if seq_op is op.ne:\r\n                    return True\r\n\r\n            for alpha, beta in zip(self, that):\r\n                if alpha != beta:\r\n                    return seq_op(alpha, beta)\r\n\r\n            return seq_op(self_len, len_that)\r\n\r\n        comparer.__name__ = '__{0}__'.format(seq_op.__name__)\r\n        doc_str = 'Return `True` if and only if Sequence is {0} `that`.'\r\n        comparer.__doc__ = doc_str.format(doc)\r\n\r\n        return comparer\r\n\r\n    __eq__ = _make_cmp(None, op.eq, 'equal to')\r\n    __ne__ = _make_cmp(None, op.ne, 'not equal to')\r\n    __lt__ = _make_cmp(None, op.lt, 'less than')\r\n    __gt__ = _make_cmp(None, op.gt, 'greater than')\r\n    __le__ = _make_cmp(None, op.le, 'less than or equal to')\r\n    __ge__ = _make_cmp(None, op.ge, 'greater than or equal to')\r\n\r\n    @recursive_repr\r\n    def __repr__(self):\r\n        return '{0}({1!r})'.format(type(self).__name__, list(self))\r\n\r\n    def _check(self):\r\n        try:\r\n\r\n            assert self._load >= 4\r\n            assert self._half == (self._load >> 1)\r\n            assert self._dual == (self._load << 1)\r\n\r\n\r\n            if self._maxes == []:\r\n                assert self._lists == []\r\n                return\r\n\r\n            assert self._maxes and self._lists\r\n\r\n\r\n            assert all(sublist[pos - 1] <= sublist[pos]\r\n                       for sublist in self._lists\r\n                       for pos in range(1, len(sublist)))\r\n\r\n\r\n            for pos in range(1, len(self._lists)):\r\n                assert self._lists[pos - 1][-1] <= self._lists[pos][0]\r\n\r\n\r\n            assert len(self._maxes) == len(self._lists)\r\n\r\n\r\n            assert all(self._maxes[pos] == self._lists[pos][-1]\r\n                       for pos in range(len(self._maxes)))\r\n\r\n\r\n            assert all(len(sublist) <= self._dual for sublist in self._lists)\r\n\r\n\r\n            assert all(len(self._lists[pos]) >= self._half\r\n                       for pos in range(0, len(self._lists) - 1))\r\n\r\n\r\n\r\n            assert self._len == sum(len(sublist) for sublist in self._lists)\r\n\r\n\r\n\r\n            if self._index:\r\n                assert len(self._index) == self._offset + len(self._lists)\r\n                assert self._len == self._index[0]\r\n\r\n                def test_offset_pos(pos):\r\n                    from_index = self._index[self._offset + pos]\r\n                    return from_index == len(self._lists[pos])\r\n\r\n                assert all(test_offset_pos(pos)\r\n                           for pos in range(len(self._lists)))\r\n\r\n                for pos in range(self._offset):\r\n                    child = (pos << 1) + 1\r\n                    if child >= len(self._index):\r\n                        assert self._index[pos] == 0\r\n                    elif child + 1 == len(self._index):\r\n                        assert self._index[pos] == self._index[child]\r\n                    else:\r\n                        child_sum = self._index[child] + self._index[child + 1]\r\n                        assert self._index[pos] == child_sum\r\n\r\n        except:\r\n            import sys\r\n            import traceback\r\n\r\n            traceback.print_exc(file=sys.stdout)\r\n\r\n            print('len', self._len)\r\n            print('load', self._load, self._half, self._dual)\r\n            print('offset', self._offset)\r\n            print('len_index', len(self._index))\r\n            print('index', self._index)\r\n            print('len_maxes', len(self._maxes))\r\n            print('maxes', self._maxes)\r\n            print('len_lists', len(self._lists))\r\n            print('lists', self._lists)\r\n\r\n            raise\r\n\r\ndef identity(value):\r\n    return value\r\n\r\nclass SortedListWithKey(SortedList):\r\n\r\n    def __init__(self, iterable=None, key=identity):\r\n\r\n        self._len = 0\r\n        self._lists = []\r\n        self._keys = []\r\n        self._maxes = []\r\n        self._index = []\r\n        self._key = key\r\n        self._load = LOAD\r\n        self._half = LOAD >> 1\r\n        self._dual = LOAD << 1\r\n        self._offset = 0\r\n\r\n        if iterable is not None:\r\n            self._update(iterable)\r\n\r\n    def __new__(cls, iterable=None, key=identity):\r\n        return object.__new__(cls)\r\n\r\n    @property\r\n    def key(self):\r\n        return self._key\r\n\r\n    def clear(self):\r\n        self._len = 0\r\n        del self._lists[:]\r\n        del self._keys[:]\r\n        del self._maxes[:]\r\n        del self._index[:]\r\n\r\n    _clear = clear\r\n\r\n    def add(self, val):\r\n        _lists = self._lists\r\n        _keys = self._keys\r\n        _maxes = self._maxes\r\n\r\n        key = self._key(val)\r\n\r\n        if _maxes:\r\n            pos = bisect_right(_maxes, key)\r\n\r\n            if pos == len(_maxes):\r\n                pos -= 1\r\n                _lists[pos].append(val)\r\n                _keys[pos].append(key)\r\n                _maxes[pos] = key\r\n            else:\r\n                idx = bisect_right(_keys[pos], key)\r\n                _lists[pos].insert(idx, val)\r\n                _keys[pos].insert(idx, key)\r\n\r\n            self._expand(pos)\r\n        else:\r\n            _lists.append([val])\r\n            _keys.append([key])\r\n            _maxes.append(key)\r\n\r\n        self._len += 1\r\n\r\n    def _expand(self, pos):\r\n\r\n        _lists = self._lists\r\n        _keys = self._keys\r\n        _index = self._index\r\n\r\n        if len(_keys[pos]) > self._dual:\r\n            _maxes = self._maxes\r\n            _load = self._load\r\n\r\n            _lists_pos = _lists[pos]\r\n            _keys_pos = _keys[pos]\r\n            half = _lists_pos[_load:]\r\n            half_keys = _keys_pos[_load:]\r\n            del _lists_pos[_load:]\r\n            del _keys_pos[_load:]\r\n            _maxes[pos] = _keys_pos[-1]\r\n\r\n            _lists.insert(pos + 1, half)\r\n            _keys.insert(pos + 1, half_keys)\r\n            _maxes.insert(pos + 1, half_keys[-1])\r\n\r\n            del _index[:]\r\n        else:\r\n            if _index:\r\n                child = self._offset + pos\r\n                while child:\r\n                    _index[child] += 1\r\n                    child = (child - 1) >> 1\r\n                _index[0] += 1\r\n\r\n    def update(self, iterable):\r\n        _lists = self._lists\r\n        _keys = self._keys\r\n        _maxes = self._maxes\r\n        values = sorted(iterable, key=self._key)\r\n\r\n        if _maxes:\r\n            if len(values) * 4 >= self._len:\r\n                values.extend(chain.from_iterable(_lists))\r\n                values.sort(key=self._key)\r\n                self._clear()\r\n            else:\r\n                _add = self.add\r\n                for val in values:\r\n                    _add(val)\r\n                return\r\n\r\n        _load = self._load\r\n        _lists.extend(values[pos:(pos + _load)]\r\n                      for pos in range(0, len(values), _load))\r\n        _keys.extend(list(map(self._key, _list)) for _list in _lists)\r\n        _maxes.extend(sublist[-1] for sublist in _keys)\r\n        self._len = len(values)\r\n        del self._index[:]\r\n\r\n    _update = update\r\n\r\n    def __contains__(self, val):\r\n        _maxes = self._maxes\r\n\r\n        if not _maxes:\r\n            return False\r\n\r\n        key = self._key(val)\r\n        pos = bisect_left(_maxes, key)\r\n\r\n        if pos == len(_maxes):\r\n            return False\r\n\r\n        _lists = self._lists\r\n        _keys = self._keys\r\n\r\n        idx = bisect_left(_keys[pos], key)\r\n\r\n        len_keys = len(_keys)\r\n        len_sublist = len(_keys[pos])\r\n\r\n        while True:\r\n            if _keys[pos][idx] != key:\r\n                return False\r\n            if _lists[pos][idx] == val:\r\n                return True\r\n            idx += 1\r\n            if idx == len_sublist:\r\n                pos += 1\r\n                if pos == len_keys:\r\n                    return False\r\n                len_sublist = len(_keys[pos])\r\n                idx = 0\r\n\r\n    def discard(self, val):\r\n\r\n        _maxes = self._maxes\r\n\r\n        if not _maxes:\r\n            return\r\n\r\n        key = self._key(val)\r\n        pos = bisect_left(_maxes, key)\r\n\r\n        if pos == len(_maxes):\r\n            return\r\n\r\n        _lists = self._lists\r\n        _keys = self._keys\r\n        idx = bisect_left(_keys[pos], key)\r\n        len_keys = len(_keys)\r\n        len_sublist = len(_keys[pos])\r\n\r\n        while True:\r\n            if _keys[pos][idx] != key:\r\n                return\r\n            if _lists[pos][idx] == val:\r\n                self._delete(pos, idx)\r\n                return\r\n            idx += 1\r\n            if idx == len_sublist:\r\n                pos += 1\r\n                if pos == len_keys:\r\n                    return\r\n                len_sublist = len(_keys[pos])\r\n                idx = 0\r\n\r\n    def remove(self, val):\r\n\r\n        _maxes = self._maxes\r\n\r\n        if not _maxes:\r\n            raise ValueError('{0!r} not in list'.format(val))\r\n\r\n        key = self._key(val)\r\n        pos = bisect_left(_maxes, key)\r\n\r\n        if pos == len(_maxes):\r\n            raise ValueError('{0!r} not in list'.format(val))\r\n\r\n        _lists = self._lists\r\n        _keys = self._keys\r\n        idx = bisect_left(_keys[pos], key)\r\n        len_keys = len(_keys)\r\n        len_sublist = len(_keys[pos])\r\n\r\n        while True:\r\n            if _keys[pos][idx] != key:\r\n                raise ValueError('{0!r} not in list'.format(val))\r\n            if _lists[pos][idx] == val:\r\n                self._delete(pos, idx)\r\n                return\r\n            idx += 1\r\n            if idx == len_sublist:\r\n                pos += 1\r\n                if pos == len_keys:\r\n                    raise ValueError('{0!r} not in list'.format(val))\r\n                len_sublist = len(_keys[pos])\r\n                idx = 0\r\n\r\n    def _delete(self, pos, idx):\r\n\r\n        _lists = self._lists\r\n        _keys = self._keys\r\n        _maxes = self._maxes\r\n        _index = self._index\r\n        keys_pos = _keys[pos]\r\n        lists_pos = _lists[pos]\r\n\r\n        del keys_pos[idx]\r\n        del lists_pos[idx]\r\n        self._len -= 1\r\n\r\n        len_keys_pos = len(keys_pos)\r\n\r\n        if len_keys_pos > self._half:\r\n\r\n            _maxes[pos] = keys_pos[-1]\r\n\r\n            if _index:\r\n                child = self._offset + pos\r\n                while child > 0:\r\n                    _index[child] -= 1\r\n                    child = (child - 1) >> 1\r\n                _index[0] -= 1\r\n\r\n        elif len(_keys) > 1:\r\n\r\n            if not pos:\r\n                pos += 1\r\n\r\n            prev = pos - 1\r\n            _keys[prev].extend(_keys[pos])\r\n            _lists[prev].extend(_lists[pos])\r\n            _maxes[prev] = _keys[prev][-1]\r\n\r\n            del _lists[pos]\r\n            del _keys[pos]\r\n            del _maxes[pos]\r\n            del _index[:]\r\n\r\n            self._expand(prev)\r\n\r\n        elif len_keys_pos:\r\n\r\n            _maxes[pos] = keys_pos[-1]\r\n\r\n        else:\r\n\r\n            del _lists[pos]\r\n            del _keys[pos]\r\n            del _maxes[pos]\r\n            del _index[:]\r\n\r\n    def _check_order(self, idx, key, val):\r\n        _len = self._len\r\n        _keys = self._keys\r\n\r\n        pos, loc = self._pos(idx)\r\n\r\n        if idx < 0:\r\n            idx += _len\r\n\r\n\r\n\r\n        if idx > 0:\r\n            idx_prev = loc - 1\r\n            pos_prev = pos\r\n\r\n            if idx_prev < 0:\r\n                pos_prev -= 1\r\n                idx_prev = len(_keys[pos_prev]) - 1\r\n\r\n            if _keys[pos_prev][idx_prev] > key:\r\n                msg = '{0!r} not in sort order at index {1}'.format(val, idx)\r\n                raise ValueError(msg)\r\n\r\n\r\n\r\n        if idx < (_len - 1):\r\n            idx_next = loc + 1\r\n            pos_next = pos\r\n\r\n            if idx_next == len(_keys[pos_next]):\r\n                pos_next += 1\r\n                idx_next = 0\r\n\r\n            if _keys[pos_next][idx_next] < key:\r\n                msg = '{0!r} not in sort order at index {1}'.format(val, idx)\r\n                raise ValueError(msg)\r\n\r\n    def __setitem__(self, index, value):\r\n\r\n        _lists = self._lists\r\n        _keys = self._keys\r\n        _maxes = self._maxes\r\n        _check_order = self._check_order\r\n        _pos = self._pos\r\n\r\n        if isinstance(index, slice):\r\n            _len = self._len\r\n            start, stop, step = index.indices(_len)\r\n            indices = range(start, stop, step)\r\n\r\n\r\n\r\n            values = tuple(value)\r\n\r\n            if step != 1:\r\n                if len(values) != len(indices):\r\n                    raise ValueError(\r\n                        'attempt to assign sequence of size %s'\r\n                        ' to extended slice of size %s'\r\n                        % (len(values), len(indices)))\r\n\r\n\r\n                log = []\r\n                _append = log.append\r\n\r\n                for idx, val in zip(indices, values):\r\n                    pos, loc = _pos(idx)\r\n                    key = self._key(val)\r\n                    _append((idx, _keys[pos][loc], key, _lists[pos][loc], val))\r\n                    _keys[pos][loc] = key\r\n                    _lists[pos][loc] = val\r\n                    if len(_keys[pos]) == (loc + 1):\r\n                        _maxes[pos] = key\r\n\r\n                try:\r\n\r\n                    for idx, oldkey, newkey, oldval, newval in log:\r\n                        _check_order(idx, newkey, newval)\r\n\r\n                except ValueError:\r\n\r\n\r\n                    for idx, oldkey, newkey, oldval, newval in log:\r\n                        pos, loc = _pos(idx)\r\n                        _keys[pos][loc] = oldkey\r\n                        _lists[pos][loc] = oldval\r\n                        if len(_keys[pos]) == (loc + 1):\r\n                            _maxes[pos] = oldkey\r\n\r\n                    raise\r\n            else:\r\n                if start == 0 and stop == self._len:\r\n                    self._clear()\r\n                    return self._update(values)\r\n\r\n                if stop < start:\r\n\r\n                    stop = start\r\n\r\n                if values:\r\n\r\n\r\n                    keys = tuple(map(self._key, values))\r\n                    alphas = iter(keys)\r\n                    betas = iter(keys)\r\n                    next(betas)\r\n                    pairs = zip(alphas, betas)\r\n\r\n                    if not all(alpha <= beta for alpha, beta in pairs):\r\n                        raise ValueError('given values not in sort order')\r\n\r\n\r\n                    if start:\r\n                        pos, loc = _pos(start - 1)\r\n                        if _keys[pos][loc] > keys[0]:\r\n                            msg = '{0!r} not in sort order at index {1}'.format(\r\n                                values[0], start)\r\n                            raise ValueError(msg)\r\n\r\n                    if stop != _len:\r\n                        pos, loc = _pos(stop)\r\n                        if _keys[pos][loc] < keys[-1]:\r\n                            msg = '{0!r} not in sort order at index {1}'.format(\r\n                                values[-1], stop)\r\n                            raise ValueError(msg)\r\n\r\n\r\n                self._delitem(index)\r\n\r\n\r\n                _insert = self.insert\r\n                for idx, val in enumerate(values):\r\n                    _insert(start + idx, val)\r\n        else:\r\n            pos, loc = _pos(index)\r\n            key = self._key(value)\r\n            _check_order(index, key, value)\r\n            _lists[pos][loc] = value\r\n            _keys[pos][loc] = key\r\n            if len(_lists[pos]) == (loc + 1):\r\n                _maxes[pos] = key\r\n\r\n    def irange(self, minimum=None, maximum=None, inclusive=(True, True),\r\n               reverse=False):\r\n        \r\n        minimum = self._key(minimum) if minimum is not None else None\r\n        maximum = self._key(maximum) if maximum is not None else None\r\n        return self._irange_key(\r\n            min_key=minimum, max_key=maximum,\r\n            inclusive=inclusive, reverse=reverse,\r\n        )\r\n\r\n    def irange_key(self, min_key=None, max_key=None, inclusive=(True, True),\r\n                   reverse=False):\r\n        \r\n        _maxes = self._maxes\r\n\r\n        if not _maxes:\r\n            return iter(())\r\n\r\n        _keys = self._keys\r\n\r\n\r\n\r\n        if min_key is None:\r\n            min_pos = 0\r\n            min_idx = 0\r\n        else:\r\n            if inclusive[0]:\r\n                min_pos = bisect_left(_maxes, min_key)\r\n\r\n                if min_pos == len(_maxes):\r\n                    return iter(())\r\n\r\n                min_idx = bisect_left(_keys[min_pos], min_key)\r\n            else:\r\n                min_pos = bisect_right(_maxes, min_key)\r\n\r\n                if min_pos == len(_maxes):\r\n                    return iter(())\r\n\r\n                min_idx = bisect_right(_keys[min_pos], min_key)\r\n\r\n\r\n\r\n        if max_key is None:\r\n            max_pos = len(_maxes) - 1\r\n            max_idx = len(_keys[max_pos])\r\n        else:\r\n            if inclusive[1]:\r\n                max_pos = bisect_right(_maxes, max_key)\r\n\r\n                if max_pos == len(_maxes):\r\n                    max_pos -= 1\r\n                    max_idx = len(_keys[max_pos])\r\n                else:\r\n                    max_idx = bisect_right(_keys[max_pos], max_key)\r\n            else:\r\n                max_pos = bisect_left(_maxes, max_key)\r\n\r\n                if max_pos == len(_maxes):\r\n                    max_pos -= 1\r\n                    max_idx = len(_keys[max_pos])\r\n                else:\r\n                    max_idx = bisect_left(_keys[max_pos], max_key)\r\n\r\n        return self._islice(min_pos, min_idx, max_pos, max_idx, reverse)\r\n\r\n    _irange_key = irange_key\r\n\r\n    def bisect_left(self, val):\r\n\r\n        return self._bisect_key_left(self._key(val))\r\n\r\n    def bisect_right(self, val):\r\n\r\n        return self._bisect_key_right(self._key(val))\r\n\r\n    bisect = bisect_right\r\n\r\n    def bisect_key_left(self, key):\r\n        \r\n        _maxes = self._maxes\r\n\r\n        if not _maxes:\r\n            return 0\r\n\r\n        pos = bisect_left(_maxes, key)\r\n\r\n        if pos == len(_maxes):\r\n            return self._len\r\n\r\n        idx = bisect_left(self._keys[pos], key)\r\n\r\n        return self._loc(pos, idx)\r\n\r\n    _bisect_key_left = bisect_key_left\r\n\r\n    def bisect_key_right(self, key):\r\n\r\n        _maxes = self._maxes\r\n\r\n        if not _maxes:\r\n            return 0\r\n\r\n        pos = bisect_right(_maxes, key)\r\n\r\n        if pos == len(_maxes):\r\n            return self._len\r\n\r\n        idx = bisect_right(self._keys[pos], key)\r\n\r\n        return self._loc(pos, idx)\r\n\r\n    bisect_key = bisect_key_right\r\n    _bisect_key_right = bisect_key_right\r\n\r\n    def count(self, val):\r\n        _maxes = self._maxes\r\n\r\n        if not _maxes:\r\n            return 0\r\n\r\n        key = self._key(val)\r\n        pos = bisect_left(_maxes, key)\r\n\r\n        if pos == len(_maxes):\r\n            return 0\r\n\r\n        _lists = self._lists\r\n        _keys = self._keys\r\n        idx = bisect_left(_keys[pos], key)\r\n        total = 0\r\n        len_keys = len(_keys)\r\n        len_sublist = len(_keys[pos])\r\n\r\n        while True:\r\n            if _keys[pos][idx] != key:\r\n                return total\r\n            if _lists[pos][idx] == val:\r\n                total += 1\r\n            idx += 1\r\n            if idx == len_sublist:\r\n                pos += 1\r\n                if pos == len_keys:\r\n                    return total\r\n                len_sublist = len(_keys[pos])\r\n                idx = 0\r\n\r\n    def copy(self):\r\n        return self.__class__(self, key=self._key)\r\n\r\n    __copy__ = copy\r\n\r\n    def append(self, val):\r\n\r\n        _lists = self._lists\r\n        _keys = self._keys\r\n        _maxes = self._maxes\r\n        key = self._key(val)\r\n\r\n        if not _maxes:\r\n            _maxes.append(key)\r\n            _keys.append([key])\r\n            _lists.append([val])\r\n            self._len = 1\r\n            return\r\n\r\n        pos = len(_keys) - 1\r\n\r\n        if key < _keys[pos][-1]:\r\n            msg = '{0!r} not in sort order at index {1}'.format(val, self._len)\r\n            raise ValueError(msg)\r\n\r\n        _lists[pos].append(val)\r\n        _keys[pos].append(key)\r\n        _maxes[pos] = key\r\n        self._len += 1\r\n        self._expand(pos)\r\n\r\n    def extend(self, values):\r\n\r\n        _lists = self._lists\r\n        _keys = self._keys\r\n        _maxes = self._maxes\r\n        _load = self._load\r\n\r\n        if not isinstance(values, list):\r\n            values = list(values)\r\n\r\n        keys = list(map(self._key, values))\r\n\r\n        if any(keys[pos - 1] > keys[pos]\r\n               for pos in range(1, len(keys))):\r\n            raise ValueError('given sequence not in sort order')\r\n\r\n        offset = 0\r\n\r\n        if _maxes:\r\n            if keys[0] < _keys[-1][-1]:\r\n                msg = '{0!r} not in sort order at index {1}'.format(values[0], self._len)\r\n                raise ValueError(msg)\r\n\r\n            if len(_keys[-1]) < self._half:\r\n                _lists[-1].extend(values[:_load])\r\n                _keys[-1].extend(keys[:_load])\r\n                _maxes[-1] = _keys[-1][-1]\r\n                offset = _load\r\n\r\n        len_keys = len(_keys)\r\n\r\n        for idx in range(offset, len(keys), _load):\r\n            _lists.append(values[idx:(idx + _load)])\r\n            _keys.append(keys[idx:(idx + _load)])\r\n            _maxes.append(_keys[-1][-1])\r\n\r\n        _index = self._index\r\n\r\n        if len_keys == len(_keys):\r\n            len_index = len(_index)\r\n            if len_index > 0:\r\n                len_values = len(values)\r\n                child = len_index - 1\r\n                while child:\r\n                    _index[child] += len_values\r\n                    child = (child - 1) >> 1\r\n                _index[0] += len_values\r\n        else:\r\n            del _index[:]\r\n\r\n        self._len += len(values)\r\n\r\n    def insert(self, idx, val):\r\n\r\n        _len = self._len\r\n        _lists = self._lists\r\n        _keys = self._keys\r\n        _maxes = self._maxes\r\n\r\n        if idx < 0:\r\n            idx += _len\r\n        if idx < 0:\r\n            idx = 0\r\n        if idx > _len:\r\n            idx = _len\r\n\r\n        key = self._key(val)\r\n\r\n        if not _maxes:\r\n            self._len = 1\r\n            _lists.append([val])\r\n            _keys.append([key])\r\n            _maxes.append(key)\r\n            return\r\n\r\n        if not idx:\r\n            if key > _keys[0][0]:\r\n                msg = '{0!r} not in sort order at index {1}'.format(val, 0)\r\n                raise ValueError(msg)\r\n            else:\r\n                self._len += 1\r\n                _lists[0].insert(0, val)\r\n                _keys[0].insert(0, key)\r\n                self._expand(0)\r\n                return\r\n\r\n        if idx == _len:\r\n            pos = len(_keys) - 1\r\n            if _keys[pos][-1] > key:\r\n                msg = '{0!r} not in sort order at index {1}'.format(val, _len)\r\n                raise ValueError(msg)\r\n            else:\r\n                self._len += 1\r\n                _lists[pos].append(val)\r\n                _keys[pos].append(key)\r\n                _maxes[pos] = _keys[pos][-1]\r\n                self._expand(pos)\r\n                return\r\n\r\n        pos, idx = self._pos(idx)\r\n        idx_before = idx - 1\r\n        if idx_before < 0:\r\n            pos_before = pos - 1\r\n            idx_before = len(_keys[pos_before]) - 1\r\n        else:\r\n            pos_before = pos\r\n\r\n        before = _keys[pos_before][idx_before]\r\n        if before <= key <= _keys[pos][idx]:\r\n            self._len += 1\r\n            _lists[pos].insert(idx, val)\r\n            _keys[pos].insert(idx, key)\r\n            self._expand(pos)\r\n        else:\r\n            msg = '{0!r} not in sort order at index {1}'.format(val, idx)\r\n            raise ValueError(msg)\r\n\r\n    def index(self, val, start=None, stop=None):\r\n\r\n        _len = self._len\r\n\r\n        if not _len:\r\n            raise ValueError('{0!r} is not in list'.format(val))\r\n\r\n        if start is None:\r\n            start = 0\r\n        if start < 0:\r\n            start += _len\r\n        if start < 0:\r\n            start = 0\r\n\r\n        if stop is None:\r\n            stop = _len\r\n        if stop < 0:\r\n            stop += _len\r\n        if stop > _len:\r\n            stop = _len\r\n\r\n        if stop <= start:\r\n            raise ValueError('{0!r} is not in list'.format(val))\r\n\r\n        _maxes = self._maxes\r\n        key = self._key(val)\r\n        pos = bisect_left(_maxes, key)\r\n\r\n        if pos == len(_maxes):\r\n            raise ValueError('{0!r} is not in list'.format(val))\r\n\r\n        stop -= 1\r\n        _lists = self._lists\r\n        _keys = self._keys\r\n        idx = bisect_left(_keys[pos], key)\r\n        len_keys = len(_keys)\r\n        len_sublist = len(_keys[pos])\r\n\r\n        while True:\r\n            if _keys[pos][idx] != key:\r\n                raise ValueError('{0!r} is not in list'.format(val))\r\n            if _lists[pos][idx] == val:\r\n                loc = self._loc(pos, idx)\r\n                if start <= loc <= stop:\r\n                    return loc\r\n                elif loc > stop:\r\n                    break\r\n            idx += 1\r\n            if idx == len_sublist:\r\n                pos += 1\r\n                if pos == len_keys:\r\n                    raise ValueError('{0!r} is not in list'.format(val))\r\n                len_sublist = len(_keys[pos])\r\n                idx = 0\r\n\r\n        raise ValueError('{0!r} is not in list'.format(val))\r\n\r\n    def __add__(self, that):\r\n\r\n        values = reduce(iadd, self._lists, [])\r\n        values.extend(that)\r\n        return self.__class__(values, key=self._key)\r\n\r\n    def __mul__(self, that):\r\n\r\n        values = reduce(iadd, self._lists, []) * that\r\n        return self.__class__(values, key=self._key)\r\n\r\n    def __imul__(self, that):\r\n\r\n        values = reduce(iadd, self._lists, []) * that\r\n        self._clear()\r\n        self._update(values)\r\n        return self\r\n\r\n    @recursive_repr\r\n    def __repr__(self):\r\n        name = type(self).__name__\r\n        values = list(self)\r\n        _key = self._key\r\n        return '{0}({1!r}, key={2!r})'.format(name, values, _key)\r\n\r\n    def _check(self):\r\n        try:\r\n\r\n            assert self._load >= 4\r\n            assert self._half == (self._load >> 1)\r\n            assert self._dual == (self._load << 1)\r\n\r\n\r\n            if self._maxes == []:\r\n                assert self._keys == []\r\n                assert self._lists == []\r\n                return\r\n\r\n            assert self._maxes and self._keys and self._lists\r\n\r\n\r\n            assert all(sublist[pos - 1] <= sublist[pos]\r\n                       for sublist in self._keys\r\n                       for pos in range(1, len(sublist)))\r\n\r\n\r\n            for pos in range(1, len(self._keys)):\r\n                assert self._keys[pos - 1][-1] <= self._keys[pos][0]\r\n\r\n\r\n            assert len(self._maxes) == len(self._lists) == len(self._keys)\r\n\r\n\r\n            assert all(len(val_list) == len(key_list)\r\n                       for val_list, key_list in zip(self._lists, self._keys))\r\n            assert all(self._key(val) == key for val, key in\r\n                       zip((_val for _val_list in self._lists for _val in _val_list),\r\n                           (_key for _key_list in self._keys for _key in _key_list)))\r\n\r\n\r\n            assert all(self._maxes[pos] == self._keys[pos][-1]\r\n                       for pos in range(len(self._maxes)))\r\n\r\n\r\n            assert all(len(sublist) <= self._dual for sublist in self._lists)\r\n\r\n\r\n            assert all(len(self._lists[pos]) >= self._half\r\n                       for pos in range(0, len(self._lists) - 1))\r\n\r\n\r\n            assert self._len == sum(len(sublist) for sublist in self._lists)\r\n\r\n            if self._index:\r\n                assert len(self._index) == self._offset + len(self._lists)\r\n                assert self._len == self._index[0]\r\n\r\n                def test_offset_pos(pos):\r\n                    from_index = self._index[self._offset + pos]\r\n                    return from_index == len(self._lists[pos])\r\n\r\n                assert all(test_offset_pos(pos)\r\n                           for pos in range(len(self._lists)))\r\n\r\n                for pos in range(self._offset):\r\n                    child = (pos << 1) + 1\r\n                    if self._index[pos] == 0:\r\n                        assert child >= len(self._index)\r\n                    elif child + 1 == len(self._index):\r\n                        assert self._index[pos] == self._index[child]\r\n                    else:\r\n                        child_sum = self._index[child] + self._index[child + 1]\r\n                        assert self._index[pos] == child_sum\r\n        except:\r\n            import sys\r\n            import traceback\r\n            traceback.print_exc(file=sys.stdout)\r\n            print('len', self._len)\r\n            print('load', self._load, self._half, self._dual)\r\n            print('offset', self._offset)\r\n            print('len_index', len(self._index))\r\n            print('index', self._index)\r\n            print('len_maxes', len(self._maxes))\r\n            print('maxes', self._maxes)\r\n            print('len_keys', len(self._keys))\r\n            print('keys', self._keys)\r\n            print('len_lists', len(self._lists))\r\n            print('lists', self._lists)\r\n            raise\r\n\r\n\r\nfrom collections import Counter\r\nm,n = map(int,input().split())\r\ns = list(map(int,input().split()))\r\nt = list(map(int,input().split()))\r\ndef f(num):\r\n    res = 1\r\n    for i in range(1,num+1):\r\n        res *= i\r\n        res %= mod\r\n    return res\r\n\r\nans = 0\r\nmod = 998244353\r\ncnt1 = Counter(s)\r\ncnt2 = Counter(t)\r\na = f(m)\r\nfor v in cnt1.values():\r\n    if v > 1:\r\n        a *= pow(f(v),mod-2,mod)\r\n        a %= mod\r\nd = SortedList(s)\r\nok = True\r\nta = 0\r\nfor i in range(min(m,n)-1):\r\n    k = t[i]\r\n    a *= pow(m-i,mod-2,mod)\r\n    idx1 = d.bisect_left(k)\r\n    ans += a*(idx1)\r\n    if cnt1[k] == 0:\r\n        ok = False\r\n        break\r\n    a *= cnt1[k]\r\n    a %= mod\r\n    cnt1[k] -= 1\r\n    d.pop(idx1)\r\n\r\ni = min(m,n)-1\r\nif ok:\r\n    if m >= n:\r\n        a *= pow(m-i,mod-2,mod)\r\n        a %= mod\r\n        idx1 = d.bisect_left(t[i])\r\n        ans += a*(idx1)\r\n    else:\r\n        a *= pow(m-i,mod-2,mod)\r\n        a %= mod\r\n        idx1 = d.bisect_right(t[i])\r\n        ans += a*(idx1)\r\nprint(ans%mod)",
    "prob_desc_created_at": "1646560500",
    "tags": [
        "combinatorics",
        "data structures",
        "dp",
        "math"
    ],
    "hidden_unit_tests": ""
}
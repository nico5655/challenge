{
    "prob_desc_time_limit": "1 second",
    "prob_desc_sample_outputs": "[\"0\\n4\\n1\\n3\\n1\\n2\\n1\\n2\", \"0\\n4\\n1\\n3\\n2\\n3\\n3\\n4\", \"0\\n0\\n-1\\n0\", \"1\\n4\\n5\", \"6\\n9\\n6\\n-8\\n-9\"]",
    "src_uid": "1881e52e92db48ae6a53a7fdcd1aa960",
    "prob_desc_notes": null,
    "prob_desc_description": "  There're $$$n$$$ robots placed on a number line. Initially, $$$i$$$-th of them occupies unit segment $$$[x_i, x_i + 1]$$$. Each robot has a program, consisting of $$$k$$$ instructions numbered from $$$1$$$ to $$$k$$$. The robot performs instructions in a cycle. Each instruction is described by an integer number. Let's denote the number corresponding to the $$$j$$$-th instruction of the $$$i$$$-th robot as $$$f_{i, j}$$$.Initial placement of robots corresponds to the moment of time $$$0$$$. During one second from moment of time $$$t$$$ ($$$0 \\le t$$$) until $$$t + 1$$$ the following process occurs:   Each robot performs $$$(t \\bmod k + 1)$$$-th instruction from its list of instructions. Robot number $$$i$$$ takes number $$$F = f_{i, (t \\bmod k + 1)}$$$. If this number is negative (less than zero), the robot is trying to move to the left with force $$$|F|$$$. If the number is positive (more than zero), the robot is trying to move to the right with force $$$F$$$. Otherwise, the robot does nothing.  Let's imaginary divide robots into groups of consecutive, using the following algorithm:   Initially, each robot belongs to its own group.  Let's sum up numbers corresponding to the instructions of the robots from one group. Note that we are summing numbers without taking them by absolute value. Denote this sum as $$$S$$$. We say that the whole group moves together, and does it with force $$$S$$$ by the same rules as a single robot. That is if $$$S$$$ is negative, the group is trying to move to the left with force $$$|S|$$$. If $$$S$$$ is positive, the group is trying to move to the right with force $$$S$$$. Otherwise, the group does nothing.  If one group is trying to move, and in the direction of movement touches another group, let's unite them. One group is touching another if their outermost robots occupy adjacent unit segments.  Continue this process until groups stop uniting.   Each robot moves by $$$1$$$ in the direction of movement of its group or stays in place if its group isn't moving. But there's one exception.  The exception is if there're two groups of robots, divided by exactly one unit segment, such that the left group is trying to move to the right and the right group is trying to move to the left. Let's denote sum in the left group as $$$S_l$$$ and sum in the right group as $$$S_r$$$. If $$$|S_l| \\le |S_r|$$$ only the right group will move. Otherwise, only the left group will move.  Note that robots from one group don't glue together. They may separate in the future. The division into groups is imaginary and is needed only to understand how robots will move during one second $$$[t, t + 1]$$$. An illustration of the process happening during one second:   Rectangles represent robots. Numbers inside rectangles correspond to instructions of robots. The final division into groups is marked with arcs. Below are the positions of the robots after moving. Only the left of the two rightmost groups moved. That's because these two groups tried to move towards each other, and were separated by exactly one unit segment.Look at the examples for a better understanding of the process.You need to answer several questions. What is the position of $$$a_i$$$-th robot at the moment of time $$$t_i$$$?",
    "prob_desc_output_spec": "For every question output a single integer on the new line. Coordinate of the left border of unit segment occupied by the $$$a_i$$$-th robot at the moment of time $$$t_i$$$.",
    "prob_desc_input_spec": "The first line contains two integer numbers $$$n$$$ and $$$k$$$ — the number of robots and the number of instructions in the program of one robot ($$$1 \\le n \\le 100$$$, $$$1 \\le k \\le 50$$$). The next line contains $$$n$$$ integer numbers $$$x_i$$$ — positions of robots at moment of time $$$0$$$ ($$$-10^9 \\le x_1 &lt; x_2 &lt; \\dots &lt; x_n &lt; 10^9$$$). The next $$$n$$$ lines contain descriptions of robots' programs. The $$$i$$$-th of these lines contains $$$k$$$ integer numbers $$$f_{i, j}$$$ ($$$|f_{i, j}| \\le 10^6$$$). The next line contains a single integer number $$$q$$$ — the number of questions you to answer ($$$1 \\le q \\le 1000$$$). The next $$$q$$$ lines contain two integer number $$$a_i$$$ and $$$t_i$$$ each, meaning that you should find a position of $$$a_i$$$-th robot at moment of time $$$t_i$$$ ($$$1 \\le a_i \\le n$$$, $$$0 \\le t_i \\le 10^{18}$$$).",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 2",
    "lang_cluster": "Python",
    "difficulty": 3500,
    "file_name": "train_110.jsonl",
    "code_uid": "544804370f082dc38cef4f3d23e093aa",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"2 1\\n0 4\\n1\\n-1\\n8\\n1 0\\n2 0\\n1 1\\n2 1\\n1 2\\n2 2\\n1 3\\n2 3\", \"2 1\\n0 4\\n2\\n-1\\n8\\n1 0\\n2 0\\n1 1\\n2 1\\n1 2\\n2 2\\n1 3\\n2 3\", \"2 2\\n0 1\\n1 -1\\n-1 1\\n4\\n1 0\\n1 1\\n1 2\\n1 3\", \"1 3\\n0\\n3 -2 1\\n3\\n1 5\\n1 10\\n1 15\", \"4 3\\n-8 -4 2 5\\n-1 3 0\\n1 -3 -4\\n2 -5 2\\n-1 -4 2\\n5\\n3 12\\n4 18\\n4 11\\n1 6\\n1 10\"]",
    "exec_outcome": "PASSED",
    "source_code": "from collections import defaultdict\r\nfrom bisect import bisect_left\r\nimport sys\r\nraw_input = iter(sys.stdin.read().splitlines()).next\r\n\r\ndef precompute(n, k, f, x):\r\n    t, link, lookup = [0], [-1], defaultdict(dict)\r\n    debug = debug2 = 0\r\n    while t[-1] != INF:\r\n        debug += 1\r\n        j = t[-1] % k\r\n        diffs = hash(tuple(min(x[-1][i+1]-x[-1][i], 2*k) for i in xrange(n-1)))\r\n        if diffs in lookup[j]:\r\n            src = lookup[j][diffs]\r\n            span = (len(t)-1)-src\r\n            reps = INF\r\n            for i in xrange(n-1):\r\n                diff_old = x[src][i+1]-x[src][i]\r\n                diff_new = x[-1][i+1]-x[-1][i]\r\n                if diff_new < diff_old:\r\n                    decay = diff_old-diff_new\r\n                    mn = min(x[z][i+1]-x[z][i] for z in xrange(src, len(t)-1))\r\n                    reps = min(reps, (mn-2)//decay-1)\r\n            if reps > 0:\r\n                link.append(src)\r\n                t.append(t[-1]+reps*span)\r\n                x.append(x[-1][:])\r\n                for i in xrange(n):\r\n                    x[-1][i] += reps*(x[-2][i]-x[src][i])\r\n                debug2 += 1\r\n                continue\r\n        lookup[j][diffs] = len(t)-1\r\n        t.append(t[-1]+1)\r\n        x.append(x[-1][:])\r\n        link.append(-1)\r\n        stk  = []\r\n        for i in xrange(n):\r\n            stk.append([i, i, f[i][j]])\r\n            while len(stk) >= 2:\r\n                if not ((stk[-1][2] < 0 or stk[-2][2] > 0) and x[-1][stk[-2][1]]+1 == x[-1][stk[-1][0]]):\r\n                    break\r\n                stk[-2][1] = stk[-1][1]\r\n                stk[-2][2] += stk[-1][2]\r\n                stk.pop()\r\n        for i in xrange(len(stk)):\r\n            d = cmp(stk[i][2], 0)\r\n            if d == 0:\r\n                continue\r\n            if i+1 < len(stk) and x[-2][stk[i+1][0]]-x[-2][stk[i][1]] == 2 and \\\r\n               stk[i][2] > 0 and stk[i+1][2] < 0 and stk[i][2] <= -stk[i+1][2]:\r\n                continue\r\n            if i-1 >= 0 and x[-2][stk[i][0]]-x[-2][stk[i-1][1]] == 2 and \\\r\n               stk[i-1][2] > 0 and stk[i][2] < 0 and not (stk[i-1][2] <= -stk[i][2]):\r\n                continue\r\n            for z in xrange(stk[i][0], stk[i][1]+1):\r\n                x[-1][z] += d\r\n    assert(debug <= n * k * k + 2)\r\n    assert(debug2 <= n + 2)\r\n    return t, link\r\n\r\ndef solution():\r\n    n, k = map(int, raw_input().strip().split())\r\n    x = [map(int, raw_input().strip().split())]\r\n    f = [map(int, raw_input().strip().split()) for _ in xrange(n)]\r\n    t, link = precompute(n, k, f, x)\r\n    result = []\r\n    for _ in xrange(int(raw_input())):\r\n        rid, T = map(int, raw_input().strip().split())\r\n        rid -= 1\r\n        i = bisect_left(t, T)\r\n        if i != len(t) and t[i] == T:\r\n            result.append(x[i][rid])\r\n            continue\r\n        i -= 1\r\n        \r\n        span = i-link[i+1]\r\n        reps = (T-t[i])//span+1\r\n        assert(i-link[i+1] == t[i]-t[link[i+1]])\r\n        rm = (T-t[i]) % span\r\n        ans = x[link[i+1]+rm][rid]\r\n        ans += (x[i][rid]-x[link[i+1]][rid])*reps\r\n        result.append(ans)\r\n    # for i in xrange(len(t)-1):\r\n    #     assert(t[i] == i)\r\n    return \"\\n\".join(map(str, result))\r\n\r\nINF = float(\"inf\")\r\nprint '%s' % solution()",
    "prob_desc_created_at": "1638110100",
    "tags": [],
    "hidden_unit_tests": ""
}
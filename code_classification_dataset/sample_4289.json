{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"4\\n2\\n0\\n3\\n1\"]",
    "src_uid": "a2b99448d6267a66bddfdcad9add311b",
    "prob_desc_notes": "NoteIn the first testcase you can go $$$5$$$ to the right: the box on position $$$1$$$ gets pushed to position $$$6$$$ and the box on position $$$5$$$ gets pushed to position $$$7$$$. Then you can go $$$6$$$ to the left to end up on position $$$-1$$$ and push a box to $$$-2$$$. At the end, the boxes are on positions $$$[-2, 6, 7, 11, 15]$$$, respectively. Among them positions $$$[-2, 6, 7, 15]$$$ are special, thus, the answer is $$$4$$$.In the second testcase you can push the box from $$$-1$$$ to $$$-10^9$$$, then the box from $$$1$$$ to $$$10^9$$$ and obtain the answer $$$2$$$.The third testcase showcases that you are not allowed to pull the boxes, thus, you can't bring them closer to special positions.In the fourth testcase all the boxes are already on special positions, so you can do nothing and still obtain the answer $$$3$$$.In the fifth testcase there are fewer special positions than boxes. You can move either $$$8$$$ or $$$9$$$ to the right to have some box on position $$$10$$$.",
    "prob_desc_description": "You are playing a game similar to Sokoban on an infinite number line. The game is discrete, so you only consider integer positions on the line.You start on a position $$$0$$$. There are $$$n$$$ boxes, the $$$i$$$-th box is on a position $$$a_i$$$. All positions of the boxes are distinct. There are also $$$m$$$ special positions, the $$$j$$$-th position is $$$b_j$$$. All the special positions are also distinct.In one move you can go one position to the left or to the right. If there is a box in the direction of your move, then you push the box to the next position in that direction. If the next position is taken by another box, then that box is also pushed to the next position, and so on. You can't go through the boxes. You can't pull the boxes towards you.You are allowed to perform any number of moves (possibly, zero). Your goal is to place as many boxes on special positions as possible. Note that some boxes can be initially placed on special positions.",
    "prob_desc_output_spec": "For each testcase print a single integer — the maximum number of boxes that can be placed on special positions.",
    "prob_desc_input_spec": "The first line contains a single integer $$$t$$$ ($$$1 \\le t \\le 1000$$$) — the number of testcases. Then descriptions of $$$t$$$ testcases follow. The first line of each testcase contains two integers $$$n$$$ and $$$m$$$ ($$$1 \\le n, m \\le 2 \\cdot 10^5$$$) — the number of boxes and the number of special positions, respectively. The second line of each testcase contains $$$n$$$ distinct integers in the increasing order $$$a_1, a_2, \\dots, a_n$$$ ($$$-10^9 \\le a_1 &lt; a_2 &lt; \\dots &lt; a_n \\le 10^9$$$; $$$a_i \\neq 0$$$) — the initial positions of the boxes. The third line of each testcase contains $$$m$$$ distinct integers in the increasing order $$$b_1, b_2, \\dots, b_m$$$ ($$$-10^9 \\le b_1 &lt; b_2 &lt; \\dots &lt; b_m \\le 10^9$$$; $$$b_i \\neq 0$$$) — the special positions. The sum of $$$n$$$ over all testcases doesn't exceed $$$2 \\cdot 10^5$$$. The sum of $$$m$$$ over all testcases doesn't exceed $$$2 \\cdot 10^5$$$.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3-64",
    "lang_cluster": "Python",
    "difficulty": 1900,
    "file_name": "train_094.jsonl",
    "code_uid": "2e71f4c6a16d5157a7545ba02adcad33",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"5\\n5 6\\n-1 1 5 11 15\\n-4 -3 -2 6 7 15\\n2 2\\n-1 1\\n-1000000000 1000000000\\n2 2\\n-1000000000 1000000000\\n-1 1\\n3 5\\n-1 1 2\\n-2 -1 1 2 5\\n2 1\\n1 2\\n10\"]",
    "exec_outcome": "PASSED",
    "source_code": "import sys\r\nfrom collections import defaultdict\r\nfrom bisect import bisect_left, bisect_right\r\ninput = sys.stdin.readline\r\n\r\ndef solve():\r\n    n, m = list(map(int, input().split()))\r\n    a = list(map(int, input().split()))\r\n    b = list(map(int, input().split()))\r\n    # start at 0; < 0; > 0\r\n    # x x + 1 x + 2...\r\n    # two parts\r\n    x1, y1 = bisect_left(a, 0), bisect_left(b, 0)\r\n\r\n    # 核心思路：把连续箱子中的最右的位置放到特殊位置上，这样可以对于每个特殊位置的左边覆盖最多的位置\r\n    ans = 0\r\n\r\n    def get_max_num(a, b):\r\n        mp = defaultdict(int)\r\n        for v in a:\r\n            mp[v] = 1\r\n        # original same\r\n        same = 0\r\n        for v in b:\r\n            if mp[v] == 1:\r\n                same += 1\r\n        maxn = same\r\n        for i, v in enumerate(b):\r\n            # delete 1\r\n\r\n            # if v in mp => Ologn\r\n            if mp[v] == 1: # O1\r\n                same -= 1\r\n            # core\r\n            # how many concutive(including same)\r\n            idx1 = bisect_right(a, v)\r\n            # how many special(most left: v - idx1 + 1, most right:v)\r\n            idx2 = bisect_left(b, v - idx1 + 1)\r\n            maxn = max(maxn, same + i - idx2 + 1)\r\n        return maxn\r\n\r\n    ans += get_max_num(a[x1:], b[y1:])\r\n\r\n\r\n    new_a = [-aa for aa in a[:x1]]\r\n    new_b = [-bb for bb in b[:y1]]\r\n\r\n    ans += get_max_num(new_a[::-1], new_b[::-1])\r\n    print(ans)\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nif __name__ == '__main__':\r\n    for _ in range(int(input())):\r\n        solve()",
    "prob_desc_created_at": "1614696300",
    "tags": [
        "binary search",
        "dp",
        "greedy",
        "implementation",
        "two pointers"
    ],
    "hidden_unit_tests": ""
}
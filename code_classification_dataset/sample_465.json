{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"0001111111\\n001\\n01\\n0\\n1\"]",
    "src_uid": "bb071f1f4fc1c129a32064c1301f4942",
    "prob_desc_notes": "NoteIn the first test case, Lee can't perform any moves.In the second test case, Lee should erase $$$s_2$$$.In the third test case, Lee can make moves, for example, in the following order: 11001101 $$$\\rightarrow$$$ 1100101 $$$\\rightarrow$$$ 110101 $$$\\rightarrow$$$ 10101 $$$\\rightarrow$$$ 1101 $$$\\rightarrow$$$ 101 $$$\\rightarrow$$$ 01.",
    "prob_desc_description": "Lee was cleaning his house for the party when he found a messy string under the carpets. Now he'd like to make it clean accurately and in a stylish way...The string $$$s$$$ he found is a binary string of length $$$n$$$ (i. e. string consists only of 0-s and 1-s).In one move he can choose two consecutive characters $$$s_i$$$ and $$$s_{i+1}$$$, and if $$$s_i$$$ is 1 and $$$s_{i + 1}$$$ is 0, he can erase exactly one of them (he can choose which one to erase but he can't erase both characters simultaneously). The string shrinks after erasing.Lee can make an arbitrary number of moves (possibly zero) and he'd like to make the string $$$s$$$ as clean as possible. He thinks for two different strings $$$x$$$ and $$$y$$$, the shorter string is cleaner, and if they are the same length, then the lexicographically smaller string is cleaner.Now you should answer $$$t$$$ test cases: for the $$$i$$$-th test case, print the cleanest possible string that Lee can get by doing some number of moves.Small reminder: if we have two strings $$$x$$$ and $$$y$$$ of the same length then $$$x$$$ is lexicographically smaller than $$$y$$$ if there is a position $$$i$$$ such that $$$x_1 = y_1$$$, $$$x_2 = y_2$$$,..., $$$x_{i - 1} = y_{i - 1}$$$ and $$$x_i &lt; y_i$$$.",
    "prob_desc_output_spec": "Print $$$t$$$ answers — one per test case. The answer to the $$$i$$$-th test case is the cleanest string Lee can get after doing some number of moves (possibly zero).",
    "prob_desc_input_spec": "The first line contains the integer $$$t$$$ ($$$1 \\le t \\le 10^4$$$) — the number of test cases.  Next $$$2t$$$ lines contain test cases — one per two lines. The first line of each test case contains the integer $$$n$$$ ($$$1 \\le n \\le 10^5$$$) — the length of the string $$$s$$$. The second line contains the binary string $$$s$$$. The string $$$s$$$ is a string of length $$$n$$$ which consists only of zeroes and ones. It's guaranteed that sum of $$$n$$$ over test cases doesn't exceed $$$10^5$$$.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3",
    "lang_cluster": "Python",
    "difficulty": 1200,
    "file_name": "train_002.jsonl",
    "code_uid": "6d75cb443fc90476dfd18173d04668c7",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"5\\n10\\n0001111111\\n4\\n0101\\n8\\n11001101\\n10\\n1110000000\\n1\\n1\"]",
    "exec_outcome": "PASSED",
    "source_code": "from sys import stdin\nfrom collections import deque\n# https://codeforces.com/contest/1354/status/D\nmod = 10**9 + 7\nimport sys\nimport random\n# sys.setrecursionlimit(10**6)\nfrom queue import PriorityQueue\nfrom collections import Counter as cc\n# def rl():\n#     return [int(w) for w in stdin.readline().split()]\nfrom bisect import bisect_right\nfrom bisect import bisect_left\nfrom collections import defaultdict\nfrom math import sqrt,factorial,gcd,log2,inf,ceil\n# map(int,input().split())\n# # l = list(map(int,input().split()))\n# from itertools import permutations\nimport heapq\n# input = lambda: sys.stdin.readline().rstrip()\ninput = lambda : sys.stdin.readline().rstrip()\nfrom sys import stdin, stdout\nfrom heapq import heapify, heappush, heappop\nfrom itertools import permutations\nfrom math import factorial as f\n\n# def ncr(x, y):\n#     return f(x) // (f(y) * f(x - y))\ndef ncr(n, r, p):\n    num = den = 1\n    for i in range(r):\n        num = (num * (n - i)) % p\n        den = (den * (i + 1)) % p\n    return (num * pow(den,\n                      p - 2, p)) % p\n\nimport sys\n\n# input = sys.stdin.readline\n# LCA\n# def bfs(na):\n#\n#     queue = [na]\n#     boo[na] = True\n#     level[na] = 0\n#\n#     while queue!=[]:\n#\n#         z = queue.pop(0)\n#\n#         for i in hash[z]:\n#\n#             if not boo[i]:\n#\n#                 queue.append(i)\n#                 level[i] = level[z] + 1\n#                 boo[i] = True\n#                 dp[i][0] = z\n#\n#\n#\n# def prec(n):\n#\n#     for i in range(1,20):\n#\n#         for j in range(1,n+1):\n#             if dp[j][i-1]!=-1:\n#                 dp[j][i] = dp[dp[j][i-1]][i-1]\n#\n#\n# def lca(u,v):\n#     if level[v] < level[u]:\n#         u,v = v,u\n#\n#     diff = level[v] - level[u]\n#\n#\n#     for i in range(20):\n#         if ((diff>>i)&1):\n#             v = dp[v][i]\n#\n#\n#     if u == v:\n#         return u\n#\n#\n#     for i in range(19,-1,-1):\n#         # print(i)\n#         if dp[u][i] != dp[v][i]:\n#\n#             u = dp[u][i]\n#             v = dp[v][i]\n#\n#\n#     return dp[u][0]\n#\n# dp = []\n#\n#\n# n = int(input())\n#\n# for i in range(n + 10):\n#\n#     ka = [-1]*(20)\n#     dp.append(ka)\n\n\n# class FenwickTree:\n#     def __init__(self, x):\n#         \"\"\"transform list into BIT\"\"\"\n#         self.bit = x\n#         for i in range(len(x)):\n#             j = i | (i + 1)\n#             if j < len(x):\n#                 x[j] += x[i]\n#\n#     def update(self, idx, x):\n#         \"\"\"updates bit[idx] += x\"\"\"\n#         while idx < len(self.bit):\n#             self.bit[idx] += x\n#             idx |= idx + 1\n#\n#     def query(self, end):\n#         \"\"\"calc sum(bit[:end])\"\"\"\n#         x = 0\n#         while end:\n#             x += self.bit[end - 1]\n#             end &= end - 1\n#         return x\n#\n#     def find_kth_smallest(self, k):\n#         \"\"\"Find largest idx such that sum(bit[:idx]) <= k\"\"\"\n#         idx = -1\n#         for d in reversed(range(len(self.bit).bit_length())):\n#             right_idx = idx + (1 << d)\n#             if right_idx < len(self.bit) and k >= self.bit[right_idx]:\n#                 idx = right_idx\n#                 k -= self.bit[idx]\n#         return idx + 1\n\n\n\n# import sys\n# def rs(): return sys.stdin.readline().strip()\n# def ri(): return int(sys.stdin.readline())\n# def ria(): return list(map(int, sys.stdin.readline().split()))\n# def prn(n): sys.stdout.write(str(n))\n# def pia(a): sys.stdout.write(' '.join([str(s) for s in a]))\n#\n#\n# import gc, os\n#\n# ii = 0\n# _inp = b''\n#\n#\n# def getchar():\n#     global ii, _inp\n#     if ii >= len(_inp):\n#         _inp = os.read(0, 100000)\n#         gc.collect()\n#         ii = 0\n#     if not _inp:\n#         return b' '[0]\n#     ii += 1\n#     return _inp[ii - 1]\n#\n#\n# def input():\n#     c = getchar()\n#     if c == b'-'[0]:\n#         x = 0\n#         sign = 1\n#     else:\n#         x = c - b'0'[0]\n#         sign = 0\n#     c = getchar()\n#     while c >= b'0'[0]:\n#         x = 10 * x + c - b'0'[0]\n#         c = getchar()\n#     if c == b'\\r'[0]:\n#         getchar()\n#     return -x if sign else x\n\n# fenwick Tree\n\n# n,q = map(int,input().split())\n#\n#\n# l1 = list(map(int,input().split()))\n#\n# l2 = list(map(int,input().split()))\n#\n# bit = [0]*(10**6 + 1)\n#\n# def update(i,add,bit):\n#\n#     while i>0 and i<len(bit):\n#\n#         bit[i]+=add\n#         i = i + (i&(-i))\n#\n#\n# def sum(i,bit):\n#     ans = 0\n#     while i>0:\n#\n#         ans+=bit[i]\n#         i = i - (i & ( -i))\n#\n#\n#     return ans\n#\n# def find_smallest(k,bit):\n#\n#     l = 0\n#     h = len(bit)\n#     while l<h:\n#\n#         mid = (l+h)//2\n#         if k <= sum(mid,bit):\n#             h = mid\n#         else:\n#             l = mid + 1\n#\n#\n#     return l\n#\n#\n# def insert(x,bit):\n#     update(x,1,bit)\n#\n# def delete(x,bit):\n#     update(x,-1,bit)\n# fa = set()\n#\n# for i in l1:\n#     insert(i,bit)\n#\n#\n# for i in l2:\n#     if i>0:\n#         insert(i,bit)\n#\n#     else:\n#         z = find_smallest(-i,bit)\n#\n#         delete(z,bit)\n#\n#\n# # print(bit)\n# if len(set(bit)) == 1:\n#     print(0)\n# else:\n#     for i in range(1,n+1):\n#         z = find_smallest(i,bit)\n#         if z!=0:\n#             print(z)\n#             break\n#\n\n# service time problem\n\n\n# def solve2(s,a,b,hash,z,cnt):\n#     temp = cnt.copy()\n#     x,y = hash[a],hash[b]\n#     i = 0\n#     j = len(s)-1\n#\n#     while z:\n#\n#         if s[j] - y>=x-s[i]:\n#             if temp[s[j]]-1 == 0:\n#                 j-=1\n#             temp[s[j]]-=1\n#             z-=1\n#\n#\n#         else:\n#             if temp[s[i]]-1 == 0:\n#                 i+=1\n#\n#             temp[s[i]]-=1\n#             z-=1\n#\n#     return s[i:j+1]\n#\n#\n#\n#\n#\n# def solve1(l,s,posn,z,hash):\n#\n#     ans = []\n#     for i in l:\n#         a,b = i\n#         ka = solve2(s,a,b,posn,z,hash)\n#         ans.append(ka)\n#\n#         return ans\n#\n# def consistent(input, window, min_entries, max_entries, tolerance):\n#\n#     l = input\n#     n = len(l)\n#     l.sort()\n#     s = list(set(l))\n#     s.sort()\n#\n#     if min_entries<=n<=max_entries:\n#\n#         if s[-1] - s[0]<window:\n#             return True\n#         hash = defaultdict(int)\n#         posn = defaultdict(int)\n#         for i in l:\n#             hash[i]+=1\n#\n#         z = (tolerance*(n))//100\n#         poss_window = set()\n#\n#\n#         for i in range(len(s)):\n#                 posn[i] = l[i]\n#                 for j in range(i+1,len(s)):\n#                     if s[j]-s[i] == window:\n#                         poss_window.add((s[i],s[j]))\n#\n#         if poss_window!=set():\n#             print(poss_window)\n#             ans = solve1(poss_window,s,posn,z,hash)\n#             print(ans)\n#\n#\n#         else:\n#             pass\n#\n#     else:\n#         return False\n#\n#\n#\n#\n# l = list(map(int,input().split()))\n#\n# min_ent,max_ent = map(int,input().split())\n# w = int(input())\n# tol = int(input())\n# consistent(l, w, min_ent, max_ent, tol)\n\n# t = int(input())\n#\n# for i in range(t):\n#\n#     n,x = map(int,input().split())\n#\n#     l = list(map(int,input().split()))\n#\n#     e,o = 0,0\n#\n#     for i in l:\n#         if i%2 == 0:\n#             e+=1\n#         else:\n#             o+=1\n#\n#     if e+o>=x and o!=0:\n#         z = e+o - x\n#         if z == 0:\n#             if o%2 == 0:\n#                 print('No')\n#             else:\n#                 print('Yes')\n#             continue\n#         if o%2 == 0:\n#             o-=1\n#             z-=1\n#             if e>=z:\n#                 print('Yes')\n#             else:\n#                 z-=e\n#                 o-=z\n#                 if o%2!=0:\n#                     print('Yes')\n#                 else:\n#                     print('No')\n#\n#         else:\n#\n#             if e>=z:\n#                 print('Yes')\n#             else:\n#                 z-=e\n#                 o-=z\n#                 if o%2!=0:\n#                     print('Yes')\n#                 else:\n#                     print('No')\n#     else:\n#         print('No')\n#\n#\n#\n#\n#\n#\n#\n# def dfs(n):\n#     boo[n] = True\n#     dp2[n] = 1\n#     for i in hash[n]:\n#         if not boo[i]:\n#\n#             dfs(i)\n#             dp2[n] += dp2[i]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#\n#\n# n = int(input())\n# x = 0\n# l = list(map(int,input().split()))\n# for i in range(n):\n#\n#      x = l[i]|x\n#\n# z = list(bin(x)[2:])\n# ha = z.copy()\n# k = z.count('1')\n# ans = 0\n# # print(z)\n# cnt = 0\n# for i in range(20):\n#\n#\n#         maxi = 0\n#         idx = -1\n#\n#         for j in range(n):\n#             k = bin(l[j])[2:]\n#             k = '0'*(len(z) -len(k)) + k\n#             cnt = 0\n#             for i in range(len(z)):\n#                 if k[i] == z[i] == '1':\n#                     cnt+=1\n#\n#             maxi = max(maxi,cnt)\n#             if maxi == cnt:\n#                 idx = j\n#         if idx!=-1:\n#\n#             k = bin(l[idx])[2:]\n#             k = '0'*(len(z) -len(k)) + k\n#\n#             for i in range(len(z)):\n#                 if k[i] == z[i] == '1':\n#                     z[i] = '0'\n#             l[idx] = 0\n#\n#\n# ans = 0\n# for i in range(len(z)):\n#     if z[i] == '0' and ha[i] == '1':\n#         ans+=1\n# flip = 0\n# for i in range(ans):\n#     flip+=2**i\n#\n#\n#\n# print(flip)\n\n# def search(k,l,low):\n#\n#     high = len(l)-1\n#     z = bisect_left(l,k,low,high)\n#\n#     return z\n#\n#\n#\n#\n#\n#\n# n,x = map(int,input().split())\n#\n# l = list(map(int,input().split()))\n#\n# prefix = [0]\n# ha = [0]\n# for i in l:\n#     prefix.append(i + prefix[-1])\n#     ha.append((i*(i+1))//2 + ha[-1])\n# fin = 0\n# print(prefix)\n# for i in range(n):\n#     ans = 0\n#     if l[i]<x:\n#\n#\n#         if prefix[-1]-prefix[i]>=x:\n#\n#             z = search(x+prefix[i],prefix,i+1)\n#             print(z)\n#             z+=i+1\n#             k1 = x-(prefix[z-1]-prefix[i])\n#             ans+=ha[z-1]\n#             ans+=(k1*(k1+1))//2\n#\n#\n#         else:\n#             z1 = x - (prefix[-1]-prefix[i])\n#             z = search(z1,prefix,1)\n#\n#             k1 = x-prefix[z-1]\n#             ans+=ha[z-1]\n#             ans+=(k1*(k1+1))//2\n#\n#\n#\n#\n#     elif l[i]>x:\n#         z1 = ((l[i])*(l[i]+1))//2\n#         z2 = ((l[i]-x)*(l[i]-x+1))//2\n#         ans+=z1-z2\n#     else:\n#         ans+=(x*(x+1))//2\n\n\n\n\n\n# t = int(input())\n#\n# for _ in range(t):\n#\n#     s = list(input())\n#     ans = [s[0]]\n#\n#     for i in range(1,len(s)-1,2):\n#         ans.append(s[i])\n#\n#     ans.append(s[-1])\n#     print(''.join(ans))\n#\n#\n#\n# t = int(input())\n#\n# for _ in range(t):\n#\n#     n = int(input())\n#     l = list(map(int,input().split()))\n#     ans = 0\n#     for i in range(n):\n#         if l[i]%2!=i%2:\n#             ans+=1\n#\n#     if ans%2 == 0:\n#         print(ans//2)\n#     else:\n#        print(-1)\n\n\n# t = int(input())\n#\n# for _ in range(t):\n#\n#     n,k = map(int,input().split())\n#     s = input()\n#\n#\n#     ans = 0\n#     ba = []\n#     for i in range(n):\n#         if s[i] == '1':\n#             ba.append(i)\n#     if ba == []:\n#         for i in range(0,n,k+1):\n#             ans+=1\n#\n#         print(ans)\n#         continue\n#\n#     i = s.index('1')\n#     c = 0\n#     for x in range(i-1,-1,-1):\n#         if c == k:\n#             c = 0\n#             ans+=1\n#         else:\n#             c+=1\n#\n#\n#     while i<len(s):\n#         count = 0\n#         dis = 0\n#         while s[i] == '0':\n#             dis+=1\n#             if dis == k:\n#                 dis = 0\n#                 count+=1\n#             if dis<k and s[i] == '1':\n#                 count-=1\n#                 break\n#             i+=1\n#             if i == n:\n#                 break\n#         i+=1\n#\n#     print(ans)\n#\n#\n#\n#\n\n# q1\n\n# def poss1(x):\n#     cnt = 1\n#     mini = inf\n#     for i in l:\n#         if cnt%2 != 0:\n#           cnt+=1\n#         else:\n#             if i<=x:\n#                 cnt+=1\n#                 mini = min()\n#         if cnt  == k:\n#             return\n#\n#     return -1\n#\n#\n#\n#\n# def poss2(x):\n#     cnt = 1\n#     for i in l:\n#         if cnt%2 == 0:\n#             cnt+=1\n#         else:\n#             if i<=x:\n#                 cnt+=1\n#         if cnt  == k:\n#             return\n#\n#     return -1\n#\n#\n#\n# n,k = map(int,input().split())\n# l = list(map(int,input().split()))\n#\n# z1 = min(l)\n# z2 = max(l)\n\n\n\n\n#\n# t = int(input())\n#\n# for _ in range(t):\n#\n#     n,k = map(int,input().split())\n#     l = list(map(int,input().split()))\n#\n#     l1 = list(map(int,input().split()))\n#     l.sort(reverse=True)\n#     l1.sort()\n#     for i in range(k):\n#         l1[i]-=1\n#\n#     i = 0\n#     j = k\n#     x = 0\n#     ans = sum(l[:k])\n#     # print(l)\n#     # print(l1)\n#     # print(ans)\n#     while x<k:\n#         cnt = 1\n#         z = l1[x]\n#         while z>cnt:\n#             j+=1\n#             cnt+=1\n#\n#         if z == 0:\n#             ans+=l[i]\n#             i+=1\n#         else:\n#             # print(j,z)\n#             ans+=l[j]\n#\n#             i+=1\n#             j+=1\n#         x+=1\n#\n#     print(ans)\n#\n#\n\n\n\nt = int(input())\n\nfor _ in range(t):\n\n    n = int(input())\n    s = input()\n    if '1' not in s:\n        print(s)\n        continue\n    if '0' not in s:\n        print(s)\n        continue\n    if n == 1:\n        print(s)\n        continue\n\n    z1 = n-s[::-1].index('0')-1\n    z2 = s.index('1')\n    if z1>z2:\n     print(s[:z2] + '0' + s[z1+1:])\n    else:\n        print(s)\n\n\n\n",
    "prob_desc_created_at": "1592921100",
    "tags": [
        "implementation",
        "greedy",
        "strings"
    ],
    "hidden_unit_tests": ""
}
{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"YES\\n6 1 4\\nNO\\nYES\\n2 5 2\\nYES\\n4 1 2\\nYES\\n1 1 3\\nYES\\n2 1 4\"]",
    "src_uid": "de7f5da2ded3fe0785bfa7237bac114e",
    "prob_desc_notes": null,
    "prob_desc_description": "You are given an array $$$a$$$ consisting of $$$n$$$ integers.Let $$$min(l, r)$$$ be the minimum value among $$$a_l, a_{l + 1}, \\ldots, a_r$$$ and $$$max(l, r)$$$ be the maximum value among $$$a_l, a_{l + 1}, \\ldots, a_r$$$.Your task is to choose three positive (greater than $$$0$$$) integers $$$x$$$, $$$y$$$ and $$$z$$$ such that:  $$$x + y + z = n$$$;  $$$max(1, x) = min(x + 1, x + y) = max(x + y + 1, n)$$$. In other words, you have to split the array $$$a$$$ into three consecutive non-empty parts that cover the whole array and the maximum in the first part equals the minimum in the second part and equals the maximum in the third part (or determine it is impossible to find such a partition).Among all such triples (partitions), you can choose any.You have to answer $$$t$$$ independent test cases.",
    "prob_desc_output_spec": "For each test case, print the answer: NO in the only line if there is no such partition of $$$a$$$ that satisfies the conditions from the problem statement. Otherwise, print YES in the first line and three integers $$$x$$$, $$$y$$$ and $$$z$$$ ($$$x + y + z = n$$$) in the second line. If there are several answers, you can print any.",
    "prob_desc_input_spec": "The first line of the input contains one integer $$$t$$$ ($$$1 \\le t \\le 2 \\cdot 10^4$$$) — the number of test cases. Then $$$t$$$ test cases follow. The first line of the test case contains one integer $$$n$$$ ($$$3 \\le n \\le 2 \\cdot 10^5$$$) — the length of $$$a$$$. The second line of the test case contains $$$n$$$ integers $$$a_1, a_2, \\ldots, a_n$$$ ($$$1 \\le a_i \\le 10^9$$$), where $$$a_i$$$ is the $$$i$$$-th element of $$$a$$$. It is guaranteed that the sum of $$$n$$$ does not exceed $$$2 \\cdot 10^5$$$ ($$$\\sum n \\le 2 \\cdot 10^5$$$).",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3",
    "lang_cluster": "Python",
    "difficulty": null,
    "file_name": "train_010.jsonl",
    "code_uid": "7685e2302d209eedead8d1f01e4131cf",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"6\\n11\\n1 2 3 3 3 4 4 3 4 2 1\\n8\\n2 9 1 7 3 9 4 1\\n9\\n2 1 4 2 4 3 3 1 2\\n7\\n4 2 1 1 4 1 4\\n5\\n1 1 1 1 1\\n7\\n4 3 4 3 3 3 4\"]",
    "exec_outcome": "PASSED",
    "source_code": "from bisect import *\nfrom collections import *\nfrom math import gcd,ceil,sqrt,floor,inf\nfrom heapq import *\nfrom itertools import *\nfrom operator import add,mul,sub,xor,truediv,floordiv\nfrom functools import *\n \n#------------------------------------------------------------------------\nimport os\nimport sys\nfrom io import BytesIO, IOBase\n# region fastio\n \nBUFSIZE = 8192\n \nclass FastIO(IOBase):\n    newlines = 0\n \n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n \n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n \n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n \n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n \n \nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n \n \nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n \n \n#------------------------------------------------------------------------\ndef RL(): return map(int, sys.stdin.readline().rstrip().split())\ndef RLL(): return list(map(int, sys.stdin.readline().rstrip().split()))\ndef N(): return int(input())\n#------------------------------------------------------------------------\n \nfrom types import GeneratorType\n \n \ndef bootstrap(f, stack=[]):\n    def wrappedfunc(*args, **kwargs):\n        if stack:\n            return f(*args, **kwargs)\n        else:\n            to = f(*args, **kwargs)\n            while True:\n                if type(to) is GeneratorType:\n                    stack.append(to)\n                    to = next(to)\n                else:\n                    stack.pop()\n                    if not stack:\n                        break\n                    to = stack[-1].send(to)\n            return to\n \n    return wrappedfunc\n \n \nfarr=[1]\nifa=[]\n \ndef fact(x,mod=0):\n    if mod:\n        while x>=len(farr):\n            farr.append(farr[-1]*len(farr)%mod)\n    else:\n        while x>=len(farr):\n            farr.append(farr[-1]*len(farr))\n    return farr[x]\n \ndef ifact(x,mod):\n    global ifa\n    ifa.append(pow(farr[-1],mod-2,mod))\n    for i in range(x,0,-1):\n        ifa.append(ifa[-1]*i%mod)\n    ifa=ifa[::-1]\n \ndef per(i,j,mod=0):\n    if i<j: return 0\n    if not mod:\n        return fact(i)//fact(i-j)\n    return farr[i]*ifa[i-j]%mod\n    \ndef com(i,j,mod=0):\n    if i<j: return 0\n    if not mod:        \n        return per(i,j)//fact(j)\n    return per(i,j,mod)*ifa[j]%mod\n \ndef catalan(n):\n    return com(2*n,n)//(n+1)\n    \ndef linc(f,t,l,r):\n    while l<r:\n        mid=(l+r)//2\n        if t>f(mid):\n            l=mid+1\n        else:\n            r=mid\n    return l\n \ndef rinc(f,t,l,r):\n    while l<r:\n        mid=(l+r+1)//2\n        if t<f(mid):\n            r=mid-1\n        else:\n            l=mid\n    return l\n \ndef ldec(f,t,l,r):\n    while l<r:\n        mid=(l+r)//2\n        if t<f(mid):\n            l=mid+1\n        else:\n            r=mid\n    return l\n \ndef rdec(f,t,l,r):\n    while l<r:\n        mid=(l+r+1)//2\n        if t>f(mid):\n            r=mid-1\n        else:\n            l=mid\n    return l\n \ndef isprime(n):\n    for i in range(2,int(n**0.5)+1):\n        if n%i==0:\n            return False\n    return True\n \ndef binfun(x):\n    c=0\n    for w in arr:\n        c+=ceil(w/x)\n    return c\n \ndef lowbit(n):\n    return n&-n\n \ndef inverse(a,m):\n    a%=m\n    if a<=1: return a\n    return ((1-inverse(m,a)*m)//a)%m\n \nclass BIT:\n    def __init__(self,arr):\n        self.arr=arr\n        self.n=len(arr)-1\n        \n    def update(self,x,v):\n        while x<=self.n:\n            self.arr[x]+=v\n            x+=x&-x\n \n    def query(self,x):\n        ans=0\n        while x:\n            ans+=self.arr[x]\n            x&=x-1\n        return ans\n'''\nclass SMT:\n    def __init__(self,arr):\n        self.n=len(arr)-1\n        self.arr=[0]*(self.n<<2)\n        self.lazy=[0]*(self.n<<2)\n        def Build(l,r,rt):\n            if l==r:\n                self.arr[rt]=arr[l]\n                return\n            m=(l+r)>>1\n            Build(l,m,rt<<1)\n            Build(m+1,r,rt<<1|1)\n            self.pushup(rt)\n        Build(1,self.n,1)\n \n    def pushup(self,rt):\n        self.arr[rt]=self.arr[rt<<1]+self.arr[rt<<1|1]\n \n    def pushdown(self,rt,ln,rn):#lr,rn表区间数字数\n        if self.lazy[rt]:\n            self.lazy[rt<<1]+=self.lazy[rt]\n            self.lazy[rt<<1|1]=self.lazy[rt]\n            self.arr[rt<<1]+=self.lazy[rt]*ln\n            self.arr[rt<<1|1]+=self.lazy[rt]*rn\n            self.lazy[rt]=0\n            \n    def update(self,L,R,c,l=1,r=None,rt=1):#L,R表示操作区间\n        if r==None: r=self.n\n        if L<=l and r<=R:\n            self.arr[rt]+=c*(r-l+1)\n            self.lazy[rt]+=c\n            return\n        m=(l+r)>>1\n        self.pushdown(rt,m-l+1,r-m)\n        if L<=m: self.update(L,R,c,l,m,rt<<1)\n        if R>m: self.update(L,R,c,m+1,r,rt<<1|1)\n        self.pushup(rt)\n \n    def query(self,L,R,l=1,r=None,rt=1):\n        if r==None: r=self.n\n        #print(L,R,l,r,rt)\n        if L<=l and R>=r:\n            return self.arr[rt]\n        m=(l+r)>>1\n        self.pushdown(rt,m-l+1,r-m)\n        ans=0\n        if L<=m: ans+=self.query(L,R,l,m,rt<<1)\n        if R>m: ans+=self.query(L,R,m+1,r,rt<<1|1)\n        return ans\n'''       \nclass DSU:#容量+路径压缩\n    def __init__(self,n):\n        self.c=[-1]*n\n \n    def same(self,x,y):\n        return self.find(x)==self.find(y)\n \n    def find(self,x):\n        if self.c[x]<0:\n            return x\n        self.c[x]=self.find(self.c[x])\n        return self.c[x]\n \n    def union(self,u,v):\n        u,v=self.find(u),self.find(v)\n        if u==v:\n            return False\n        if self.c[u]<self.c[v]:\n            u,v=v,u\n        self.c[u]+=self.c[v]\n        self.c[v]=u\n        return True\n \n    def size(self,x): return -self.c[self.find(x)]\n    \nclass UFS:#秩+路径\n    def __init__(self,n):\n        self.parent=[i for i in range(n)]\n        self.ranks=[0]*n\n \n    def find(self,x):\n        if x!=self.parent[x]:\n            self.parent[x]=self.find(self.parent[x])\n        return self.parent[x]\n \n    def union(self,u,v):\n        pu,pv=self.find(u),self.find(v)\n        if pu==pv:\n            return False\n        if self.ranks[pu]>=self.ranks[pv]:\n            self.parent[pv]=pu\n            if self.ranks[pv]==self.ranks[pu]:\n                self.ranks[pu]+=1\n        else:\n            self.parent[pu]=pv\n \ndef Prime(n):\n    c=0\n    prime=[]\n    flag=[0]*(n+1)\n    for i in range(2,n+1):\n        if not flag[i]:\n            prime.append(i)\n            c+=1\n        for j in range(c):\n            if i*prime[j]>n: break\n            flag[i*prime[j]]=prime[j]\n            if i%prime[j]==0: break\n    return prime\n \ndef dij(s,graph):\n    d={}\n    d[s]=0\n    heap=[(0,s)]\n    seen=set()\n    while heap:\n        dis,u=heappop(heap)\n        if u in seen:\n            continue\n        for v in graph[u]:\n            if v not in d or d[v]>d[u]+graph[u][v]:\n                d[v]=d[u]+graph[u][v]\n                heappush(heap,(d[v],v))\n    return d\n \ndef GP(it): return [[ch,len(list(g))] for ch,g in groupby(it)]\n \nclass DLN:\n    def __init__(self,val):\n        self.val=val\n        self.pre=None\n        self.next=None\n\n  \nt=N()\nfor i in range(t):\n    n=N()\n    a=RLL()\n    ma=max(a)\n    res=[]\n    c=0\n    for i,x in enumerate(a):\n        if x==ma:\n            c+=1\n            res.append(i+1)\n    if c>=3:\n        x=res[1]-1\n        y=1\n        z=n-x-y\n        print('YES')\n        print(x,y,z)\n    else:\n        l=r=res[0]-1\n        pre=[0]*n\n        suf=[0]*n\n        pre[0]=a[0]\n        suf[n-1]=a[n-1]\n        #print(l,r)\n        for i in range(l):\n            pre[i]=max(pre[i-1],a[i])\n        for j in range(n-2,r,-1):\n            suf[j]=max(suf[j+1],a[j])\n        s=set(a)\n        s=sorted(s,reverse=True)\n        f=0\n        c=Counter()\n        c[a[l]]+=1\n        for j in range(1,len(s)):\n            while r<n-1 and a[r+1]>=s[j]: \n                c[a[r+1]]+=1\n                r+=1\n            while l>0 and a[l-1]>=s[j]:\n                l-=1\n                c[a[l]]+=1\n            #print(s[j],l,r,c)\n            tmp=c[s[j]]\n            x=l\n            y=r+1-x\n            if l==0:\n                if a[l]==s[j]:\n                    x=1\n                    y-=1\n                    tmp-=1\n                else:\n                    break\n            else:\n                if pre[l-1]>s[j]:\n                    continue\n                elif pre[l-1]<s[j]:\n                    if a[l]==s[j]:\n                        x+=1\n                        y-=1\n                        tmp-=1\n                    else:\n                        continue\n            if r==n-1:\n                if a[r]==s[j]:\n                    tmp-=1\n                    y-=1\n                else:\n                    break\n            else:\n                #print(suf[r+1],s[j])\n                if suf[r+1]>s[j]:\n                    continue\n                elif suf[r+1]<s[j]:\n                    if a[r]==s[j]:\n                        y-=1\n                        tmp-=1\n                    else:\n                        continue\n            if tmp:\n                f=1\n                break\n        if f:\n            print('YES')\n            #if not max(a[:x])==min(a[x:x+y])==max(a[x+y:]):\n                #print(a)\n            print(x,y,n-x-y)\n        else:\n            print('NO')\n\n\n''' \nsys.setrecursionlimit(200000)\nimport threading\nthreading.stack_size(10**8)\nt=threading.Thread(target=main)\nt.start()\nt.join()\n'''\n\n''' \nsys.setrecursionlimit(200000)\nimport threading\nthreading.stack_size(10**8)\nt=threading.Thread(target=main)\nt.start()\nt.join()\n'''\n",
    "prob_desc_created_at": "1606228500",
    "tags": [
        "data structures",
        "two pointers",
        "binary search",
        "greedy"
    ],
    "hidden_unit_tests": ""
}
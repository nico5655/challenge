{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"1\", \"2\"]",
    "src_uid": "74da42a1627e4a00fbaae91c75140287",
    "prob_desc_notes": null,
    "prob_desc_description": "Iahub and Sorin are the best competitive programmers in their town. However, they can't both qualify to an important contest. The selection will be made with the help of a single problem. Blatnatalag, a friend of Iahub, managed to get hold of the problem before the contest. Because he wants to make sure Iahub will be the one qualified, he tells Iahub the following task.You're given an (1-based) array a with n elements. Let's define function f(i, j) (1 ≤ i, j ≤ n) as (i - j)2 + g(i, j)2. Function g is calculated by the following pseudo-code:int g(int i, int j) {    int sum = 0;    for (int k = min(i, j) + 1; k &lt;= max(i, j); k = k + 1)        sum = sum + a[k];    return sum;}Find a value mini ≠ j  f(i, j).Probably by now Iahub already figured out the solution to this problem. Can you?",
    "prob_desc_output_spec": "Output a single integer — the value of mini ≠ j  f(i, j).",
    "prob_desc_input_spec": "The first line of input contains a single integer n (2 ≤ n ≤ 100000). Next line contains n integers a[1], a[2], ..., a[n] ( - 104 ≤ a[i] ≤ 104). ",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 2",
    "lang_cluster": "Python",
    "difficulty": 2200,
    "file_name": "train_066.jsonl",
    "code_uid": "b5e6750d3e97a9ed00febe76f645faf9",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"4\\n1 0 0 -1\", \"2\\n1 -1\"]",
    "exec_outcome": "PASSED",
    "source_code": "import sys\n\nsys.setrecursionlimit(10 ** 6)\n\ndef pyes_no(condition) :\n  if condition :\n    print (\"YES\")\n  else :\n    print (\"NO\")\n\ndef plist(a, s = ' ') :\n  print (s.join(map(str, a)))\n\ndef rint() :\n  return int(sys.stdin.readline())\n\ndef rints() :\n  return map(int, sys.stdin.readline().split())\n\ndef rfield(n, m = None) :\n  if m == None :\n    m = n\n  \n  field = []\n  for i in xrange(n) :\n    chars = sys.stdin.readline().strip()\n    assert(len(chars) == m)\n    field.append(chars)\n  return field\n\ndef pfield(field, separator = '') :\n  print ('\\n'.join(map(lambda x: separator.join(x), field)))\n\ndef check_field_equal(field, i, j, value) :\n  if i >= 0 and i < len(field) and j >= 0 and j < len(field[i]) :\n    return value == field[i][j]\n  return None \n\ndef digits(x, p) :\n  digits = []\n  while x > 0 :\n    digits.append(x % p)\n    x //= p\n  return digits\n\ndef modpower(a, n, mod) :\n  r = a ** (n % 2)\n  if n > 1 :\n    r *= modpower(a, n // 2, mod) ** 2\n  return r % mod\n\ndef gcd(a, b) :\n  if a > b :\n    a, b = b, a\n  \n  while a > 0 :\n    a, b = b % a, a\n\n  return b\n\ndef vector_distance(a, b) :\n  diff = vector_diff(a, b)\n  \n  return scalar_product(diff, diff) ** 0.5\n\ndef vector_inverse(v) :\n  r = [-x for x in v]\n\n  return tuple(r)\n\ndef vector_diff(a, b) :\n  return vector_sum(a, vector_inverse(b))\n\ndef vector_sum(a, b) :\n  r = [c1 + c2 for c1, c2 in zip(a, b)]\n    \n  return tuple(r)\n\ndef scalar_product(a, b) :\n  r = 0\n  for c1, c2 in zip(a, b) :\n    r += c1 * c2\n\n  return r\n\ndef check_rectangle(points) :\n  assert(len(points) == 4)\n\n  A, B, C, D = points\n\n  for A1, A2, A3, A4 in [\n    (A, B, C, D),\n    (A, C, B, D),\n    (A, B, D, C),\n    (A, C, D, B),\n    (A, D, B, C),\n    (A, D, C, B),\n  ] :\n    sides = (\n      vector_diff(A1, A2),\n      vector_diff(A2, A3),\n      vector_diff(A3, A4),\n      vector_diff(A4, A1),\n    )\n    if all(scalar_product(s1, s2) == 0 for s1, s2 in zip(sides, sides[1:])) :\n       return True\n  return False\n\ndef check_square(points) :\n  if not check_rectangle(points) :\n    return False\n  A, B, C, D = points\n\n  for A1, A2, A3, A4 in [\n    (A, B, C, D),\n    (A, C, B, D),\n    (A, B, D, C),\n    (A, C, D, B),\n    (A, D, B, C),\n    (A, D, C, B),\n  ] :\n    side_lengths = [\n      (first[0] - next[0]) ** 2 + (first[1] - next[1]) ** 2 for first, next in zip([A1, A2, A3, A4], [A2, A3, A4, A1])\n    ]\n    if len(set(side_lengths)) == 1 :\n      return True\n    \n  return False\n\ndef check_right(p) :\n  # Check if there are same points\n  for a, b in [\n    (p[0], p[1]),\n    (p[0], p[2]),\n    (p[1], p[2]),\n  ] :\n    if a[0] == b[0] and a[1] == b[1] :\n      return False\n\n  a, b, c = p\n  a, b, c = vector_diff(a, b), vector_diff(b, c), vector_diff(c, a)   \n\n  return scalar_product(a, b) * scalar_product(a, c) * scalar_product(b, c) == 0\n\ndef partial_sum(a) :\n  p = [0] * (len(a) + 1)\n  for i, x in enumerate(a) :\n    p[i + 1] = x + p[i]\n\n  return p\n\ndef distance(a, b, i, j) :\n  return (a - b) ** 2 + (i + j) ** 2\n\n# from __future__ import generators\n\ndef closestpair(L):\n\tdef square(x): return x*x\n\tdef sqdist(p,q): return square(p[0]-q[0])+square(p[1]-q[1])\n\t\n\t# Work around ridiculous Python inability to change variables in outer scopes\n\t# by storing a list \"best\", where best[0] = smallest sqdist found so far and\n\t# best[1] = pair of points giving that value of sqdist.  Then best itself is never\n\t# changed, but its elements best[0] and best[1] can be.\n\t#\n\t# We use the pair L[0],L[1] as our initial guess at a small distance.\n\tbest = [sqdist(L[0],L[1]), (L[0],L[1])]\n\t\n\t# check whether pair (p,q) forms a closer pair than one seen already\n\tdef testpair(p,q):\n\t\td = sqdist(p,q)\n\t\tif d < best[0]:\n\t\t\tbest[0] = d\n\t\t\tbest[1] = p,q\n\t\t\t\n\t# merge two sorted lists by y-coordinate\n\tdef merge(A,B):\n\t\ti = 0\n\t\tj = 0\n\t\twhile i < len(A) or j < len(B):\n\t\t\tif j >= len(B) or (i < len(A) and A[i][1] <= B[j][1]):\n\t\t\t\tyield A[i]\n\t\t\t\ti += 1\n\t\t\telse:\n\t\t\t\tyield B[j]\n\t\t\t\tj += 1\n\n\t# Find closest pair recursively; returns all points sorted by y coordinate\n\tdef recur(L):\n\t\tif len(L) < 2:\n\t\t\treturn L\n\t\tsplit = len(L)/2\n\t\tsplitx = L[split][0]\n\t\tL = list(merge(recur(L[:split]), recur(L[split:])))\n\n\t\t# Find possible closest pair across split line\n\t\t# Note: this is not quite the same as the algorithm described in class, because\n\t\t# we use the global minimum distance found so far (best[0]), instead of\n\t\t# the best distance found within the recursive calls made by this call to recur().\n\t\t# This change reduces the size of E, speeding up the algorithm a little.\n\t\t#\n\t\tE = [p for p in L if abs(p[0]-splitx) < best[0]]\n\t\tfor i in range(len(E)):\n\t\t\tfor j in range(1,8):\n\t\t\t\tif i+j < len(E):\n\t\t\t\t\ttestpair(E[i],E[i+j])\n\t\treturn L\n\t\n\tL.sort()\n\trecur(L)\n\treturn best[1]\n\n\nn = rint()\n\na = rints()[1:]\na = partial_sum(a)\npoints = list(enumerate(a))\n\np1, p2 = closestpair(points)\n\nprint (p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2\n",
    "prob_desc_created_at": "1399822800",
    "tags": [
        "data structures",
        "geometry",
        "divide and conquer"
    ],
    "hidden_unit_tests": ""
}
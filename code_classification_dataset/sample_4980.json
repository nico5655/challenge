{
    "prob_desc_time_limit": "9 seconds",
    "prob_desc_sample_outputs": "[\"YES\\nabc\", \"NO\", \"YES\\nbaaaaaaaaa\", \"NO\"]",
    "src_uid": "8c33618363cacf005e4735cecfdbe2eb",
    "prob_desc_notes": null,
    "prob_desc_description": "You are given a tree consisting of $$$n$$$ vertices, and $$$q$$$ triples $$$(x_i, y_i, s_i)$$$, where $$$x_i$$$ and $$$y_i$$$ are integers from $$$1$$$ to $$$n$$$, and $$$s_i$$$ is a string with length equal to the number of vertices on the simple path from $$$x_i$$$ to $$$y_i$$$.You want to write a lowercase Latin letter on each vertex in such a way that, for each of $$$q$$$ given triples, at least one of the following conditions holds:  if you write out the letters on the vertices on the simple path from $$$x_i$$$ to $$$y_i$$$ in the order they appear on this path, you get the string $$$s_i$$$;  if you write out the letters on the vertices on the simple path from $$$y_i$$$ to $$$x_i$$$ in the order they appear on this path, you get the string $$$s_i$$$. Find any possible way to write a letter on each vertex to meet these constraints, or report that it is impossible.",
    "prob_desc_output_spec": "If there is no way to meet the conditions on all triples, print NO. Otherwise, print YES in the first line, and a string of $$$n$$$ lowercase Latin letters in the second line; the $$$i$$$-th character of the string should be the letter you write on the $$$i$$$-th vertex. If there are multiple answers, print any of them.",
    "prob_desc_input_spec": "The first line contains two integers $$$n$$$ and $$$q$$$ ($$$2 \\le n \\le 4 \\cdot 10^5$$$; $$$1 \\le q \\le 4 \\cdot 10^5$$$) — the number of vertices in the tree and the number of triples, respectively. Then $$$n - 1$$$ lines follow; the $$$i$$$-th of them contains two integers $$$u_i$$$ and $$$v_i$$$ ($$$1 \\le u_i, v_i \\le n$$$; $$$u_i \\ne v_i$$$) — the endpoints of the $$$i$$$-th edge. These edges form a tree. Then $$$q$$$ lines follow; the $$$j$$$-th of them contains two integers $$$x_j$$$ and $$$y_j$$$, and a string $$$s_j$$$ consisting of lowercase Latin letters. The length of $$$s_j$$$ is equal to the number of vertices on the simple path between $$$x_j$$$ and $$$y_j$$$. Additional constraint on the input: $$$\\sum \\limits_{j=1}^{q} |s_j| \\le 4 \\cdot 10^5$$$.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3-64",
    "lang_cluster": "Python",
    "difficulty": 2600,
    "file_name": "train_110.jsonl",
    "code_uid": "c8bbe3b1d97d762a0751ebd67a89958b",
    "prob_desc_memory_limit": "1024 megabytes",
    "prob_desc_sample_inputs": "[\"3 2\\n2 3\\n2 1\\n2 1 ab\\n2 3 bc\", \"3 2\\n2 3\\n2 1\\n2 1 ab\\n2 3 cd\", \"10 10\\n1 2\\n1 3\\n1 4\\n1 5\\n1 6\\n1 7\\n1 8\\n1 9\\n1 10\\n1 2 ab\\n1 3 ab\\n1 4 ab\\n1 5 ab\\n1 6 ab\\n1 7 ab\\n1 8 ab\\n1 9 ab\\n1 10 ab\\n10 2 aba\", \"10 10\\n1 2\\n1 3\\n1 4\\n1 5\\n1 6\\n1 7\\n1 8\\n1 9\\n1 10\\n1 2 ab\\n1 3 ab\\n1 4 aa\\n1 5 ab\\n1 6 ab\\n1 7 ab\\n1 8 ab\\n1 9 ab\\n1 10 ab\\n10 2 aba\"]",
    "exec_outcome": "PASSED",
    "source_code": "class _csr:\r\n    def __init__(self, n, edges):\r\n        self.start = [0] * (n + 1)\r\n        self.elist = [0] * len(edges)\r\n        for v, _ in edges:\r\n            self.start[v + 1] += 1\r\n        for i in range(1, n + 1):\r\n            self.start[i] += self.start[i - 1]\r\n        counter = self.start.copy()\r\n        for v, e in edges:\r\n            self.elist[counter[v]] = e\r\n            counter[v] += 1\r\n\r\nclass scc_graph:\r\n    \"\"\"It calculates the strongly connected components of directed graphs.\r\n    \"\"\"\r\n \r\n    def __init__(self, n):\r\n        \"\"\"It creates a directed graph with n vertices and 0 edges.\r\n \r\n        Constraints\r\n        -----------\r\n \r\n        >   0 <= n <= 10 ** 8\r\n \r\n        Complexity\r\n        ----------\r\n \r\n        >   O(n)\r\n        \"\"\"\r\n        self.n = n\r\n        self.edges = []\r\n \r\n    def add_edge(self, from_, to):\r\n        \"\"\"It adds a directed edge from the vertex `from_` to the vertex `to`.\r\n \r\n        Constraints\r\n        -----------\r\n \r\n        >   0 <= from_ < n\r\n \r\n        >   0 <= to < n\r\n \r\n        Complexity\r\n        ----------\r\n \r\n        >   O(1) amortized\r\n        \"\"\"\r\n        # assert 0 <= from_ < self.n\r\n        # assert 0 <= to < self.n\r\n        self.edges.append((from_, to))\r\n \r\n    def _scc_ids(self):\r\n        g = _csr(self.n, self.edges)\r\n        now_ord = 0\r\n        group_num = 0\r\n        visited = []\r\n        low = [0] * self.n\r\n        order = [-1] * self.n\r\n        ids = [0] * self.n\r\n        parent = [-1] * self.n\r\n        stack = []\r\n        for i in range(self.n):\r\n            if order[i] == -1:\r\n                stack.append(i)\r\n                stack.append(i)\r\n                while stack:\r\n                    v = stack.pop()\r\n                    if order[v] == -1:\r\n                        low[v] = order[v] = now_ord\r\n                        now_ord += 1\r\n                        visited.append(v)\r\n                        for i in range(g.start[v], g.start[v + 1]):\r\n                            to = g.elist[i]\r\n                            if order[to] == -1:\r\n                                stack.append(to)\r\n                                stack.append(to)\r\n                                parent[to] = v\r\n                            else:\r\n                                low[v] = min(low[v], order[to])\r\n                    else:\r\n                        if low[v] == order[v]:\r\n                            while True:\r\n                                u = visited.pop()\r\n                                order[u] = self.n\r\n                                ids[u] = group_num\r\n                                if u == v:\r\n                                    break\r\n                            group_num += 1\r\n                        if parent[v] != -1:\r\n                            low[parent[v]] = min(low[parent[v]], low[v])\r\n        for i, x in enumerate(ids):\r\n            ids[i] = group_num - 1 - x\r\n        return group_num, ids\r\n \r\n    def scc(self):\r\n        \"\"\"It returns the list of the \"list of the vertices\" that satisfies the following.\r\n \r\n        >   Each vertex is in exactly one \"list of the vertices\".\r\n \r\n        >   Each \"list of the vertices\" corresponds to the vertex set of a strongly connected component.\r\n        The order of the vertices in the list is undefined.\r\n \r\n        >   The list of \"list of the vertices\" are sorted in topological order,\r\n        i.e., for two vertices u, v in different strongly connected components,\r\n        if there is a directed path from u to v,\r\n        the list contains u appears earlier than the list contains v.\r\n \r\n        Complexity\r\n        ----------\r\n \r\n        >   O(n + m), where m is the number of added edges.\r\n        \"\"\"\r\n        group_num, ids = self._scc_ids()\r\n        groups = [[] for _ in range(group_num)]\r\n        for i, x in enumerate(ids):\r\n            groups[x].append(i)\r\n        return groups\r\n \r\n \r\nclass two_sat:\r\n    \"\"\"It solves 2-SAT.\r\n \r\n    For variables x[0], x[1], ..., x[n-1] and clauses with form\r\n \r\n    >   ((x[i] = f) or (x[j] = g)),\r\n \r\n    it decides whether there is a truth assignment that satisfies all clauses.\r\n    \"\"\"\r\n \r\n    def __init__(self, n):\r\n        \"\"\"It creates a 2-SAT of n variables and 0 clauses.\r\n \r\n        Constraints\r\n        -----------\r\n \r\n        >   0 <= n <= 10 ** 8\r\n \r\n        Complexity\r\n        ----------\r\n \r\n        >   O(n)\r\n        \"\"\"\r\n        self.n = n\r\n        self._answer = [False] * n\r\n        self.scc = scc_graph(2 * n)\r\n \r\n    def add_clause(self, i, f, j, g):\r\n        \"\"\"It adds a clause ((x[i] = f) or (x[j] = g)).\r\n \r\n        Constraints\r\n        -----------\r\n \r\n        >   0 <= i < n\r\n \r\n        >   0 <= j < n\r\n \r\n        Complexity\r\n        ----------\r\n \r\n        >   O(1) amortized\r\n        \"\"\"\r\n        # assert 0 <= i < self.n\r\n        # assert 0 <= j < self.n\r\n        self.scc.add_edge(2 * i + (f == 0), 2 * j + (g == 1))\r\n        self.scc.add_edge(2 * j + (g == 0), 2 * i + (f == 1))\r\n \r\n    def satisfiable(self):\r\n        \"\"\"If there is a truth assignment that satisfies all clauses, it returns `True`.\r\n        Otherwise, it returns `False`.\r\n \r\n        Constraints\r\n        -----------\r\n \r\n        >   You may call it multiple times.\r\n \r\n        Complexity\r\n        ----------\r\n \r\n        >   O(n + m), where m is the number of added clauses.\r\n        \"\"\"\r\n        _, ids = self.scc._scc_ids()\r\n        for i in range(self.n):\r\n            if ids[2 * i] == ids[2 * i + 1]:\r\n                return False\r\n            self._answer[i] = (ids[2*i] < ids[2*i+1])\r\n        return True\r\n \r\n    def answer(self):\r\n        \"\"\"It returns a truth assignment that satisfies all clauses of the last call of `satisfiable`.\r\n        If we call it before calling `satisfiable` or when the last call of `satisfiable` returns `False`,\r\n        it returns the list of length n with undefined elements.\r\n \r\n        Complexity\r\n        ----------\r\n \r\n        >   O(n)\r\n        \"\"\"\r\n        return self._answer.copy()\r\n\r\nimport sys,random,bisect\r\nfrom collections import deque,defaultdict\r\nfrom heapq import heapify,heappop,heappush\r\nfrom itertools import permutations\r\nfrom math import gcd,log\r\n\r\ninput = lambda :sys.stdin.readline().rstrip()\r\nmi = lambda :map(int,input().split())\r\nli = lambda :list(mi())\r\n\r\nN,Q = mi()\r\nedge = [[] for v in range(N)]\r\nfor _ in range(N-1):\r\n    u,v = mi()\r\n    edge[u-1].append(v-1)\r\n    edge[v-1].append(u-1)\r\n\r\nparent = [[-1]*19 for i in range(N)]\r\ndepth = [0] * N\r\ndeq = deque([0])\r\nwhile deq:\r\n    v = deq.popleft()\r\n    for nv in edge[v]:\r\n        if nv==parent[v][0]:\r\n            continue\r\n        parent[nv][0] = v\r\n        depth[nv] = depth[v] + 1\r\n        deq.append(nv)\r\n\r\nfor k in range(1,19):\r\n    for v in range(N):\r\n        if parent[v][k-1]==-1:\r\n            parent[v][k] = -1\r\n        else:\r\n            pv = parent[v][k-1]\r\n            parent[v][k] = parent[pv][k-1]\r\n    \r\n\r\ndef lca(u,v):\r\n    if depth[u] > depth[v]:\r\n        u,v = v,u\r\n    \r\n    dd = depth[v] - depth[u]\r\n    for k in range(19)[::-1]:\r\n        if dd>>k & 1:\r\n            v = parent[v][k]\r\n    \r\n    if u==v:\r\n        return u\r\n        \r\n    for k in range(19)[::-1]:\r\n        pu,pv = parent[u][k],parent[v][k]\r\n        if pu!=pv:\r\n            u,v = pu,pv\r\n    return parent[u][0]\r\n\r\ndef path(u,v):\r\n    L = lca(u,v)\r\n    res0 = [u]\r\n    pos = u\r\n    while pos!=L:\r\n        pos = parent[pos][0]\r\n        res0.append(pos)\r\n    \r\n    res1 = [v]\r\n    pos = v\r\n    while pos!=L:\r\n        pos = parent[pos][0]\r\n        res1.append(pos)\r\n    res1.pop()\r\n    return res0 + res1[::-1]\r\n\r\ncand = [None for v in range(N)]\r\nstring = []\r\nfor i in range(Q):\r\n    u,v,s = input().split()\r\n    u,v = int(u)-1,int(v)-1\r\n\r\n    p = path(u,v)\r\n    n = len(s)\r\n    for j in range(n):\r\n        v = p[j]\r\n        if cand[v] is None:\r\n            cand[v] = set([s[j],s[-j-1]])\r\n        else:\r\n            cand[v] &= set([s[j],s[-j-1]])\r\n    string.append((u,v,s))\r\n\r\nfor v in range(N):\r\n    if cand[v] is None:\r\n        cand[v] = [\"a\",\"b\"]\r\n    else:\r\n        cand[v] = list(cand[v]) + [\"(\",\")\"][:2-len(cand[v])]\r\n\r\n#print(cand)\r\n\r\nG = two_sat(N+Q)\r\nfor i in range(Q):\r\n    u,v,s = string[i]\r\n    p = path(u,v)\r\n    n = len(s)\r\n    for j in range(n):\r\n        if s[j]==s[-j-1]:\r\n            continue\r\n\r\n        v = p[j]\r\n\r\n        t = s[j]\r\n        if t==cand[v][0]:\r\n            G.add_clause(i+N,1,v,0)\r\n        elif t==cand[v][1]:\r\n            G.add_clause(i+N,1,v,1)\r\n        else:\r\n            G.add_clause(i+N,1,i+N,1)\r\n        \r\n        t = s[-j-1]\r\n        if t==cand[v][0]:\r\n            G.add_clause(i+N,0,v,0)\r\n        elif t==cand[v][1]:\r\n            G.add_clause(i+N,0,v,1)\r\n        else:\r\n            G.add_clause(i+N,0,i+N,0)\r\n\r\ncheck = G.satisfiable()\r\nif not check:\r\n    exit(print(\"NO\"))\r\n\r\nans = G.answer()\r\nres = []\r\nfor v in range(N):\r\n    if ans[v]:\r\n        res.append(cand[v][1])\r\n    else:\r\n        res.append(cand[v][0])\r\n#print(res,ans)\r\nfor i in range(Q):\r\n    u,v,s = string[i]\r\n    p = path(u,v)\r\n    n = len(s)\r\n\r\n    if any(res[p[j]]!=s[j] for j in range(n)) and any(res[p[j]]!=s[-j-1] for j in range(n)):\r\n        exit(print(\"NO\"))\r\n\r\nprint(\"YES\")\r\nprint(\"\".join(res))\r\n    \r\n    ",
    "prob_desc_created_at": "1647960300",
    "tags": [
        "2-sat",
        "dfs and similar",
        "dsu",
        "graphs",
        "trees"
    ],
    "hidden_unit_tests": ""
}
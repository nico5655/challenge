{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"5\\n10\\n5\\n2\\n5\\n3\\n1\\n0\", \"49\\n35\\n24\\n29\\n49\\n39\\n31\\n23\\n29\\n27\", \"1332632508\\n1333333000\"]",
    "src_uid": "c72b1a45f5cf80a31c239cf1409c0104",
    "prob_desc_notes": null,
    "prob_desc_description": "You are given a matrix, consisting of $$$n$$$ rows and $$$m$$$ columns. The rows are numbered top to bottom, the columns are numbered left to right.Each cell of the matrix can be either free or locked.Let's call a path in the matrix a staircase if it:   starts and ends in the free cell;  visits only free cells;  has one of the two following structures:   the second cell is $$$1$$$ to the right from the first one, the third cell is $$$1$$$ to the bottom from the second one, the fourth cell is $$$1$$$ to the right from the third one, and so on;  the second cell is $$$1$$$ to the bottom from the first one, the third cell is $$$1$$$ to the right from the second one, the fourth cell is $$$1$$$ to the bottom from the third one, and so on.  In particular, a path, consisting of a single cell, is considered to be a staircase.Here are some examples of staircases:  Initially all the cells of the matrix are free.You have to process $$$q$$$ queries, each of them flips the state of a single cell. So, if a cell is currently free, it makes it locked, and if a cell is currently locked, it makes it free.Print the number of different staircases after each query. Two staircases are considered different if there exists such a cell that appears in one path and doesn't appear in the other path.",
    "prob_desc_output_spec": "Print $$$q$$$ integers — the $$$i$$$-th value should be equal to the number of different staircases after $$$i$$$ queries. Two staircases are considered different if there exists such a cell that appears in one path and doesn't appear in the other path.",
    "prob_desc_input_spec": "The first line contains three integers $$$n$$$, $$$m$$$ and $$$q$$$ ($$$1 \\le n, m \\le 1000$$$; $$$1 \\le q \\le 10^4$$$) — the sizes of the matrix and the number of queries. Each of the next $$$q$$$ lines contains two integers $$$x$$$ and $$$y$$$ ($$$1 \\le x \\le n$$$; $$$1 \\le y \\le m$$$) — the description of each query.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "Python 3",
    "lang_cluster": "Python",
    "difficulty": 2100,
    "file_name": "train_090.jsonl",
    "code_uid": "413ca9100c30f80ee9eaf5cb2abae5fe",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"2 2 8\\n1 1\\n1 1\\n1 1\\n2 2\\n1 1\\n1 2\\n2 1\\n1 1\", \"3 4 10\\n1 4\\n1 2\\n2 3\\n1 2\\n2 3\\n3 2\\n1 3\\n3 4\\n1 3\\n3 1\", \"1000 1000 2\\n239 634\\n239 634\"]",
    "exec_outcome": "PASSED",
    "source_code": "class SplayTree():\r\n\tdef __init__(self):\r\n\t\tself.children={}\r\n\t\tself.parents={}\r\n\t\tself.root=None\r\n\tdef insert(self, x):\r\n\t\tif self.root is None:\r\n\t\t\tself.root=x\r\n\t\t\tself.children[x]=[None,None]\r\n\t\t\tself.parents[x]=None\r\n\t\telse:\r\n\t\t\tcurr = self.root\r\n\t\t\twhile True:\r\n\t\t\t\tif curr == x:\r\n\t\t\t\t\tself.splay(x)\r\n\t\t\t\t\treturn None\r\n\t\t\t\telif x < curr:\r\n\t\t\t\t\tif self.children[curr][0] is None:\r\n\t\t\t\t\t\tself.children[curr][0] = x\r\n\t\t\t\t\t\tself.children[x] = [None, None]\r\n\t\t\t\t\t\tself.parents[x] = curr\r\n\t\t\t\t\t\tself.splay(x)\r\n\t\t\t\t\t\treturn None\r\n\t\t\t\t\telse:\r\n\t\t\t\t\t\tcurr = self.children[curr][0]\r\n\t\t\t\telse:\r\n\t\t\t\t\tif self.children[curr][1] is None:\r\n\t\t\t\t\t\tself.children[curr][1] = x\r\n\t\t\t\t\t\tself.children[x] = [None, None]\r\n\t\t\t\t\t\tself.parents[x] = curr\r\n\t\t\t\t\t\tself.splay(x)\r\n\t\t\t\t\t\treturn None\r\n\t\t\t\t\telse:\r\n\t\t\t\t\t\tcurr = self.children[curr][1]\r\n\r\n\tdef find(self, x):\r\n\t\treturn x in self.parents\r\n\r\n\tdef delete(self, x, show=False):\r\n\t\tif self.children[x][0] is None and self.children[x][1] is None:\r\n\t\t\tif self.root == x:\r\n\t\t\t\tself.root = None\r\n\t\t\tdel self.children[x]\r\n\t\t\tp = self.parents[x]\r\n\t\t\tdel self.parents[x]\r\n\t\t\tfor i in range(2):\r\n\t\t\t\tif self.children[p][i] == x:\r\n\t\t\t\t\tself.children[p][i] = None\r\n\t\t\tself.splay(p)\r\n\t\telif self.children[x][0] is None or self.children[x][1] is None:\r\n\t\t\tif self.children[x][0] is None:\r\n\t\t\t\tind = 1\r\n\t\t\telse:\r\n\t\t\t\tind = 0\r\n\t\t\tchild = self.children[x][ind]\r\n\t\t\tif self.root == x:\r\n\t\t\t\tself.root = child\r\n\t\t\t\tdel self.children[x]\r\n\t\t\t\tdel self.parents[x]\r\n\t\t\t\tself.parents[child] = None\r\n\t\t\telse:\r\n\t\t\t\tp = self.parents[x]\r\n\t\t\t\tself.parents[child] = p\r\n\t\t\t\tfor i in range(2):\r\n\t\t\t\t\tif self.children[p][i] == x:\r\n\t\t\t\t\t\tself.children[p][i] = child\r\n\t\t\t\tdel self.parents[x]\r\n\t\t\t\tdel self.children[x]\r\n\t\t\t\tself.splay(p)\r\n\t\telse:\r\n\t\t\ts = self.successor(x)\r\n\t\t\tif self.parents[s] == x:\r\n\t\t\t\tskids = self.children[s][:]\r\n\t\t\t\txkid = self.children[x][0]\r\n\t\t\t\txpar = self.parents[x]\r\n\t\t\t\tself.children[s] = [xkid, x]\r\n\t\t\t\tself.parents[s] = xpar\r\n\t\t\t\tself.children[x] = skids\r\n\t\t\t\tself.parents[x] = s\r\n\t\t\t\tfor i in skids:\r\n\t\t\t\t\tif i is not None:\r\n\t\t\t\t\t\tself.parents[i] = x\r\n\t\t\t\tif xkid is not None:\r\n\t\t\t\t\tself.parents[xkid] = s\r\n\t\t\t\tif xpar is not None:\r\n\t\t\t\t\tfor i in range(2):\r\n\t\t\t\t\t\tif self.children[xpar][i] == x:\r\n\t\t\t\t\t\t\tself.children[xpar][i] = s\r\n\t\t\t\tif self.root == x:\r\n\t\t\t\t\tself.root = s\r\n\t\t\t\tself.delete(x)\r\n\t\t\t\tif xpar is not None:\r\n\t\t\t\t\tself.splay(xpar)\r\n\t\t\telse:\r\n\t\t\t\tskids = self.children[s][:]\r\n\t\t\t\tspar = self.parents[s]\r\n\t\t\t\txkids = self.children[x][:]\r\n\t\t\t\txpar = self.parents[x]\r\n\t\t\t\tself.children[s] = xkids\r\n\t\t\t\tself.parents[s] = xpar\r\n\t\t\t\tself.children[x] = skids\r\n\t\t\t\tself.parents[x] = spar\r\n\t\t\t\tfor i in skids:\r\n\t\t\t\t\tif i is not None:\r\n\t\t\t\t\t\tself.parents[i] = x\r\n\t\t\t\tfor i in xkids:\r\n\t\t\t\t\tif i is not None:\r\n\t\t\t\t\t\tself.parents[i] = s\r\n\t\t\t\tfor i in range(2):\r\n\t\t\t\t\tif spar is not None and self.children[spar][i] == s:\r\n\t\t\t\t\t\tself.children[spar][i] = x\r\n\t\t\t\t\tif xpar is not None and self.children[xpar][i] == x:\r\n\t\t\t\t\t\tself.children[xpar][i] = s\r\n\t\t\t\tif self.root == x:\r\n\t\t\t\t\tself.root = s\r\n\t\t\t\tif show:\r\n\t\t\t\t\tprint(self.children)\r\n\t\t\t\t\tprint(self.parents)\r\n\t\t\t\t\tprint(self.root)\r\n\t\t\t\tself.delete(x)\r\n\t\t\t\tif xpar is not None:\r\n\t\t\t\t\tself.splay(xpar)\r\n\r\n\tdef successor(self,x):\r\n\t\tif self.find(x):\r\n\t\t\tif self.children[x][1] is None:\r\n\t\t\t\tcurr = x\r\n\t\t\t\twhile self.parents[curr] is not None:\r\n\t\t\t\t\tif self.parents[curr] > curr:\r\n\t\t\t\t\t\treturn self.parents[curr]\r\n\t\t\t\t\tcurr = self.parents[curr]\r\n\t\t\t\treturn None \r\n\t\t\telse:\r\n\t\t\t\tcurr = self.children[x][1]\r\n\t\t\twhile self.children[curr][0] is not None:\r\n\t\t\t\tcurr = self.children[curr][0]\r\n\t\t\treturn curr\r\n\t\telse:\r\n\t\t\tcurr = self.root\r\n\t\t\tprev = None\r\n\t\t\twhile True:\r\n\t\t\t\tif x < curr:\r\n\t\t\t\t\tif self.children[curr][0] is None:\r\n\t\t\t\t\t\tself.splay(curr)\r\n\t\t\t\t\t\treturn curr\r\n\t\t\t\t\telse:\r\n\t\t\t\t\t\tprev = curr\r\n\t\t\t\t\t\tcurr = self.children[curr][0]\r\n\t\t\t\telse:\r\n\t\t\t\t\tif self.children[curr][1] is None:\r\n\t\t\t\t\t\tif prev is not None:\r\n\t\t\t\t\t\t\tself.splay(prev)\r\n\t\t\t\t\t\treturn prev\r\n\t\t\t\t\telse:\r\n\t\t\t\t\t\tcurr = self.children[curr][1]\r\n\tdef predecessor(self,x):\r\n\t\tif self.find(x):\r\n\t\t\tif self.children[x][0] is None:\r\n\t\t\t\tcurr = x\r\n\t\t\t\twhile self.parents[curr] is not None:\r\n\t\t\t\t\tif self.parents[curr] < curr:\r\n\t\t\t\t\t\treturn self.parents[curr]\r\n\t\t\t\t\tcurr = self.parents[curr]\r\n\t\t\t\treturn None\r\n\t\t\telse:\r\n\t\t\t\tcurr = self.children[x][0]\r\n\t\t\twhile self.children[curr][1] is not None:\r\n\t\t\t\tcurr = self.children[curr][1]\r\n\t\t\treturn  curr\r\n\t\telse:\r\n\t\t\tcurr = self.root\r\n\t\t\tprev = None\r\n\t\t\twhile True:\r\n\t\t\t\tif x > curr:\r\n\t\t\t\t\tif self.children[curr][1] is None:\r\n\t\t\t\t\t\tself.splay(curr)\r\n\t\t\t\t\t\treturn curr\r\n\t\t\t\t\telse:\r\n\t\t\t\t\t\tprev = curr\r\n\t\t\t\t\t\tcurr = self.children[curr][1]\r\n\t\t\t\telse:\r\n\t\t\t\t\tif self.children[curr][0] is None:\r\n\t\t\t\t\t\tif prev is not None:\r\n\t\t\t\t\t\t\tself.splay(prev)\r\n\t\t\t\t\t\treturn prev\r\n\t\t\t\t\telse:\r\n\t\t\t\t\t\tcurr = self.children[curr][0]\r\n\r\n\tdef splay(self, x):\r\n\t\twhile self.parents[x] is not None:\r\n\t\t\tp = self.parents[x]\r\n\t\t\tgp = self.parents[p]\r\n\t\t\tif gp is None:\r\n\t\t\t\tif p > x:\r\n\t\t\t\t\ta,b = self.children[x]\r\n\t\t\t\t\tc = self.children[p][1]\r\n\t\t\t\t\tself.children[x] = [a,p]\r\n\t\t\t\t\tself.children[p] = [b,c]\r\n\t\t\t\t\tself.parents[x] = None\r\n\t\t\t\t\tself.parents[p] = x\r\n\t\t\t\t\tself.parents[b] = p\r\n\t\t\t\t\tself.root = x\r\n\t\t\t\telse:\r\n\t\t\t\t\ta = self.children[p][0]\r\n\t\t\t\t\tb,c = self.children[x]\r\n\t\t\t\t\tself.children[x] = [p,c]\r\n\t\t\t\t\tself.children[p] = [a,b]\r\n\t\t\t\t\tself.parents[x] = None\r\n\t\t\t\t\tself.parents[p] = x\r\n\t\t\t\t\tself.parents[b] = p\r\n\t\t\t\t\tself.root = x\r\n\t\t\telse:\r\n\t\t\t\tggp = self.parents[gp]\r\n\t\t\t\tif p > x and gp > x:\r\n\t\t\t\t\ta,b = self.children[x]\r\n\t\t\t\t\tc = self.children[p][1]\r\n\t\t\t\t\td = self.children[gp][1]\r\n\t\t\t\t\tself.children[x] = [a,p]\r\n\t\t\t\t\tself.children[p] = [b,gp]\r\n\t\t\t\t\tself.children[gp] = [c,d]\r\n\t\t\t\t\tself.parents[x] = ggp\r\n\t\t\t\t\tself.parents[p] = x\r\n\t\t\t\t\tself.parents[gp] = p\r\n\t\t\t\t\tself.parents[b] = p\r\n\t\t\t\t\tself.parents[c] = gp\r\n\t\t\t\telif p < x and gp < x:\r\n\t\t\t\t\tc,d = self.children[x]\r\n\t\t\t\t\tb = self.children[p][0]\r\n\t\t\t\t\ta = self.children[gp][0]\r\n\t\t\t\t\tself.children[x] = [p,d]\r\n\t\t\t\t\tself.children[p] = [gp,c]\r\n\t\t\t\t\tself.children[gp] = [a,b]\r\n\t\t\t\t\tself.parents[x] = ggp\r\n\t\t\t\t\tself.parents[p] = x\r\n\t\t\t\t\tself.parents[gp] = p\r\n\t\t\t\t\tself.parents[b] = gp\r\n\t\t\t\t\tself.parents[c] = p\r\n\t\t\t\telif p < x and gp > x:\r\n\t\t\t\t\tb,c = self.children[x]\r\n\t\t\t\t\ta = self.children[p][0]\r\n\t\t\t\t\td = self.children[gp][1]\r\n\t\t\t\t\tself.children[x] = [p,gp]\r\n\t\t\t\t\tself.children[p] = [a,b]\r\n\t\t\t\t\tself.children[gp] = [c,d]\r\n\t\t\t\t\tself.parents[x] = ggp\r\n\t\t\t\t\tself.parents[p] = x\r\n\t\t\t\t\tself.parents[gp] = x\r\n\t\t\t\t\tself.parents[b] = p\r\n\t\t\t\t\tself.parents[c] = gp\r\n\t\t\t\telse:\r\n\t\t\t\t\tb,c = self.children[x]\r\n\t\t\t\t\td = self.children[p][1]\r\n\t\t\t\t\ta = self.children[gp][0]\r\n\t\t\t\t\tself.children[x] = [gp,p]\r\n\t\t\t\t\tself.children[p] = [c,d]\r\n\t\t\t\t\tself.children[gp] = [a,b]\r\n\t\t\t\t\tself.parents[x] = ggp\r\n\t\t\t\t\tself.parents[p] = x\r\n\t\t\t\t\tself.parents[gp] = x\r\n\t\t\t\t\tself.parents[b] = gp\r\n\t\t\t\t\tself.parents[c] = p\r\n\t\t\t\tif ggp is not None:\r\n\t\t\t\t\tfor i in range(2):\r\n\t\t\t\t\t\tif self.children[ggp][i] == gp:\r\n\t\t\t\t\t\t\tself.children[ggp][i] = x\r\n\t\t\t\telse:\r\n\t\t\t\t\tself.root = x\r\n\t\t\tif None in self.parents:\r\n\t\t\t\tdel self.parents[None]\r\n\r\n\r\nn,m,q = map(int,input().split())\r\ndiag = {}\r\nfor i in range(-m,n+1):\r\n\tdiag[i] = SplayTree()\r\n\tdiag[i].insert(max(0,i))\r\n\tdiag[i].insert(min(n+1,m+1+i))\r\n\r\ntotal = 0\r\nj = n\r\nk = m\r\nwhile j>0 and k>0:\r\n\ttotal += 2*j*k\r\n\ttotal += j*(k-1)\r\n\ttotal += k*(j-1)\r\n\tj-=1\r\n\tk-=1\r\ntotal -= n*m\r\nfor _ in range(q):\r\n\tx, y = map(int, input().split())\r\n\tdiff = x-y\r\n\tpred = diag[diff].predecessor(x)\r\n\tsucc = diag[diff].successor(x)\r\n\tpredup = diag[diff-1].predecessor(x)\r\n\tsuccup = diag[diff-1].successor(x-1)\r\n\tpreddown = diag[diff+1].predecessor(x+1)\r\n\tsuccdown = diag[diff+1].successor(x)\r\n\tbeforeup = min(2*(x-pred)-1,2*(x-predup)-2)\r\n\tafterup = min(2*(succ-x)-1,2*(succup-x))\r\n\tbeforedown = min(2*(x-pred)-1,2*(x-preddown))\r\n\tafterdown = min(2*(succ-x)-1,2*(succdown-x)-2)\r\n\tchange = (beforeup+1)*(afterup+1) + (beforedown+1)*(afterdown+1) - 1\r\n\tif diag[diff].find(x):\r\n\t\ttotal += change\r\n\t\tdiag[diff].delete(x)\r\n\telse:\r\n\t\ttotal -= change\r\n\t\tdiag[diff].insert(x)\r\n\tprint(total)\r\n",
    "prob_desc_created_at": "1633856700",
    "tags": [
        "brute force",
        "combinatorics",
        "data structures",
        "dfs and similar",
        "dp",
        "implementation",
        "math"
    ],
    "hidden_unit_tests": ""
}
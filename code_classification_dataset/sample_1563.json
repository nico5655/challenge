{
    "prob_desc_time_limit": "3 seconds",
    "prob_desc_sample_outputs": "[\"6\", \"8\", \"15\"]",
    "src_uid": "a2a785ec219f7554383780a6efd4fd2b",
    "prob_desc_notes": "NoteIn the first example you should use the second column to go up, collecting in each row treasures from the first column.  In the second example, it is optimal to use the first column to go up.  In the third example, it is optimal to collect the treasure at cell $$$(1;6)$$$, go up to row $$$2$$$ at column $$$6$$$, then collect the treasure at cell $$$(2;2)$$$, go up to the top row at column $$$1$$$ and collect the last treasure at cell $$$(3;4)$$$. That's a total of $$$15$$$ moves.  ",
    "prob_desc_description": "You are on the island which can be represented as a $$$n \\times m$$$ table. The rows are numbered from $$$1$$$ to $$$n$$$ and the columns are numbered from $$$1$$$ to $$$m$$$. There are $$$k$$$ treasures on the island, the $$$i$$$-th of them is located at the position $$$(r_i, c_i)$$$.Initially you stand at the lower left corner of the island, at the position $$$(1, 1)$$$. If at any moment you are at the cell with a treasure, you can pick it up without any extra time. In one move you can move up (from $$$(r, c)$$$ to $$$(r+1, c)$$$), left (from $$$(r, c)$$$ to $$$(r, c-1)$$$), or right (from position $$$(r, c)$$$ to $$$(r, c+1)$$$). Because of the traps, you can't move down.However, moving up is also risky. You can move up only if you are in a safe column. There are $$$q$$$ safe columns: $$$b_1, b_2, \\ldots, b_q$$$. You want to collect all the treasures as fast as possible. Count the minimum number of moves required to collect all the treasures.",
    "prob_desc_output_spec": "Print the minimum number of moves required to collect all the treasures.",
    "prob_desc_input_spec": "The first line contains integers $$$n$$$, $$$m$$$, $$$k$$$ and $$$q$$$ ($$$2 \\le n, \\, m, \\, k, \\, q \\le 2 \\cdot 10^5$$$, $$$q \\le m$$$) — the number of rows, the number of columns, the number of treasures in the island and the number of safe columns. Each of the next $$$k$$$ lines contains two integers $$$r_i, c_i$$$, ($$$1 \\le r_i \\le n$$$, $$$1 \\le c_i \\le m$$$) — the coordinates of the cell with a treasure. All treasures are located in distinct cells. The last line contains $$$q$$$ distinct integers $$$b_1, b_2, \\ldots, b_q$$$ ($$$1 \\le b_i \\le m$$$) — the indices of safe columns.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3",
    "lang_cluster": "Python",
    "difficulty": 2100,
    "file_name": "train_010.jsonl",
    "code_uid": "40a17c0488649d756a803201c1c82ae2",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"3 3 3 2\\n1 1\\n2 1\\n3 1\\n2 3\", \"3 5 3 2\\n1 2\\n2 3\\n3 1\\n1 5\", \"3 6 3 2\\n1 6\\n2 2\\n3 4\\n1 6\"]",
    "exec_outcome": "PASSED",
    "source_code": "# see bisect module:\n# https://codeforces.com/contest/1201/submission/58302708\n\n# python complexity:\n# https://www.ics.uci.edu/~pattis/ICS-33/lectures/complexitypython.txt\n\n# solve using DP\n\nn, m, k, q = map(int, input().split())\n# n rows\n# m cols\n\ntr_min = [None for _ in range(n)]\ntr_max = [None for _ in range(n)]\nfor _ in range(k):\n    row, col = map(int, input().split())\n    row = n - row\n    col -= 1\n    if tr_min[row] == None or col < tr_min[row]:\n        tr_min[row] = col\n    if tr_max[row] == None or col > tr_max[row]:\n        tr_max[row] = col\ntr_min[-1] = 0\ntr_max[-1] = tr_max[-1] or 0\n\nsavecols = sorted(map(lambda t: int(t) - 1, input().split()))\n# binary search? :)\ndef binsearch(arr, val):\n    l, r = 0, len(arr)-1\n    while l <= r:\n        mid = l + (r - l) // 2\n        if (arr[mid] < val):\n            l = mid + 1\n        elif (arr[mid] > val):\n            r = mid - 1\n        else:\n            return mid\n\n    return r\n    \n\ndef find_short_descent(A, B):\n    if A > B:\n        return find_short_descent(B, A) # this is invariant\n\n    idx1 = binsearch(savecols, A)\n    idx2 = idx1 + 1\n    minval = m*m\n    if idx2 < len(savecols):\n        if savecols[idx2] < B:\n            return B - A\n        else:\n            minval = min(minval, (savecols[idx2] << 1) - A - B)\n\n    if idx1 >= 0:\n        minval = min(minval, A + B - (savecols[idx1] << 1))\n    return minval\n\n\n\nl, r = 0, 0\nfound_valid = False\nlast_valid = None\nfor row in range(0, n):\n    #insert idea here\n    if found_valid == False:\n        if tr_min[row] != None:\n            found_valid = True\n            last_valid = row\n            l = (tr_max[row] - tr_min[row])\n            r = (tr_max[row] - tr_min[row])\n            continue\n        continue\n    \n    if tr_min[row] == None:\n        l += 1\n        r += 1\n        continue\n\n    ll = find_short_descent(tr_min[last_valid], tr_min[row])\n    lr = find_short_descent(tr_min[last_valid], tr_max[row])\n    rl = find_short_descent(tr_max[last_valid], tr_min[row])\n    rr = find_short_descent(tr_max[last_valid], tr_max[row])\n        \n    #l += min(ll, rl) + 1 + (tr_max[row] - tr_min[row])\n    #r += min(lr, rr) + 1 + (tr_max[row] - tr_min[row])\n    #l, r = r, l\n    new_l = min(l + lr, r + rr) + 1 + (tr_max[row] - tr_min[row])\n    new_r = min(l + ll, r + rl) + 1 + (tr_max[row] - tr_min[row])\n    l, r = new_l, new_r\n    last_valid = row\n\n# insert last step on row n here\nansw = l + tr_min[last_valid]\nprint(answ)",
    "prob_desc_created_at": "1564936500",
    "tags": [
        "dp",
        "binary search",
        "implementation",
        "greedy"
    ],
    "hidden_unit_tests": ""
}
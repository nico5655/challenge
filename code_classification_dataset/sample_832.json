{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"2\\n1 2 1 2 2\\n2\\n2 1 2 1 2 1\\n3\\n2 3 2 3 1\\n1\\n1 1 1\"]",
    "src_uid": "1f4c3f5e7205fe556b50320cecf66c89",
    "prob_desc_notes": null,
    "prob_desc_description": "The round carousel consists of $$$n$$$ figures of animals. Figures are numbered from $$$1$$$ to $$$n$$$ in order of the carousel moving. Thus, after the $$$n$$$-th figure the figure with the number $$$1$$$ follows. Each figure has its own type — the type of the animal corresponding to this figure (the horse, the tiger and so on). The type of animal of the $$$i$$$-th figure equals $$$t_i$$$.    The example of the carousel for $$$n=9$$$ and $$$t=[5, 5, 1, 15, 1, 5, 5, 1, 1]$$$. You want to color each figure in one of the colors. You think that it's boring if the carousel contains two different figures (with the distinct types of animals) going one right after another and colored in the same color.Your task is to color the figures in such a way that the number of distinct colors used is the minimum possible and there are no figures of the different types going one right after another and colored in the same color. If you use exactly $$$k$$$ distinct colors, then the colors of figures should be denoted with integers from $$$1$$$ to $$$k$$$.",
    "prob_desc_output_spec": "Print $$$q$$$ answers, for each test case print two lines. In the first line print one integer $$$k$$$ — the minimum possible number of distinct colors of figures. In the second line print $$$n$$$ integers $$$c_1, c_2, \\dots, c_n$$$ ($$$1 \\le c_i \\le k$$$), where $$$c_i$$$ is the color of the $$$i$$$-th figure. If there are several answers, you can print any.",
    "prob_desc_input_spec": "The input contains one or more test cases. The first line contains one integer $$$q$$$ ($$$1 \\le q \\le 10^4$$$) — the number of test cases in the test. Then $$$q$$$ test cases follow. One test case is given on two lines. The first line of the test case contains one integer $$$n$$$ ($$$3 \\le n \\le 2 \\cdot 10^5$$$) — the number of figures in the carousel. Figures are numbered from $$$1$$$ to $$$n$$$ in order of carousel moving. Assume that after the $$$n$$$-th figure the figure $$$1$$$ goes. The second line of the test case contains $$$n$$$ integers $$$t_1, t_2, \\dots, t_n$$$ ($$$1 \\le t_i \\le 2 \\cdot 10^5$$$), where $$$t_i$$$ is the type of the animal of the $$$i$$$-th figure. The sum of $$$n$$$ over all test cases does not exceed $$$2\\cdot10^5$$$.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 2",
    "lang_cluster": "Python",
    "difficulty": 1800,
    "file_name": "train_004.jsonl",
    "code_uid": "40cabc85f756d727eeebc1ed81ae27b8",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"4\\n5\\n1 2 1 2 2\\n6\\n1 2 2 1 2 2\\n5\\n1 2 1 2 3\\n3\\n10 10 10\"]",
    "exec_outcome": "PASSED",
    "source_code": "from __future__ import division, print_function\nimport sys \n# sys.setrecursionlimit(10**6) \nfrom sys import stdin, stdout\nimport bisect            #c++ upperbound\nimport math\nimport heapq\ndef modinv(n,p):\n    return pow(n,p-2,p)\ndef cin():\n    return map(int,sin().split())\ndef ain():                           #takes array as input\n    return list(map(int,sin().split()))\ndef sin():\n    return input()\ndef inin():\n    return int(input())\nimport math  \ndef Divisors(n) : \n    l = []  \n    for i in range(1, int(math.sqrt(n) + 1)) :\n        if (n % i == 0) : \n            if (n // i == i) : \n                l.append(i) \n            else : \n                l.append(i)\n                l.append(n//i)\n    return l\n\n\"\"\"*******************************************************\"\"\"\ndef main():\n    t=inin()\n    for _ in range(t):\n        x=0\n        n=inin()\n        a=ain()\n        d={}\n        x=0\n        b=[]\n        b.append(0)\n        l=-1\n        f=1\n        for i in range(1,n):\n            if(a[i]!=a[i-1]):\n                x+=1\n                f=2\n                x=x%2\n            else:\n                if(l==-1):\n                    l=i\n            b.append(x)\n        if(a[n-1]!=a[0]):\n            if(b[n-1]==b[0]):\n                # print(l)\n                if(l==-1):\n                    b[n-1]=2\n                    f=3\n                else:\n                    b[l]=(b[l]+1)%2\n                    x=b[l]\n                    for j in range(l+1,n):\n                        # print(a[j],a[j-1],x)\n                        if(a[j]!=a[j-1]):\n                            x+=1\n                            x=x%2\n                        # print(x)\n                        b[j]=x\n\n        for i in range(n):\n            b[i]=b[i]+1\n        print(f)\n        print(*b)\n\n\n\n######## Python 2 and 3 footer by Pajenegod and c1729\n \n# Note because cf runs old PyPy3 version which doesn't have the sped up\n# unicode strings, PyPy3 strings will many times be slower than pypy2.\n# There is a way to get around this by using binary strings in PyPy3\n# but its syntax is different which makes it kind of a mess to use.\n \n# So on cf, use PyPy2 for best string performance.\n \npy2 = round(0.5)\nif py2:\n    from future_builtins import ascii, filter, hex, map, oct, zip\n    range = xrange\n \nimport os, sys\nfrom io import IOBase, BytesIO\n \nBUFSIZE = 8192\nclass FastIO(BytesIO):\n    newlines = 0\n \n    def __init__(self, file):\n        self._file = file\n        self._fd = file.fileno()\n        self.writable = \"x\" in file.mode or \"w\" in file.mode\n        self.write = super(FastIO, self).write if self.writable else None\n \n    def _fill(self):\n        s = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n        self.seek((self.tell(), self.seek(0,2), super(FastIO, self).write(s))[0])\n        return s\n \n    def read(self):\n        while self._fill(): pass\n        return super(FastIO,self).read()\n \n    def readline(self):\n        while self.newlines == 0:\n            s = self._fill(); self.newlines = s.count(b\"\\n\") + (not s)\n        self.newlines -= 1\n        return super(FastIO, self).readline()\n \n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.getvalue())\n            self.truncate(0), self.seek(0)\n \nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        if py2:\n            self.write = self.buffer.write\n            self.read = self.buffer.read\n            self.readline = self.buffer.readline\n        else:\n            self.write = lambda s:self.buffer.write(s.encode('ascii'))\n            self.read = lambda:self.buffer.read().decode('ascii')\n            self.readline = lambda:self.buffer.readline().decode('ascii')\n \n \nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip('\\r\\n')\n \n# Cout implemented in Python\nimport sys\nclass ostream:\n    def __lshift__(self,a):\n        sys.stdout.write(str(a))\n        return self\ncout = ostream()\nendl = '\\n'\n \n# Read all remaining integers in stdin, type is given by optional argument, this is fast\ndef readnumbers(zero = 0):\n    conv = ord if py2 else lambda x:x\n    A = []; numb = zero; sign = 1; i = 0; s = sys.stdin.buffer.read()\n    try:\n        while True:\n            if s[i] >= b'0' [0]:\n                numb = 10 * numb + conv(s[i]) - 48\n            elif s[i] == b'-' [0]: sign = -1\n            elif s[i] != b'\\r' [0]:\n                A.append(sign*numb)\n                numb = zero; sign = 1\n            i += 1\n    except:pass\n    if s and s[-1] >= b'0' [0]:\n        A.append(sign*numb)\n    return A\n \nif __name__== \"__main__\":\n  main()",
    "prob_desc_created_at": "1585233300",
    "tags": [
        "dp",
        "greedy",
        "graphs",
        "constructive algorithms",
        "math"
    ],
    "hidden_unit_tests": ""
}
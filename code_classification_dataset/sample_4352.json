{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"0\", \"1\\n2 4\", \"5\\n5 2\\n2 3\\n3 4\\n4 7\\n6 8\"]",
    "src_uid": "1bf6e28c366b555664a3a6d2c0ded909",
    "prob_desc_notes": "NoteIn the first example, we cannot add any edge.In the second example, the initial forests are as follows.We can add an edge $$$(2, 4)$$$.",
    "prob_desc_description": "This is the hard version of the problem. The only difference between the two versions is the constraint on $$$n$$$. You can make hacks only if all versions of the problem are solved.A forest is an undirected graph without cycles (not necessarily connected).Mocha and Diana are friends in Zhijiang, both of them have a forest with nodes numbered from $$$1$$$ to $$$n$$$, and they would like to add edges to their forests such that:   After adding edges, both of their graphs are still forests.  They add the same edges. That is, if an edge $$$(u, v)$$$ is added to Mocha's forest, then an edge $$$(u, v)$$$ is added to Diana's forest, and vice versa. Mocha and Diana want to know the maximum number of edges they can add, and which edges to add.",
    "prob_desc_output_spec": "The first line contains only one integer $$$h$$$, the maximum number of edges Mocha and Diana can add. Each of the next $$$h$$$ lines contains two integers $$$u$$$ and $$$v$$$ ($$$1 \\le u, v \\le n$$$, $$$u \\neq v$$$) — the edge you add each time. If there are multiple correct answers, you can print any one of them.",
    "prob_desc_input_spec": "The first line contains three integers $$$n$$$, $$$m_1$$$ and $$$m_2$$$ ($$$1 \\le n \\le 10^5$$$, $$$0 \\le m_1, m_2 &lt; n$$$) — the number of nodes and the number of initial edges in Mocha's forest and Diana's forest. Each of the next $$$m_1$$$ lines contains two integers $$$u$$$ and $$$v$$$ ($$$1 \\le u, v \\le n$$$, $$$u \\neq v$$$) — the edges in Mocha's forest. Each of the next $$$m_2$$$ lines contains two integers $$$u$$$ and $$$v$$$ ($$$1 \\le u, v \\le n$$$, $$$u \\neq v$$$) — the edges in Diana's forest.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3",
    "lang_cluster": "Python",
    "difficulty": 2500,
    "file_name": "train_095.jsonl",
    "code_uid": "4318a30d916c7f2a01651423c9fedd52",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"3 2 2\\n1 2\\n2 3\\n1 2\\n1 3\", \"5 3 2\\n5 4\\n2 1\\n4 3\\n4 3\\n1 4\", \"8 1 2\\n1 7\\n2 6\\n1 5\"]",
    "exec_outcome": "PASSED",
    "source_code": "import collections as _collections\r\nimport random as _random\r\nimport sys as _sys\r\n\r\n\r\ndef _main():\r\n    [tests_n] = [1]\r\n    for i_test in range(tests_n):\r\n        [n, m_1, m_2] = _read_ints()\r\n        edges_1 = tuple(_read_n_egdes(m_1))\r\n        edges_2 = tuple(_read_n_egdes(m_2))\r\n        new_edges = add_max_edges_n(n, edges_1, edges_2)\r\n        print(len(new_edges))\r\n        for u, v in new_edges:\r\n            print(u+1, v+1)\r\n\r\n\r\ndef add_max_edges_n(nodes_n, edges_1, edges_2):\r\n    nodes = list(range(nodes_n))\r\n    colors_1 = _DSU.from_equivalence_relations(edges_1, nodes=nodes)\r\n    colors_2 = _DSU.from_equivalence_relations(edges_2, nodes=nodes)\r\n    del edges_1, edges_2\r\n    \r\n    new_edges = []\r\n    \r\n    while min(len(colors_1.owners), len(colors_2.owners)) > 1:\r\n        colors_1, colors_2, nodes, new_new_edges = _try_remove_largest_group(nodes, colors_1, colors_2)\r\n        new_edges.extend(new_new_edges)\r\n        colors_2, colors_1, nodes, new_new_edges = _try_remove_largest_group(nodes, colors_2, colors_1)\r\n        new_edges.extend(new_new_edges)\r\n    \r\n    return new_edges\r\n\r\n\r\ndef _try_remove_largest_group(nodes, colors_1, colors_2):\r\n    new_edges = []\r\n    \r\n    def consider_edge(u, v):\r\n        if not colors_1.is_same_owner(u, v) and not colors_2.is_same_owner(u, v):\r\n            new_edges.append((u, v))\r\n            colors_1.merge_owners(u, v)\r\n            colors_2.merge_owners(u, v)\r\n    \r\n    largest_owner_1 = max(colors_1.owners, key=lambda owner: len(colors_1.get_group_by_owner(owner)))\r\n    largest_1 = set(colors_1.get_group_by_owner(largest_owner_1))\r\n    from_largest = next(iter(largest_1))\r\n    for node in nodes:\r\n        if node != from_largest:\r\n            consider_edge(node, from_largest)\r\n            if not colors_1.is_same_owner(node, from_largest):\r\n                assert colors_2.is_same_owner(node, from_largest)\r\n    \r\n    nontrivial_largest = [x for x in largest_1 if not colors_2.is_same_owner(x, from_largest)]\r\n    \r\n    for node in nodes:\r\n        if colors_1.is_same_owner(node, from_largest):\r\n            continue\r\n        while nontrivial_largest and colors_2.is_same_owner(node, nontrivial_largest[-1]):\r\n            nontrivial_largest.pop()\r\n        if nontrivial_largest:\r\n            consider_edge(node, nontrivial_largest.pop())\r\n    \r\n    nodes = [node for node in nodes if node not in largest_1]\r\n    colors_1 = _DSU.from_other_dsu(colors_1, nodes=nodes)\r\n    colors_2 = _DSU.from_other_dsu(colors_2, nodes=nodes)\r\n    \r\n    return colors_1, colors_2, nodes, new_edges\r\n\r\n\r\nclass _DSU:\r\n    \r\n    def __init__(self, nodes):\r\n        nodes = set(nodes)\r\n        self._parents = {node: node for node in nodes}\r\n        self._owners = set(nodes)\r\n        self._groups_by_owners = {owner: [owner] for owner in nodes}\r\n    \r\n    def _is_owner(self, node):\r\n        return node == self._parents[node]\r\n    \r\n    def _get_owner(self, node):\r\n        to_fix = []\r\n        while not self._is_owner(node):\r\n            to_fix.append(node)\r\n            node = self._parents[node]\r\n        for x in to_fix:\r\n            self._parents[x] = node\r\n        return node\r\n    \r\n    def is_same_owner(self, node_1, node_2):\r\n        return self._get_owner(node_1) == self._get_owner(node_2)\r\n    \r\n    def merge_owners(self, node_1, node_2):\r\n        node_1 = self._get_owner(node_1)\r\n        node_2 = self._get_owner(node_2)\r\n        assert node_1 != node_2\r\n        self._parents[node_2] = node_1\r\n        self._owners.discard(node_2)\r\n        old_groups = [self._groups_by_owners[node_1], self._groups_by_owners[node_2]]\r\n        del self._groups_by_owners[node_1], self._groups_by_owners[node_2]\r\n        lower_group, higher_group = sorted(old_groups, key=len)\r\n        higher_group.extend(lower_group)\r\n        lower_group.clear()\r\n        self._groups_by_owners[node_1] = higher_group\r\n    \r\n    def get_group_by_owner(self, owner):\r\n        return self._groups_by_owners[owner]\r\n    \r\n    @property\r\n    def owners(self):\r\n        return self._owners\r\n    \r\n    @classmethod\r\n    def from_equivalence_relations(cls, equivalence_relations, *, nodes):\r\n        self = cls(nodes)\r\n        for u, v in equivalence_relations:\r\n            if not self.is_same_owner(u, v):\r\n                self.merge_owners(u, v)\r\n        return self\r\n    \r\n    @classmethod\r\n    def from_other_dsu(cls, other_dsu, *, nodes):\r\n        nodes = set(nodes)\r\n        groups = [other_dsu.get_group_by_owner(owner) for owner in other_dsu.owners]\r\n        new_dsu = cls(nodes)\r\n        for group in groups:\r\n            group = [node for node in group if node in nodes]\r\n            if group:\r\n                u, *vs = group\r\n                for v in vs:\r\n                    new_dsu.merge_owners(u, v)\r\n        return new_dsu\r\n\r\n\r\ndef _read_n_egdes(edges_n):\r\n    edges = (_read_ints() for i_edge in range(edges_n))\r\n    edges = ((u-1, v-1) for u, v in edges)\r\n    return edges\r\n\r\n\r\ndef _read_ints():\r\n    return map(int, _read_string().split())\r\n\r\n\r\ndef _read_string():\r\n    result = _sys.stdin.readline()\r\n    assert result and result[-1] == '\\n'\r\n    return result[:-1]\r\n\r\n\r\nif __name__ == '__main__':\r\n    _main()\r\n",
    "prob_desc_created_at": "1629038100",
    "tags": [
        "brute force",
        "constructive algorithms",
        "dfs and similar",
        "dsu",
        "graphs",
        "greedy",
        "trees",
        "two pointers"
    ],
    "hidden_unit_tests": ""
}
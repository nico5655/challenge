{
    "prob_desc_time_limit": "4 seconds",
    "prob_desc_sample_outputs": "[\"1 3\\n2 2 3\\n0\\n3 1 2 4\\n1 2\"]",
    "src_uid": "ff84bc8e8e01c82e1ecaa2a39a7f8dc6",
    "prob_desc_notes": "NoteGraph of Andarz Gu in the sample case is as follows (ID of people in each city are written next to them):  ",
    "prob_desc_description": "Recently Duff has been a soldier in the army. Malek is her commander.Their country, Andarz Gu has n cities (numbered from 1 to n) and n - 1 bidirectional roads. Each road connects two different cities. There exist a unique path between any two cities.There are also m people living in Andarz Gu (numbered from 1 to m). Each person has and ID number. ID number of i - th person is i and he/she lives in city number ci. Note that there may be more than one person in a city, also there may be no people living in the city.  Malek loves to order. That's why he asks Duff to answer to q queries. In each query, he gives her numbers v, u and a.To answer a query:Assume there are x people living in the cities lying on the path from city v to city u. Assume these people's IDs are p1, p2, ..., px in increasing order. If k = min(x, a), then Duff should tell Malek numbers k, p1, p2, ..., pk in this order. In the other words, Malek wants to know a minimums on that path (or less, if there are less than a people).Duff is very busy at the moment, so she asked you to help her and answer the queries.",
    "prob_desc_output_spec": "For each query, print numbers k, p1, p2, ..., pk separated by spaces in one line.",
    "prob_desc_input_spec": "The first line of input contains three integers, n, m and q (1 ≤ n, m, q ≤ 105). The next n - 1 lines contain the roads. Each line contains two integers v and u, endpoints of a road (1 ≤ v, u ≤ n, v ≠ u). Next line contains m integers c1, c2, ..., cm separated by spaces (1 ≤ ci ≤ n for each 1 ≤ i ≤ m). Next q lines contain the queries. Each of them contains three integers, v, u and a (1 ≤ v, u ≤ n and 1 ≤ a ≤ 10).",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 2",
    "lang_cluster": "Python",
    "difficulty": 2200,
    "file_name": "train_039.jsonl",
    "code_uid": "10e269a3dc6c3dd54a658cb451fd2f09",
    "prob_desc_memory_limit": "512 megabytes",
    "prob_desc_sample_inputs": "[\"5 4 5\\n1 3\\n1 2\\n1 4\\n4 5\\n2 1 4 3\\n4 5 6\\n1 5 2\\n5 5 10\\n2 3 3\\n5 3 1\"]",
    "exec_outcome": "PASSED",
    "source_code": "import sys\nrange = xrange\ninput = raw_input\n\nclass Hld:\n    def __init__(self, graph, data, f = min):\n        root = 0\n        n = len(graph) + 1\n        self.data = data\n        self.f = f\n        \n        bfs = [root]\n        self.depth = [-1]*n\n        self.depth[root] = 0\n        self.P = [-1]*n\n        for node in bfs:\n            for nei in graph[node]:\n                if self.depth[nei] == -1:\n                    bfs.append(nei)\n                    self.P[nei] = node\n                    self.depth[nei] = 1 + self.depth[node]\n\n        fam_size = [1]*n\n        preffered_child = list(range(n))\n        for node in reversed(bfs):\n            p = self.P[node]\n            if fam_size[preffered_child[p]] <= fam_size[node]:\n                preffered_child[p] = node\n            fam_size[p] += fam_size[node]\n        fam_size[root] //= 2\n\n        self.hld_P = list(range(n))\n        self.prefix_values = [0]*n\n        values = [[] for _ in range(n)]\n        for node in bfs:\n            self.hld_P[preffered_child[node]] = self.hld_P[node]\n            values[self.hld_P[node]].append(data[node])\n            self.prefix_values[node] = data[node] if node == self.hld_P[node] else f(self.prefix_values[self.P[node]], data[node])\n        self.seg_values = [self.seg_builder(value) for value in values]\n\n    def seg_builder(self, data):\n        self.f = f\n        ans = [0]*len(data)\n        ans += data\n        for i in reversed(range(1, len(data))):\n            ans[i] = self.f(ans[2 * i], ans[2 * i + 1])\n        return ans\n\n    def seg_query(self, data, l, r):\n        l += len(data) >> 1\n        r += len(data) >> 1\n        val = data[l]\n        l += 1\n        while l < r:\n            if l & 1:\n                val = self.f(val, data[l])\n                l += 1\n            if r & 1:\n                val = self.f(val, data[r - 1])\n            l >>= 1\n            r >>= 1\n        return val\n\n\n    def __call__(self, u,v):\n        if u == v:\n            return self.data[u]\n        if self.depth[u] < self.depth[v]:\n            u,v = v,u\n        val = self.data[u]\n        u = self.P[u]\n \n        uhld = self.hld_P[u]\n        vhld = self.hld_P[v]\n        while uhld != vhld:\n            if self.depth[uhld] >= self.depth[vhld]:\n                val = self.f(self.prefix_values[u], val)\n                u = self.P[uhld]\n                uhld = self.hld_P[u]\n            else:\n                val = self.f(self.prefix_values[v], val)\n                v = self.P[vhld]\n                vhld = self.hld_P[v]\n        if self.depth[u] < self.depth[v]:\n            u,v = v,u\n        return self.f(\n                self.seg_query(self.seg_values[uhld],\n                    self.depth[v] - self.depth[uhld], \n                    self.depth[u] - self.depth[uhld] + 1)\n                , val)\n\n\ninp = [int(x) for x in sys.stdin.read().split()]; ii = 0\n \nn = inp[ii]; ii += 1\nm = inp[ii]; ii += 1\nq = inp[ii]; ii += 1\n \ncoupl = [[] for _ in range(n)]\nfor _ in range(n - 1):\n    u = inp[ii] - 1; ii += 1\n    v = inp[ii] - 1; ii += 1\n \n    coupl[u].append(v)\n    coupl[v].append(u)\n \ndef f(A, B):\n    ans = []\n    A = list(A)\n    B = list(B)\n    goal = min(10, len(A) + len(B))\n    while len(ans) < goal:\n        if A and (not B or A[-1] < B[-1]):\n            ans.append(A.pop())\n        else:\n            ans.append(B.pop())\n    ans.reverse()\n    return ans\n \nC = inp[ii:ii + m]; ii += m\ndata = [[] for _ in range(n)]\nfor i in range(m):\n    if len(data[C[i] - 1]) < 10:\n        data[C[i] - 1].append(i + 1)\nfor d in data:\n    d.reverse()\nhld = Hld(coupl, data, f)\n \nout = []\nfor _ in range(q):\n    v = inp[ii] - 1; ii += 1\n    u = inp[ii] - 1; ii += 1\n    a = inp[ii]; ii += 1\n \n    ans = list(hld(v, u))\n    ans.append(min(len(ans), a))\n    out.append(' '.join(str(x) for x in ans[-1:~a-1:-1]))\nprint '\\n'.join(out)\n",
    "prob_desc_created_at": "1444926600",
    "tags": [
        "data structures",
        "trees"
    ],
    "hidden_unit_tests": ""
}
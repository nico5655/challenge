{
    "prob_desc_time_limit": "1 second",
    "prob_desc_sample_outputs": "[\"0\\n2\\n3\\n3\"]",
    "src_uid": "c19500d867fd0108fdeed2cbd00bc970",
    "prob_desc_notes": "NoteIn the first test case, Sam got lucky and the sequence is already great for the number $$$4$$$ because you can divide it into such pairs: $$$(1, 4)$$$, $$$(4, 16)$$$. Thus we can add $$$0$$$ numbers.In the second test case, you can add numbers $$$1$$$ and $$$14$$$ to the sequence, then you can divide all $$$8$$$ integers into such pairs: $$$(1, 2)$$$, $$$(1, 2)$$$, $$$(2, 4)$$$, $$$(7, 14)$$$. It is impossible to add less than $$$2$$$ integers to fix the sequence.",
    "prob_desc_description": "A sequence of positive integers is called great for a positive integer $$$x$$$, if we can split it into pairs in such a way that in each pair the first number multiplied by $$$x$$$ is equal to the second number. More formally, a sequence $$$a$$$ of size $$$n$$$ is great for a positive integer $$$x$$$, if $$$n$$$ is even and there exists a permutation $$$p$$$ of size $$$n$$$, such that for each $$$i$$$ ($$$1 \\le i \\le \\frac{n}{2}$$$) $$$a_{p_{2i-1}} \\cdot x = a_{p_{2i}}$$$. Sam has a sequence $$$a$$$ and a positive integer $$$x$$$. Help him to make the sequence great: find the minimum possible number of positive integers that should be added to the sequence $$$a$$$ to make it great for the number $$$x$$$.",
    "prob_desc_output_spec": "For each test case print a single integer — the minimum number of integers that can be added to the end of $$$a$$$ to make it a great sequence for the number $$$x$$$.",
    "prob_desc_input_spec": "Each test contains multiple test cases. The first line contains a single integer $$$t$$$ ($$$1 \\le t \\le 20\\,000$$$) — the number of test cases. Description of the test cases follows. The first line of each test case contains two integers $$$n$$$, $$$x$$$ ($$$1 \\le n \\le 2 \\cdot 10^5$$$, $$$2 \\le x \\le 10^6$$$). The next line contains $$$n$$$ integers $$$a_1, a_2, \\ldots, a_n$$$ ($$$1 \\le a_i \\le 10^9$$$). It is guaranteed that the sum of $$$n$$$ over all test cases does not exceed $$$2 \\cdot 10^5$$$.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3-64",
    "lang_cluster": "Python",
    "difficulty": 1200,
    "file_name": "train_092.jsonl",
    "code_uid": "51a7a72e8b75e41d77cd314f11883430",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"4\\n4 4\\n1 16 4 4\\n6 2\\n1 2 2 2 4 7\\n5 3\\n5 2 3 5 15\\n9 10\\n10 10 10 20 1 100 200 2000 3\"]",
    "exec_outcome": "PASSED",
    "source_code": "import collections\r\nimport os, sys\r\nfrom io import BytesIO, IOBase\r\n\r\ninf = sys.maxsize\r\n\r\n\r\ndef get_ints():\r\n    return map(int, input().split())\r\n\r\n\r\ndef get_array():\r\n    return list(map(int, input().split()))\r\n\r\n\r\nmod = 1000000007\r\nMOD = 998244353\r\n\r\n\r\ndef main():\r\n    for _ in range(int(input())):\r\n        n,x=get_ints()\r\n        A=get_array()\r\n        d=collections.Counter(A)\r\n        A.sort()\r\n        ans=0\r\n        for ele in A:\r\n            if d[ele] and d[ele*x]:\r\n                d[ele]-=1\r\n                d[ele*x]-=1\r\n        print(sum(d.values()))\r\n\r\n\r\n\r\n\r\n\r\n\r\n# region fastio\r\n\r\nBUFSIZE = 8192\r\n\r\n\r\nclass FastIO(IOBase):\r\n    newlines = 0\r\n\r\n    def __init__(self, file):\r\n        self._file = file\r\n        self._fd = file.fileno()\r\n        self.buffer = BytesIO()\r\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\r\n        self.write = self.buffer.write if self.writable else None\r\n\r\n    def read(self):\r\n        while True:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            if not b:\r\n                break\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines = 0\r\n        return self.buffer.read()\r\n\r\n    def readline(self):\r\n        while self.newlines == 0:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            self.newlines = b.count(b\"\\n\") + (not b)\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines -= 1\r\n        return self.buffer.readline()\r\n\r\n    def flush(self):\r\n        if self.writable:\r\n            os.write(self._fd, self.buffer.getvalue())\r\n            self.buffer.truncate(0), self.buffer.seek(0)\r\n\r\n\r\nclass IOWrapper(IOBase):\r\n    def __init__(self, file):\r\n        self.buffer = FastIO(file)\r\n        self.flush = self.buffer.flush\r\n        self.writable = self.buffer.writable\r\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\r\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\r\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\r\n\r\n\r\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\r\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\r\n\r\n# endregion\r\n\r\nif __name__ == \"__main__\":\r\n    main()\r\n",
    "prob_desc_created_at": "1645611000",
    "tags": [
        "greedy",
        "sortings"
    ],
    "hidden_unit_tests": ""
}
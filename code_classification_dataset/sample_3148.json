{
    "prob_desc_time_limit": "3 seconds",
    "prob_desc_sample_outputs": "[\"2\\n2\\n0\\n1\\n0\", \"1\\n0\\n0\\n0\\n2\\n0\\n0\"]",
    "src_uid": "e29842d75d7061ed2b4fca6c8488d0e4",
    "prob_desc_notes": null,
    "prob_desc_description": "Polycarpus got hold of a family tree. The found tree describes the family relations of n people, numbered from 1 to n. Every person in this tree has at most one direct ancestor. Also, each person in the tree has a name, the names are not necessarily unique.We call the man with a number a a 1-ancestor of the man with a number b, if the man with a number a is a direct ancestor of the man with a number b.We call the man with a number a a k-ancestor (k &gt; 1) of the man with a number b, if the man with a number b has a 1-ancestor, and the man with a number a is a (k - 1)-ancestor of the 1-ancestor of the man with a number b.In the tree the family ties do not form cycles. In other words there isn't a person who is his own direct or indirect ancestor (that is, who is an x-ancestor of himself, for some x, x &gt; 0).We call a man with a number a the k-son of the man with a number b, if the man with a number b is a k-ancestor of the man with a number a.Polycarpus is very much interested in how many sons and which sons each person has. He took a piece of paper and wrote m pairs of numbers vi, ki. Help him to learn for each pair vi, ki the number of distinct names among all names of the ki-sons of the man with number vi.",
    "prob_desc_output_spec": "Print m whitespace-separated integers — the answers to Polycarpus's records. Print the answers to the records in the order, in which the records occur in the input.",
    "prob_desc_input_spec": "The first line of the input contains a single integer n (1 ≤ n ≤ 105) — the number of people in the tree. Next n lines contain the description of people in the tree. The i-th line contains space-separated string si and integer ri (0 ≤ ri ≤ n), where si is the name of the man with a number i, and ri is either the number of the direct ancestor of the man with a number i or 0, if the man with a number i has no direct ancestor.  The next line contains a single integer m (1 ≤ m ≤ 105) — the number of Polycarpus's records. Next m lines contain space-separated pairs of integers. The i-th line contains integers vi, ki (1 ≤ vi, ki ≤ n). It is guaranteed that the family relationships do not form cycles. The names of all people are non-empty strings, consisting of no more than 20 lowercase English letters.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "Python 2",
    "lang_cluster": "Python",
    "difficulty": 2400,
    "file_name": "train_043.jsonl",
    "code_uid": "ee02f0c9e678a82a6d3e53dc4dd923b1",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"6\\npasha 0\\ngerald 1\\ngerald 1\\nvalera 2\\nigor 3\\nolesya 1\\n5\\n1 1\\n1 2\\n1 3\\n3 1\\n6 1\", \"6\\nvalera 0\\nvalera 1\\nvalera 1\\ngerald 0\\nvalera 4\\nkolya 4\\n7\\n1 1\\n1 2\\n2 1\\n2 2\\n4 1\\n5 1\\n6 1\"]",
    "exec_outcome": "PASSED",
    "source_code": "n = int(raw_input())\nchild = [set({}) for i in range(0, n + 1)]\nquery = [list({}) for i in range(0, n + 1)]\nans = [dict(set({})) for i in range(0, n + 1)]\nss = [0 for i in range(0, n + 1)]\nfa = [0 for i in range(0, n + 1)]\nhash_string = dict()\nnowstrings = 0\nfor i in range(1, n + 1):\n    s = raw_input().split()\n    child[int(s[1])] |= {i}\n    fa[i] = int(s[1])\n    if s[0] not in hash_string:\n        nowstrings += 1\n        hash_string[s[0]] = nowstrings\n    ss[i] = hash_string[s[0]]\nfa[0] = -1\nChild = [list(child[i]) for i in range(0, n+1)]\nlenChild = [len(Child[i]) for i in range(0, n+1)]\nnowChild = [0 for i in range(0, n+1)]\nm = int(raw_input())\nanswer = [0 for i in range(0, m)]\nfor i in range(0, m):\n    s = raw_input().split()\n    query[int(s[0])] += {int(s[1])}\n    query[int(s[0])] += {i}\ndef dfs(x, dep):\n    while x != -1:\n        if nowChild[x] == lenChild[x]:\n            if x != 0:\n                ans[x][dep] = {ss[x]}\n                for nowlistindex in range(0, len(query[x]), 2):\n                    i = query[x][nowlistindex]\n                    j = query[x][nowlistindex+1]\n                    if dep + i not in ans[x]:\n                        answer[j] = 0\n                    else:\n                        answer[j] = len(ans[x][dep + i])\n                \"\"\"count ans\"\"\"\n                if len(ans[x]) < len(ans[fa[x]]):\n                    for j in ans[x]:\n                        if j not in ans[fa[x]]:\n                            ans[fa[x]][j] = ans[x][j]\n                        elif len(ans[x][j]) < len(ans[fa[x]][j]):\n                            ans[fa[x]][j] |= ans[x][j]\n                            ans[x][j].clear()\n                        else:\n                            ans[x][j] |= ans[fa[x]][j]\n                            ans[fa[x]][j].clear()\n                            ans[fa[x]][j] = ans[x][j]\n                    ans[x].clear()\n                else:\n                    for j in ans[fa[x]]:\n                        if j not in ans[x]:\n                            ans[x][j] = ans[fa[x]][j]\n                        elif len(ans[x][j]) > len(ans[fa[x]][j]):\n                            ans[x][j] |= ans[fa[x]][j]\n                            ans[fa[x]][j].clear()\n                        else:\n                            ans[fa[x]][j] |= ans[x][j]\n                            ans[x][j].clear()\n                            ans[x][j] = ans[fa[x]][j]\n                    ans[fa[x]].clear()\n                    ans[fa[x]] = ans[x]\n            x = fa[x]\n            nowChild[x] += 1\n            dep -= 1\n        else:\n            x = Child[x][nowChild[x]]\n            dep += 1\ndfs(0, 0)\nfor i in range(0, m):\n    print(answer[i])\n",
    "prob_desc_created_at": "1353511800",
    "tags": [
        "dp",
        "sortings",
        "data structures",
        "binary search",
        "dfs and similar"
    ],
    "hidden_unit_tests": ""
}
{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"YES\\n1 5\\n1 4\\n5 3\\n4 3\\n5 4\", \"YES\\n3 1\\n3 2\\n5 3\\n3 4\\n4 5\", \"NO\"]",
    "src_uid": "29a9015981b39df9db40d41c73286e9f",
    "prob_desc_notes": "NoteIn the first example, the array $$$b$$$ will change as follows: $$$[0,0,0,0,0] \\rightarrow [-1,0,0,1,0] \\rightarrow [-2,0,0,1,1] \\rightarrow [-2,0,1,0,1] \\rightarrow [-2,0,2,0,0] \\rightarrow [-2,0,2,1,-1]$$$. $$$a_i = b_i$$$ for all indices $$$i$$$ from $$$1$$$ to $$$5$$$.In the second example, it is enough for us that $$$b_2 = 1$$$ at the end, since only $$$s_2 = 1$$$.In the third example, the operations cannot be performed as required.",
    "prob_desc_description": "Oh no, on the first exam Madoka got this hard problem:Given integer $$$n$$$ and $$$m$$$ pairs of integers ($$$v_i, u_i$$$). Also there is an array $$$b_1, b_2, \\ldots, b_n$$$, initially filled with zeros.Then for each index $$$i$$$, where $$$1 \\leq i \\leq m$$$, perform either $$$b_{v_i} := b_{v_i} - 1$$$ and $$$b_{u_i} := b_{u_i} + 1$$$, or $$$b_{v_i} := b_{v_i} + 1$$$ and $$$b_{u_i} := b_{u_i} - 1$$$. Note that exactly one of these operations should be performed for every $$$i$$$.Also there is an array $$$s$$$ of length $$$n$$$ consisting of $$$0$$$ and $$$1$$$. And there is an array $$$a_1, a_2, \\ldots, a_n$$$, where it is guaranteed, that if $$$s_i = 0$$$ holds, then $$$a_i = 0$$$.Help Madoka and determine whenever it is possible to perform operations in such way that for every $$$i$$$, where $$$s_i = 1$$$ it holds that $$$a_i = b_i$$$. If it possible you should also provide Madoka with a way to perform operations.",
    "prob_desc_output_spec": "In the first line print \"YES\" if it is possible to perform operations in the required way, and \"NO\" otherwise. You may print each letter in any case (for example, \"YES\", \"Yes\", \"yes\", \"yEs\" will all be recognized as positive answer). In case you printed \"YES\", print $$$m$$$ pairs of integers. If for pair $$$(v_i, u_i)$$$ we should perform $$$b_{v_i} := b_{v_i} - 1$$$ and $$$b_{u_i} := b_{u_i} + 1$$$, print $$$(v_i, u_i)$$$. Otherwise print $$$(u_i, v_i)$$$. If there are multiple ways to get the correct answer, you can print any of them. You can print pairs in any order.",
    "prob_desc_input_spec": "The first line contains two integers $$$n$$$ and $$$m$$$ ($$$2 \\leq n \\leq 10000, 1 \\leq m \\leq 10000$$$) — the length of the array $$$a$$$ and the number of pair of integers. The second line contains $$$n$$$ integers $$$s_1, s_2, \\ldots s_n$$$ ($$$0 \\le s_i \\le 1$$$) — the elements of the array $$$s$$$. The third line contains $$$n$$$ integers $$$a_1, a_2, \\ldots, a_n$$$ ($$$|a_i| \\leq m$$$) — the elements of the array $$$a$$$. It is guaranteed that if $$$s_i = 0$$$ holds, then $$$a_i = 0$$$. $$$i$$$-th of the following $$$m$$$ lines contains two integers $$$v_i$$$ and $$$u_i$$$ ($$$1 \\leq v_i, u_i \\leq n, v_i \\ne u_i$$$) — the indexes of the elements of the array $$$b$$$ to which the operation is performed. It is also guaranteed that there are no two indices $$$i$$$ and $$$j$$$, where $$$1 \\le i &lt; j \\le m$$$, such that $$$(v_i, u_i) = (v_j, u_j)$$$ or $$$(v_i, u_i) = (u_j, v_j)$$$.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3-64",
    "lang_cluster": "Python",
    "difficulty": 2500,
    "file_name": "train_104.jsonl",
    "code_uid": "1daf45157599c0131049e21058c209db",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"5 5\\n1 1 1 1 1\\n-2 0 2 1 -1\\n1 5\\n1 4\\n3 5\\n3 4\\n4 5\", \"5 5\\n0 1 0 1 0\\n0 1 0 0 0\\n1 3\\n2 3\\n3 5\\n3 4\\n4 5\", \"4 4\\n1 1 1 1\\n0 2 -2 2\\n1 3\\n1 4\\n2 3\\n2 4\"]",
    "exec_outcome": "PASSED",
    "source_code": "from collections import deque\r\n\r\nimport sys\r\nsys.setrecursionlimit(10**4+10)\r\nclass mf_graph:\r\n    n=1\r\n    g=[[] for i in range(1)]\r\n    pos=[]\r\n    def __init__(self,N):\r\n        self.n=N\r\n        self.g=[[] for i in range(N)]\r\n        self.pos=[]\r\n    def add_edge(self,From,To,cap):\r\n        assert 0<=From and From<self.n\r\n        assert 0<=To and To<self.n\r\n        assert 0<=cap\r\n        m=len(self.pos)\r\n        self.pos.append((From,len(self.g[From])))\r\n        self.g[From].append({\"to\":To,\"rev\":len(self.g[To]),\"cap\":cap})\r\n        self.g[To].append({\"to\":From,\"rev\":len(self.g[From])-1,\"cap\":0})\r\n        return m\r\n    def get_edge(self,i):\r\n        m=len(self.pos)\r\n        assert 0<=i and i<m\r\n        _e=self.g[self.pos[i][0]][self.pos[i][1]]\r\n        _re=self.g[_e[\"to\"]][_e[\"rev\"]]\r\n        return {\"from\":self.pos[i][0],\r\n                \"to\":_e[\"to\"],\r\n                \"cap\":_e[\"cap\"]+_re[\"cap\"],\r\n                \"flow\":_re[\"cap\"]}\r\n    def edges(self):\r\n        m=len(self.pos)\r\n        result=[]\r\n        for i in range(m):\r\n            result.append(self.get_edge(i))\r\n        return result\r\n    def change_edge(self,i,new_cap,new_flow):\r\n        m=len(self.pos)\r\n        assert 0<=i and i<m\r\n        assert 0<=new_flow and new_flow<=new_cap\r\n        _e=self.g[self.pos[i][0]][self.pos[i][1]]\r\n        _re=self.g[_e[\"to\"]][_e[\"rev\"]]\r\n        _e[\"cap\"]=new_cap-new_flow\r\n        _re[\"cap\"]=new_flow\r\n    def flow(self,s,t,flow_limit=(1<<63)-1):\r\n        assert 0<=s and s<self.n\r\n        assert 0<=t and t<self.n\r\n        level=[0 for i in range(self.n)]\r\n        Iter=[0 for i in range(self.n)]\r\n        que=deque([])\r\n        def bfs():\r\n            for i in range(self.n):level[i]=-1\r\n            level[s]=0\r\n            que=deque([])\r\n            que.append(s)\r\n            while(len(que)>0):\r\n                v=que.popleft()\r\n                for e in self.g[v]:\r\n                    if e[\"cap\"]==0 or level[e[\"to\"]]>=0:continue\r\n                    level[e[\"to\"]]=level[v]+1\r\n                    if e[\"to\"]==t:return\r\n                    que.append(e[\"to\"])\r\n        def dfs(func,v,up):\r\n            if (v==s):return up\r\n            res=0\r\n            level_v=level[v]\r\n            for i in range(Iter[v],len(self.g[v])):\r\n                e=self.g[v][i]\r\n                if (level_v<=level[e[\"to\"]] or self.g[e[\"to\"]][e[\"rev\"]][\"cap\"]==0):continue\r\n                d=func(func,e[\"to\"],min(up-res,self.g[e[\"to\"]][e[\"rev\"]][\"cap\"]))\r\n                if d<=0:continue\r\n                self.g[v][i][\"cap\"]+=d\r\n                self.g[e[\"to\"]][e[\"rev\"]][\"cap\"]-=d\r\n                res+=d\r\n                if res==up:return res\r\n            level[v]=self.n\r\n            return res\r\n        flow=0\r\n        while(flow<flow_limit):\r\n            bfs()\r\n            if level[t]==-1:break\r\n            for i in range(self.n):Iter[i]=0\r\n            while(flow<flow_limit):\r\n                f=dfs(dfs,t,flow_limit-flow)\r\n                if not(f):break\r\n                flow+=f\r\n        return flow\r\n    def min_cut(self,s):\r\n        visited=[False for i in range(self.n)]\r\n        que=deque([])\r\n        que.append(s)\r\n        while(len(que)>0):\r\n            p=que.popleft()\r\n            visited[p]=True\r\n            for e in self.g[p]:\r\n                if e[\"cap\"] and not(visited[e[\"to\"]]):\r\n                    visited[e[\"to\"]]=True\r\n                    que.append(e[\"to\"])\r\n        return\r\n\r\nfrom sys import stdin\r\ninput=lambda :stdin.readline()[:-1]\r\n\r\n\r\nn,m=map(int,input().split())\r\ns=list(map(int,input().split()))\r\na=list(map(int,input().split()))\r\ng=mf_graph(n+m+2)\r\nS=n+m\r\nT=S+1\r\ntmp=[0]*n\r\nedges=[]\r\nedge1=[]\r\nedge2=[]\r\nfor i in range(m):\r\n  x,y=map(lambda x:int(x)-1,input().split())\r\n  tmp[x]+=1\r\n  tmp[y]+=1\r\n  if s[x]==1 and s[y]==1:\r\n    edge1.append((x,y,i))\r\n  elif s[x]==1 or s[y]==1:\r\n    edge2.append((x,y,i))\r\n  edges.append((x,y))\r\n  \r\ncnt=0\r\nfor i in range(n):\r\n  if s[i]==1:\r\n    if a[i]>tmp[i] or (tmp[i]-a[i])%2==1:\r\n      print('NO')\r\n      exit()\r\n    t=(tmp[i]-a[i])//2\r\n    if t!=0:\r\n      g.add_edge(i,T,t)\r\n      cnt+=t\r\n\r\nfor x,y,i in edge1:\r\n  g.add_edge(S,n+i,1)\r\n  g.add_edge(n+i,x,1)\r\n  g.add_edge(n+i,y,1)\r\n\r\nans_flow=g.flow(S,T)\r\nfor x,y,i in edge2:\r\n  g.add_edge(S,n+i,1)\r\n  g.add_edge(n+i,x,1)\r\n  g.add_edge(n+i,y,1)\r\nans_flow+=g.flow(S,T)\r\nif ans_flow!=cnt:\r\n  print('NO')\r\n  exit()\r\n\r\nans=[-1]*m\r\nfor e in g.edges():\r\n  frm=e['from']-n\r\n  if 0<=frm<m:\r\n    to=e['to']\r\n    if e['flow']!=0:\r\n      ans[frm]=to\r\n\r\nANS=[]\r\nfor i in range(m):\r\n  x,y=edges[i]\r\n  if ans[i]!=-1:\r\n    if ans[i]==x:\r\n      ANS.append((x,y))\r\n    else:\r\n      ANS.append((y,x))\r\n  else:\r\n    if s[x]==0:\r\n      ANS.append((x,y))\r\n    elif s[y]==0:\r\n      ANS.append((y,x))\r\n    else:\r\n      print('NO')\r\n      exit()\r\n\r\nprint('YES')\r\nfor x,y in ANS:\r\n  print(x+1,y+1)",
    "prob_desc_created_at": "1662129300",
    "tags": [
        "constructive algorithms",
        "flows",
        "graph matchings",
        "graphs",
        "implementation"
    ],
    "hidden_unit_tests": ""
}
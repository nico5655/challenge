{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"0\\n1\\n2\\n0\"]",
    "src_uid": "d0c50562764f2008045fe57e5da5de1c",
    "prob_desc_notes": null,
    "prob_desc_description": "You are playing a game where your character should overcome different obstacles. The current problem is to come down from a cliff. The cliff has height $$$h$$$, and there is a moving platform on each height $$$x$$$ from $$$1$$$ to $$$h$$$.Each platform is either hidden inside the cliff or moved out. At first, there are $$$n$$$ moved out platforms on heights $$$p_1, p_2, \\dots, p_n$$$. The platform on height $$$h$$$ is moved out (and the character is initially standing there).If you character is standing on some moved out platform on height $$$x$$$, then he can pull a special lever, which switches the state of two platforms: on height $$$x$$$ and $$$x - 1$$$. In other words, the platform you are currently standing on will hide in the cliff and the platform one unit below will change it state: it will hide if it was moved out or move out if it was hidden. In the second case, you will safely land on it. Note that this is the only way to move from one platform to another.Your character is quite fragile, so it can safely fall from the height no more than $$$2$$$. In other words falling from the platform $$$x$$$ to platform $$$x - 2$$$ is okay, but falling from $$$x$$$ to $$$x - 3$$$ (or lower) is certain death. Sometimes it's not possible to come down from the cliff, but you can always buy (for donate currency) several magic crystals. Each magic crystal can be used to change the state of any single platform (except platform on height $$$h$$$, which is unaffected by the crystals). After being used, the crystal disappears.What is the minimum number of magic crystal you need to buy to safely land on the $$$0$$$ ground level?",
    "prob_desc_output_spec": "For each query print one integer — the minimum number of magic crystals you have to spend to safely come down on the ground level (with height $$$0$$$).",
    "prob_desc_input_spec": "The first line contains one integer $$$q$$$ ($$$1 \\le q \\le 100$$$) — the number of queries. Each query contains two lines and is independent of all other queries. The first line of each query contains two integers $$$h$$$ and $$$n$$$ ($$$1 \\le h \\le 10^9$$$, $$$1 \\le n \\le \\min(h, 2 \\cdot 10^5)$$$) — the height of the cliff and the number of moved out platforms. The second line contains $$$n$$$ integers $$$p_1, p_2, \\dots, p_n$$$ ($$$h = p_1 &gt; p_2 &gt; \\dots &gt; p_n \\ge 1$$$) — the corresponding moved out platforms in the descending order of their heights. The sum of $$$n$$$ over all queries does not exceed $$$2 \\cdot 10^5$$$.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 2",
    "lang_cluster": "Python",
    "difficulty": 1600,
    "file_name": "train_000.jsonl",
    "code_uid": "b084f1988c923dff4a8b4fa95dc6f846",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"4\\n3 2\\n3 1\\n8 6\\n8 7 6 5 3 2\\n9 6\\n9 8 5 4 3 1\\n1 1\\n1\"]",
    "exec_outcome": "PASSED",
    "source_code": "#!/usr/bin/env pypy\nfrom __future__ import division, print_function\nfrom collections import defaultdict, Counter, deque\nfrom future_builtins import ascii, filter, hex, map, oct, zip\nfrom random import randint\nfrom itertools import imap as map, izip as zip, permutations, combinations, combinations_with_replacement\nfrom __builtin__ import xrange as range\nfrom math import ceil\nfrom _continuation import continulet\nfrom cStringIO import StringIO\nfrom io import IOBase\nimport __pypy__\nfrom bisect import bisect, insort, bisect_left, bisect_right\nimport sys\nimport os\nimport re\nsys.setrecursionlimit(9999)\ninf = float('inf')\nmod = int(1e9) + 7\nmod_ = 998244353\nN = 5001\n\n'''\nCheck for special cases (n=1)\nOne wrong submission = 10 mins penalty!\ndo smth instead of nothing and stay organized\n'''\n\n\ndef main():\n\tfor _ in range(int(input())):\n\t\th, n = map(int, input().split())\n\t\tarr = list(set(map(int, input().split())))\n\t\tif n == 1:\n\t\t\tprint(0)\n\t\t\tcontinue\n\t\tcnt = 0\n\t\tind = 0\n\t\twhile arr[ind] > 2:\n\t\t\tgap = arr[ind]-arr[ind+1]\n\t\t\t# if gap == 2:\n\t\t\t# \tind += 1\n\t\t\t# else:\n\t\t\tarr[ind] = arr[ind+1]+1\n\t\t\tif ind+2 > n-1:\n\t\t\t\tif arr[ind] > 2 and arr[ind+1]+1 > 2:\n\t\t\t\t\tcnt += 1\n\t\t\t\tbreak\n\t\t\tif arr[ind]-arr[ind+2] > 2:\n\t\t\t\tarr[ind+1] = arr[ind+2]+1\n\t\t\t\tcnt += 1\n\t\t\t\tind += 1\n\t\t\telse:\n\t\t\t\tind += 2\n\t\t\tif ind+1 > n-1 or arr[ind] <= 2:\n\t\t\t\tbreak\n\t\t# print(arr)\n\t\tprint(cnt)\n\n\n\n\nBUFSIZE = 8192\nclass FastI(IOBase):\n\tdef __init__(self, file):\n\t\tself._fd = file.fileno()\n\t\tself._buffer = StringIO()\n\t\tself.newlines = 0\n \n\tdef read(self):\n\t\twhile True:\n\t\t\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n\t\t\tif not b:\n\t\t\t\tbreak\n\t\t\tptr = self.buffer.tell()\n\t\t\tself.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n\t\tself.newlines = 0\n\t\treturn self.buffer.read()\n \n\tdef readline(self):\n\t\twhile self.newlines == 0:\n\t\t\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n\t\t\tself.newlines = b.count(\"\\n\") + (not b)\n\t\t\tptr = self._buffer.tell()\n\t\t\tself._buffer.seek(0, 2), self._buffer.write(\n\t\t\t\tb), self._buffer.seek(ptr)\n\t\tself.newlines -= 1\n\t\treturn self._buffer.readline()\nclass FastO(IOBase):\n\tdef __init__(self, file):\n\t\tself._fd = file.fileno()\n\t\tself._buffer = __pypy__.builders.StringBuilder()\n\t\tself.write = lambda s: self._buffer.append(s)\n \n\tdef flush(self):\n\t\tos.write(self._fd, self._buffer.build())\n\t\tself._buffer = __pypy__.builders.StringBuilder()\ndef print(*args, **kwargs):\n\tsep, file = kwargs.pop(\"sep\", \" \"), kwargs.pop(\"file\", sys.stdout)\n\tat_start = True\n\tfor x in args:\n\t\tif not at_start:\n\t\t\tfile.write(sep)\n\t\tfile.write(str(x))\n\t\tat_start = False\n\tfile.write(kwargs.pop(\"end\", \"\\n\"))\n\tif kwargs.pop(\"flush\", False):\n\t\tfile.flush()\ndef gcd(x, y):\n\twhile y:\n\t\tx, y = y, x % y\n\treturn x\nsys.stdin, sys.stdout = FastI(sys.stdin), FastO(sys.stdout)\ndef input(): return sys.stdin.readline().rstrip(\"\\r\\n\")\nif __name__ == \"__main__\":\n\tdef bootstrap(cont):\n\t\tcall, arg = cont.switch()\n\t\twhile True:\n\t\t\tcall, arg = cont.switch(to=continulet(\n\t\t\t\tlambda _, f, args: f(*args), call, arg))\n\tcont = continulet(bootstrap)\n\tcont.switch()\n\tmain()",
    "prob_desc_created_at": "1570545300",
    "tags": [
        "dp",
        "greedy",
        "math"
    ],
    "hidden_unit_tests": ""
}
{
    "prob_desc_time_limit": "4 seconds",
    "prob_desc_sample_outputs": "[\"001\\n11\\n00\\n100110\"]",
    "src_uid": "268cf03c271d691c3c1e3922e884753e",
    "prob_desc_notes": "NoteIn the first test case, if we do not use the spell, the accumulated rainfall distribution will be like this:  If we erase the third day's rain, the flood is avoided and the accumulated rainfall distribution looks like this:  In the second test case, since initially the flood will not happen, we can erase any day's rain.In the third test case, there is no way to avoid the flood.",
    "prob_desc_description": "You are the owner of a harvesting field which can be modeled as an infinite line, whose positions are identified by integers.It will rain for the next $$$n$$$ days. On the $$$i$$$-th day, the rain will be centered at position $$$x_i$$$ and it will have intensity $$$p_i$$$. Due to these rains, some rainfall will accumulate; let $$$a_j$$$ be the amount of rainfall accumulated at integer position $$$j$$$. Initially $$$a_j$$$ is $$$0$$$, and it will increase by $$$\\max(0,p_i-|x_i-j|)$$$ after the $$$i$$$-th day's rain.A flood will hit your field if, at any moment, there is a position $$$j$$$ with accumulated rainfall $$$a_j&gt;m$$$.You can use a magical spell to erase exactly one day's rain, i.e., setting $$$p_i=0$$$. For each $$$i$$$ from $$$1$$$ to $$$n$$$, check whether in case of erasing the $$$i$$$-th day's rain there is no flood.",
    "prob_desc_output_spec": "For each test case, output a binary string $$$s$$$ length of $$$n$$$. The $$$i$$$-th character of $$$s$$$ is 1 if after erasing the $$$i$$$-th day's rain there is no flood, while it is 0, if after erasing the $$$i$$$-th day's rain the flood still happens.",
    "prob_desc_input_spec": "Each test contains multiple test cases. The first line contains the number of test cases $$$t$$$ ($$$1 \\leq t \\leq 10^4$$$). The description of the test cases follows. The first line of each test case contains two integers $$$n$$$ and $$$m$$$ ($$$1 \\leq n \\leq 2 \\cdot 10^5$$$, $$$1 \\leq m \\leq 10^9$$$) — the number of rainy days and the maximal accumulated rainfall with no flood occurring. Then $$$n$$$ lines follow. The $$$i$$$-th of these lines contains two integers $$$x_i$$$ and $$$p_i$$$ ($$$1 \\leq x_i,p_i \\leq 10^9$$$) — the position and intensity of the $$$i$$$-th day's rain. The sum of $$$n$$$ over all test cases does not exceed $$$2 \\cdot 10^5$$$.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3-64",
    "lang_cluster": "Python",
    "difficulty": 2100,
    "file_name": "train_083.jsonl",
    "code_uid": "8adfa83cba4043968bea540becb73e44",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"4\\n\\n3 6\\n\\n1 5\\n\\n5 5\\n\\n3 4\\n\\n2 3\\n\\n1 3\\n\\n5 2\\n\\n2 5\\n\\n1 6\\n\\n10 6\\n\\n6 12\\n\\n4 5\\n\\n1 6\\n\\n12 5\\n\\n5 5\\n\\n9 7\\n\\n8 3\"]",
    "exec_outcome": "PASSED",
    "source_code": "import sys\r\ninput = sys.stdin.readline\r\nfrom heapq import heappop, heappush\r\nfor t in range(int(input())):\r\n    n, m = list(map(int, input().split()))\r\n    d = {}\r\n    D = {}\r\n    for i in range(n):\r\n        x, p = list(map(int, input().split()))\r\n        d[i] = (x, p)\r\n        if (x, p) not in D:\r\n            D[(x, p)] = []\r\n        D[(x, p)].append(i)\r\n    total, count, curr = 0, 0, 0\r\n    heap = []\r\n    rain = sorted(d.values())\r\n    pos = {}\r\n    for i in range(n):\r\n        x, p = rain[i]\r\n        total += p - (x-curr)*count\r\n        count += 1\r\n        heappush(heap, x+p)\r\n        curr = x\r\n        pos[curr] = total\r\n        if i == n-1:\r\n            break\r\n        nxt, _ = rain[i+1]\r\n        while heap and heap[0] <= nxt:\r\n            total -= (heap[0]-curr)*count\r\n            count -= 1\r\n            curr = heappop(heap)\r\n    heap = []\r\n    total, count, curr = 0, 0, 0\r\n    for i in range(n-1, -1, -1):\r\n        x, p = rain[i]\r\n        total -= (curr-x)*count\r\n        count += 1\r\n        heappush(heap, -(x-p))\r\n        pos[x] += total\r\n        if i < n-1 and rain[i+1][0] == x:\r\n            pos[x] -= total\r\n        curr = x\r\n        total += p\r\n        if i == 0:\r\n            break\r\n        nxt, _ = rain[i-1]\r\n        while heap and -heap[0] >= nxt:\r\n            total -= (heap[0]+curr)*count\r\n            count -= 1\r\n            curr = -heappop(heap)\r\n    res = [0]*n\r\n    L, R = [0]*n, [0]*n\r\n    Mp = rain[0][0]\r\n    Max = pos[Mp]\r\n    for i in range(n):\r\n        x, p = rain[i]\r\n        if Max+(x-Mp) <= pos[x] or (Max <= m and pos[x] > m):\r\n            Mp, Max = x, pos[x]\r\n        if Max+(x-Mp)-p > m and Max > m:\r\n            L[i] = 0\r\n        else:\r\n            L[i] = 1\r\n    Mp = rain[-1][0]\r\n    Max = pos[Mp]\r\n    for i in range(n-1, -1, -1):\r\n        x, p = rain[i]\r\n        if Max+(Mp-x) <= pos[x] or (Max <= m and pos[x] > m):\r\n            Mp, Max = x, pos[x]\r\n        if Max+(Mp-x)-p > m and Max > m:\r\n            R[i] = 0\r\n        else:\r\n            R[i] = 1\r\n    for i in range(n):\r\n        for ind in D[rain[i]]:\r\n            if res[ind]:\r\n                break\r\n            res[ind] = str(L[i]&R[i])\r\n    print(''.join(res))",
    "prob_desc_created_at": "1658673300",
    "tags": [
        "binary search",
        "brute force",
        "data structures",
        "sortings"
    ],
    "hidden_unit_tests": ""
}
{
    "prob_desc_time_limit": "2.5 seconds",
    "prob_desc_sample_outputs": "[\"4\\n3\\n4\\n2\\n3\\n4\\n1\\n2\\n3\\n4\", \"5\\n3\\n3\\n3\"]",
    "src_uid": "c90c7a562c8221dd428c807c919ae156",
    "prob_desc_notes": "NoteIn the first example Misha's mother is interested in the first $$$10$$$ years after the rule was introduced. The host cities these years are 4, 3, 4, 2, 3, 4, 1, 2, 3, 4.In the second example the host cities after the new city is introduced are 2, 3, 1, 2, 3, 5, 1, 2, 3, 4, 5, 1.",
    "prob_desc_description": "Misha was interested in water delivery from childhood. That's why his mother sent him to the annual Innovative Olympiad in Irrigation (IOI). Pupils from all Berland compete there demonstrating their skills in watering. It is extremely expensive to host such an olympiad, so after the first $$$n$$$ olympiads the organizers introduced the following rule of the host city selection.The host cities of the olympiads are selected in the following way. There are $$$m$$$ cities in Berland wishing to host the olympiad, they are numbered from $$$1$$$ to $$$m$$$. The host city of each next olympiad is determined as the city that hosted the olympiad the smallest number of times before. If there are several such cities, the city with the smallest index is selected among them.Misha's mother is interested where the olympiad will be held in some specific years. The only information she knows is the above selection rule and the host cities of the first $$$n$$$ olympiads. Help her and if you succeed, she will ask Misha to avoid flooding your house.",
    "prob_desc_output_spec": "Print $$$q$$$ integers. The $$$i$$$-th of them should be the city the olympiad will be hosted in the year $$$k_i$$$.",
    "prob_desc_input_spec": "The first line contains three integers $$$n$$$, $$$m$$$ and $$$q$$$ ($$$1 \\leq n, m, q \\leq 500\\,000$$$) — the number of olympiads before the rule was introduced, the number of cities in Berland wishing to host the olympiad, and the number of years Misha's mother is interested in, respectively. The next line contains $$$n$$$ integers $$$a_1, a_2, \\ldots, a_n$$$ ($$$1 \\leq a_i \\leq m$$$), where $$$a_i$$$ denotes the city which hosted the olympiad in the $$$i$$$-th year. Note that before the rule was introduced the host city was chosen arbitrarily. Each of the next $$$q$$$ lines contains an integer $$$k_i$$$ ($$$n + 1 \\leq k_i \\leq 10^{18}$$$) — the year number Misha's mother is interested in host city in.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 2",
    "lang_cluster": "Python",
    "difficulty": 2200,
    "file_name": "train_018.jsonl",
    "code_uid": "7fbfbf4d7b0928052a38ba6dd170f875",
    "prob_desc_memory_limit": "512 megabytes",
    "prob_desc_sample_inputs": "[\"6 4 10\\n3 1 1 1 2 2\\n7\\n8\\n9\\n10\\n11\\n12\\n13\\n14\\n15\\n16\", \"4 5 4\\n4 4 5 1\\n15\\n9\\n13\\n6\"]",
    "exec_outcome": "PASSED",
    "source_code": "class seg:\n    def __init__(self, n):\n        self.n = n\n        m = 1\n        while m < n: m *= 2\n        self.m = m\n        self.data = [0]*(2 * m)\n    \n    def add(self, ind):\n        ind += self.m\n        while ind:\n            self.data[ind] += 1\n            ind >>= 1\n    \n    def binary(self,k):\n        ind = 1\n        while ind < self.m:\n            ind <<= 1\n            if self.data[ind] < k:\n                k -= self.data[ind]\n                ind |= 1\n        return ind - self.m\n\n# This mergesort can be like 7 times faster than build in sort\n# (for stupid reasons)\ndef mergesort(n, key, reverse=False):\n    A = list(range(n))\n    B = list(A)\n\n    n = len(A)\n    for i in range(0, n - 1, 2):\n        if key(A[i]) > key(A[i ^ 1]):\n            A[i], A[i ^ 1] = A[i ^ 1], A[i]\n\n    width = 2\n    while width < n:\n        for i in range(0, n, 2 * width):\n            R1, R2 = min(i + width, n), min(i + 2 * width, n)\n            j, k = R1, i\n            while i < R1 and j < R2:\n                if key(A[i]) > key(A[j]):\n                    B[k] = A[j]\n                    j += 1\n                else:\n                    B[k] = A[i]\n                    i += 1\n                k += 1\n            while i < R1:\n                B[k] = A[i]\n                k += 1\n                i += 1\n            while k < R2:\n                B[k] = A[k]\n                k += 1\n        A, B = B, A\n        width *= 2\n\n    if reverse:\n        A.reverse()\n    return A\n\ndef main():\n    n, m, q = [int(x) for x in input().split()]\n\n    A = [int(x) for x in input().split()]\n\n    hosts = [0.0]*m\n    for a in A:\n        hosts[a-1] += 1.0\n\n    order = mergesort(m, hosts.__getitem__)\n    years = []\n    s = 0.0\n    for before,i in enumerate(order):\n        years.append(before * hosts[i] - s)\n        s += hosts[i]\n    \n    big = 1000000000000\n    big -= big % m\n    bigf = float(big)\n    \n    def mapper(x):\n        if len(x) <= 12:\n            return float(x)\n        return (int(x) % m) + bigf\n    \n    B = [mapper(x) - n - 1 for x in sys.stdin.buffer.read().split()]\n    qorder = mergesort(q, B.__getitem__, reverse=True)\n    ans = [0]*q\n\n    segg = seg(m)\n    for before,i in enumerate(order):\n        segg.add(i)\n\n        while qorder and (before == m-1 or years[before + 1] > B[qorder[-1]]):\n            qind = qorder.pop()\n            q = int((B[qind] - years[before]) % (before + 1))\n            ans[qind] = segg.binary(q + 1) + 1\n    print '\\n'.join(str(x) for x in ans)\n\n\n######## Python 2 and 3 footer by Pajenegod and c1729\n\n# Note because cf runs old PyPy3 version which doesn't have the sped up\n# unicode strings, PyPy3 strings will many times be slower than pypy2.\n# There is a way to get around this by using binary strings in PyPy3\n# but its syntax is different which makes it kind of a mess to use.\n\n# So on cf, use PyPy2 for best string performance.\n\npy2 = round(0.5)\nif py2:\n    from future_builtins import ascii, filter, hex, map, oct, zip\n    range = xrange\n\nimport os, sys\nfrom io import IOBase, BytesIO\n\nBUFSIZE = 8192\nclass FastIO(BytesIO):\n    newlines = 0\n\n    def __init__(self, file):\n        self._file = file\n        self._fd = file.fileno()\n        self.writable = \"x\" in file.mode or \"w\" in file.mode\n        self.write = super(FastIO, self).write if self.writable else None\n\n    def _fill(self):\n        s = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n        self.seek((self.tell(), self.seek(0,2), super(FastIO, self).write(s))[0])\n        return s\n\n    def read(self):\n        while self._fill(): pass\n        return super(FastIO,self).read()\n\n    def readline(self):\n        while self.newlines == 0:\n            s = self._fill(); self.newlines = s.count(b\"\\n\") + (not s)\n        self.newlines -= 1\n        return super(FastIO, self).readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.getvalue())\n            self.truncate(0), self.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        if py2:\n            self.write = self.buffer.write\n            self.read = self.buffer.read\n            self.readline = self.buffer.readline\n        else:\n            self.write = lambda s:self.buffer.write(s.encode('ascii'))\n            self.read = lambda:self.buffer.read().decode('ascii')\n            self.readline = lambda:self.buffer.readline().decode('ascii')\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline()\n\n# Cout implemented in Python\nimport sys\nclass ostream:\n    def __lshift__(self,a):\n        sys.stdout.write(str(a))\n        return self\ncout = ostream()\nendl = '\\n'\n\n# Read all remaining integers in stdin, type is given by optional argument, this is fast\ndef readnumbers(zero = 0):\n    conv = ord if py2 else lambda x:x\n    A = []; numb = zero; sign = 1; i = 0; s = sys.stdin.buffer.read()\n    try:\n        while True:\n            if s[i] >= b'0' [0]:\n                numb = 10 * numb + conv(s[i]) - 48\n            elif s[i] == b'-' [0]: sign = -1\n            elif s[i] != b'\\r' [0]:\n                A.append(sign*numb)\n                numb = zero; sign = 1\n            i += 1\n    except:pass\n    if s and s[-1] >= b'0' [0]:\n        A.append(sign*numb)\n    return A\n\nif __name__== \"__main__\":\n  main()",
    "prob_desc_created_at": "1560677700",
    "tags": [
        "two pointers",
        "implementation",
        "sortings",
        "data structures",
        "binary search",
        "trees"
    ],
    "hidden_unit_tests": ""
}
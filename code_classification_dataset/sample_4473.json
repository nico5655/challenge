{
    "prob_desc_time_limit": "8 seconds",
    "prob_desc_sample_outputs": "[\"48\\n47\\n47\", \"44\\n46\", \"413\", \"190431\\n187503\\n188085\\n189903\\n189708\"]",
    "src_uid": "33ad21c1e922b8a2aba774fe54baf06a",
    "prob_desc_notes": null,
    "prob_desc_description": "Consider a segment $$$[0, d]$$$ of the coordinate line. There are $$$n$$$ lanterns and $$$m$$$ points of interest in this segment.For each lantern, you can choose its power — an integer between $$$0$$$ and $$$d$$$ (inclusive). A lantern with coordinate $$$x$$$ illuminates the point of interest with coordinate $$$y$$$ if $$$|x - y|$$$ is less than or equal to the power of the lantern.A way to choose the power values for all lanterns is considered valid if every point of interest is illuminated by at least one lantern.You have to process $$$q$$$ queries. Each query is represented by one integer $$$f_i$$$. To answer the $$$i$$$-th query, you have to:  add a lantern on coordinate $$$f_i$$$;  calculate the number of valid ways to assign power values to all lanterns, and print it modulo $$$998244353$$$;  remove the lantern you just added. ",
    "prob_desc_output_spec": "For each query, print one integer — the answer to it, taken modulo $$$998244353$$$.",
    "prob_desc_input_spec": "The first line contains three integers $$$d$$$, $$$n$$$ and $$$m$$$ ($$$4 \\le d \\le 3 \\cdot 10^5$$$; $$$1 \\le n \\le 2 \\cdot 10^5$$$; $$$1 \\le m \\le 16$$$) — the size of the segment, the number of lanterns and the number of points of interest, respectively. The second line contains $$$n$$$ integers $$$l_1, l_2, \\dots, l_n$$$ ($$$1 \\le l_i \\le d - 1$$$), where $$$l_i$$$ is the coordinate of the $$$i$$$-th lantern. The third line contains $$$m$$$ integers $$$p_1, p_2, \\dots, p_m$$$ ($$$1 \\le p_i \\le d - 1$$$), where $$$p_i$$$ is the coordinate of the $$$i$$$-th point of interest. The fourth line contains one integer $$$q$$$ ($$$1 \\le q \\le 5 \\cdot 10^5$$$) — the number of queries. The fifth line contains $$$q$$$ integers $$$f_1, f_2, \\dots, f_q$$$ ($$$1 \\le f_i \\le d - 1$$$), where $$$f_i$$$ is the integer representing the $$$i$$$-th query. Additional constraint on the input: during the processing of each query, no coordinate contains more than one object (i. e. there cannot be two or more lanterns with the same coordinate, two or more points of interest with the same coordinate, or a lantern and a point of interest with the same coordinate).",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3-64",
    "lang_cluster": "Python",
    "difficulty": 2700,
    "file_name": "train_098.jsonl",
    "code_uid": "b2241af211b8e193bad9ed8c6124450c",
    "prob_desc_memory_limit": "512 megabytes",
    "prob_desc_sample_inputs": "[\"6 1 1\\n4\\n3\\n3\\n2 1 5\", \"6 1 2\\n4\\n2 5\\n2\\n1 3\", \"20 1 2\\n11\\n15 7\\n1\\n8\", \"20 3 5\\n5 7 18\\n1 6 3 10 19\\n5\\n4 17 15 8 9\"]",
    "exec_outcome": "PASSED",
    "source_code": "input = __import__('sys').stdin.readline\r\n\r\n\r\nMOD = 998244353\r\n\r\n\r\nd, n, m = map(int, input().split())\r\nlamps = list(sorted(map(int, input().split()))) # n\r\npoints = list(sorted(map(int, input().split()))) # m\r\n\r\n# 1. O(m^2) to find all interesting points (sould be around m^2 points)\r\npositions = [x for x in points]\r\npositions.append(0)\r\npositions.append(d)\r\nfor i in range(m):\r\n    for j in range(i+1, m):\r\n        mid = (points[i] + points[j]) // 2\r\n        positions.append(mid)\r\n        positions.append(mid+1)\r\npositions = list(sorted(set(positions)))\r\nposmap = {x: i for i, x in enumerate(positions)}\r\n\r\n# print('points', points)\r\n# print('positions', positions)\r\n\r\n# 2. O(nm) to precompute QueryL and QueryR\r\ni = 0\r\nqueryL = []\r\nfor p in points:\r\n    queries = [0] * len(positions)\r\n    while positions[i] < p:\r\n        i += 1\r\n\r\n    j = i    \r\n    q = 1\r\n    for x in lamps:\r\n        if x <= p:\r\n            continue\r\n        while x > positions[j]:\r\n            queries[j] = q\r\n            j += 1\r\n        q = q * (x - p) % MOD\r\n    \r\n    while j < len(positions):\r\n        queries[j] = q\r\n        j += 1\r\n    \r\n    queryL.append(queries)\r\n    # print('L p:', p, queries)\r\n\r\ni = len(positions)-1\r\nqueryR = []\r\nfor p in points[::-1]:\r\n    queries = [0] * len(positions)\r\n    while positions[i] > p:\r\n        i -= 1\r\n\r\n    j = i\r\n    q = 1\r\n    for x in lamps[::-1]:\r\n        if x > p:\r\n            continue\r\n        while x < positions[j]:\r\n            queries[j] = q\r\n            j -= 1\r\n        q = q * (p - x) % MOD\r\n    while j >= 0:\r\n        queries[j] = q\r\n        j -= 1\r\n    \r\n    queryR.append(queries)\r\n    # print('R p:', p, queries)\r\n\r\nqueryR = queryR[::-1]\r\n# print('queryL', queryL)\r\n# print('queryR', queryR)\r\n\r\n# 3. O(m*2^m) to convert all mask to product of QueryL & QueryR and calculate the inclusion-exclusion & accumulate its SumQueryL[L..R] SumQueryR[L..R] values\r\nquerySums = [[[0]*len(positions) for _ in range(len(points))] for _ in range(2)]\r\ncurrent_ans = 0\r\nfor mask in range(1, 1 << m):\r\n    keys = []\r\n    prev_idx = -1\r\n    popcnt = 0\r\n    q = 1\r\n    for i in range(m):\r\n        if (mask >> i) & 1:\r\n            p = points[i]\r\n            if prev_idx == -1:\r\n                keys.append((1, i, 0))\r\n                q = q * queryR[i][0] % MOD\r\n            else:\r\n                prev_p = points[prev_idx]\r\n                mid = (prev_p + p) // 2\r\n                \r\n                keys.append((0, prev_idx, posmap[mid]))\r\n                q = q * queryL[prev_idx][posmap[mid]] % MOD\r\n                \r\n                keys.append((1, i, posmap[mid+1]))\r\n                q = q * queryR[i][posmap[mid+1]] % MOD\r\n            \r\n            prev_idx = i\r\n            popcnt += 1\r\n    \r\n    keys.append((0, prev_idx, len(positions)-1))\r\n    q = q * queryL[prev_idx][-1] % MOD\r\n    if popcnt & 1:\r\n        current_ans = (current_ans - q) % MOD\r\n        for i, j, k in keys:\r\n            querySums[i][j][k] = (querySums[i][j][k] - q) % MOD\r\n    else:\r\n        current_ans = (current_ans + q) % MOD\r\n        for i, j, k in keys:\r\n            querySums[i][j][k] = (querySums[i][j][k] + q) % MOD\r\n    \r\n    # print('mask', ('{:0' + str(m) + 'b}').format(mask), q, keys)\r\n\r\nfor j in range(m):\r\n    for k in range(len(positions) -2, -1, -1):\r\n        querySums[0][j][k] = (querySums[0][j][k] + querySums[0][j][k+1]) % MOD\r\n    for k in range(1, len(positions)):\r\n        querySums[1][j][k] = (querySums[1][j][k] + querySums[1][j][k-1]) % MOD\r\n\r\n# 4. for each query, update the total ans by affected SumQueryL and SumQueryR (those with L <= x <= R)\r\ncurrent_ans += pow(d+1, n+1, MOD)\r\ncurrent_ans %= MOD\r\n\r\n_ = int(input())\r\nfor x in map(int, input().split()):\r\n    ans = current_ans\r\n\r\n    pos = -1\r\n    lo, hi = 0, len(positions)-1\r\n    while lo <= hi:\r\n        mid = (lo + hi) // 2\r\n        if positions[mid] >= x:\r\n            pos = mid\r\n            hi = mid-1\r\n        else:\r\n            lo = mid+1\r\n    \r\n    for j in range(m):\r\n        if points[j] < x:\r\n            total = querySums[0][j][pos]\r\n            ans -= total\r\n            ans += total * (x - points[j]) % MOD\r\n            ans %= MOD\r\n    \r\n    pos = -1\r\n    lo, hi = 0, len(positions)-1\r\n    while lo <= hi:\r\n        mid = (lo + hi) // 2\r\n        if positions[mid] <= x:\r\n            pos = mid\r\n            lo = mid+1\r\n        else:\r\n            hi = mid-1\r\n    \r\n    for j in range(m):\r\n        if x <= points[j]:\r\n            total = querySums[1][j][pos]\r\n            ans -= total\r\n            ans += total * (points[j] - x) % MOD\r\n            ans %= MOD\r\n\r\n    print(ans)\r\n",
    "prob_desc_created_at": "1662647700",
    "tags": [
        "binary search",
        "bitmasks",
        "brute force",
        "combinatorics",
        "dp",
        "math",
        "two pointers"
    ],
    "hidden_unit_tests": ""
}
{
    "prob_desc_time_limit": "1.5 seconds",
    "prob_desc_sample_outputs": "[\"NO\\nN/A\\nYES\\nYES\\nNO\"]",
    "src_uid": "b618c6067c966e0ca846ea463300df75",
    "prob_desc_notes": "NoteIn the first test for the five first queries:  Initially Sam tells that people $$$4$$$, $$$5$$$ are not sick.  In the next query Sam asks the status of the patient $$$5$$$. From the previous query, we know that the patient is definitely not sick.  In the next query Sam asks the status of the patient $$$6$$$. We don't know any information about that patient now.  After that Sam tells that there exists a sick patient among $$$4$$$, $$$5$$$, $$$6$$$.  In the next query Sam asks the status of the patient $$$6$$$. Now we can tell that this patient is definitely sick. ",
    "prob_desc_description": "In the work of a doctor, it is important to maintain the anonymity of clients and the results of tests. The test results are sent to everyone personally by email, but people are very impatient and they want to know the results right away.That's why in the testing lab \"De-vitro\" doctors came up with an experimental way to report the results. Let's assume that $$$n$$$ people took the tests in the order of the queue. Then the chief doctor Sam can make several statements, in each telling if there is a sick person among the people in the queue from $$$l$$$-th to $$$r$$$-th (inclusive), for some values $$$l$$$ and $$$r$$$.During the process, Sam will check how well this scheme works and will be interested in whether it is possible to find out the test result of $$$i$$$-th person from the information he announced. And if it can be done, then is that patient sick or not.Help Sam to test his scheme.",
    "prob_desc_output_spec": "After each Sam question (query with $$$t = 1$$$) print:   \"NO\", if the patient is definitely not sick,  \"YES\", if the patient is definitely sick.  \"N/A\", if it is impossible to definitely identify the status of patient having the given information. ",
    "prob_desc_input_spec": "The first line contains two integers $$$n$$$, $$$q$$$ ($$$1 \\le n, q \\le 2 \\cdot 10^5$$$) — the number of people and the number of queries. In each of the next $$$q$$$ lines, the description of the query is given. The first number in the line is $$$t$$$ ($$$t = 0$$$ or $$$t = 1$$$) — the type of the query. If $$$t = 0$$$, the line contains three more integers $$$l, r, x$$$ ($$$1 \\le l \\le r \\le n$$$, $$$x = 0$$$ or $$$x = 1$$$). This query means that Sam tells that among the people in the queue from $$$l$$$-th to $$$r$$$-th (inclusive):    there was at least one sick person, if $$$x=1$$$,  there is no sick people, if $$$x=0$$$.  If $$$t = 1$$$, the line contains one more integer $$$j$$$ ($$$1 \\le j \\le n$$$) — the position of the patient in the queue, for which Sam wants to know the status. All queries are correct, that means that there always exists an example of the queue of length $$$n$$$ for which all reported results (statements from queries with $$$t = 0$$$) are true.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3-64",
    "lang_cluster": "Python",
    "difficulty": 2200,
    "file_name": "train_092.jsonl",
    "code_uid": "01fbca1a3c2dcf3279df1997f18fd771",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"6 9\\n0 4 5 0\\n1 5\\n1 6\\n0 4 6 1\\n1 6\\n0 2 5 1\\n0 2 2 0\\n1 3\\n1 2\"]",
    "exec_outcome": "PASSED",
    "source_code": "import sys\r\nimport os\r\nfrom io import BytesIO, IOBase\r\nfrom heapq import heappush, heappop\r\n\r\n# region fastio\r\nBUFSIZE = 8192\r\n \r\nclass FastIO(IOBase):\r\n    newlines = 0\r\n \r\n    def __init__(self, file):\r\n        self._fd = file.fileno()\r\n        self.buffer = BytesIO()\r\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\r\n        self.write = self.buffer.write if self.writable else None\r\n \r\n    def read(self):\r\n        while True:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            if not b:\r\n                break\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines = 0\r\n        return self.buffer.read()\r\n \r\n    def readline(self):\r\n        while self.newlines == 0:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            self.newlines = b.count(b\"\\n\") + (not b)\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines -= 1\r\n        return self.buffer.readline()\r\n \r\n    def flush(self):\r\n        if self.writable:\r\n            os.write(self._fd, self.buffer.getvalue())\r\n            self.buffer.truncate(0), self.buffer.seek(0)\r\n \r\nclass IOWrapper(IOBase):\r\n    def __init__(self, file):\r\n        self.buffer = FastIO(file)\r\n        self.flush = self.buffer.flush\r\n        self.writable = self.buffer.writable\r\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\r\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\r\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\r\n\r\nif sys.version_info[0] < 3:\r\n    sys.stdin = BytesIO(os.read(0, os.fstat(0).st_size))\r\nelse:\r\n    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\r\n\r\nf = sys.stdin\r\nif os.environ.get('USER') == \"loic\":\r\n    f = open(\"data.in\")\r\n    \r\nline = lambda: f.readline().split()\r\nui = lambda: int(line()[0])\r\nti = lambda: map(int,line())\r\nli = lambda: list(ti())\r\n\r\n#######################################################################\r\n\r\n# From https://github.com/cheran-senthil/PyRival/blob/master/pyrival/data_structures/SortedList.py\r\nclass SortedList:\r\n    def __init__(self, iterable=[], _load=5000):\r\n        \"\"\"Initialize sorted list instance.\"\"\"\r\n        values = sorted(iterable)\r\n        self._len = _len = len(values)\r\n        self._load = _load\r\n        self._lists = _lists = [values[i:i + _load] for i in range(0, _len, _load)]\r\n        self._list_lens = [len(_list) for _list in _lists]\r\n        self._mins = [_list[0] for _list in _lists]\r\n        self._fen_tree = []\r\n        self._rebuild = True\r\n\r\n    def _fen_build(self):\r\n        \"\"\"Build a fenwick tree instance.\"\"\"\r\n        self._fen_tree[:] = self._list_lens\r\n        _fen_tree = self._fen_tree\r\n        for i in range(len(_fen_tree)):\r\n            if i | i + 1 < len(_fen_tree):\r\n                _fen_tree[i | i + 1] += _fen_tree[i]\r\n        self._rebuild = False\r\n\r\n    def _fen_update(self, index, value):\r\n        \"\"\"Update `fen_tree[index] += value`.\"\"\"\r\n        if not self._rebuild:\r\n            _fen_tree = self._fen_tree\r\n            while index < len(_fen_tree):\r\n                _fen_tree[index] += value\r\n                index |= index + 1\r\n\r\n    def _fen_query(self, end):\r\n        \"\"\"Return `sum(_fen_tree[:end])`.\"\"\"\r\n        if self._rebuild:\r\n            self._fen_build()\r\n\r\n        _fen_tree = self._fen_tree\r\n        x = 0\r\n        while end:\r\n            x += _fen_tree[end - 1]\r\n            end &= end - 1\r\n        return x\r\n\r\n    def _fen_findkth(self, k):\r\n        \"\"\"Return a pair of (the largest `idx` such that `sum(_fen_tree[:idx]) <= k`, `k - sum(_fen_tree[:idx])`).\"\"\"\r\n        _list_lens = self._list_lens\r\n        if k < _list_lens[0]:\r\n            return 0, k\r\n        if k >= self._len - _list_lens[-1]:\r\n            return len(_list_lens) - 1, k + _list_lens[-1] - self._len\r\n        if self._rebuild:\r\n            self._fen_build()\r\n\r\n        _fen_tree = self._fen_tree\r\n        idx = -1\r\n        for d in reversed(range(len(_fen_tree).bit_length())):\r\n            right_idx = idx + (1 << d)\r\n            if right_idx < len(_fen_tree) and k >= _fen_tree[right_idx]:\r\n                idx = right_idx\r\n                k -= _fen_tree[idx]\r\n        return idx + 1, k\r\n\r\n    def _delete(self, pos, idx):\r\n        \"\"\"Delete value at the given `(pos, idx)`.\"\"\"\r\n        _lists = self._lists\r\n        _mins = self._mins\r\n        _list_lens = self._list_lens\r\n\r\n        self._len -= 1\r\n        self._fen_update(pos, -1)\r\n        del _lists[pos][idx]\r\n        _list_lens[pos] -= 1\r\n\r\n        if _list_lens[pos]:\r\n            _mins[pos] = _lists[pos][0]\r\n        else:\r\n            del _lists[pos]\r\n            del _list_lens[pos]\r\n            del _mins[pos]\r\n            self._rebuild = True\r\n\r\n    def _loc_left(self, value):\r\n        \"\"\"Return an index pair that corresponds to the first position of `value` in the sorted list.\"\"\"\r\n        if not self._len:\r\n            return 0, 0\r\n\r\n        _lists = self._lists\r\n        _mins = self._mins\r\n\r\n        lo, pos = -1, len(_lists) - 1\r\n        while lo + 1 < pos:\r\n            mi = (lo + pos) >> 1\r\n            if value <= _mins[mi]:\r\n                pos = mi\r\n            else:\r\n                lo = mi\r\n\r\n        if pos and value <= _lists[pos - 1][-1]:\r\n            pos -= 1\r\n\r\n        _list = _lists[pos]\r\n        lo, idx = -1, len(_list)\r\n        while lo + 1 < idx:\r\n            mi = (lo + idx) >> 1\r\n            if value <= _list[mi]:\r\n                idx = mi\r\n            else:\r\n                lo = mi\r\n\r\n        return pos, idx\r\n\r\n    def _loc_right(self, value):\r\n        \"\"\"Return an index pair that corresponds to the last position of `value` in the sorted list.\"\"\"\r\n        if not self._len:\r\n            return 0, 0\r\n\r\n        _lists = self._lists\r\n        _mins = self._mins\r\n\r\n        pos, hi = 0, len(_lists)\r\n        while pos + 1 < hi:\r\n            mi = (pos + hi) >> 1\r\n            if value < _mins[mi]:\r\n                hi = mi\r\n            else:\r\n                pos = mi\r\n\r\n        _list = _lists[pos]\r\n        lo, idx = -1, len(_list)\r\n        while lo + 1 < idx:\r\n            mi = (lo + idx) >> 1\r\n            if value < _list[mi]:\r\n                idx = mi\r\n            else:\r\n                lo = mi\r\n\r\n        return pos, idx\r\n\r\n    def add(self, value):\r\n        \"\"\"Add `value` to sorted list.\"\"\"\r\n        _load = self._load\r\n        _lists = self._lists\r\n        _mins = self._mins\r\n        _list_lens = self._list_lens\r\n\r\n        self._len += 1\r\n        if _lists:\r\n            pos, idx = self._loc_right(value)\r\n            self._fen_update(pos, 1)\r\n            _list = _lists[pos]\r\n            _list.insert(idx, value)\r\n            _list_lens[pos] += 1\r\n            _mins[pos] = _list[0]\r\n            if _load + _load < len(_list):\r\n                _lists.insert(pos + 1, _list[_load:])\r\n                _list_lens.insert(pos + 1, len(_list) - _load)\r\n                _mins.insert(pos + 1, _list[_load])\r\n                _list_lens[pos] = _load\r\n                del _list[_load:]\r\n                self._rebuild = True\r\n        else:\r\n            _lists.append([value])\r\n            _mins.append(value)\r\n            _list_lens.append(1)\r\n            self._rebuild = True\r\n\r\n    def discard(self, value):\r\n        \"\"\"Remove `value` from sorted list if it is a member.\"\"\"\r\n        _lists = self._lists\r\n        if _lists:\r\n            pos, idx = self._loc_right(value)\r\n            if idx and _lists[pos][idx - 1] == value:\r\n                self._delete(pos, idx - 1)\r\n\r\n    def remove(self, value):\r\n        \"\"\"Remove `value` from sorted list; `value` must be a member.\"\"\"\r\n        _len = self._len\r\n        self.discard(value)\r\n        if _len == self._len:\r\n            raise ValueError('{0!r} not in list'.format(value))\r\n\r\n    def pop(self, index=-1):\r\n        \"\"\"Remove and return value at `index` in sorted list.\"\"\"\r\n        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)\r\n        value = self._lists[pos][idx]\r\n        self._delete(pos, idx)\r\n        return value\r\n\r\n    def bisect_left(self, value):\r\n        \"\"\"Return the first index to insert `value` in the sorted list.\"\"\"\r\n        pos, idx = self._loc_left(value)\r\n        return self._fen_query(pos) + idx\r\n\r\n    def bisect_right(self, value):\r\n        \"\"\"Return the last index to insert `value` in the sorted list.\"\"\"\r\n        pos, idx = self._loc_right(value)\r\n        return self._fen_query(pos) + idx\r\n\r\n    def count(self, value):\r\n        \"\"\"Return number of occurrences of `value` in the sorted list.\"\"\"\r\n        return self.bisect_right(value) - self.bisect_left(value)\r\n\r\n    def __len__(self):\r\n        \"\"\"Return the size of the sorted list.\"\"\"\r\n        return self._len\r\n\r\n    def __getitem__(self, index):\r\n        \"\"\"Lookup value at `index` in sorted list.\"\"\"\r\n        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)\r\n        return self._lists[pos][idx]\r\n\r\n    def __delitem__(self, index):\r\n        \"\"\"Remove value at `index` from sorted list.\"\"\"\r\n        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)\r\n        self._delete(pos, idx)\r\n\r\n    def __contains__(self, value):\r\n        \"\"\"Return true if `value` is an element of the sorted list.\"\"\"\r\n        _lists = self._lists\r\n        if _lists:\r\n            pos, idx = self._loc_left(value)\r\n            return idx < len(_lists[pos]) and _lists[pos][idx] == value\r\n        return False\r\n\r\n    def __iter__(self):\r\n        \"\"\"Return an iterator over the sorted list.\"\"\"\r\n        return (value for _list in self._lists for value in _list)\r\n\r\n    def __reversed__(self):\r\n        \"\"\"Return a reverse iterator over the sorted list.\"\"\"\r\n        return (value for _list in reversed(self._lists) for value in reversed(_list))\r\n\r\n    def __repr__(self):\r\n        \"\"\"Return string representation of sorted list.\"\"\"\r\n        return 'SortedList({0})'.format(list(self))\r\n\r\n\r\nclass Data:\r\n    def __init__(self, val):\r\n        self.val = val\r\n    \r\n    def __str__(self):\r\n        d = self.__dict__\r\n        res = \"\"\r\n        for k,v in d.items():\r\n            res += str(k) + \" : \" + str(v) + \"\\n\"\r\n        return res\r\n        \r\nclass SegmentTree:\r\n    def __init__(self, arr=[]):\r\n        self.n = len(arr)\r\n        self.sz = 1<<(self.n-1).bit_length()\r\n        self.data = [None] * 2 * self.sz\r\n        \r\n        for i in range(self.n):\r\n            self.data[self.sz + i] = arr[i]\r\n        for i in range(self.sz - 1, 0, -1):\r\n            self.data[i] = merge(self.data[i<<1], self.data[i<<1|1])\r\n \r\n \r\n    def update(self, pos, new_val):\r\n        i = self.sz + pos\r\n        self.data[i] = new_val\r\n     \r\n        while i > 1:\r\n            i >>= 1\r\n            self.data[i] = merge(self.data[i<<1], self.data[i<<1|1])\r\n        \r\n    def query(self, l, r):\r\n        tl = self.sz + l\r\n        tr = self.sz + r + 1\r\n        res_left = None\r\n        res_right = None\r\n     \r\n        while tl < tr:\r\n            if tl & 1:\r\n                res_left = merge(res_left, self.data[tl])\r\n                tl += 1\r\n            if tr & 1:\r\n                tr -= 1\r\n                res_right = merge(self.data[tr], res_right)\r\n            tl >>= 1\r\n            tr >>= 1\r\n     \r\n        return merge(res_left, res_right)\r\n\r\ndef merge(a, b):\r\n    #################################\r\n    if a is None and b is not None:\r\n        return b\r\n    if b is None and a is not None:\r\n        return a\r\n    if a is None and b is None:\r\n        return None\r\n    #################################\r\n    \r\n    return min(a,b)\r\n\r\ndef solve():\r\n    \r\n    res = []\r\n    sl = SortedList(range(N))\r\n    arr = [10**9 for _ in range(N)]\r\n    st = SegmentTree(arr)\r\n    \r\n    for q in Q:\r\n        if q[0] == 0:\r\n            l,r,x = q[1:]\r\n            l -= 1\r\n            r -= 1\r\n            if x == 0:\r\n                idx = sl.bisect_left(l)\r\n                while idx < len(sl) and sl[idx] <= r:\r\n                    sl.remove(sl[idx])\r\n            else:\r\n                if r < st.query(l, l):\r\n                    st.update(l, r)\r\n        else:\r\n            j = q[1]\r\n            j -= 1\r\n            if j not in sl:\r\n                res.append(\"NO\")\r\n            else:\r\n                idx = sl.bisect_left(j)\r\n                bef = sl[idx-1]+1 if idx > 0 else 0\r\n                idx = sl.bisect_right(j)\r\n                aft = sl[idx] if idx < len(sl) else N\r\n                val = st.query(bef, j)\r\n                if val < aft:\r\n                    res.append(\"YES\")\r\n                else:\r\n                    res.append(\"N/A\")\r\n    \r\n    return \"\\n\".join(v for v in res)\r\n\r\nfor test in range(1,1+1):\r\n    N,M = ti()\r\n    U = []\r\n    Q = []\r\n    for _ in range(M):\r\n        Q.append(tuple(ti()))\r\n    \r\n    print(solve())\r\n    \r\nf.close()",
    "prob_desc_created_at": "1645611000",
    "tags": [
        "binary search",
        "data structures",
        "sortings"
    ],
    "hidden_unit_tests": ""
}
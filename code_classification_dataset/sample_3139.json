{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"5\\n3 + 3\\n3 ^ 6\\n3 + 5\\n3 + 6\\n8 ^ 9\", \"10\\n123 + 123\\n123 ^ 246\\n141 + 123\\n246 + 123\\n264 ^ 369\\n121 + 246\\n367 ^ 369\\n30 + 30\\n60 + 60\\n120 ^ 121\"]",
    "src_uid": "d8134a016838448ed827233003626362",
    "prob_desc_notes": null,
    "prob_desc_description": "You have a blackboard and initially only an odd number $$$x$$$ is written on it. Your goal is to write the number $$$1$$$ on the blackboard.You may write new numbers on the blackboard with the following two operations.   You may take two numbers (not necessarily distinct) already on the blackboard and write their sum on the blackboard. The two numbers you have chosen remain on the blackboard.  You may take two numbers (not necessarily distinct) already on the blackboard and write their bitwise XOR on the blackboard. The two numbers you have chosen remain on the blackboard.  Perform a sequence of operations such that at the end the number $$$1$$$ is on the blackboard.",
    "prob_desc_output_spec": "Print on the first line the number $$$q$$$ of operations you perform. Then $$$q$$$ lines should follow, each describing one operation.    The \"sum\" operation is described by the line \"$$$a$$$ + $$$b$$$\", where $$$a, b$$$ must be integers already present on the blackboard.  The \"xor\" operation is described by the line \"$$$a$$$ ^ $$$b$$$\", where $$$a, b$$$ must be integers already present on the blackboard.  The operation symbol (+ or ^) must be separated from $$$a, b$$$ by a whitespace. You can perform at most $$$100,000$$$ operations (that is, $$$q\\le 100,000$$$) and all numbers written on the blackboard must be in the range $$$[0, 5\\cdot10^{18}]$$$. It can be proven that under such restrictions the required sequence of operations exists. You can output any suitable sequence of operations.",
    "prob_desc_input_spec": "The single line of the input contains the odd integer $$$x$$$ ($$$3 \\le x \\le 999,999$$$).",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3",
    "lang_cluster": "Python",
    "difficulty": 2500,
    "file_name": "train_043.jsonl",
    "code_uid": "0628980da30b0ba4afd0430fdafa07cd",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"3\", \"123\"]",
    "exec_outcome": "PASSED",
    "source_code": "#!/usr/bin/env python\nfrom __future__ import division, print_function\nfrom operator import *\n\nimport os\nimport sys\nfrom io import BytesIO, IOBase\n#from types import ModuleType\n\nsys.setrecursionlimit(1 << 10)\nclass TailRecurseException(BaseException):\n    def __init__(self, args, kwargs):\n        self.args = args\n        self.kwargs = kwargs\n\n# https://code.activestate.com/recipes/474088-tail-call-optimization-decorator/\ndef tail_call_optimized(g):\n    \"\"\"\n    This function decorates a function with tail call\n    optimization. It does this by throwing an exception\n  if it is it's own grandparent, and catching such\n    exceptions to fake the tail call optimization.\n    \n  This function fails if the decorated\n    function recurses in a non-tail context.\n    \"\"\"\n    def func(*args, **kwargs):\n        f = sys._getframe()\n        if f.f_back and f.f_back.f_back and f.f_back.f_back.f_code == f.f_code:\n            raise TailRecurseException(args, kwargs)\n        else:\n            while 1:\n                try:\n                    return g(*args, **kwargs)\n                except TailRecurseException as e:\n                    args = e.args\n                    kwargs = e.kwargs\n    func.__doc__ = g.__doc__\n    return func\ndef identity(g): return g\ntco = identity\n\nif sys.version_info[0] < 3:\n    from __builtin__ import xrange as range\n    from future_builtins import ascii, filter, hex, map, oct, zip\n\nfrom collections import defaultdict\n\n____dm = None\nONLINE_JUDGE = __debug__\n\ndef inputline():\n    global inp\n    inp = input().split()\n    inp.reverse()\n\ndef readint(): return int(inp.pop())\ndef readfloat(): return float(inp.pop())\ndef nextline(): return inputline()\ndef void(*arg): return None\ndisplayln = print\nprintln = print\nif ONLINE_JUDGE:\n    dbgln = void\nelse:\n    dbgln = print\ndef add1(x): return x + 1\ndef sub1(x): return x - 1\ndef ceildiv(a, b): return -(-a // b)\n\ndef g231():\n    ##@tco\n    def lo_0(x_1):\n        ##@tco\n        def do_3(j_4):\n            g133 = gt(j_4, x_1)\n            if g133 != False:\n                return j_4\n            else:\n                g134 = mul(2, j_4)\n                return do_3(g134)\n        g135 = do_3\n        lb2_2 = g135(1)\n        ##@tco\n        def do_5(i_6, j_7, t_8):\n            g136 = gt(j_7, x_1)\n            if g136 != False:\n                return t_8\n            else:\n                g137 = truediv(i_6, 2)\n                g138 = add(j_7, i_6)\n                g139 = add1(t_8)\n                return do_5(g137, g138, g139)\n        g140 = do_5\n        g141 = truediv(lb2_2, 4)\n        g142 = truediv(lb2_2, 2)\n        return g140(g141, g142, 0)\n    global cnt_9\n    cnt_9 = 120\n    ##@tco\n    def solve_lo1_10(x_11):\n        global cnt_9\n        ##@tco\n        def do_13(i_14, j_15):\n            g143 = gt(j_15, x_11)\n            if g143 != False:\n                return i_14\n            else:\n                g144 = add1(i_14)\n                g145 = mul(2, j_15)\n                return do_13(g144, g145)\n        g146 = do_13\n        btx_12 = g146(0, 1)\n        g147 = sub(btx_12, 1)\n        g148 = pow(2, g147)\n        y_16 = mul(x_11, g148)\n        i_17 = sub(btx_12, 1)\n        ##@tco\n        def do_18(x_19, i_20):\n            global cnt_9\n            g149 = eq(i_20, 0)\n            if g149 != False:\n                return None\n            else:\n                g150 = sub1(cnt_9)\n                _151 = cnt_9 = g150\n\n                void()\n                print(x_19, \"+\", x_19)\n                g152 = mul(2, x_19)\n                g153 = sub(i_20, 1)\n                return do_18(g152, g153)\n        g154 = do_18\n        g154(x_11, i_17)\n        a_21 = add(y_16, x_11)\n        g155 = sub1(cnt_9)\n        _156 = cnt_9 = g155\n\n        void()\n        print(y_16, \"+\", x_11)\n        b_22 = xor(y_16, x_11)\n        g157 = sub1(cnt_9)\n        _158 = cnt_9 = g157\n\n        void()\n        print(y_16, \"^\", x_11)\n        c_23 = xor(a_21, b_22)\n        g159 = sub1(cnt_9)\n        _160 = cnt_9 = g159\n\n        void()\n        print(a_21, \"^\", b_22)\n        loc_24 = lo_0(c_23)\n        g161 = gt(loc_24, 1)\n        if g161 != False:\n            c2_25 = add(c_23, c_23)\n            a_27 = c_23\n            b_26 = c_23\n            g162 = sub1(cnt_9)\n            _163 = cnt_9 = g162\n\n            void()\n            print(a_27, \"+\", b_26)\n            q_28 = xor(c_23, c2_25)\n            a_29 = c_23\n            g164 = sub1(cnt_9)\n            _165 = cnt_9 = g164\n\n            void()\n            print(a_29, \"^\", c2_25)\n            g166 = pow(2, loc_24)\n            w_30 = mul(q_28, g166)\n            ##@tco\n            def do_31(x_32, i_33):\n                global cnt_9\n                g167 = eq(i_33, 0)\n                if g167 != False:\n                    return None\n                else:\n                    g168 = sub1(cnt_9)\n                    _169 = cnt_9 = g168\n\n                    void()\n                    print(x_32, \"+\", x_32)\n                    g170 = mul(2, x_32)\n                    g171 = sub(i_33, 1)\n                    return do_31(g170, g171)\n            g172 = do_31\n            g172(q_28, loc_24)\n            qa_34 = add(q_28, w_30)\n            g173 = sub1(cnt_9)\n            _174 = cnt_9 = g173\n\n            void()\n            print(q_28, \"+\", w_30)\n            qb_35 = xor(q_28, w_30)\n            g175 = sub1(cnt_9)\n            _176 = cnt_9 = g175\n\n            void()\n            print(q_28, \"^\", w_30)\n            qc_36 = xor(qa_34, qb_35)\n            g177 = sub1(cnt_9)\n            _178 = cnt_9 = g177\n\n            void()\n            print(qa_34, \"^\", qb_35)\n            g179 = mul(2, q_28)\n            qd_37 = xor(qc_36, g179)\n            b_38 = mul(2, q_28)\n            g180 = sub1(cnt_9)\n            _181 = cnt_9 = g180\n\n            void()\n            print(qc_36, \"^\", b_38)\n            g182 = sub(loc_24, 1)\n            g183 = pow(2, g182)\n            qe_39 = mul(qd_37, g183)\n            i_40 = sub(loc_24, 1)\n            ##@tco\n            def do_41(x_42, i_43):\n                global cnt_9\n                g184 = eq(i_43, 0)\n                if g184 != False:\n                    return None\n                else:\n                    g185 = sub1(cnt_9)\n                    _186 = cnt_9 = g185\n\n                    void()\n                    print(x_42, \"+\", x_42)\n                    g187 = mul(2, x_42)\n                    g188 = sub(i_43, 1)\n                    return do_41(g187, g188)\n            g189 = do_41\n            g189(qd_37, i_40)\n            qqq_44 = xor(q_28, qe_39)\n            g190 = sub1(cnt_9)\n            _191 = cnt_9 = g190\n\n            void()\n            print(q_28, \"^\", qe_39)\n            _192 = c_23 = qqq_44\n\n            void()\n        else:\n            None\n        g193 = sub(btx_12, 2)\n        g194 = pow(2, g193)\n        mul(c_23, g194)\n        x_46 = c_23\n        i_45 = sub(btx_12, 2)\n        ##@tco\n        def do_47(x_48, i_49):\n            global cnt_9\n            g195 = eq(i_49, 0)\n            if g195 != False:\n                return None\n            else:\n                g196 = sub1(cnt_9)\n                _197 = cnt_9 = g196\n\n                void()\n                print(x_48, \"+\", x_48)\n                g198 = mul(2, x_48)\n                g199 = sub(i_49, 1)\n                return do_47(g198, g199)\n        g200 = do_47\n        g200(x_46, i_45)\n        ##@tco\n        def do_51(i_52, k_53, j_54):\n            g201 = eq(i_52, c_23)\n            if g201 != False:\n                return j_54\n            else:\n                g202 = mul(2, i_52)\n                g203 = mul(2, k_53)\n                g204 = and_(j_54, i_52)\n                g205 = eq(g204, 0)\n                def g208():\n                    global cnt_9\n                    if g205 != False:\n                        return j_54\n                    else:\n                        nj_55 = xor(j_54, k_53)\n                        g206 = sub1(cnt_9)\n                        _207 = cnt_9 = g206\n\n                        void()\n                        print(j_54, \"^\", k_53)\n                        return nj_55\n                g208 = g208()\n                return do_51(g202, g203, g208)\n        g209 = do_51\n        g210 = mul(2, x_11)\n        global f_50\n        f_50 = g209(2, g210, x_11)\n        ##@tco\n        def do_56(qq_57):\n            global f_50\n            global cnt_9\n            g211 = gt(qq_57, f_50)\n            if g211 != False:\n                return None\n            else:\n                g212 = and_(qq_57, f_50)\n                g213 = gt(g212, 0)\n                if g213 != False:\n                    nf_58 = xor(qq_57, f_50)\n                    b_59 = f_50\n                    g214 = sub1(cnt_9)\n                    _215 = cnt_9 = g214\n\n                    void()\n                    print(qq_57, \"^\", b_59)\n                    _216 = f_50 = nf_58\n\n                    void()\n                else:\n                    None\n                g217 = mul(2, qq_57)\n                return do_56(g217)\n        g218 = do_56\n        return g218(c_23)\n    n_60 = readint()\n    print(120)\n    g219 = eq(n_60, 1)\n    if g219 != False:\n        None\n    else:\n        g220 = lo_0(n_60)\n        g221 = gt(g220, 1)\n        if g221 != False:\n            x2_61 = add(n_60, n_60)\n            g222 = sub1(cnt_9)\n            _223 = cnt_9 = g222\n\n            void()\n            print(n_60, \"+\", n_60)\n            y_62 = xor(n_60, x2_61)\n            g224 = sub1(cnt_9)\n            _225 = cnt_9 = g224\n\n            void()\n            print(n_60, \"^\", x2_61)\n            solve_lo1_10(y_62)\n        else:\n            solve_lo1_10(n_60)\n    @tail_call_optimized\n    def do_63(cnt_64):\n        global cnt_9\n        g226 = eq(cnt_64, 0)\n        if g226 != False:\n            return None\n        else:\n            g227 = sub1(cnt_9)\n            _228 = cnt_9 = g227\n\n            void()\n            print(n_60, \"+\", n_60)\n            g229 = sub1(cnt_64)\n            return do_63(g229)\n    g230 = do_63\n    return g230(cnt_9)\n_232 = main = g231\n\nvoid()\nNone\n \n# region fastio\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\ndef print(*args, **kwargs):\n    \"\"\"Prints the values to a stream, or to sys.stdout by default.\"\"\"\n    sep, file = kwargs.pop(\"sep\", \" \"), kwargs.pop(\"file\", sys.stdout)\n    at_start = True\n    for x in args:\n        if not at_start:\n            file.write(sep)\n        file.write(str(x))\n        at_start = False\n    file.write(kwargs.pop(\"end\", \"\\n\"))\n    if kwargs.pop(\"flush\", False):\n        file.flush()\n\n\nif sys.version_info[0] < 3:\n    sys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)\nelse:\n    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\n\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n# endregion\n\nif __name__ == \"__main__\":\n    inputline()\n    main()\n    \n",
    "prob_desc_created_at": "1602341400",
    "tags": [
        "constructive algorithms",
        "number theory",
        "bitmasks",
        "math",
        "matrices"
    ],
    "hidden_unit_tests": ""
}
{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"? 4 4 2 3 2\\n\\n? 3 5 1 5 5\\n\\n? 5 2 4 3 1\\n\\n! 3 2 1 5 4\"]",
    "src_uid": "2cb5fe3fdff43e104729866cdfa73102",
    "prob_desc_notes": "NoteIn the sample, the hidden permutation $$$p$$$ is $$$[3, 2, 1, 5, 4]$$$. Three queries were made.The first query is $$$a = [4, 4, 2, 3, 2]$$$. This yields $$$s = [3 + 4, 2 + 4, 1 + 2, 5 + 3, 4 + 2] = [7, 6, 3, 8, 6]$$$. $$$6$$$ is the only number that appears more than once, and it appears first at index $$$2$$$, making the answer to the query $$$2$$$.The second query is $$$a = [3, 5, 1, 5, 5]$$$. This yields $$$s = [3 + 3, 2 + 5, 1 + 1, 5 + 5, 4 + 5] = [6, 7, 2, 10, 9]$$$. There are no numbers that appear more than once here, so the answer to the query is $$$0$$$.The third query is $$$a = [5, 2, 4, 3, 1]$$$. This yields $$$s = [3 + 5, 2 + 2, 1 + 4, 5 + 3, 4 + 1] = [8, 4, 5, 8, 5]$$$. $$$5$$$ and $$$8$$$ both occur more than once here. $$$5$$$ first appears at index $$$3$$$, while $$$8$$$ first appears at index $$$1$$$, and $$$1 &lt; 3$$$, making the answer to the query $$$1$$$.Note that the sample is only meant to provide an example of how the interaction works; it is not guaranteed that the above queries represent a correct strategy with which to determine the answer.",
    "prob_desc_description": "It turns out that the meaning of life is a permutation $$$p_1, p_2, \\ldots, p_n$$$ of the integers $$$1, 2, \\ldots, n$$$ ($$$2 \\leq n \\leq 100$$$). Omkar, having created all life, knows this permutation, and will allow you to figure it out using some queries.A query consists of an array $$$a_1, a_2, \\ldots, a_n$$$ of integers between $$$1$$$ and $$$n$$$. $$$a$$$ is not required to be a permutation. Omkar will first compute the pairwise sum of $$$a$$$ and $$$p$$$, meaning that he will compute an array $$$s$$$ where $$$s_j = p_j + a_j$$$ for all $$$j = 1, 2, \\ldots, n$$$. Then, he will find the smallest index $$$k$$$ such that $$$s_k$$$ occurs more than once in $$$s$$$, and answer with $$$k$$$. If there is no such index $$$k$$$, then he will answer with $$$0$$$.You can perform at most $$$2n$$$ queries. Figure out the meaning of life $$$p$$$.",
    "prob_desc_output_spec": null,
    "prob_desc_input_spec": null,
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3-64",
    "lang_cluster": "Python",
    "difficulty": 1800,
    "file_name": "train_087.jsonl",
    "code_uid": "37d598518b10a7839209ca870e09e27d",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"5\\n\\n2\\n\\n0\\n\\n1\"]",
    "exec_outcome": "PASSED",
    "source_code": "# ---------------------------iye ha aam zindegi---------------------------------------------\r\nimport math\r\nimport random\r\nimport heapq,bisect\r\nimport sys\r\nfrom collections import deque, defaultdict\r\nfrom fractions import Fraction\r\nimport sys\r\nfrom itertools import permutations\r\nfrom collections import defaultdict\r\nmod = 10 ** 9 + 7\r\nmod1 = 998244353\r\n\r\n# ------------------------------warmup----------------------------\r\nimport os\r\nimport sys\r\nfrom io import BytesIO, IOBase\r\n\r\nBUFSIZE = 8192\r\n\r\n\r\nclass FastIO(IOBase):\r\n    newlines = 0\r\n\r\n    def __init__(self, file):\r\n        self._fd = file.fileno()\r\n        self.buffer = BytesIO()\r\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\r\n        self.write = self.buffer.write if self.writable else None\r\n\r\n    def read(self):\r\n        while True:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            if not b:\r\n                break\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines = 0\r\n        return self.buffer.read()\r\n\r\n    def readline(self):\r\n        while self.newlines == 0:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            self.newlines = b.count(b\"\\n\") + (not b)\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines -= 1\r\n        return self.buffer.readline()\r\n\r\n    def flush(self):\r\n        if self.writable:\r\n            os.write(self._fd, self.buffer.getvalue())\r\n            self.buffer.truncate(0), self.buffer.seek(0)\r\n\r\n\r\nclass IOWrapper(IOBase):\r\n    def __init__(self, file):\r\n        self.buffer = FastIO(file)\r\n        self.flush = self.buffer.flush\r\n        self.writable = self.buffer.writable\r\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\r\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\r\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\r\n\r\n\r\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\r\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\r\n\r\n\r\n# -------------------game starts now----------------------------------------------------import math\r\nclass TreeNode:\r\n    def __init__(self, k, v):\r\n        self.key = k\r\n        self.value = v\r\n        self.left = None\r\n        self.right = None\r\n        self.parent = None\r\n        self.height = 1\r\n        self.num_left = 1\r\n        self.num_total = 1\r\n\r\n\r\nclass AvlTree:\r\n\r\n    def __init__(self):\r\n        self._tree = None\r\n\r\n    def add(self, k, v):\r\n        if not self._tree:\r\n            self._tree = TreeNode(k, v)\r\n            return\r\n        node = self._add(k, v)\r\n        if node:\r\n            self._rebalance(node)\r\n\r\n    def _add(self, k, v):\r\n        node = self._tree\r\n        while node:\r\n            if k < node.key:\r\n                if node.left:\r\n                    node = node.left\r\n                else:\r\n                    node.left = TreeNode(k, v)\r\n                    node.left.parent = node\r\n                    return node.left\r\n            elif node.key < k:\r\n                if node.right:\r\n                    node = node.right\r\n                else:\r\n                    node.right = TreeNode(k, v)\r\n                    node.right.parent = node\r\n                    return node.right\r\n            else:\r\n                node.value = v\r\n                return\r\n\r\n    @staticmethod\r\n    def get_height(x):\r\n        return x.height if x else 0\r\n\r\n    @staticmethod\r\n    def get_num_total(x):\r\n        return x.num_total if x else 0\r\n\r\n    def _rebalance(self, node):\r\n\r\n        n = node\r\n        while n:\r\n            lh = self.get_height(n.left)\r\n            rh = self.get_height(n.right)\r\n            n.height = max(lh, rh) + 1\r\n            balance_factor = lh - rh\r\n            n.num_total = 1 + self.get_num_total(n.left) + self.get_num_total(n.right)\r\n            n.num_left = 1 + self.get_num_total(n.left)\r\n\r\n            if balance_factor > 1:\r\n                if self.get_height(n.left.left) < self.get_height(n.left.right):\r\n                    self._rotate_left(n.left)\r\n                self._rotate_right(n)\r\n            elif balance_factor < -1:\r\n                if self.get_height(n.right.right) < self.get_height(n.right.left):\r\n                    self._rotate_right(n.right)\r\n                self._rotate_left(n)\r\n            else:\r\n                n = n.parent\r\n\r\n    def _remove_one(self, node):\r\n        \"\"\"\r\n        Side effect!!! Changes node. Node should have exactly one child\r\n        \"\"\"\r\n        replacement = node.left or node.right\r\n        if node.parent:\r\n            if AvlTree._is_left(node):\r\n                node.parent.left = replacement\r\n            else:\r\n                node.parent.right = replacement\r\n            replacement.parent = node.parent\r\n            node.parent = None\r\n        else:\r\n            self._tree = replacement\r\n            replacement.parent = None\r\n        node.left = None\r\n        node.right = None\r\n        node.parent = None\r\n        self._rebalance(replacement)\r\n\r\n    def _remove_leaf(self, node):\r\n        if node.parent:\r\n            if AvlTree._is_left(node):\r\n                node.parent.left = None\r\n            else:\r\n                node.parent.right = None\r\n            self._rebalance(node.parent)\r\n        else:\r\n            self._tree = None\r\n        node.parent = None\r\n        node.left = None\r\n        node.right = None\r\n\r\n    def remove(self, k):\r\n        node = self._get_node(k)\r\n        if not node:\r\n            return\r\n        if AvlTree._is_leaf(node):\r\n            self._remove_leaf(node)\r\n            return\r\n        if node.left and node.right:\r\n            nxt = AvlTree._get_next(node)\r\n            node.key = nxt.key\r\n            node.value = nxt.value\r\n            if self._is_leaf(nxt):\r\n                self._remove_leaf(nxt)\r\n            else:\r\n                self._remove_one(nxt)\r\n            self._rebalance(node)\r\n        else:\r\n            self._remove_one(node)\r\n\r\n    def get(self, k):\r\n        node = self._get_node(k)\r\n        return node.value if node else -1\r\n\r\n    def _get_node(self, k):\r\n        if not self._tree:\r\n            return None\r\n        node = self._tree\r\n        while node:\r\n            if k < node.key:\r\n                node = node.left\r\n            elif node.key < k:\r\n                node = node.right\r\n            else:\r\n                return node\r\n        return None\r\n\r\n    def get_at(self, pos):\r\n        x = pos + 1\r\n        node = self._tree\r\n        while node:\r\n            if x < node.num_left:\r\n                node = node.left\r\n            elif node.num_left < x:\r\n                x -= node.num_left\r\n                node = node.right\r\n            else:\r\n                return (node.key, node.value)\r\n        raise IndexError(\"Out of ranges\")\r\n\r\n    @staticmethod\r\n    def _is_left(node):\r\n        return node.parent.left and node.parent.left == node\r\n\r\n    @staticmethod\r\n    def _is_leaf(node):\r\n        return node.left is None and node.right is None\r\n\r\n    def _rotate_right(self, node):\r\n        if not node.parent:\r\n            self._tree = node.left\r\n            node.left.parent = None\r\n        elif AvlTree._is_left(node):\r\n            node.parent.left = node.left\r\n            node.left.parent = node.parent\r\n        else:\r\n            node.parent.right = node.left\r\n            node.left.parent = node.parent\r\n        bk = node.left.right\r\n        node.left.right = node\r\n        node.parent = node.left\r\n        node.left = bk\r\n        if bk:\r\n            bk.parent = node\r\n        node.height = max(self.get_height(node.left), self.get_height(node.right)) + 1\r\n        node.num_total = 1 + self.get_num_total(node.left) + self.get_num_total(node.right)\r\n        node.num_left = 1 + self.get_num_total(node.left)\r\n\r\n    def _rotate_left(self, node):\r\n        if not node.parent:\r\n            self._tree = node.right\r\n            node.right.parent = None\r\n        elif AvlTree._is_left(node):\r\n            node.parent.left = node.right\r\n            node.right.parent = node.parent\r\n        else:\r\n            node.parent.right = node.right\r\n            node.right.parent = node.parent\r\n        bk = node.right.left\r\n        node.right.left = node\r\n        node.parent = node.right\r\n        node.right = bk\r\n        if bk:\r\n            bk.parent = node\r\n        node.height = max(self.get_height(node.left), self.get_height(node.right)) + 1\r\n        node.num_total = 1 + self.get_num_total(node.left) + self.get_num_total(node.right)\r\n        node.num_left = 1 + self.get_num_total(node.left)\r\n\r\n    @staticmethod\r\n    def _get_next(node):\r\n        if not node.right:\r\n            return node.parent\r\n        n = node.right\r\n        while n.left:\r\n            n = n.left\r\n        return n\r\n\r\n\r\n# -----------------------------------------------binary seacrh tree---------------------------------------\r\nclass SegmentTree1:\r\n    def __init__(self, data, default=2*10**9, func=lambda a, b: min(a,b)):\r\n        \"\"\"initialize the segment tree with data\"\"\"\r\n        self._default = default\r\n        self._func = func\r\n        self._len = len(data)\r\n        self._size = _size = 1 << (self._len - 1).bit_length()\r\n\r\n        self.data = [default] * (2 * _size)\r\n        self.data[_size:_size + self._len] = data\r\n        for i in reversed(range(_size)):\r\n            self.data[i] = func(self.data[i + i], self.data[i + i + 1])\r\n\r\n    def __delitem__(self, idx):\r\n        self[idx] = self._default\r\n\r\n    def __getitem__(self, idx):\r\n        return self.data[idx + self._size]\r\n\r\n    def __setitem__(self, idx, value):\r\n        idx += self._size\r\n        self.data[idx] = value\r\n        idx >>= 1\r\n        while idx:\r\n            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])\r\n            idx >>= 1\r\n\r\n    def __len__(self):\r\n        return self._len\r\n\r\n    def query(self, start, stop):\r\n        if start == stop:\r\n            return self.__getitem__(start)\r\n        stop += 1\r\n        start += self._size\r\n        stop += self._size\r\n\r\n        res = self._default\r\n        while start < stop:\r\n            if start & 1:\r\n                res = self._func(res, self.data[start])\r\n                start += 1\r\n            if stop & 1:\r\n                stop -= 1\r\n                res = self._func(res, self.data[stop])\r\n            start >>= 1\r\n            stop >>= 1\r\n        return res\r\n\r\n    def __repr__(self):\r\n        return \"SegmentTree({0})\".format(self.data)\r\n\r\n\r\n# -------------------game starts now----------------------------------------------------import math\r\nclass SegmentTree:\r\n    def __init__(self, data, default=0, func=lambda a, b: a+b):\r\n        \"\"\"initialize the segment tree with data\"\"\"\r\n        self._default = default\r\n        self._func = func\r\n        self._len = len(data)\r\n        self._size = _size = 1 << (self._len - 1).bit_length()\r\n\r\n        self.data = [default] * (2 * _size)\r\n        self.data[_size:_size + self._len] = data\r\n        for i in reversed(range(_size)):\r\n            self.data[i] = func(self.data[i + i], self.data[i + i + 1])\r\n\r\n    def __delitem__(self, idx):\r\n        self[idx] = self._default\r\n\r\n    def __getitem__(self, idx):\r\n        return self.data[idx + self._size]\r\n\r\n    def __setitem__(self, idx, value):\r\n        idx += self._size\r\n        self.data[idx] = value\r\n        idx >>= 1\r\n        while idx:\r\n            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])\r\n            idx >>= 1\r\n\r\n    def __len__(self):\r\n        return self._len\r\n\r\n    def query(self, start, stop):\r\n        if start == stop:\r\n            return self.__getitem__(start)\r\n        stop += 1\r\n        start += self._size\r\n        stop += self._size\r\n\r\n        res = self._default\r\n        while start < stop:\r\n            if start & 1:\r\n                res = self._func(res, self.data[start])\r\n                start += 1\r\n            if stop & 1:\r\n                stop -= 1\r\n                res = self._func(res, self.data[stop])\r\n            start >>= 1\r\n            stop >>= 1\r\n        return res\r\n\r\n    def __repr__(self):\r\n        return \"SegmentTree({0})\".format(self.data)\r\n\r\n\r\n# -------------------------------iye ha chutiya zindegi-------------------------------------\r\nclass Factorial:\r\n    def __init__(self, MOD):\r\n        self.MOD = MOD\r\n        self.factorials = [1, 1]\r\n        self.invModulos = [0, 1]\r\n        self.invFactorial_ = [1, 1]\r\n\r\n    def calc(self, n):\r\n        if n <= -1:\r\n            print(\"Invalid argument to calculate n!\")\r\n            print(\"n must be non-negative value. But the argument was \" + str(n))\r\n            exit()\r\n        if n < len(self.factorials):\r\n            return self.factorials[n]\r\n        nextArr = [0] * (n + 1 - len(self.factorials))\r\n        initialI = len(self.factorials)\r\n        prev = self.factorials[-1]\r\n        m = self.MOD\r\n        for i in range(initialI, n + 1):\r\n            prev = nextArr[i - initialI] = prev * i % m\r\n        self.factorials += nextArr\r\n        return self.factorials[n]\r\n\r\n    def inv(self, n):\r\n        if n <= -1:\r\n            print(\"Invalid argument to calculate n^(-1)\")\r\n            print(\"n must be non-negative value. But the argument was \" + str(n))\r\n            exit()\r\n        p = self.MOD\r\n        pi = n % p\r\n        if pi < len(self.invModulos):\r\n            return self.invModulos[pi]\r\n        nextArr = [0] * (n + 1 - len(self.invModulos))\r\n        initialI = len(self.invModulos)\r\n        for i in range(initialI, min(p, n + 1)):\r\n            next = -self.invModulos[p % i] * (p // i) % p\r\n            self.invModulos.append(next)\r\n        return self.invModulos[pi]\r\n\r\n    def invFactorial(self, n):\r\n        if n <= -1:\r\n            print(\"Invalid argument to calculate (n^(-1))!\")\r\n            print(\"n must be non-negative value. But the argument was \" + str(n))\r\n            exit()\r\n        if n < len(self.invFactorial_):\r\n            return self.invFactorial_[n]\r\n        self.inv(n)  # To make sure already calculated n^-1\r\n        nextArr = [0] * (n + 1 - len(self.invFactorial_))\r\n        initialI = len(self.invFactorial_)\r\n        prev = self.invFactorial_[-1]\r\n        p = self.MOD\r\n        for i in range(initialI, n + 1):\r\n            prev = nextArr[i - initialI] = (prev * self.invModulos[i % p]) % p\r\n        self.invFactorial_ += nextArr\r\n        return self.invFactorial_[n]\r\n\r\n\r\nclass Combination:\r\n    def __init__(self, MOD):\r\n        self.MOD = MOD\r\n        self.factorial = Factorial(MOD)\r\n\r\n    def ncr(self, n, k):\r\n        if k < 0 or n < k:\r\n            return 0\r\n        k = min(k, n - k)\r\n        f = self.factorial\r\n        return f.calc(n) * f.invFactorial(max(n - k, k)) * f.invFactorial(min(k, n - k)) % self.MOD\r\n\r\n\r\n# --------------------------------------iye ha combinations ka zindegi---------------------------------\r\ndef powm(a, n, m):\r\n    if a == 1 or n == 0:\r\n        return 1\r\n    if n % 2 == 0:\r\n        s = powm(a, n // 2, m)\r\n        return s * s % m\r\n    else:\r\n        return a * powm(a, n - 1, m) % m\r\n\r\n\r\n# --------------------------------------iye ha power ka zindegi---------------------------------\r\ndef sort_list(list1, list2):\r\n    zipped_pairs = zip(list2, list1)\r\n\r\n    z = [x for _, x in sorted(zipped_pairs)]\r\n\r\n    return z\r\n\r\n\r\n# --------------------------------------------------product----------------------------------------\r\ndef product(l):\r\n    por = 1\r\n    for i in range(len(l)):\r\n        por *= l[i]\r\n    return por\r\n\r\n\r\n# --------------------------------------------------binary----------------------------------------\r\ndef binarySearchCount(arr, n, key):\r\n    left = 0\r\n    right = n - 1\r\n\r\n    count = 0\r\n\r\n    while (left <= right):\r\n        mid = int((right + left) / 2)\r\n\r\n        # Check if middle element is\r\n        # less than or equal to key\r\n        if (arr[mid] <= key):\r\n            count = mid + 1\r\n            left = mid + 1\r\n\r\n        # If key is smaller, ignore right half\r\n        else:\r\n            right = mid - 1\r\n\r\n    return count\r\n\r\n\r\n# --------------------------------------------------binary----------------------------------------\r\ndef countdig(n):\r\n    c = 0\r\n    while (n > 0):\r\n        n //= 10\r\n        c += 1\r\n    return c\r\ndef binary(x, length):\r\n    y = bin(x)[2:]\r\n    return y if len(y) >= length else \"0\" * (length - len(y)) + y\r\n\r\ndef countGreater(arr, n, k):\r\n    l = 0\r\n    r = n - 1\r\n\r\n    # Stores the index of the left most element\r\n    # from the array which is greater than k\r\n    leftGreater = n\r\n\r\n    # Finds number of elements greater than k\r\n    while (l <= r):\r\n        m = int(l + (r - l) / 2)\r\n        if (arr[m] >= k):\r\n            leftGreater = m\r\n            r = m - 1\r\n\r\n        # If mid element is less than\r\n        # or equal to k update l\r\n        else:\r\n            l = m + 1\r\n\r\n    # Return the count of elements\r\n    # greater than k\r\n    return (n - leftGreater)\r\n#-----------------------------------------------trie-----------------------------------------------\r\nclass TrieNode:\r\n    def __init__(self):\r\n        self.children = [None] * 26\r\n        self.isEndOfWord = False\r\nclass Trie:\r\n    def __init__(self):\r\n        self.root = self.getNode()\r\n    def getNode(self):\r\n        return TrieNode()\r\n    def _charToIndex(self, ch):\r\n        return ord(ch) - ord('a')\r\n    def insert(self, key):\r\n        pCrawl = self.root\r\n        length = len(key)\r\n        for level in range(length):\r\n            index = self._charToIndex(key[level])\r\n            if not pCrawl.children[index]:\r\n                pCrawl.children[index] = self.getNode()\r\n            pCrawl = pCrawl.children[index]\r\n        pCrawl.isEndOfWord = True\r\n    def search(self, key):\r\n        pCrawl = self.root\r\n        length = len(key)\r\n        for level in range(length):\r\n            index = self._charToIndex(key[level])\r\n            if not pCrawl.children[index]:\r\n                return False\r\n            pCrawl = pCrawl.children[index]\r\n        return pCrawl != None and pCrawl.isEndOfWord\r\n#-----------------------------------------trie---------------------------------\r\nclass Node:\r\n    def __init__(self, data):\r\n        self.data = data\r\n        self.count=0\r\n        self.left = None  # left node for 0\r\n        self.right = None  # right node for 1\r\nclass BinaryTrie:\r\n    def __init__(self):\r\n        self.root = Node(0)\r\n    def insert(self, pre_xor):\r\n        self.temp = self.root\r\n        for i in range(31, -1, -1):\r\n            val = pre_xor & (1 << i)\r\n            if val:\r\n                if not self.temp.right:\r\n                    self.temp.right = Node(0)\r\n                self.temp = self.temp.right\r\n                self.temp.count+=1\r\n            if not val:\r\n                if not self.temp.left:\r\n                    self.temp.left = Node(0)\r\n                self.temp = self.temp.left\r\n                self.temp.count += 1\r\n        self.temp.data = pre_xor\r\n    def query(self, xor):\r\n        self.temp = self.root\r\n        for i in range(31, -1, -1):\r\n            val = xor & (1 << i)\r\n            if not val:\r\n                if self.temp.left and self.temp.left.count>0:\r\n                    self.temp = self.temp.left\r\n                elif self.temp.right:\r\n                    self.temp = self.temp.right\r\n            else:\r\n                if self.temp.right and self.temp.right.count>0:\r\n                    self.temp = self.temp.right\r\n                elif self.temp.left:\r\n                    self.temp = self.temp.left\r\n            self.temp.count-=1\r\n        return xor ^ self.temp.data\r\n# --------------------------------------------------binary-----------------------------------\r\nn=int(input())\r\nans=[0]*n\r\none=-1\r\nf=0\r\nfor i in range(1,n+1):\r\n    arr = [n] * n\r\n    arr[-1]=i\r\n    print(\"?\",*arr,sep=\" \",flush=True)\r\n    k=int(input())\r\n    if k!=0:\r\n        ans[-1]=n+1-i\r\n        f=1\r\n        break\r\nif f==0:\r\n    ans[-1]=1\r\nfor i in range(1,n+1):\r\n    arr=[i]*n\r\n    if i+ans[-1]==n+1:\r\n        continue\r\n    arr[-1]=n+1-ans[-1]\r\n    print(\"?\", *arr, sep=\" \", flush=True)\r\n    k = int(input())\r\n    ans[k-1]=n-i+1\r\nprint(\"!\",*ans,sep=\" \",flush=True)\r\n\r\n\r\n",
    "prob_desc_created_at": "1634468700",
    "tags": [
        "constructive algorithms",
        "greedy",
        "interactive"
    ],
    "hidden_unit_tests": ""
}
{
    "prob_desc_time_limit": "3 seconds",
    "prob_desc_sample_outputs": "[\"3\", \"6\", \"6\"]",
    "src_uid": "a45a5a4b95f97a49960bc86953dd8723",
    "prob_desc_notes": "NoteFor the first example, there is exactly one set having $$$k$$$ points for $$$k = 1, 2, 3$$$, so the total number is $$$3$$$.For the second example, the numbers of sets having $$$k$$$ points for $$$k = 1, 2, 3$$$ are $$$3$$$, $$$2$$$, $$$1$$$ respectively, and their sum is $$$6$$$.For the third example, as the following figure shows, there are  $$$2$$$ sets having one point;  $$$3$$$ sets having two points;  $$$1$$$ set having four points. Therefore, the number of different non-empty sets in this example is $$$2 + 3 + 0 + 1 = 6$$$.  ",
    "prob_desc_description": "There are $$$n$$$ points on the plane, the $$$i$$$-th of which is at $$$(x_i, y_i)$$$. Tokitsukaze wants to draw a strange rectangular area and pick all the points in the area.The strange area is enclosed by three lines, $$$x = l$$$, $$$y = a$$$ and $$$x = r$$$, as its left side, its bottom side and its right side respectively, where $$$l$$$, $$$r$$$ and $$$a$$$ can be any real numbers satisfying that $$$l &lt; r$$$. The upper side of the area is boundless, which you can regard as a line parallel to the $$$x$$$-axis at infinity. The following figure shows a strange rectangular area.  A point $$$(x_i, y_i)$$$ is in the strange rectangular area if and only if $$$l &lt; x_i &lt; r$$$ and $$$y_i &gt; a$$$. For example, in the above figure, $$$p_1$$$ is in the area while $$$p_2$$$ is not.Tokitsukaze wants to know how many different non-empty sets she can obtain by picking all the points in a strange rectangular area, where we think two sets are different if there exists at least one point in one set of them but not in the other.",
    "prob_desc_output_spec": "Print a single integer — the number of different non-empty sets of points she can obtain.",
    "prob_desc_input_spec": "The first line contains a single integer $$$n$$$ ($$$1 \\leq n \\leq 2 \\times 10^5$$$) — the number of points on the plane. The $$$i$$$-th of the next $$$n$$$ lines contains two integers $$$x_i$$$, $$$y_i$$$ ($$$1 \\leq x_i, y_i \\leq 10^9$$$) — the coordinates of the $$$i$$$-th point. All points are distinct.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 2",
    "lang_cluster": "Python",
    "difficulty": 2000,
    "file_name": "train_022.jsonl",
    "code_uid": "19f5240ab3513a8f235ec471a078402f",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"3\\n1 1\\n1 2\\n1 3\", \"3\\n1 1\\n2 1\\n3 1\", \"4\\n2 1\\n2 2\\n3 1\\n3 2\"]",
    "exec_outcome": "PASSED",
    "source_code": "#!/usr/bin/env pypy\nfrom __future__ import division, print_function\n\nimport operator as op\nimport os\nimport sys\nfrom __builtin__ import xrange as range\nfrom bisect import bisect_left, bisect_right, insort\nfrom cStringIO import StringIO\nfrom functools import reduce\nfrom future_builtins import ascii, filter, hex, map, oct, zip\nfrom io import IOBase\nfrom itertools import chain, repeat, starmap\n\nimport __pypy__\n\n\ndef main():\n    n = int(input())\n    points = [tuple(map(int, input().split())) for _ in range(n)]\n    order = sorted(range(n), key=lambda x: (-points[x][1], points[x][0]))\n\n    seen = SortedList()\n    cnt, i = 0, 0\n    while i < n:\n        y = points[order[i]][1]\n        row = []\n        while i < n and points[order[i]][1] == y:\n            x = points[order[i]][0]\n            row.append(x)\n            if x not in seen:\n                seen.add(x)\n            i += 1\n\n        prev = -1\n        for xi in row:\n            lo = seen.bisect_left(xi) - seen.bisect_right(prev)\n            hi = len(seen) - seen.bisect_right(xi)\n            cnt += (lo + 1) * (hi + 1)\n            prev = xi\n\n    print(cnt)\n\n\nclass SortedList():\n    \"\"\"Sorted list is a sorted mutable sequence.\"\"\"\n    DEFAULT_LOAD_FACTOR = 500\n\n    def __init__(self, iterable=None):\n        \"\"\"Initialize sorted list instance.\"\"\"\n        self._len = 0\n        self._load = self.DEFAULT_LOAD_FACTOR\n        self._lists = []\n        self._maxes = []\n        self._index = []\n        self._offset = 0\n        if iterable is not None:\n            self.update(iterable)\n\n    def add(self, value):\n        \"\"\"Add `value` to sorted list.\"\"\"\n        _lists = self._lists\n        _maxes = self._maxes\n        if _maxes:\n            pos = bisect_right(_maxes, value)\n            if pos == len(_maxes):\n                pos -= 1\n                _lists[pos].append(value)\n                _maxes[pos] = value\n            else:\n                insort(_lists[pos], value)\n            self._expand(pos)\n        else:\n            _lists.append([value])\n            _maxes.append(value)\n        self._len += 1\n\n    def _expand(self, pos):\n        \"\"\"Split sublists with length greater than double the load-factor.\"\"\"\n        _load = self._load\n        _lists = self._lists\n        _index = self._index\n\n        if len(_lists[pos]) > (_load << 1):\n            _maxes = self._maxes\n            _lists_pos = _lists[pos]\n            half = _lists_pos[_load:]\n            del _lists_pos[_load:]\n            _maxes[pos] = _lists_pos[-1]\n            _lists.insert(pos + 1, half)\n            _maxes.insert(pos + 1, half[-1])\n            del _index[:]\n        else:\n            if _index:\n                child = self._offset + pos\n                while child:\n                    _index[child] += 1\n                    child = (child - 1) >> 1\n                _index[0] += 1\n\n    def update(self, iterable):\n        \"\"\"Update sorted list by adding all values from `iterable`.\"\"\"\n        _lists = self._lists\n        _maxes = self._maxes\n        values = sorted(iterable)\n\n        if _maxes:\n            if len(values) * 4 >= self._len:\n                values.extend(chain.from_iterable(_lists))\n                values.sort()\n                self.clear()\n            else:\n                _add = self.add\n                for val in values:\n                    _add(val)\n                return\n\n        _load = self._load\n        _lists.extend(values[pos:(pos + _load)]\n                      for pos in range(0, len(values), _load))\n        _maxes.extend(sublist[-1] for sublist in _lists)\n        self._len = len(values)\n        del self._index[:]\n\n    def __contains__(self, value):\n        \"\"\"Return true if `value` is an element of the sorted list.\"\"\"\n        _maxes = self._maxes\n        pos = bisect_left(_maxes, value)\n        if pos == len(_maxes):\n            return False\n\n        _lists = self._lists\n        idx = bisect_left(_lists[pos], value)\n        return _lists[pos][idx] == value\n\n    def remove(self, value):\n        \"\"\"Remove `value` from sorted list if it is a member.\"\"\"\n        _maxes = self._maxes\n        pos = bisect_left(_maxes, value)\n        if pos == len(_maxes):\n            return\n\n        _lists = self._lists\n        idx = bisect_left(_lists[pos], value)\n        if _lists[pos][idx] == value:\n            self._delete(pos, idx)\n\n    def _delete(self, pos, idx):\n        \"\"\"Delete value at the given `(pos, idx)`.\"\"\"\n        _lists = self._lists\n        _maxes = self._maxes\n        _index = self._index\n\n        _lists_pos = _lists[pos]\n        del _lists_pos[idx]\n        self._len -= 1\n\n        len_lists_pos = len(_lists_pos)\n        if len_lists_pos > (self._load >> 1):\n            _maxes[pos] = _lists_pos[-1]\n\n            if _index:\n                child = self._offset + pos\n                while child > 0:\n                    _index[child] -= 1\n                    child = (child - 1) >> 1\n                _index[0] -= 1\n        elif len(_lists) > 1:\n            if not pos:\n                pos += 1\n            prev = pos - 1\n            _lists[prev].extend(_lists[pos])\n            _maxes[prev] = _lists[prev][-1]\n            del _lists[pos]\n            del _maxes[pos]\n            del _index[:]\n            self._expand(prev)\n        elif len_lists_pos:\n            _maxes[pos] = _lists_pos[-1]\n        else:\n            del _lists[pos]\n            del _maxes[pos]\n            del _index[:]\n\n    def _loc(self, pos, idx):\n        \"\"\"Convert an index pair (lists index, sublist index) into a single\n        index number that corresponds to the position of the value in the\n        sorted list.\"\"\"\n        if not pos:\n            return idx\n\n        _index = self._index\n        if not _index:\n            self._build_index()\n        total = 0\n        pos += self._offset\n        while pos:\n            if not pos & 1:\n                total += _index[pos - 1]\n            pos = (pos - 1) >> 1\n        return total + idx\n\n    def _pos(self, idx):\n        \"\"\"Convert an index into an index pair (lists index, sublist index)\n        that can be used to access the corresponding lists position.\"\"\"\n        if idx < 0:\n            last_len = len(self._lists[-1])\n            if (-idx) <= last_len:\n                return len(self._lists) - 1, last_len + idx\n            idx += self._len\n            if idx < 0:\n                raise IndexError('list index out of range')\n        elif idx >= self._len:\n            raise IndexError('list index out of range')\n\n        if idx < len(self._lists[0]):\n            return 0, idx\n\n        _index = self._index\n        if not _index:\n            self._build_index()\n\n        pos = 0\n        child = 1\n        len_index = len(_index)\n        while child < len_index:\n            index_child = _index[child]\n            if idx < index_child:\n                pos = child\n            else:\n                idx -= index_child\n                pos = child + 1\n            child = (pos << 1) + 1\n        return (pos - self._offset, idx)\n\n    def _build_index(self):\n        \"\"\"Build a positional index for indexing the sorted list.\"\"\"\n        row0 = list(map(len, self._lists))\n        if len(row0) == 1:\n            self._index[:] = row0\n            self._offset = 0\n            return\n\n        head = iter(row0)\n        tail = iter(head)\n        row1 = list(starmap(op.add, zip(head, tail)))\n        if len(row0) & 1:\n            row1.append(row0[-1])\n        if len(row1) == 1:\n            self._index[:] = row1 + row0\n            self._offset = 1\n            return\n\n        size = 1 << (len(row1) - 1).bit_length()\n        row1.extend(repeat(0, size - len(row1)))\n        tree = [row0, row1]\n        while len(tree[-1]) > 1:\n            head = iter(tree[-1])\n            tail = iter(head)\n            row = list(starmap(op.add, zip(head, tail)))\n            tree.append(row)\n        reduce(list.__iadd__, reversed(tree), self._index)\n        self._offset = size * 2 - 1\n\n    def __delitem__(self, index):\n        \"\"\"Remove value at `index` from sorted list.\"\"\"\n        if isinstance(index, slice):\n            start, stop, step = index.indices(self._len)\n            if step == 1 and start < stop:\n                if start == 0 and stop == self._len:\n                    return self.clear()\n                elif self._len <= 8 * (stop - start):\n                    values = self.__getitem__(slice(None, start))\n                    if stop < self._len:\n                        values += self.__getitem__(slice(stop, None))\n                    self.clear()\n                    return self.update(values)\n\n            indices = range(start, stop, step)\n            if step > 0:\n                indices = reversed(indices)\n            _pos, _delete = self._pos, self._delete\n            for index in indices:\n                pos, idx = _pos(index)\n                _delete(pos, idx)\n        else:\n            pos, idx = self._pos(index)\n            self._delete(pos, idx)\n\n    def __getitem__(self, index):\n        \"\"\"Lookup value at `index` in sorted list.\"\"\"\n        _lists = self._lists\n\n        if isinstance(index, slice):\n            start, stop, step = index.indices(self._len)\n\n            if step == 1 and start < stop:\n                if start == 0 and stop == self._len:\n                    return reduce(list.__iadd__, self._lists, [])\n\n                start_pos, start_idx = self._pos(start)\n                if stop == self._len:\n                    stop_pos = len(_lists) - 1\n                    stop_idx = len(_lists[stop_pos])\n                else:\n                    stop_pos, stop_idx = self._pos(stop)\n                if start_pos == stop_pos:\n                    return _lists[start_pos][start_idx:stop_idx]\n\n                prefix = _lists[start_pos][start_idx:]\n                middle = _lists[(start_pos + 1):stop_pos]\n                result = reduce(list.__iadd__, middle, prefix)\n                result += _lists[stop_pos][:stop_idx]\n                return result\n\n            if step == -1 and start > stop:\n                result = self.__getitem__(slice(stop + 1, start + 1))\n                result.reverse()\n                return result\n\n            indices = range(start, stop, step)\n            return list(self.__getitem__(index) for index in indices)\n        else:\n            if self._len:\n                if index == 0:\n                    return _lists[0][0]\n                elif index == -1:\n                    return _lists[-1][-1]\n            else:\n                raise IndexError('list index out of range')\n\n            if 0 <= index < len(_lists[0]):\n                return _lists[0][index]\n\n            len_last = len(_lists[-1])\n            if -len_last < index < 0:\n                return _lists[-1][len_last + index]\n\n            pos, idx = self._pos(index)\n            return _lists[pos][idx]\n\n    def __iter__(self):\n        \"\"\"Return an iterator over the sorted list.\"\"\"\n        return chain.from_iterable(self._lists)\n\n    def __reversed__(self):\n        \"\"\"Return a reverse iterator over the sorted list.\"\"\"\n        return chain.from_iterable(map(reversed, reversed(self._lists)))\n\n    def __len__(self):\n        \"\"\"Return the size of the sorted list.\"\"\"\n        return self._len\n\n    def bisect_left(self, value):\n        \"\"\"Return an index to insert `value` in the sorted list.\"\"\"\n        pos = bisect_left(self._maxes, value)\n        return self._len if pos == len(self._maxes) else self._loc(\n            pos, bisect_left(self._lists[pos], value))\n\n    def bisect_right(self, value):\n        \"\"\"Return an index to insert `value` in the sorted list.\"\"\"\n        pos = bisect_right(self._maxes, value)\n        return self._len if pos == len(self._maxes) else self._loc(\n            pos, bisect_right(self._lists[pos], value))\n\n    def count(self, value):\n        \"\"\"Return number of occurrences of `value` in the sorted list.\"\"\"\n        _maxes = self._maxes\n        if not _maxes:\n            return 0\n\n        pos_left = bisect_left(_maxes, value)\n        if pos_left == len(_maxes):\n            return 0\n\n        _lists = self._lists\n        idx_left = bisect_left(_lists[pos_left], value)\n        pos_right = bisect_right(_maxes, value)\n        if pos_right == len(_maxes):\n            return self._len - self._loc(pos_left, idx_left)\n\n        idx_right = bisect_right(_lists[pos_right], value)\n        if pos_left == pos_right:\n            return idx_right - idx_left\n\n        right = self._loc(pos_right, idx_right)\n        left = self._loc(pos_left, idx_left)\n        return right - left\n\n    def __copy__(self):\n        \"\"\"Return a shallow copy of the sorted list.\"\"\"\n        return self.__class__(self)\n\n    def pop(self, index=-1):\n        \"\"\"Remove and return value at `index` in sorted list.\"\"\"\n        if not self._len:\n            raise IndexError('pop index out of range')\n\n        _lists = self._lists\n        if 0 <= index < len(_lists[0]):\n            val = _lists[0][index]\n            self._delete(0, index)\n            return val\n\n        len_last = len(_lists[-1])\n        if -len_last < index < 0:\n            pos = len(_lists) - 1\n            loc = len_last + index\n            val = _lists[pos][loc]\n            self._delete(pos, loc)\n            return val\n\n        pos, idx = self._pos(index)\n        val = _lists[pos][idx]\n        self._delete(pos, idx)\n        return val\n\n    def index(self, value, start=0, stop=None):\n        \"\"\"Return first index of value in sorted list.\"\"\"\n        _len = self._len\n        if start < 0:\n            start += _len\n        if start < 0:\n            start = 0\n        if stop is None:\n            stop = _len\n        if stop < 0:\n            stop += _len\n        if stop > _len:\n            stop = _len\n\n        if stop <= start:\n            raise ValueError('{0!r} is not in list'.format(value))\n\n        _maxes = self._maxes\n        pos_left = bisect_left(_maxes, value)\n        if pos_left == len(_maxes):\n            raise ValueError('{0!r} is not in list'.format(value))\n\n        _lists = self._lists\n        idx_left = bisect_left(_lists[pos_left], value)\n        if _lists[pos_left][idx_left] != value:\n            raise ValueError('{0!r} is not in list'.format(value))\n\n        stop -= 1\n        left = self._loc(pos_left, idx_left)\n        if start <= left:\n            if left <= stop:\n                return left\n        else:\n            if start <= self.bisect_right(value) - 1:\n                return start\n        raise ValueError('{0!r} is not in list'.format(value))\n\n    def __add__(self, other):\n        \"\"\"Return new sorted list containing all values in both sequences.\"\"\"\n        values = reduce(list.__iadd__, self._lists, [])\n        values.extend(other)\n        return self.__class__(values)\n\n    __radd__ = __add__\n\n    def __iadd__(self, other):\n        \"\"\"Update sorted list with values from `other`.\"\"\"\n        self.update(other)\n        return self\n\n    def __mul__(self, num):\n        \"\"\"Return new sorted list with `num` shallow copies of values.\"\"\"\n        values = reduce(list.__iadd__, self._lists, []) * num\n        return self.__class__(values)\n\n    __rmul__ = __mul__\n\n    def __imul__(self, num):\n        \"\"\"Update the sorted list with `num` shallow copies of values.\"\"\"\n        values = reduce(list.__iadd__, self._lists, []) * num\n        self.clear()\n        self.update(values)\n        return self\n\n    def __make_cmp(seq_op):\n        \"Make comparator method.\"\n\n        def comparer(self, other):\n            \"Compare method for sorted list and sequence.\"\n            self_len = self._len\n            len_other = len(other)\n            if self_len != len_other:\n                if seq_op is op.eq:\n                    return False\n                if seq_op is op.ne:\n                    return True\n\n            for alpha, beta in zip(self, other):\n                if alpha != beta:\n                    return seq_op(alpha, beta)\n            return seq_op(self_len, len_other)\n\n        comparer.__name__ = '__{0}__'.format(seq_op.__name__)\n        return comparer\n\n    __eq__ = __make_cmp(op.eq)\n    __ne__ = __make_cmp(op.ne)\n    __lt__ = __make_cmp(op.lt)\n    __gt__ = __make_cmp(op.gt)\n    __le__ = __make_cmp(op.le)\n    __ge__ = __make_cmp(op.ge)\n    __make_cmp = staticmethod(__make_cmp)\n\n    def __repr__(self):\n        \"\"\"Return string representation of sorted list.\"\"\"\n        return 'SortedList({0})'.format(reduce(list.__iadd__, self._lists, []))\n\n\n# region fastio\n\nBUFSIZE = 8192\n\n\nclass FastI(IOBase):\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self._buffer = StringIO()\n        self.newlines = 0\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(\"\\n\") + (not b)\n            ptr = self._buffer.tell()\n            self._buffer.seek(0,\n                              2), self._buffer.write(b), self._buffer.seek(ptr)\n        self.newlines -= 1\n        return self._buffer.readline()\n\n\nclass FastO(IOBase):\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self._buffer = __pypy__.builders.StringBuilder()\n        self.write = lambda s: self._buffer.append(s)\n\n    def flush(self):\n        os.write(self._fd, self._buffer.build())\n        self._buffer = __pypy__.builders.StringBuilder()\n\n\ndef print(*args, **kwargs):\n    sep, file = kwargs.pop(\"sep\", \" \"), kwargs.pop(\"file\", sys.stdout)\n    at_start = True\n    for x in args:\n        if not at_start:\n            file.write(sep)\n        file.write(str(x))\n        at_start = False\n    file.write(kwargs.pop(\"end\", \"\\n\"))\n    if kwargs.pop(\"flush\", False):\n        file.flush()\n\n\nsys.stdin, sys.stdout = FastI(sys.stdin), FastO(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n# endregion\n\nif __name__ == \"__main__\":\n    main()\n",
    "prob_desc_created_at": "1562942100",
    "tags": [
        "data structures",
        "divide and conquer"
    ],
    "hidden_unit_tests": ""
}
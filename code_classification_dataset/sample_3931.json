{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"YES\\nYES\\nNO\\nYES\\nNO\\nYES\"]",
    "src_uid": "8386c1a5db2565ccc8a7154cefa29391",
    "prob_desc_notes": "NoteIn the first test case, a one-character string is semi-Fibonacci, being itself a Fibonacci string.In the second test case, a string of two different characters is Fibonacci.In the third test case, the string \"abb\" (let the first of the alphabet letter be a, the second letter b) is not a semi-Fibonacci string, since no permutation of its letters (\"abb\", \"bab\", and \"bba\") is a Fibonacci string.In the fourth test case, two permutations of the letters of the string \"abaccac\" (the first letter is a, the second letter is b, the third letter is c) are Fibonacci strings — \"abaaccc\" and \"cbccaaa\".",
    "prob_desc_description": "In all schools in Buryatia, in the $$$1$$$ class, everyone is told the theory of Fibonacci strings.\"A block is a subsegment of a string where all the letters are the same and are bounded on the left and right by the ends of the string or by letters other than the letters in the block. A string is called a Fibonacci string if, when it is divided into blocks, their lengths in the order they appear in the string form the Fibonacci sequence ($$$f_0 = f_1 = 1$$$, $$$f_i = f_{i-2} + f_{i-1}$$$), starting from the zeroth member of this sequence. A string is called semi-Fibonacci if it possible to reorder its letters to get a Fibonacci string.\"Burenka decided to enter the Buryat State University, but at the entrance exam she was given a difficult task. She was given a string consisting of the letters of the Buryat alphabet (which contains exactly $$$k$$$ letters), and was asked if the given string is semi-Fibonacci. The string can be very long, so instead of the string, she was given the number of appearances of each letter ($$$c_i$$$ for the $$$i$$$-th letter) in that string. Unfortunately, Burenka no longer remembers the theory of Fibonacci strings, so without your help she will not pass the exam.",
    "prob_desc_output_spec": "For each test case print the string \"YES\" if the corresponding string is semi-Fibonacci, and \"NO\" if it is not. You can print \"YES\" and \"NO\" in any case (for example, the strings \"yEs\", \"yes\", \"Yes\" will be recognized as a positive answer).",
    "prob_desc_input_spec": "The first line contains one integer $$$t$$$ ($$$1 \\leq t \\leq 10^4$$$) — the number of test cases. The following is a description of the input data sets. The first line of each test case contains one integer $$$k$$$ ($$$1 \\leq k \\leq 100$$$) — the number of letters in the alphabet. The second line of each test case contains $$$k$$$ integers $$$c_1, c_2, \\ldots, c_k$$$ ($$$1 \\leq c_i \\leq 10^9$$$) — the number of occurrences of each letter in the string.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3-64",
    "lang_cluster": "Python",
    "difficulty": 2000,
    "file_name": "train_087.jsonl",
    "code_uid": "4acc36c25a6cb9e7d01957c409114fdd",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"6\\n\\n1\\n\\n1\\n\\n2\\n\\n1 1\\n\\n2\\n\\n1 2\\n\\n3\\n\\n3 1 3\\n\\n2\\n\\n7 5\\n\\n6\\n\\n26 8 3 4 13 34\"]",
    "exec_outcome": "PASSED",
    "source_code": "#!/usr/bin/env PyPy3\r\n\r\nfrom collections import Counter, defaultdict, deque\r\nimport itertools\r\nimport re\r\nimport math\r\nfrom functools import reduce\r\nimport operator\r\nimport bisect\r\nfrom heapq import *\r\nimport functools\r\nmod=998244353\r\n\r\nimport sys\r\nimport os\r\nfrom io import BytesIO, IOBase\r\nBUFSIZE = 8192\r\nclass FastIO(IOBase):\r\n    newlines = 0\r\n    def __init__(self, file):\r\n        self._fd = file.fileno()\r\n        self.buffer = BytesIO()\r\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\r\n        self.write = self.buffer.write if self.writable else None\r\n    def read(self):\r\n        while True:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            if not b:\r\n                break\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines = 0\r\n        return self.buffer.read()\r\n    def readline(self):\r\n        while self.newlines == 0:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            self.newlines = b.count(b\"\\n\") + (not b)\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines -= 1\r\n        return self.buffer.readline()\r\n    def flush(self):\r\n        if self.writable:\r\n            os.write(self._fd, self.buffer.getvalue())\r\n            self.buffer.truncate(0), self.buffer.seek(0)\r\nclass IOWrapper(IOBase):\r\n    def __init__(self, file):\r\n        self.buffer = FastIO(file)\r\n        self.flush = self.buffer.flush\r\n        self.writable = self.buffer.writable\r\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\r\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\r\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\r\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\r\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\r\n\r\nx = [1,1]\r\nfor i in range(60):\r\n        x.append(x[-1] + x[-2])\r\n\r\ncums = [0] + list(itertools.accumulate(x))\r\n#print(cums)\r\n#print(x)\r\nt = int(input())\r\nfor _ in range(t):\r\n    n = int(input())\r\n    a = list(map(int,input().split()))\r\n    su = sum(a)\r\n    if not su in cums:\r\n        print('NO')\r\n    else:\r\n        if n == 1:\r\n            if su == 1:\r\n                print('YES')\r\n            else:\r\n                print('NO')\r\n            continue\r\n        pos = 0\r\n        for i in range(60):\r\n            if cums[i] == su:\r\n                pos = i\r\n                break\r\n\r\n        hp = [-aa for aa in a]\r\n        heapify(hp)\r\n        cur = -1\r\n        for i in range(pos)[::-1]:\r\n            now = heappop(hp)\r\n            if (cur == -now):\r\n                nnow = heappop(hp)\r\n                nnow = -nnow\r\n                if nnow < x[i]:\r\n                    print('NO')\r\n                    break\r\n                nnow -= x[i]\r\n                cur = nnow\r\n                heappush(hp,now)\r\n                heappush(hp,nnow)\r\n\r\n            else:\r\n                now = -now\r\n                if now < x[i]:\r\n                    print('NO')\r\n                    break\r\n                now -= x[i]\r\n                cur = now\r\n                heappush(hp,-now)\r\n        else:\r\n            print('YES')",
    "prob_desc_created_at": "1660660500",
    "tags": [
        "greedy",
        "implementation",
        "math",
        "number theory"
    ],
    "hidden_unit_tests": ""
}
{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"0\\n1\\n2\\n0\"]",
    "src_uid": "7e678f141f411d3872f25559e2c1f17c",
    "prob_desc_notes": "NoteIn the first test case no operations are needed to minimize the value of $$$\\operatorname{DIFF} - \\operatorname{MEX}$$$.In the second test case it is possible to replace $$$5$$$ by $$$1$$$. After that the array $$$a$$$ is $$$[0,\\, 2,\\, 4,\\, 1]$$$, $$$\\operatorname{DIFF} = 4$$$, $$$\\operatorname{MEX} = \\operatorname{MEX}(\\{0, 1, 2, 4\\}) = 3$$$, so the answer is $$$1$$$.In the third test case one possible array $$$a$$$ is $$$[4,\\, 13,\\, 0,\\, 0,\\, 13,\\, 1,\\, 2]$$$, $$$\\operatorname{DIFF} = 5$$$, $$$\\operatorname{MEX} = 3$$$.In the fourth test case one possible array $$$a$$$ is $$$[1,\\, 2,\\, 3,\\, 0,\\, 0,\\, 0]$$$.",
    "prob_desc_description": "You are given an array $$$a$$$ of $$$n$$$ non-negative integers. In one operation you can change any number in the array to any other non-negative integer.Let's define the cost of the array as $$$\\operatorname{DIFF}(a) - \\operatorname{MEX}(a)$$$, where $$$\\operatorname{MEX}$$$ of a set of non-negative integers is the smallest non-negative integer not present in the set, and $$$\\operatorname{DIFF}$$$ is the number of different numbers in the array.For example, $$$\\operatorname{MEX}(\\{1, 2, 3\\}) = 0$$$, $$$\\operatorname{MEX}(\\{0, 1, 2, 4, 5\\}) = 3$$$.You should find the minimal cost of the array $$$a$$$ if you are allowed to make at most $$$k$$$ operations.",
    "prob_desc_output_spec": "For each test case output a single integer — minimal cost that it is possible to get making at most $$$k$$$ operations.",
    "prob_desc_input_spec": "The input consists of multiple test cases. The first line contains a single integer $$$t$$$ ($$$1 \\le t \\le 10^4$$$) — the number of test cases. Description of the test cases follows. The first line of each test case contains two integers $$$n$$$ and $$$k$$$ ($$$1 \\le n \\le 10^5$$$, $$$0 \\le k \\le 10^5$$$) — the length of the array $$$a$$$ and the number of operations that you are allowed to make. The second line of each test case contains $$$n$$$ integers $$$a_1, a_2, \\ldots, a_n$$$ ($$$0 \\le a_i \\le 10^9$$$) — the elements of the array $$$a$$$. It is guaranteed that the sum of $$$n$$$ over all test cases does not exceed $$$10^5$$$.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3-64",
    "lang_cluster": "Python",
    "difficulty": 2100,
    "file_name": "train_103.jsonl",
    "code_uid": "e9a11c7fb588557df960748f06023752",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"4\\n\\n4 1\\n\\n3 0 1 2\\n\\n4 1\\n\\n0 2 4 5\\n\\n7 2\\n\\n4 13 0 0 13 1337 1000000000\\n\\n6 2\\n\\n1 2 8 0 0 0\"]",
    "exec_outcome": "PASSED",
    "source_code": "import os, sys\r\nfrom io import BytesIO, IOBase\r\nfrom array import array\r\n\r\n\r\nclass FastIO(IOBase):\r\n    newlines = 0\r\n\r\n    def __init__(self, file):\r\n        self._fd = file.fileno()\r\n        self.buffer = BytesIO()\r\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\r\n        self.write = self.buffer.write if self.writable else None\r\n\r\n    def read(self):\r\n        while True:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, 8192))\r\n            if not b:\r\n                break\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines = 0\r\n        return self.buffer.read()\r\n\r\n    def readline(self):\r\n        while self.newlines == 0:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, 8192))\r\n            self.newlines = b.count(b\"\\n\") + (not b)\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines -= 1\r\n        return self.buffer.readline()\r\n\r\n    def flush(self):\r\n        if self.writable:\r\n            os.write(self._fd, self.buffer.getvalue())\r\n            self.buffer.truncate(0), self.buffer.seek(0)\r\n\r\n\r\nclass IOWrapper(IOBase):\r\n    def __init__(self, file):\r\n        self.buffer = FastIO(file)\r\n        self.flush = self.buffer.flush\r\n        self.writable = self.buffer.writable\r\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\r\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\r\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\r\n\r\n\r\nclass segmenttree:\r\n    def __init__(self, n, default=0, func=lambda a, b: a + b):\r\n        self.tree, self.n, self.func, self.default = [default] * (2 * n), n, func, default\r\n\r\n    def fill(self, arr):\r\n        self.tree[self.n:] = arr\r\n        for i in range(self.n - 1, 0, -1):\r\n            self.tree[i] = self.func(self.tree[i << 1], self.tree[(i << 1) + 1])\r\n\r\n    # get interval[l,r)\r\n    def query(self, l, r):\r\n        res = self.default\r\n        l += self.n\r\n        r += self.n\r\n        while l < r:\r\n            if l & 1:\r\n                res = self.func(res, self.tree[l])\r\n                l += 1\r\n            if r & 1:\r\n                r -= 1\r\n                res = self.func(res, self.tree[r])\r\n            l >>= 1\r\n            r >>= 1\r\n\r\n        return res\r\n\r\n    def __setitem__(self, ix, val):\r\n        ix += self.n\r\n        self.tree[ix] = val\r\n\r\n        while ix > 1:\r\n            self.tree[ix >> 1] = self.func(self.tree[ix], self.tree[ix ^ 1])\r\n            ix >>= 1\r\n\r\n    def __getitem__(self, item):\r\n        return self.tree[item + self.n]\r\n\r\n\r\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\r\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\r\ninp = lambda dtype: [dtype(x) for x in input().split()]\r\nceil1, out = lambda a, b: (a + b - 1) // b, []\r\n\r\nfor _ in range(int(input())):\r\n    n, k = inp(int)\r\n    a = array('i', sorted(inp(int)))\r\n    coun = segmenttree(n + 2)\r\n    coun2 = segmenttree(n + 2)\r\n    ix, ans = n - 1, n\r\n    cum = array('i', [0] * (n + 3))\r\n\r\n    for i in range(n):\r\n        if a[i] <= n:\r\n            cum[a[i]] = 1\r\n\r\n    for i in range(1, n + 1):\r\n        cum[i] += cum[i - 1]\r\n\r\n    for mex in range(n, -1, -1):\r\n        mmex = 0\r\n\r\n        while ix > -1 and a[ix] >= mex:\r\n            mmex += 1\r\n            if ix == 0 or a[ix] != a[ix - 1]:\r\n                coun[mmex] += mmex\r\n                coun2[mmex] += 1\r\n                mmex = 0\r\n\r\n            ix -= 1\r\n\r\n        if ix < n - 1 and a[ix + 1] != mex:\r\n            mmex = 0\r\n\r\n        k_ = k - mmex\r\n        rem = max(mex - cum[mex - 1] - mmex, 0)\r\n\r\n        if rem > k_:\r\n            continue\r\n\r\n        coun2[mmex] -= 1\r\n        coun[mmex] -= mmex\r\n        if coun.query(1, n + 1) <= rem:\r\n            ans = 0\r\n        else:\r\n            be, en = 0, n\r\n            while be < en:\r\n                md = (be + en + 1) >> 1\r\n                if coun.query(0, md + 1) <= k_:\r\n                    be = md\r\n                else:\r\n                    en = md - 1\r\n\r\n            k_ -= coun.query(1, be + 1)\r\n            ans = min(ans, coun2.query(1, n + 1) - (coun2.query(1, be + 1) + k_ // (be + 1)))\r\n\r\n        coun2[mmex] += 1\r\n        coun[mmex] += mmex\r\n    out.append(f'{ans}')\r\nprint('\\n'.join(out))\r\n",
    "prob_desc_created_at": "1652970900",
    "tags": [
        "binary search",
        "brute force",
        "constructive algorithms",
        "data structures",
        "greedy",
        "two pointers"
    ],
    "hidden_unit_tests": ""
}
{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"4\\naabbbbbba\"]",
    "src_uid": "3ffb3a2ae3e96fc26d539c9676389ae5",
    "prob_desc_notes": "NoteThe tree from the sample is shown below:  The tree after assigning characters to every node (according to the output) is the following:  Strings for all nodes are the following:   string of node $$$1$$$ is: a  string of node $$$2$$$ is: aa  string of node $$$3$$$ is: aab  string of node $$$4$$$ is: aab  string of node $$$5$$$ is: aabb  string of node $$$6$$$ is: aabb  string of node $$$7$$$ is: aabb  string of node $$$8$$$ is: aabb  string of node $$$9$$$ is: aa The set of unique strings is $$$\\{\\text{a}, \\text{aa}, \\text{aab}, \\text{aabb}\\}$$$, so the number of distinct strings is $$$4$$$.",
    "prob_desc_description": "Kilani and Abd are neighbors for 3000 years, but then the day came and Kilani decided to move to another house. As a farewell gift, Kilani is going to challenge Abd with a problem written by their other neighbor with the same name Abd.  The problem is:You are given a connected tree rooted at node $$$1$$$.You should assign a character a or b to every node in the tree so that the total number of a's is equal to $$$x$$$ and the total number of b's is equal to $$$n - x$$$.Let's define a string for each node $$$v$$$ of the tree as follows:   if $$$v$$$ is root then the string is just one character assigned to $$$v$$$:  otherwise, let's take a string defined for the $$$v$$$'s parent $$$p_v$$$ and add to the end of it a character assigned to $$$v$$$. You should assign every node a character in a way that minimizes the number of distinct strings among the strings of all nodes.",
    "prob_desc_output_spec": "In the first line, print the minimum possible total number of distinct strings. In the second line, print $$$n$$$ characters, where all characters are either a or b and the $$$i$$$-th character is the character assigned to the $$$i$$$-th node. Make sure that the total number of a's is equal to $$$x$$$ and the total number of b's is equal to $$$n - x$$$. If there is more than one answer you can print any of them.",
    "prob_desc_input_spec": "The first line contains two integers $$$n$$$ and $$$x$$$ ($$$1 \\leq n \\leq 10^5$$$; $$$0 \\leq x \\leq n$$$) — the number of vertices in the tree the number of a's. The second line contains $$$n - 1$$$ integers $$$p_2, p_3, \\dots, p_{n}$$$ ($$$1 \\leq p_i \\leq n$$$; $$$p_i \\neq i$$$), where $$$p_i$$$ is the parent of node $$$i$$$. It is guaranteed that the input describes a connected tree.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 2",
    "lang_cluster": "Python",
    "difficulty": 3100,
    "file_name": "train_107.jsonl",
    "code_uid": "5726db2b032796c9c35d4404b6a194cb",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"9 3\\n1 2 2 4 4 4 3 1\"]",
    "exec_outcome": "PASSED",
    "source_code": "n, a = map(int, raw_input().split());p = [-1] + [int(x) - 1 for x in raw_input().split()];g = [[] for i in range(n)]\r\nfor i in range(1, n):\tg[p[i]].append(i)\r\nd = [-1 for i in range(n)];d_all = [[] for i in range(n)];d_lv = [[] for i in range(n)];d_nlv = [[] for i in range(n)];q = [0];d[0] = 0\r\nwhile len(q) > 0:\r\n\tv = q.pop()\r\n\td_all[d[v]].append(v)\r\n\tif len(g[v]) == 0:\r\n\t\td_lv[d[v]].append(v)\r\n\telse:\r\n\t\td_nlv[d[v]].append(v)\r\n\tfor u in g[v]:\r\n\t\tif d[u] == -1:\r\n\t\t\td[u] = d[v] + 1\r\n\t\t\tq.append(u)\r\nmx = max(d) + 1\r\nmx_lv_pos = -1\r\nfor i in range(mx):\r\n\tif mx_lv_pos == -1 or len(d_lv[i]) > len(d_lv[mx_lv_pos]):\r\n\t\tmx_lv_pos = i\r\nwg = [len(d_all[i]) if i != mx_lv_pos else 0 for i in range(mx)]\r\n\r\nun = sorted(list(set(wg)))[1:]\r\npos = {}\r\nfor i in range(len(un)):\r\n\tpos[un[i]] = i\r\nvals = [[] for i in range(len(un))]\r\nfor i in range(len(wg)):\r\n\tif wg[i] != 0:\r\n\t\tvals[pos[wg[i]]].append(i)\r\n\r\nlst = [[-1, -1] for i in range(n + 1)]\r\ndp = [[False for j in range(n + 1)] for i in range(2)]\r\ndp[0][0] = True\r\n\r\nl = len(un)\r\nfor ii in range(l):\r\n\ti = ii & 1\r\n\tni = i ^ 1\r\n\tdp[ni] = [False for j in range(n + 1)]\r\n\tlst_tk = [-1 for j in range(un[ii])]\r\n\tfor j in range(n + 1):\r\n\t\trm = j % un[ii]\r\n\t\tif dp[i][j]:\r\n\t\t\tlst_tk[rm] = j\r\n\t\t\tdp[ni][j] = True\r\n\t\telif lst_tk[rm] >= 0 and (j - lst_tk[rm]) // un[ii] <= len(vals[ii]):\r\n\t\t\tdp[ni][j] = True\r\n\t\t\tlst[j] = [lst_tk[rm], ii]\r\ndp = dp[l & 1]\r\nans = mx\r\nres = -1\r\nif dp[a]:\r\n\tres = a\r\nelif a - len(d_all[mx_lv_pos]) >= 0 and dp[a - len(d_all[mx_lv_pos])]:\r\n\tres = a - len(d_all[mx_lv_pos])\r\nelse:\r\n\tfor i in range(a + 1):\r\n\t\tif dp[i] and ((len(d_nlv[mx_lv_pos]) <= a - i <= len(d_all[mx_lv_pos])) or (0 <= a - i <= len(d_lv[mx_lv_pos]))):\r\n\t\t\tres = i\r\n\t\t\tbreak\r\n\tans += 1\r\ncur = res\r\nfin = set()\r\nwhile cur > 0:\r\n\tp = lst[cur][0]\r\n\tx = lst[cur][1]\r\n\twhile cur > p:\r\n\t\tfin.add(vals[x].pop())\r\n\t\tcur -= un[x]\r\ns = [1 for i in range(n)]\r\na -= res\r\n\r\nfor i in range(mx + 1):\r\n\tif i in fin:\r\n\t\tfor v in d_all[i]:\r\n\t\t\ts[v] = 0\r\n\tif i == mx_lv_pos:\r\n\t\tif a == len(d_all[i]):\r\n\t\t\tfor v in d_all[i]:\r\n\t\t\t\ts[v] = 0\r\n\t\t\ta -= len(d_nlv[i])\r\n\t\telif a != 0 and len(d_nlv[i]) <= a <= len(d_all[i]):\r\n\t\t\ta -= len(d_nlv[i])\r\n\t\t\tfor v in d_nlv[i]:\r\n\t\t\t\ts[v] = 0\r\n\t\tfor _ in range(a):\r\n\t\t\ts[d_lv[i].pop()] = 0\r\nprint(ans)\r\nprint(\"\".join([\"ab\"[x] for x in s]))",
    "prob_desc_created_at": "1612535700",
    "tags": [
        "dp",
        "greedy",
        "trees"
    ],
    "hidden_unit_tests": ""
}
{
    "prob_desc_time_limit": "1 second",
    "prob_desc_sample_outputs": "[\"1\", \"0\"]",
    "src_uid": "a34f2aa89fe0e78b495b20400d73acf1",
    "prob_desc_notes": "NoteThe first test case corresponds to the tree shown in the statement. As we have seen before, we can transform the tree into a star with center at vertex $$$5$$$ by applying a single operation to vertices $$$2$$$, $$$4$$$, and $$$5$$$.In the second test case, the given tree is already a star with the center at vertex $$$4$$$, so no operations have to be performed.",
    "prob_desc_description": "You are given a tree with $$$n$$$ vertices. You are allowed to modify the structure of the tree through the following multi-step operation:  Choose three vertices $$$a$$$, $$$b$$$, and $$$c$$$ such that $$$b$$$ is adjacent to both $$$a$$$ and $$$c$$$.  For every vertex $$$d$$$ other than $$$b$$$ that is adjacent to $$$a$$$, remove the edge connecting $$$d$$$ and $$$a$$$ and add the edge connecting $$$d$$$ and $$$c$$$.  Delete the edge connecting $$$a$$$ and $$$b$$$ and add the edge connecting $$$a$$$ and $$$c$$$. As an example, consider the following tree:  The following diagram illustrates the sequence of steps that happen when we apply an operation to vertices $$$2$$$, $$$4$$$, and $$$5$$$:  It can be proven that after each operation, the resulting graph is still a tree.Find the minimum number of operations that must be performed to transform the tree into a star. A star is a tree with one vertex of degree $$$n - 1$$$, called its center, and $$$n - 1$$$ vertices of degree $$$1$$$.",
    "prob_desc_output_spec": "Print a single integer  — the minimum number of operations needed to transform the tree into a star. It can be proven that under the given constraints, it is always possible to transform the tree into a star using at most $$$10^{18}$$$ operations.",
    "prob_desc_input_spec": "The first line contains an integer $$$n$$$ ($$$3 \\le n \\le 2 \\cdot 10^5$$$)  — the number of vertices in the tree. The $$$i$$$-th of the following $$$n - 1$$$ lines contains two integers $$$u_i$$$ and $$$v_i$$$ ($$$1 \\le u_i, v_i \\le n$$$, $$$u_i \\neq v_i$$$) denoting that there exists an edge connecting vertices $$$u_i$$$ and $$$v_i$$$. It is guaranteed that the given edges form a tree.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3",
    "lang_cluster": "Python",
    "difficulty": 2800,
    "file_name": "train_005.jsonl",
    "code_uid": "62ef7edca328924e63757b39c5d42156",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"6\\n4 5\\n2 6\\n3 2\\n1 2\\n2 4\", \"4\\n2 4\\n4 1\\n3 4\"]",
    "exec_outcome": "PASSED",
    "source_code": "import sys\nfrom collections import defaultdict\n\n\ndef rl(): return sys.stdin.readline().strip()\n\ndef BFS(s,nbrs):\n    level = defaultdict(int)\n    ind = 0\n    level[ind] += 1\n    frontier = [s]\n    visited = {s}\n    while frontier:\n        next = []\n        ind += 1\n        for u in frontier:\n            for v in nbrs[u]:\n                if v not in visited:\n                    next.append(v)\n                    visited.add(v)\n                    level[ind] += 1\n        frontier = next\n    return level\n\n\nn = int(rl())\nvert = []\nnbrs = defaultdict(list)\nfor i in range(n-1):\n    vert.append(list(map(int,rl().split())))\n    j = vert[-1][0]\n    k = vert[-1][1]\n    nbrs[j].append(k)\n    nbrs[k].append(j)\nnew = 0\ncounter = BFS(1,nbrs)\nfor i in range(2,n-1,2):\n    new += counter[i]\nans = min(n-2-new,new)\nprint(ans)\n",
    "prob_desc_created_at": "1593873900",
    "tags": [
        "graphs",
        "constructive algorithms",
        "graph matchings",
        "dfs and similar",
        "trees",
        "brute force"
    ],
    "hidden_unit_tests": ""
}
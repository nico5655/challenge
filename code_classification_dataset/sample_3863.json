{
    "prob_desc_time_limit": "1 second",
    "prob_desc_sample_outputs": "[\"ALICE\\nBOB\\nALICE\"]",
    "src_uid": "aef15a076b04e510e663a41341c8d156",
    "prob_desc_notes": "NoteIn the first test case of example,   in the $$$1$$$-st move, Alice will use the $$$2$$$-nd operation to reverse the string, since doing the $$$1$$$-st operation will result in her loss anyway. This also forces Bob to use the $$$1$$$-st operation.  in the $$$2$$$-nd move, Bob has to perform the $$$1$$$-st operation, since the $$$2$$$-nd operation cannot be performed twice in a row. All characters of the string are '1', game over.  Alice spends $$$0$$$ dollars while Bob spends $$$1$$$ dollar. Hence, Alice wins.In the second test case of example,   in the $$$1$$$-st move Alice has to perform the $$$1$$$-st operation, since the string is currently a palindrome.  in the $$$2$$$-nd move Bob reverses the string.  in the $$$3$$$-rd move Alice again has to perform the $$$1$$$-st operation. All characters of the string are '1', game over.  Alice spends $$$2$$$ dollars while Bob spends $$$0$$$ dollars. Hence, Bob wins.",
    "prob_desc_description": "The only difference between the easy and hard versions is that the given string $$$s$$$ in the easy version is initially a palindrome, this condition is not always true for the hard version.A palindrome is a string that reads the same left to right and right to left. For example, \"101101\" is a palindrome, while \"0101\" is not.Alice and Bob are playing a game on a string $$$s$$$ of length $$$n$$$ consisting of the characters '0' and '1'. Both players take alternate turns with Alice going first.In each turn, the player can perform one of the following operations:   Choose any $$$i$$$ ($$$1 \\le i \\le n$$$), where $$$s[i] =$$$ '0' and change $$$s[i]$$$ to '1'. Pay 1 dollar.  Reverse the whole string, pay 0 dollars. This operation is only allowed if the string is currently not a palindrome, and the last operation was not reverse. That is, if Alice reverses the string, then Bob can't reverse in the next move, and vice versa. Reversing a string means reordering its letters from the last to the first. For example, \"01001\" becomes \"10010\" after reversing.The game ends when every character of string becomes '1'. The player who spends minimum dollars till this point wins the game and it is a draw if both spend equal dollars. If both players play optimally, output whether Alice wins, Bob wins, or if it is a draw.",
    "prob_desc_output_spec": "For each test case print a single word in a new line:    \"ALICE\", if Alice will win the game,  \"BOB\", if Bob will win the game,  \"DRAW\", if the game ends in a draw. ",
    "prob_desc_input_spec": "The first line contains a single integer $$$t$$$ ($$$1 \\le t \\le 10^3$$$). Then $$$t$$$ test cases follow. The first line of each test case contains a single integer $$$n$$$ ($$$1 \\le n \\le 10^3$$$). The second line of each test case contains the string $$$s$$$ of length $$$n$$$, consisting of the characters '0' and '1'. It is guaranteed that the string $$$s$$$ contains at least one '0'. Note that there is no limit on the sum of $$$n$$$ over test cases.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3-64",
    "lang_cluster": "Python",
    "difficulty": 1900,
    "file_name": "train_085.jsonl",
    "code_uid": "91c8c89dec2af98e5131378a2c031d29",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"3\\n3\\n110\\n2\\n00\\n4\\n1010\"]",
    "exec_outcome": "PASSED",
    "source_code": "import os,sys\r\nfrom random import randint\r\nfrom io import BytesIO, IOBase\r\n\r\nfrom collections import defaultdict,deque,Counter\r\nfrom bisect import bisect_left,bisect_right\r\nfrom heapq import heappush,heappop\r\nfrom functools import lru_cache\r\nfrom itertools import accumulate\r\nimport math\r\n\r\n# Fast IO Region\r\nBUFSIZE = 8192\r\nclass FastIO(IOBase):\r\n    newlines = 0\r\n    def __init__(self, file):\r\n        self._fd = file.fileno()\r\n        self.buffer = BytesIO()\r\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\r\n        self.write = self.buffer.write if self.writable else None\r\n    def read(self):\r\n        while True:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            if not b:\r\n                break\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines = 0\r\n        return self.buffer.read()\r\n    def readline(self):\r\n        while self.newlines == 0:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            self.newlines = b.count(b\"\\n\") + (not b)\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines -= 1\r\n        return self.buffer.readline()\r\n    def flush(self):\r\n        if self.writable:\r\n            os.write(self._fd, self.buffer.getvalue())\r\n            self.buffer.truncate(0), self.buffer.seek(0)\r\nclass IOWrapper(IOBase):\r\n    def __init__(self, file):\r\n        self.buffer = FastIO(file)\r\n        self.flush = self.buffer.flush\r\n        self.writable = self.buffer.writable\r\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\r\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\r\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\r\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\r\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\r\n\r\n\r\n# for _ in range(int(input())):\r\n#     n = int(input())\r\n#     a = list(map(int, input().split()))\r\n\r\n# for _ in range(int(input())):\r\n#     n = int(input())\r\n#     l = len(str(bin(n)[2:]))\r\n#     print(pow(2, l - 1) - 1)\r\n\r\n# for _ in range(int(input())):\r\n#     n = int(input())\r\n#     s = input()\r\n#     cnt = s.count('0')\r\n#     if cnt == 1 or cnt % 2 == 0:\r\n#         print('BOB')\r\n#     else:\r\n#         print('ALICE')\r\n\r\nfor _ in range(int(input())):\r\n    n = int(input())\r\n    s = input()\r\n    cnt = cntp = 0\r\n    for i in range(n // 2):\r\n        if s[i] == '1' and s[n - 1 - i] == '0':\r\n            cnt += 1\r\n        elif s[i] == '0' and s[n - 1 - i] == '1':\r\n            cnt += 1\r\n        elif s[i] == s[n - 1 - i] == '0':\r\n            cntp += 2\r\n    \r\n    if cnt == 0:\r\n        cnt = s.count('0')\r\n        if cnt == 1 or cnt % 2 == 0:\r\n            print('BOB')\r\n        else:\r\n            print('ALICE')\r\n    else:\r\n        if n % 2 == 0 or (n % 2 and s[n // 2] == '1'):\r\n            print('ALICE')\r\n        else:\r\n            if cnt == 1 and cntp == 0:\r\n                print('DRAW')\r\n            else:\r\n                print('ALICE')\r\n            \r\n",
    "prob_desc_created_at": "1621521300",
    "tags": [
        "constructive algorithms",
        "games"
    ],
    "hidden_unit_tests": ""
}
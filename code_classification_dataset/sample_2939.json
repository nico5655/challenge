{
    "prob_desc_time_limit": "3 seconds",
    "prob_desc_sample_outputs": "[\"5\\n7\\n7\\n5\\n4\\n8\\n49\", \"3\\n2\\n1\\n0\\n0\\n0\\n0\\n0\\n499999999\"]",
    "src_uid": "ef6535b1788c59146d5782041188920d",
    "prob_desc_notes": "NoteConsider the first example.Initially, the set of piles is $$$[1, 2, 6, 8, 10]$$$. The answer before the first query is $$$5$$$ because you can move all piles from $$$1$$$ to $$$2$$$ with one move, all piles from $$$10$$$ to $$$8$$$ with $$$2$$$ moves and all piles from $$$6$$$ to $$$8$$$ with $$$2$$$ moves.After the first query, the set becomes $$$[1, 2, 4, 6, 8, 10]$$$. Then the answer is $$$7$$$ because you can move all piles from $$$6$$$ to $$$4$$$ with $$$2$$$ moves, all piles from $$$4$$$ to $$$2$$$ with $$$2$$$ moves, all piles from $$$2$$$ to $$$1$$$ with $$$1$$$ move and all piles from $$$10$$$ to $$$8$$$ with $$$2$$$ moves.After the second query, the set of piles becomes $$$[1, 2, 4, 6, 8, 9, 10]$$$ and the answer is the same (and the previous sequence of moves can be applied to the current set of piles).After the third query, the set of piles becomes $$$[1, 2, 4, 8, 9, 10]$$$ and the answer is $$$5$$$ because you can move all piles from $$$1$$$ to $$$2$$$ with $$$1$$$ move, all piles from $$$2$$$ to $$$4$$$ with $$$2$$$ moves, all piles from $$$10$$$ to $$$9$$$ with $$$1$$$ move and all piles from $$$9$$$ to $$$8$$$ with $$$1$$$ move.After the fourth query, the set becomes $$$[1, 2, 4, 8, 9]$$$ and the answer is almost the same (the previous sequence of moves can be applied without moving piles from $$$10$$$).After the fifth query, the set becomes $$$[1, 2, 4, 8, 9, 100]$$$. You can move all piles from $$$1$$$ and further to $$$9$$$ and keep $$$100$$$ at its place. So the answer is $$$8$$$.After the sixth query, the set becomes $$$[1, 2, 4, 8, 9, 50, 100]$$$. The answer is $$$49$$$ and can be obtained with almost the same sequence of moves as after the previous query. The only difference is that you need to move all piles from $$$50$$$ to $$$9$$$ too.",
    "prob_desc_description": "Vova decided to clean his room. The room can be represented as the coordinate axis $$$OX$$$. There are $$$n$$$ piles of trash in the room, coordinate of the $$$i$$$-th pile is the integer $$$p_i$$$. All piles have different coordinates.Let's define a total cleanup as the following process. The goal of this process is to collect all the piles in no more than two different $$$x$$$ coordinates. To achieve this goal, Vova can do several (possibly, zero) moves. During one move, he can choose some $$$x$$$ and move all piles from $$$x$$$ to $$$x+1$$$ or $$$x-1$$$ using his broom. Note that he can't choose how many piles he will move.Also, there are two types of queries:  $$$0$$$ $$$x$$$ — remove a pile of trash from the coordinate $$$x$$$. It is guaranteed that there is a pile in the coordinate $$$x$$$ at this moment.  $$$1$$$ $$$x$$$ — add a pile of trash to the coordinate $$$x$$$. It is guaranteed that there is no pile in the coordinate $$$x$$$ at this moment. Note that it is possible that there are zero piles of trash in the room at some moment.Vova wants to know the minimum number of moves he can spend if he wants to do a total cleanup before any queries. He also wants to know this number of moves after applying each query. Queries are applied in the given order. Note that the total cleanup doesn't actually happen and doesn't change the state of piles. It is only used to calculate the number of moves.For better understanding, please read the Notes section below to see an explanation for the first example.",
    "prob_desc_output_spec": "Print $$$q+1$$$ integers: the minimum number of moves Vova needs to do a total cleanup before the first query and after each of $$$q$$$ queries.",
    "prob_desc_input_spec": "The first line of the input contains two integers $$$n$$$ and $$$q$$$ ($$$1 \\le n, q \\le 10^5$$$) — the number of piles in the room before all queries and the number of queries, respectively. The second line of the input contains $$$n$$$ distinct integers $$$p_1, p_2, \\dots, p_n$$$ ($$$1 \\le p_i \\le 10^9$$$), where $$$p_i$$$ is the coordinate of the $$$i$$$-th pile. The next $$$q$$$ lines describe queries. The $$$i$$$-th query is described with two integers $$$t_i$$$ and $$$x_i$$$ ($$$0 \\le t_i \\le 1; 1 \\le x_i \\le 10^9$$$), where $$$t_i$$$ is $$$0$$$ if you need to remove a pile from the coordinate $$$x_i$$$ and is $$$1$$$ if you need to add a pile to the coordinate $$$x_i$$$. It is guaranteed that for $$$t_i = 0$$$ there is such pile in the current set of piles and for $$$t_i = 1$$$ there is no such pile in the current set of piles.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 2",
    "lang_cluster": "Python",
    "difficulty": 2100,
    "file_name": "train_036.jsonl",
    "code_uid": "d86a61c033e3c271088b5d24d24b0139",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"5 6\\n1 2 6 8 10\\n1 4\\n1 9\\n0 6\\n0 10\\n1 100\\n1 50\", \"5 8\\n5 1 2 4 3\\n0 1\\n0 2\\n0 3\\n0 4\\n0 5\\n1 1000000000\\n1 1\\n1 500000000\"]",
    "exec_outcome": "PASSED",
    "source_code": "from __future__ import print_function, division\nfrom sys import stdin, stdout\nimport operator as op\nfrom bisect import *\nfrom itertools import chain, repeat, starmap\nfrom functools import reduce\n\n\nclass SortedList():\n    \"\"\"Sorted list is a sorted mutable sequence.\"\"\"\n    DEFAULT_LOAD_FACTOR = 1000\n\n    def __init__(self, iterable=None):\n        \"\"\"Initialize sorted list instance.\"\"\"\n        self._len = 0\n        self._load = self.DEFAULT_LOAD_FACTOR\n        self._lists = []\n        self._maxes = []\n        self._index = []\n        self._offset = 0\n        if iterable is not None:\n            self.update(iterable)\n\n    def clear(self):\n        \"\"\"Remove all values from sorted list.\"\"\"\n        self._len = 0\n        del self._lists[:]\n        del self._maxes[:]\n        del self._index[:]\n        self._offset = 0\n\n    def add(self, value):\n        \"\"\"Add `value` to sorted list.\"\"\"\n        _lists = self._lists\n        _maxes = self._maxes\n        if _maxes:\n            pos = bisect_right(_maxes, value)\n            if pos == len(_maxes):\n                _lists[pos - 1].append(value)\n                _maxes[pos - 1] = value\n            else:\n                insort(_lists[pos], value)\n            self._expand(pos)\n        else:\n            _lists.append([value])\n            _maxes.append(value)\n        self._len += 1\n\n    def _expand(self, pos):\n        \"\"\"Split sublists with length greater than double the load-factor.\"\"\"\n        _load = self._load\n        _lists = self._lists\n        _index = self._index\n\n        if len(_lists[pos]) > (_load << 1):\n            _maxes = self._maxes\n            _lists_pos = _lists[pos]\n            half = _lists_pos[_load:]\n            del _lists_pos[_load:]\n            _maxes[pos] = _lists_pos[-1]\n            _lists.insert(pos + 1, half)\n            _maxes.insert(pos + 1, half[-1])\n            del _index[:]\n        else:\n            if _index:\n                child = self._offset + pos\n                while child:\n                    _index[child] += 1\n                    child = (child - 1) >> 1\n                _index[0] += 1\n\n    def update(self, iterable):\n        \"\"\"Update sorted list by adding all values from `iterable`.\"\"\"\n        _lists = self._lists\n        _maxes = self._maxes\n        values = sorted(iterable)\n\n        if _maxes:\n            if len(values) * 4 >= self._len:\n                values.extend(chain.from_iterable(_lists))\n                values.sort()\n                self.clear()\n            else:\n                _add = self.add\n                for val in values:\n                    _add(val)\n                return\n\n        _load = self._load\n        _lists.extend(values[pos:(pos + _load)] for pos in range(0, len(values), _load))\n        _maxes.extend(sublist[-1] for sublist in _lists)\n        self._len = len(values)\n        del self._index[:]\n\n    def __contains__(self, value):\n        \"\"\"Return true if `value` is an element of the sorted list.\"\"\"\n        _maxes = self._maxes\n        pos = bisect_left(_maxes, value)\n        if pos == len(_maxes):\n            return False\n\n        _lists = self._lists\n        idx = bisect_left(_lists[pos], value)\n        return _lists[pos][idx] == value\n\n    def remove(self, value):\n        \"\"\"Remove `value` from sorted list if it is a member.\"\"\"\n        _maxes = self._maxes\n        pos = bisect_left(_maxes, value)\n        if pos == len(_maxes):\n            return\n\n        _lists = self._lists\n        idx = bisect_left(_lists[pos], value)\n        if _lists[pos][idx] == value:\n            self._delete(pos, idx)\n\n    def _delete(self, pos, idx):\n        \"\"\"Delete value at the given `(pos, idx)`.\"\"\"\n        _lists = self._lists\n        _maxes = self._maxes\n        _index = self._index\n\n        _lists_pos = _lists[pos]\n        del _lists_pos[idx]\n        self._len -= 1\n\n        len_lists_pos = len(_lists_pos)\n        if len_lists_pos > (self._load >> 1):\n            _maxes[pos] = _lists_pos[-1]\n\n            if _index:\n                child = self._offset + pos\n                while child > 0:\n                    _index[child] -= 1\n                    child = (child - 1) >> 1\n                _index[0] -= 1\n        elif len(_lists) > 1:\n            if not pos:\n                pos += 1\n            prev = pos - 1\n            _lists[prev].extend(_lists[pos])\n            _maxes[prev] = _lists[prev][-1]\n            del _lists[pos]\n            del _maxes[pos]\n            del _index[:]\n            self._expand(prev)\n        elif len_lists_pos:\n            _maxes[pos] = _lists_pos[-1]\n        else:\n            del _lists[pos]\n            del _maxes[pos]\n            del _index[:]\n\n    def _loc(self, pos, idx):\n        \"\"\"Convert an index pair (lists index, sublist index) into a single\n        index number that corresponds to the position of the value in the\n        sorted list.\"\"\"\n        if not pos:\n            return idx\n\n        _index = self._index\n        if not _index:\n            self._build_index()\n        total = 0\n        pos += self._offset\n        while pos:\n            if not pos & 1:\n                total += _index[pos - 1]\n            pos = (pos - 1) >> 1\n        return total + idx\n\n    def _pos(self, idx):\n        \"\"\"Convert an index into an index pair (lists index, sublist index)\n        that can be used to access the corresponding lists position.\"\"\"\n        if idx < 0:\n            last_len = len(self._lists[-1])\n            if (-idx) <= last_len:\n                return len(self._lists) - 1, last_len + idx\n            idx += self._len\n            if idx < 0:\n                raise IndexError('list index out of range')\n        elif idx >= self._len:\n            raise IndexError('list index out of range')\n\n        if idx < len(self._lists[0]):\n            return 0, idx\n\n        _index = self._index\n        if not _index:\n            self._build_index()\n\n        pos = 0\n        child = 1\n        len_index = len(_index)\n        while child < len_index:\n            index_child = _index[child]\n            if idx < index_child:\n                pos = child\n            else:\n                idx -= index_child\n                pos = child + 1\n            child = (pos << 1) + 1\n        return (pos - self._offset, idx)\n\n    def _build_index(self):\n        \"\"\"Build a positional index for indexing the sorted list.\"\"\"\n        row0 = list(map(len, self._lists))\n        if len(row0) == 1:\n            self._index[:] = row0\n            self._offset = 0\n            return\n\n        head = iter(row0)\n        tail = iter(head)\n        row1 = list(starmap(op.add, zip(head, tail)))\n        if len(row0) & 1:\n            row1.append(row0[-1])\n        if len(row1) == 1:\n            self._index[:] = row1 + row0\n            self._offset = 1\n            return\n\n        size = 1 << (len(row1) - 1).bit_length()\n        row1.extend(repeat(0, size - len(row1)))\n        tree = [row0, row1]\n        while len(tree[-1]) > 1:\n            head = iter(tree[-1])\n            tail = iter(head)\n            row = list(starmap(op.add, zip(head, tail)))\n            tree.append(row)\n        reduce(list.__iadd__, reversed(tree), self._index)\n        self._offset = size * 2 - 1\n\n    def __delitem__(self, index):\n        \"\"\"Remove value at `index` from sorted list.\"\"\"\n        if isinstance(index, slice):\n            start, stop, step = index.indices(self._len)\n            if step == 1 and start < stop:\n                if start == 0 and stop == self._len:\n                    return self.clear()\n                elif self._len <= 8 * (stop - start):\n                    values = self.__getitem__(slice(None, start))\n                    if stop < self._len:\n                        values += self.__getitem__(slice(stop, None))\n                    self.clear()\n                    return self.update(values)\n\n            indices = range(start, stop, step)\n            if step > 0:\n                indices = reversed(indices)\n            _pos, _delete = self._pos, self._delete\n            for index in indices:\n                pos, idx = _pos(index)\n                _delete(pos, idx)\n        else:\n            pos, idx = self._pos(index)\n            self._delete(pos, idx)\n\n    def __getitem__(self, index):\n        \"\"\"Lookup value at `index` in sorted list.\"\"\"\n        _lists = self._lists\n\n        if isinstance(index, slice):\n            start, stop, step = index.indices(self._len)\n\n            if step == 1 and start < stop:\n                if start == 0 and stop == self._len:\n                    return reduce(list.__iadd__, self._lists, [])\n\n                start_pos, start_idx = self._pos(start)\n                if stop == self._len:\n                    stop_pos = len(_lists) - 1\n                    stop_idx = len(_lists[stop_pos])\n                else:\n                    stop_pos, stop_idx = self._pos(stop)\n                if start_pos == stop_pos:\n                    return _lists[start_pos][start_idx:stop_idx]\n\n                prefix = _lists[start_pos][start_idx:]\n                middle = _lists[(start_pos + 1):stop_pos]\n                result = reduce(list.__iadd__, middle, prefix)\n                result += _lists[stop_pos][:stop_idx]\n                return result\n\n            if step == -1 and start > stop:\n                result = self.__getitem__(slice(stop + 1, start + 1))\n                result.reverse()\n                return result\n\n            indices = range(start, stop, step)\n            return list(self.__getitem__(index) for index in indices)\n        else:\n            if self._len:\n                if index == 0:\n                    return _lists[0][0]\n                elif index == -1:\n                    return _lists[-1][-1]\n            else:\n                raise IndexError('list index out of range')\n\n            if 0 <= index < len(_lists[0]):\n                return _lists[0][index]\n\n            len_last = len(_lists[-1])\n            if -len_last < index < 0:\n                return _lists[-1][len_last + index]\n\n            pos, idx = self._pos(index)\n            return _lists[pos][idx]\n\n    def __iter__(self):\n        \"\"\"Return an iterator over the sorted list.\"\"\"\n        return chain.from_iterable(self._lists)\n\n    def __reversed__(self):\n        \"\"\"Return a reverse iterator over the sorted list.\"\"\"\n        return chain.from_iterable(map(reversed, reversed(self._lists)))\n\n    def __len__(self):\n        \"\"\"Return the size of the sorted list.\"\"\"\n        return self._len\n\n    def bisect_left(self, value):\n        \"\"\"Return an index to insert `value` in the sorted list.\"\"\"\n        pos = bisect_left(self._maxes, value)\n        return self._len if pos == len(self._maxes) else self._loc(pos, bisect_left(self._lists[pos], value))\n\n    def bisect_right(self, value):\n        \"\"\"Return an index to insert `value` in the sorted list.\"\"\"\n        pos = bisect_right(self._maxes, value)\n        return self._len if pos == len(self._maxes) else self._loc(pos, bisect_right(self._lists[pos], value))\n\n    bisect = bisect_right\n\n    def count(self, value):\n        \"\"\"Return number of occurrences of `value` in the sorted list.\"\"\"\n        _maxes = self._maxes\n        if not _maxes:\n            return 0\n\n        pos_left = bisect_left(_maxes, value)\n        if pos_left == len(_maxes):\n            return 0\n\n        _lists = self._lists\n        idx_left = bisect_left(_lists[pos_left], value)\n        pos_right = bisect_right(_maxes, value)\n        if pos_right == len(_maxes):\n            return self._len - self._loc(pos_left, idx_left)\n\n        idx_right = bisect_right(_lists[pos_right], value)\n        if pos_left == pos_right:\n            return idx_right - idx_left\n\n        right = self._loc(pos_right, idx_right)\n        left = self._loc(pos_left, idx_left)\n        return right - left\n\n    def copy(self):\n        \"\"\"Return a shallow copy of the sorted list.\"\"\"\n        return self.__class__(self)\n\n    __copy__ = copy\n\n    def pop(self, index=-1):\n        \"\"\"Remove and return value at `index` in sorted list.\"\"\"\n        if not self._len:\n            raise IndexError('pop index out of range')\n\n        _lists = self._lists\n        if 0 <= index < len(_lists[0]):\n            val = _lists[0][index]\n            self._delete(0, index)\n            return val\n\n        len_last = len(_lists[-1])\n        if -len_last < index < 0:\n            pos = len(_lists) - 1\n            loc = len_last + index\n            val = _lists[pos][loc]\n            self._delete(pos, loc)\n            return val\n\n        pos, idx = self._pos(index)\n        val = _lists[pos][idx]\n        self._delete(pos, idx)\n        return val\n\n    def index(self, value, start=0, stop=None):\n        \"\"\"Return first index of value in sorted list.\"\"\"\n        _len = self._len\n        if start < 0:\n            start += _len\n        if start < 0:\n            start = 0\n        if stop is None:\n            stop = _len\n        if stop < 0:\n            stop += _len\n        if stop > _len:\n            stop = _len\n\n        if stop <= start:\n            raise ValueError('{0!r} is not in list'.format(value))\n\n        _maxes = self._maxes\n        pos_left = bisect_left(_maxes, value)\n        if pos_left == len(_maxes):\n            raise ValueError('{0!r} is not in list'.format(value))\n\n        _lists = self._lists\n        idx_left = bisect_left(_lists[pos_left], value)\n        if _lists[pos_left][idx_left] != value:\n            raise ValueError('{0!r} is not in list'.format(value))\n\n        stop -= 1\n        left = self._loc(pos_left, idx_left)\n        if start <= left:\n            if left <= stop:\n                return left\n        else:\n            if start <= self.bisect_right(value) - 1:\n                return start\n        raise ValueError('{0!r} is not in list'.format(value))\n\n    def __add__(self, other):\n        \"\"\"Return new sorted list containing all values in both sequences.\"\"\"\n        values = reduce(list.__iadd__, self._lists, [])\n        values.extend(other)\n        return self.__class__(values)\n\n    __radd__ = __add__\n\n    def __iadd__(self, other):\n        \"\"\"Update sorted list with values from `other`.\"\"\"\n        self.update(other)\n        return self\n\n    def __mul__(self, num):\n        \"\"\"Return new sorted list with `num` shallow copies of values.\"\"\"\n        values = reduce(list.__iadd__, self._lists, []) * num\n        return self.__class__(values)\n\n    __rmul__ = __mul__\n\n    def __imul__(self, num):\n        \"\"\"Update the sorted list with `num` shallow copies of values.\"\"\"\n        values = reduce(list.__iadd__, self._lists, []) * num\n        self.clear()\n        self.update(values)\n        return self\n\n    def __make_cmp(seq_op):\n        \"Make comparator method.\"\n\n        def comparer(self, other):\n            \"Compare method for sorted list and sequence.\"\n            self_len = self._len\n            len_other = len(other)\n            if self_len != len_other:\n                if seq_op is op.eq:\n                    return False\n                if seq_op is op.ne:\n                    return True\n\n            for alpha, beta in zip(self, other):\n                if alpha != beta:\n                    return seq_op(alpha, beta)\n            return seq_op(self_len, len_other)\n\n        comparer.__name__ = '__{0}__'.format(seq_op.__name__)\n        return comparer\n\n    __eq__ = __make_cmp(op.eq)\n    __ne__ = __make_cmp(op.ne)\n    __lt__ = __make_cmp(op.lt)\n    __gt__ = __make_cmp(op.gt)\n    __le__ = __make_cmp(op.le)\n    __ge__ = __make_cmp(op.ge)\n    __make_cmp = staticmethod(__make_cmp)\n\n    def __repr__(self):\n        \"\"\"Return string representation of sorted list.\"\"\"\n        return 'SortedList({0})'.format(reduce(list.__iadd__, self._lists, []))\n\n\ndef fast2():\n    import os, sys, atexit\n    from cStringIO import StringIO as BytesIO\n    # range = xrange\n    sys.stdout = BytesIO()\n    atexit.register(lambda: os.write(1, sys.stdout.getvalue()))\n    return BytesIO(os.read(0, os.fstat(0).st_size)).readline\n\n\ninput = fast2()\nrints = lambda: [int(x) for x in input().split()]\nrints_2d = lambda n: [rints() for _ in range(n)]\npr = lambda args, sep: stdout.write(sep.join(map(str, args)) + '\\n')\nsolve = lambda: 0 if len(a) < 4 else a[-2] - a[0] - diff[-2]\nbound = lambda x: (bisect_left(a, x) - 1, bisect_right(a, x))\nout = []\n\nn, m = rints()\na, qur = SortedList(rints() + [10 ** 9 + 2]), rints_2d(m)\ndiff = SortedList([10 ** 9 + 2])\n\nfor i in range(n - 1):\n    diff.add(a[i + 1] - a[i])\n\nout.append(solve())\n\nfor x, y in qur:\n    lo, hi = bound(y)\n    if x:\n        if lo > -1:\n            diff.add(y - a[lo])\n        if hi != len(a) - 1:\n            diff.add(a[hi] - y)\n        if lo > -1 and hi != len(a) - 1:\n            diff.remove(a[hi] - a[lo])\n        a.add(y)\n    else:\n        if lo > -1:\n            diff.remove(y - a[lo])\n        if hi != len(a) - 1:\n            diff.remove(a[hi] - y)\n        if lo > -1 and hi != len(a) - 1:\n            diff.add(a[hi] - a[lo])\n        a.remove(y)\n\n    out.append(solve())\npr(out, '\\n')\n",
    "prob_desc_created_at": "1600094100",
    "tags": [
        "data structures",
        "implementation"
    ],
    "hidden_unit_tests": ""
}
{
    "prob_desc_time_limit": "4 seconds",
    "prob_desc_sample_outputs": "[\"0 1 1 1 1 0 1 1\"]",
    "src_uid": "2dcc82e6abc733a9c4567742294184dc",
    "prob_desc_notes": null,
    "prob_desc_description": "You are given a tree consisting of $$$n$$$ vertices. Some of the vertices (at least two) are black, all the other vertices are white.You place a chip on one of the vertices of the tree, and then perform the following operations:  let the current vertex where the chip is located is $$$x$$$. You choose a black vertex $$$y$$$, and then move the chip along the first edge on the simple path from $$$x$$$ to $$$y$$$. You are not allowed to choose the same black vertex $$$y$$$ in two operations in a row (i. e., for every two consecutive operations, the chosen black vertex should be different).You end your operations when the chip moves to the black vertex (if it is initially placed in a black vertex, you don't perform the operations at all), or when the number of performed operations exceeds $$$100^{500}$$$.For every vertex $$$i$$$, you have to determine if there exists a (possibly empty) sequence of operations that moves the chip to some black vertex, if the chip is initially placed on the vertex $$$i$$$.",
    "prob_desc_output_spec": "Print $$$n$$$ integers. The $$$i$$$-th integer should be equal to $$$1$$$ if there exists a (possibly empty) sequence of operations that moves the chip to some black vertex if it is placed on the vertex $$$i$$$, and $$$0$$$ if no such sequence of operations exists.",
    "prob_desc_input_spec": "The first line contains one integer $$$n$$$ ($$$3 \\le n \\le 3 \\cdot 10^5$$$) — the number of vertices in the tree. The second line contains $$$n$$$ integers $$$c_1, c_2, \\dots, c_n$$$ ($$$0 \\le c_i \\le 1$$$), where $$$c_i = 0$$$ means that the $$$i$$$-th vertex is white, and $$$c_i = 1$$$ means that the $$$i$$$-th vertex is black. At least two values of $$$c_i$$$ are equal to $$$1$$$. Then $$$n-1$$$ lines follow, each of them contains two integers $$$u_i$$$ and $$$v_i$$$ ($$$1 \\le u_i, v_i \\le n$$$; $$$u_i \\ne v_i$$$) — the endpoints of some edge. These edges form a tree.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3-64",
    "lang_cluster": "Python",
    "difficulty": 2400,
    "file_name": "train_087.jsonl",
    "code_uid": "70d88734342c645f3bdcb74bad3c5d5b",
    "prob_desc_memory_limit": "512 megabytes",
    "prob_desc_sample_inputs": "[\"8\\n0 1 0 0 0 0 1 0\\n8 6\\n2 5\\n7 8\\n6 5\\n4 5\\n6 1\\n7 3\"]",
    "exec_outcome": "PASSED",
    "source_code": "from sys import stdin\r\ninp = stdin.readline\r\n\r\nn = int(inp())\r\n\r\nbow = [int(x) for x in inp().split()]\r\n\r\n# tree[nr][color, [connected]]\r\ntree = {i+1: [c, set()] for i, c in enumerate(bow)}\r\n\r\nfor i in range(n-1):\r\n    a, b = map(int, inp().split())\r\n    tree[a][1].add(b)\r\n    tree[b][1].add(a)\r\n\r\nblacks = []\r\nfor i in range(n):\r\n    if bow[i] == 1:\r\n        blacks.append(i+1)\r\n\r\nblacksDone = {c: set() for c in blacks}\r\n\r\nans = [0 for i in range(n)]\r\n\r\nfor start in blacks:\r\n\r\n    arr = [[start, set(tree[start][1]).difference(blacksDone[start])]]\r\n    layer = 0\r\n    blackNr = len(blacksDone[start])\r\n    branch = set()\r\n    branch2 = set()\r\n    blackBranch = False\r\n    blackLayer = -1\r\n\r\n    ans[start-1] = 1\r\n    for c in arr[0][1]:\r\n        ans[c-1] = 1\r\n\r\n    while True:\r\n        # counter\r\n        if len(arr[layer][1]) > 0:\r\n            current = arr[layer][1].pop()\r\n            arr.append([current, set(tree[current][1])])\r\n            arr[-1][1].discard(arr[layer][0])\r\n            layer += 1\r\n\r\n            if layer > blackLayer != -1:\r\n                branch2.add(current)\r\n            elif layer > 1:\r\n                branch.add(current)\r\n\r\n            if tree[current][0] == 1 and current != start:\r\n                if len(blacksDone[current]) >= 1:\r\n                    blackNr = 2\r\n                    break\r\n\r\n                if not blackBranch:\r\n                    blackNr += 1\r\n                    blackBranch = True\r\n                elif blackLayer > -1:\r\n                    blackNr = 2\r\n                    break\r\n\r\n                blackLayer = layer-1\r\n                blacksDone[current].add(arr[layer-1][0])\r\n                arr[layer-1][1] = set(tree[arr[layer-1][0]][1])\r\n                arr[layer-1][1].discard(arr[layer-2][0])\r\n                arr[layer-1][1].discard(current)\r\n                arr.pop()\r\n\r\n                ans[arr[layer-1][0]-1] = 1\r\n                layer -= 1\r\n\r\n        else:\r\n            layer -= 1\r\n\r\n            if layer == 1:\r\n                if not blackBranch:\r\n                    for c in branch:\r\n                        ans[c-1] = 1\r\n                else:\r\n                    blackBranch = False\r\n                branch = set()\r\n            elif layer == blackLayer:\r\n                for c in branch2:\r\n                    ans[c - 1] = 1\r\n                branch2 = set()\r\n\r\n            if layer < blackLayer:\r\n                blackLayer = -1\r\n\r\n            if layer == -1:\r\n                break\r\n\r\n            arr.pop()\r\n\r\n        if blackNr > 1:\r\n            break\r\n\r\n    if blackNr > 1:\r\n        break\r\n\r\nif blackNr > 1:\r\n    ans = [1]*n\r\n\r\nprint(*ans)\r\n\r\n",
    "prob_desc_created_at": "1642343700",
    "tags": [
        "dfs and similar",
        "greedy",
        "trees"
    ],
    "hidden_unit_tests": ""
}
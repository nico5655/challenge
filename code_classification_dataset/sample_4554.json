{
    "prob_desc_time_limit": "3 seconds",
    "prob_desc_sample_outputs": "[\"? 1 2 3\\n\\n? 3 4 5\\n\\n! 3 4 1 2\\n\\n? 7 1 9\\n\\n! 4 2 3 6 8\"]",
    "src_uid": "98c584b0479eb26d8b0307bd72fc48fd",
    "prob_desc_notes": "NoteExplanation for example interaction (note that this example only exists to demonstrate the interaction procedure and does not provide any hint for the solution):For the first test case:Question \"? 1 2 3\" returns $$$0$$$, so there are more impostors than crewmates among players $$$1$$$, $$$2$$$ and $$$3$$$.Question \"? 3 4 5\" returns $$$1$$$, so there are more crewmates than impostors among players $$$3$$$, $$$4$$$ and $$$5$$$.Outputting \"! 3 4 1 2\" means that one has found all the impostors, by some miracle. There are $$$k = 3$$$ impostors. The players who are impostors are players $$$4$$$, $$$1$$$ and $$$2$$$.For the second test case:Question \"? 7 1 9\" returns $$$1$$$, so there are more crewmates than impostors among players $$$7$$$, $$$1$$$ and $$$9$$$.Outputting \"! 4 2 3 6 8\" means that one has found all the impostors, by some miracle. There are $$$k = 4$$$ impostors. The players who are impostors are players $$$2$$$, $$$3$$$, $$$6$$$ and $$$8$$$.",
    "prob_desc_description": "This is an interactive problem. The only difference between the easy and hard version is the limit on number of questions.There are $$$n$$$ players labelled from $$$1$$$ to $$$n$$$. It is guaranteed that $$$n$$$ is a multiple of $$$3$$$.Among them, there are $$$k$$$ impostors and $$$n-k$$$ crewmates. The number of impostors, $$$k$$$, is not given to you. It is guaranteed that $$$\\frac{n}{3} &lt; k &lt; \\frac{2n}{3}$$$.In each question, you can choose three distinct integers $$$a$$$, $$$b$$$, $$$c$$$ ($$$1 \\le a, b, c \\le n$$$) and ask: \"Among the players labelled $$$a$$$, $$$b$$$ and $$$c$$$, are there more impostors or more crewmates?\" You will be given the integer $$$0$$$ if there are more impostors than crewmates, and $$$1$$$ otherwise.Find the number of impostors $$$k$$$ and the indices of players that are impostors after asking at most $$$n+6$$$ questions.The jury is adaptive, which means the indices of impostors may not be fixed beforehand and can depend on your questions. It is guaranteed that there is at least one set of impostors which fulfills the constraints and the answers to your questions at any time.",
    "prob_desc_output_spec": null,
    "prob_desc_input_spec": "Each test contains multiple test cases. The first line contains the number of test cases $$$t$$$ ($$$1 \\le t \\le 100$$$). Description of the test cases follows. The first and only line of each test case contains a single integer $$$n$$$ ($$$6 \\le n &lt; 10^4$$$, $$$n$$$ is a multiple of $$$3$$$) — the number of players. It is guaranteed that the sum of $$$n$$$ over all test cases does not exceed $$$2 \\cdot 10^4$$$.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "Python 3",
    "lang_cluster": "Python",
    "difficulty": 2400,
    "file_name": "train_100.jsonl",
    "code_uid": "a7cdcddaf4eef3765ca1223327e66c49",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"2\\n6\\n\\n0\\n\\n1\\n\\n9\\n\\n1\"]",
    "exec_outcome": "PASSED",
    "source_code": "def ask(a, b, c):\r\n    print(f'? {a} {b} {c}', flush=True)\r\n    s = input()\r\n    if s == '-1':\r\n        exit()\r\n    else:\r\n        return int(s)\r\n\r\nfor _ in range(int(input())):\r\n    n = int(input())\r\n    ans = [0]*n\r\n    fp = [0]*2\r\n    sp = [0]*2\r\n    tp = [0]*2\r\n    fop= [0]*2\r\n    fp[0]= ['0000', '0010', '0100', '1000', '0001', '0011', '0101', '1001' ]\r\n    fp[1] = ['1111', '1101', '1011', '0111', '1110', '1100', '1010', '0110']\r\n    sp[0] = ['0000', '0010', '0100', '0110', '0001', '0011', '1000', '1010']\r\n    sp[1] = ['1111', '1101', '1011', '1001', '1110', '1100', '0111', '0101']\r\n    tp[0] = ['0000', '1000', '0100', '1100', '0010', '1010', '0001', '1001']\r\n    tp[1] = ['1111', '0111', '1011', '0011', '1101', '0101', '1110', '0110']\r\n    fop[0] = ['0000', '0100', '1000', '1100', '0010', '0110', '0001', '0101']\r\n    fop[1] = ['1111', '1011', '0111', '0011', '1101', '1001', '1110', '1010']\r\n    m = ask(1, 2, 3)\r\n    for k in range(1,n//3):\r\n        i = 3*k\r\n        tmp = ask(i + 1, i + 2, i + 3)\r\n        if tmp!= m:\r\n            break\r\n    if tmp == 1:\r\n        r = tp[1]\r\n        j = 3*(k-1)\r\n        p = fp[ask(j + 1, i + 1, i + 2)]\r\n        q = sp[ask(j + 1, i + 1, i + 3)]\r\n        s = fop[ask(j + 1, i + 2, i + 3)]\r\n        x =  list(((set(p)&set(q)) & set(r)) & set(s))\r\n        if len(x) == 1:\r\n            ans[j] = '0'\r\n            ans[i:i+3] = list(x[0])[1:]\r\n            zeropos = j+1\r\n            onepos = i+ list(x[0]).index('1')\r\n        else:\r\n            p = fp[ask(j + 2, i + 1, i + 2)]\r\n            q = sp[ask(j + 2, i + 1, i + 3)]\r\n            s = fop[ask(j + 2, i + 2, i + 3)]\r\n            x = list(((set(p) & set(q)) & set(r)) & set(s))\r\n            if len(x) == 1:\r\n                ans[j+1] = '0'\r\n                ans[i:i + 3] = list(x[0])[1:]\r\n                zeropos = j + 2\r\n                onepos = i + list(x[0]).index('1')\r\n            else:\r\n                ans[i:i+3] = list('111')\r\n                onepos = i + 1\r\n                t = ask(j+1, j+2, onepos)\r\n                if  t== 0:\r\n                    ans[j] = '0'\r\n                    ans[j+1] = '0'\r\n                    zeropos = j+1\r\n                else:\r\n                    ans[j+2] = '0'\r\n                    zeropos = j+3\r\n        for z in range(j+1,j+4):\r\n            if z!= zeropos:\r\n                ans[z-1] = str(ask(z, zeropos, onepos))\r\n        for c in range(0,k-1):\r\n            d = 3*c\r\n            b = ask(d+1, d+2, onepos)\r\n            if b == 0:\r\n                ans[d] = '0'\r\n                ans[d+1] = '0'\r\n                ans[d+2] = str(ask(zeropos, d + 3, onepos))\r\n            else:\r\n                ans[d+2] = '0'\r\n                ans[d + 1] = str(ask(d + 2, zeropos, onepos))\r\n                ans[d] = str(1- int(ans[d+1]))\r\n    else:\r\n        r = tp[0]\r\n        j = 3 * (k - 1)\r\n        p = fp[ask(j + 1, i + 1, i + 2)]\r\n        q = sp[ask(j + 1, i + 1, i + 3)]\r\n        s = fop[ask(j + 1, i + 2, i + 3)]\r\n        x = list(((set(p) & set(q)) & set(r)) & set(s))\r\n        if len(x) == 1:\r\n            ans[j] = '1'\r\n            ans[i :i + 3] = list(x[0])[1:]\r\n            onepos = j + 1\r\n            zeropos = i  + list(x[0]).index('0')\r\n        else:\r\n            p = fp[ask(j + 2, i + 1, i + 2)]\r\n            q = sp[ask(j + 2, i + 1, i + 3)]\r\n            s = fop[ask(j + 2, i + 2, i + 3)]\r\n            x = list(((set(p) & set(q)) & set(r)) & set(s))\r\n            if len(x) == 1:\r\n                ans[j + 1] = '1'\r\n                ans[i :i + 3] = list(x[0][1:])\r\n                onepos = j + 2\r\n                zeropos = i + list(x[0]).index('0')\r\n            else:\r\n                ans[i :i + 3] = list('000')\r\n                zeropos = i + 1\r\n                t = ask(j + 1, j + 2, zeropos)\r\n                if t == 1:\r\n                    ans[j] = '1'\r\n                    ans[j + 1] = '1'\r\n                    onepos = j + 1\r\n                else:\r\n                    ans[j + 2] = '1'\r\n                    onepos = j + 3\r\n\r\n        for z in range(j+1,j+4):\r\n            if z!= onepos:\r\n                ans[z-1] = str(ask(z, zeropos, onepos))\r\n\r\n        for c in range(0,k-1):\r\n            d = 3*c\r\n            b = str(ask(d+1, d+2, zeropos))\r\n            if b == '1':\r\n                ans[d] = '1'\r\n                ans[d+1] = '1'\r\n                ans[d+2] = str(ask(d + 3, zeropos, onepos))\r\n            else:\r\n                ans[d+2] = '1'\r\n                ans[d + 1] = str(ask(d + 2, zeropos, onepos))\r\n                ans[d] = str(1- int(ans[d+1]))\r\n\r\n    for l in range(i+4,n+1):\r\n        ans[l - 1] = str(ask(l, zeropos, onepos))\r\n    #print(ans)\r\n    indans = [str(i+1) for i in range(n) if ans[i] == '0']\r\n    fans = '! '+str(len(indans)) + ' ' + ' '.join(indans)\r\n    print(fans, flush=True)\r\n",
    "prob_desc_created_at": "1639661700",
    "tags": [
        "constructive algorithms",
        "implementation",
        "interactive",
        "math"
    ],
    "hidden_unit_tests": ""
}
{
    "prob_desc_time_limit": "4 seconds",
    "prob_desc_sample_outputs": "[\"314\"]",
    "src_uid": "202396838c98654c4e40179f21a225a0",
    "prob_desc_notes": null,
    "prob_desc_description": "Let's denote the size of the maximum matching in a graph $$$G$$$ as $$$\\mathit{MM}(G)$$$.You are given a bipartite graph. The vertices of the first part are numbered from $$$1$$$ to $$$n$$$, the vertices of the second part are numbered from $$$n+1$$$ to $$$2n$$$. Each vertex's degree is $$$2$$$.For a tuple of four integers $$$(l, r, L, R)$$$, where $$$1 \\le l \\le r \\le n$$$ and $$$n+1 \\le L \\le R \\le 2n$$$, let's define $$$G'(l, r, L, R)$$$ as the graph which consists of all vertices of the given graph that are included in the segment $$$[l, r]$$$ or in the segment $$$[L, R]$$$, and all edges of the given graph such that each of their endpoints belongs to one of these segments. In other words, to obtain $$$G'(l, r, L, R)$$$ from the original graph, you have to remove all vertices $$$i$$$ such that $$$i \\notin [l, r]$$$ and $$$i \\notin [L, R]$$$, and all edges incident to these vertices.Calculate the sum of $$$\\mathit{MM}(G(l, r, L, R))$$$ over all tuples of integers $$$(l, r, L, R)$$$ having $$$1 \\le l \\le r \\le n$$$ and $$$n+1 \\le L \\le R \\le 2n$$$.",
    "prob_desc_output_spec": "Print one integer — the sum of $$$\\mathit{MM}(G(l, r, L, R))$$$ over all tuples of integers $$$(l, r, L, R)$$$ having $$$1 \\le l \\le r \\le n$$$ and $$$n+1 \\le L \\le R \\le 2n$$$.",
    "prob_desc_input_spec": "The first line contains one integer $$$n$$$ ($$$2 \\le n \\le 1500$$$) — the number of vertices in each part. Then $$$2n$$$ lines follow, each denoting an edge of the graph. The $$$i$$$-th line contains two integers $$$x_i$$$ and $$$y_i$$$ ($$$1 \\le x_i \\le n$$$; $$$n + 1 \\le y_i \\le 2n$$$) — the endpoints of the $$$i$$$-th edge. There are no multiple edges in the given graph, and each vertex has exactly two incident edges.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3-64",
    "lang_cluster": "Python",
    "difficulty": 2600,
    "file_name": "train_104.jsonl",
    "code_uid": "41bd3f73363cc3d11f0b33d92c75e8c2",
    "prob_desc_memory_limit": "512 megabytes",
    "prob_desc_sample_inputs": "[\"5\\n4 6\\n4 9\\n2 6\\n3 9\\n1 8\\n5 10\\n2 7\\n3 7\\n1 10\\n5 8\"]",
    "exec_outcome": "PASSED",
    "source_code": "\n\n\nclass unionfind:\n    def __init__(self,uni_num):\n        self.uni_num=uni_num\n        self.union_root = [-1 for i in range(self.uni_num + 1)]\n        self.union_depth = [0] * (self.uni_num + 1)\n        self.e_num=[0]*(self.uni_num+1)\n\n    def find(self,x):  # 親は誰？\n        if self.union_root[x] < 0:\n            return x\n        else:\n            self.union_root[x] = self.find(self.union_root[x])\n            return self.union_root[x]\n\n    def unite(self,x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            self.e_num[x]+=1\n            return\n        if self.union_depth[x] < self.union_depth[y]:\n            x, y = y, x\n        if self.union_depth[x] == self.union_depth[y]:\n            self.union_depth[x] += 1\n        self.union_root[x] += self.union_root[y]\n        self.union_root[y] = x\n        self.e_num[x]+=self.e_num[y]+1\n\n\n    def size(self,x):\n        return -self.union_root[self.find(x)]\n\n    def same(self,x,y):\n        return self.find(x)==self.find(y)\n    def edge(self,x):\n        return self.e_num[self.find(x)]\n\n\nn=int(input())\nroot=[[] for i in range(2*n+3)]\nuf=unionfind(2*n+10)\nfor i in range(2*n):\n    u,v=map(int,input().split())\n    root[u].append(v)\n    root[v].append(u)\n    uf.unite(u,v)\nseen=[0]*(2*n+4)\ndef cnt(mal,mir,maL,miR,ng1,ng2):\n    if mal>mir or maL>miR:return 0\n\n    res1=mal*(n+1-mir)\n    if 1<=ng1<=n:\n        a,b=min(mal,ng1),max(mir,ng1)\n        res1-=a*(n+1-b)\n    if 1<=ng2<=n:\n        a, b = min(mal, ng2), max(mir, ng2)\n        res1 -= a * (n + 1 - b)\n    if (1<=ng1<=n and 1<=ng2<=n):\n        a,b=min(mal,ng1,ng2),max(mir,ng1,ng2)\n        res1+=a*(n+1-b)\n\n    maL-=n\n    miR-=n\n    ng1-=n\n    ng2-=n\n    res2=maL*(n+1-miR)\n    if 1<=ng1<=n:\n        a,b=min(maL,ng1),max(miR,ng1)\n        res2-=a*(n+1-b)\n    if 1<=ng2<=n:\n        a, b = min(maL, ng2), max(miR, ng2)\n        res2 -= a * (n + 1 - b)\n    if (1<=ng1<=n and 1<=ng2<=n):\n        a,b=min(maL,ng1,ng2),max(miR,ng1,ng2)\n        res2+=a*(n+1-b)\n    return res1*res2\n\n\n\n\n\n\nans=0\nfor x in range(1,2*n+1):\n    if x!=uf.find(x):continue\n    path=[x]\n    now=x\n    while 1:\n        seen[now]=1\n        flag=0\n        for y in root[now]:\n            if seen[y]:continue\n            now=y\n            path.append(y)\n            flag=1\n            break\n        if not flag:break\n    m=len(path)\n\n    for indl in range(m):\n        maxl = 10 ** 10\n        minr = -10 ** 10\n        maxL = 10 ** 10\n        minR = -10 ** 10\n        indr=(indl+1)%m\n        num=0\n        while 1:\n            if indr==indl:break\n            ans+=(num//2)*cnt(maxl,minr,maxL,minR,path[indl],path[indr])\n            nod=path[indr]\n            if nod<=n:\n                maxl=min(maxl,nod)\n                minr=max(minr,nod)\n            else:\n                maxL=min(maxL,nod)\n                minR=max(minR,nod)\n            num+=1\n            indr+=1\n            indr%=m\n    for ind in range(m):\n        maxl = 10 ** 10\n        minr = -10 ** 10\n        maxL = 10 ** 10\n        minR = -10 ** 10\n        i=(ind+1)%m\n        while 1:\n            if i==ind:break\n            nod = path[i]\n            if nod <= n:\n                maxl = min(maxl, nod)\n                minr = max(minr, nod)\n            else:\n                maxL = min(maxL, nod)\n                minR = max(minR, nod)\n            i=(i+1)%m\n        num=m-1\n        ans+=(num//2)*cnt(maxl,minr,maxL,minR,path[ind],path[ind])\n\n    maxl = 10 ** 10\n    minr = -10 ** 10\n    maxL = 10 ** 10\n    minR = -10 ** 10\n    for i in range(m):\n        nod = path[i]\n        if nod <= n:\n            maxl = min(maxl, nod)\n            minr = max(minr, nod)\n        else:\n            maxL = min(maxL, nod)\n            minR = max(minR, nod)\n    num=m\n    ans += (num // 2) * cnt(maxl, minr, maxL, minR,10**9,10**9)\n\n\nprint(ans)\n\n\n\n\n",
    "prob_desc_created_at": "1646922900",
    "tags": [
        "brute force",
        "combinatorics",
        "constructive algorithms",
        "dfs and similar",
        "graph matchings",
        "greedy",
        "math"
    ],
    "hidden_unit_tests": ""
}
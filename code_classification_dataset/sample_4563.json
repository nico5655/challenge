{
    "prob_desc_time_limit": "1 second",
    "prob_desc_sample_outputs": "[\"YES\\nYES\\nNO\\nYES\\nNO\"]",
    "src_uid": "ff95cd4632b2ddf8bb54981634badcae",
    "prob_desc_notes": "NoteThe first test case is shown in the statement.In the second test case, we transform $$$a$$$ into $$$b$$$ by using zero operations.In the third test case, there is no legal operation, so it is impossible to transform $$$a$$$ into $$$b$$$.In the fourth test case, here is one such transformation:   Select the length $$$2$$$ prefix to get $$$100101010101$$$.  Select the length $$$12$$$ prefix to get $$$011010101010$$$.  Select the length $$$8$$$ prefix to get $$$100101011010$$$.  Select the length $$$4$$$ prefix to get $$$011001011010$$$.  Select the length $$$6$$$ prefix to get $$$100110011010$$$. In the fifth test case, the only legal operation is to transform $$$a$$$ into $$$111000$$$. From there, the only legal operation is to return to the string we started with, so we cannot transform $$$a$$$ into $$$b$$$.",
    "prob_desc_description": "There is a binary string $$$a$$$ of length $$$n$$$. In one operation, you can select any prefix of $$$a$$$ with an equal number of $$$0$$$ and $$$1$$$ symbols. Then all symbols in the prefix are inverted: each $$$0$$$ becomes $$$1$$$ and each $$$1$$$ becomes $$$0$$$.For example, suppose $$$a=0111010000$$$.   In the first operation, we can select the prefix of length $$$8$$$ since it has four $$$0$$$'s and four $$$1$$$'s: $$$[01110100]00\\to [10001011]00$$$.  In the second operation, we can select the prefix of length $$$2$$$ since it has one $$$0$$$ and one $$$1$$$: $$$[10]00101100\\to [01]00101100$$$.  It is illegal to select the prefix of length $$$4$$$ for the third operation, because it has three $$$0$$$'s and one $$$1$$$. Can you transform the string $$$a$$$ into the string $$$b$$$ using some finite number of operations (possibly, none)?",
    "prob_desc_output_spec": "For each test case, output \"YES\" if it is possible to transform $$$a$$$ into $$$b$$$, or \"NO\" if it is impossible. You can print each letter in any case (upper or lower).",
    "prob_desc_input_spec": "The first line contains a single integer $$$t$$$ ($$$1\\le t\\le 10^4$$$) — the number of test cases. The first line of each test case contains a single integer $$$n$$$ ($$$1\\le n\\le 3\\cdot 10^5$$$) — the length of the strings $$$a$$$ and $$$b$$$. The following two lines contain strings $$$a$$$ and $$$b$$$ of length $$$n$$$, consisting of symbols $$$0$$$ and $$$1$$$. The sum of $$$n$$$ across all test cases does not exceed $$$3\\cdot 10^5$$$.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3-64",
    "lang_cluster": "Python",
    "difficulty": 1200,
    "file_name": "train_100.jsonl",
    "code_uid": "b8c56965606eb0ef9b60e3748f4dff4b",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"5\\n10\\n0111010000\\n0100101100\\n4\\n0000\\n0000\\n3\\n001\\n000\\n12\\n010101010101\\n100110011010\\n6\\n000111\\n110100\"]",
    "exec_outcome": "PASSED",
    "source_code": "import math\r\nimport string\r\n\r\n\r\ndef main_function():\r\n    test_cases = range(int(input()))\r\n    answers = []\r\n\r\n    for test_case in test_cases:\r\n        n = int(input())\r\n        equal_counter = 0\r\n        s_1 = list(input())\r\n        s_2 = list(input())\r\n        for i in range(n):\r\n            j = n - 1 - i\r\n            if s_1[j] == s_2[j]:\r\n                equal_counter += 1\r\n            else:\r\n                break\r\n        counter_1 = 0\r\n        counter_0 = 0\r\n        is_equal_mode = False\r\n        counter_for_completeness = False\r\n        good_for = True\r\n        for i in range(len(s_1)):\r\n            if i == 0:\r\n                if s_1[i] == s_2[i]:\r\n                    is_equal_mode = True\r\n                else:\r\n                    is_equal_mode = False\r\n                if s_1[i] == \"1\":\r\n                    counter_1 += 1\r\n                else:\r\n                    counter_0 += 1\r\n            else:\r\n                if is_equal_mode:\r\n                    if s_1[i] != s_2[i]:\r\n                        good_for = False\r\n                        break\r\n                else:\r\n                    if s_1[i] == s_2[i]:\r\n                        good_for = False\r\n                        break\r\n                if s_1[i] == \"1\":\r\n                    counter_1 += 1\r\n                else:\r\n                    counter_0 += 1\r\n                if counter_1 == counter_0:\r\n                    #print(i)\r\n                    counter_for_completeness = True\r\n                    if i + 1 < len(s_1):\r\n                        if s_1[i + 1] == s_2[i + 1]:\r\n                            is_equal_mode = True\r\n                        else:\r\n                            is_equal_mode = False\r\n                    if i + equal_counter >= len(s_1) - 1:\r\n                        # print(\"break worked\")\r\n                        break\r\n                else:\r\n                    counter_for_completeness = False\r\n        # print(good_for)\r\n        # print(equal_counter)\r\n        # print(counter_for_completeness)\r\n        if not counter_for_completeness:\r\n            good_for = False\r\n        # print(good_for)\r\n        if equal_counter == len(s_1):\r\n            good_for = True\r\n        # print(equal_counter)\r\n        # print(good_for)\r\n        if good_for:\r\n            print(\"YES\")\r\n        else:\r\n            print(\"NO\")\r\n\r\n\r\nmain_function()\r\n\r\n",
    "prob_desc_created_at": "1617460500",
    "tags": [
        "constructive algorithms",
        "greedy",
        "implementation",
        "math"
    ],
    "hidden_unit_tests": ""
}
{
    "prob_desc_time_limit": "5 seconds",
    "prob_desc_sample_outputs": "[\"15\\n12\\n2\"]",
    "src_uid": "d3baf23c53ba50a03f5ef63d58d177cb",
    "prob_desc_notes": "NoteAfter the first update $$$c$$$ is equal to $$$14$$$. The pairs that sum up to $$$14$$$ are: $$$(0, 14)$$$, $$$(1, 13)$$$, $$$(2, 12)$$$, $$$(3, 11)$$$, $$$(4, 10)$$$, $$$(5, 9)$$$, $$$(6, 8)$$$, $$$(7, 7)$$$, $$$(8, 6)$$$, $$$(9, 5)$$$, $$$(10, 4)$$$, $$$(11, 3)$$$, $$$(12, 2)$$$, $$$(13, 1)$$$, $$$(14, 0)$$$.After the second update $$$c$$$ is equal to $$$11$$$.After the third update $$$c$$$ is equal to $$$01$$$.",
    "prob_desc_description": "Let $$$a$$$ and $$$b$$$ be some non-negative integers. Let's define strange addition of $$$a$$$ and $$$b$$$ as following:  write down the numbers one under another and align them by their least significant digit;  add them up digit by digit and concatenate the respective sums together. Assume that both numbers have an infinite number of leading zeros.For example, let's take a look at a strange addition of numbers $$$3248$$$ and $$$908$$$:  You are given a string $$$c$$$, consisting of $$$n$$$ digits from $$$0$$$ to $$$9$$$. You are also given $$$m$$$ updates of form:   $$$x~d$$$ — replace the digit at the $$$x$$$-th position of $$$c$$$ with a digit $$$d$$$. Note that string $$$c$$$ might have leading zeros at any point of time.After each update print the number of pairs $$$(a, b)$$$ such that both $$$a$$$ and $$$b$$$ are non-negative integers and the result of a strange addition of $$$a$$$ and $$$b$$$ is equal to $$$c$$$.Note that the numbers of pairs can be quite large, so print them modulo $$$998244353$$$.",
    "prob_desc_output_spec": "Print $$$m$$$ integers — the $$$i$$$-th value should be equal to the number of pairs $$$(a, b)$$$ such that both $$$a$$$ and $$$b$$$ are non-negative integers and the result of a strange addition of $$$a$$$ and $$$b$$$ is equal to $$$c$$$ after $$$i$$$ updates are applied. Note that the numbers of pairs can be quite large, so print them modulo $$$998244353$$$.",
    "prob_desc_input_spec": "The first line contains two integers $$$n$$$ and $$$m$$$ ($$$1 \\le n, m \\le 5 \\cdot 10^5$$$) — the length of the number $$$c$$$ and the number of updates. The second line contains a string $$$c$$$, consisting of exactly $$$n$$$ digits from $$$0$$$ to $$$9$$$. Each of the next $$$m$$$ lines contains two integers $$$x$$$ and $$$d$$$ ($$$1 \\le x \\le n$$$, $$$0 \\le d \\le 9$$$) — the descriptions of updates.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 2",
    "lang_cluster": "Python",
    "difficulty": 2600,
    "file_name": "train_027.jsonl",
    "code_uid": "18cb249635dec2b7533f084a9c386e84",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"2 3\\n14\\n2 4\\n2 1\\n1 0\"]",
    "exec_outcome": "PASSED",
    "source_code": "# -*- coding: utf-8 -*-\n\"\"\"\nCreated on Sun Jul 12 23:12:26 2020\n\n@author: shubham gupta\n\"\"\"\n\nimport sys\nrange = xrange\ninput = raw_input\n# n log^2 n segtree solution \n\nclass segtree:\n    def __init__(self,n):\n        self.m = 1\n        while self.m < n:\n            self.m *= 2\n        self.data = [0] * (2 * self.m)\n\n    def __setitem__(self,i,x):\n        x = +(x != 1)\n        i += self.m\n        self.data[i] = x\n        i >>= 1\n        while i:\n            self.data[i] = self.data[2 * i] + self.data[2 * i + 1]\n            i >>= 1\n\n    def __call__(self,l,r):\n        l += self.m\n        r += self.m\n        s = 0\n        while l < r:\n            if l & 1:\n                s += self.data[l]\n                l += 1\n            if r & 1:\n                r -= 1\n                s += self.data[r]\n            l >>= 1\n            r >>= 1\n        return s\n\nMOD = 998244353 \n\ndef fast_modder(MOD):\n    \"\"\" Returns function modmul(a,b) that quickly calculates a * b % MOD, assuming 0 <= a,b < MOD \"\"\"\n    import sys, platform\n    impl = platform.python_implementation()\n    maxs = sys.maxsize\n    if 'PyPy' in impl and MOD <= maxs and MOD ** 2 > maxs:\n        import __pypy__\n        intsub = __pypy__.intop.int_sub\n        intmul = __pypy__.intop.int_mul\n        intmulmod = __pypy__.intop.int_mulmod\n        if MOD < 2**30:\n            MODINV = 1.0 / MOD\n            def modmul(a, b):\n                x = intsub(intmul(a,b), intmul(MOD, int(MODINV * a * b)))\n                return x - MOD if x >= MOD else (x if x >= 0 else x + MOD)\n        else:\n            def modmul(a, b):return intmulmod(a, b, MOD)\n    else:\n        def modmul(a, b):return a * b % MOD\n    return modmul\n\nmodmul = fast_modder(MOD)\ndef redu(x):return x if x < MOD else x - MOD\ndef modinv(x):return pow(x, MOD - 2, MOD)\n\nn,m = [int(x) for x in input().split()]\nC = [ord(c) - ord('0') for c in input()]\n\nseg = segtree(n)\nfor i in range(n):seg[i] = C[i]\n\ndef valer(n, x):\n    if n == -1:return 1\n    if n == 0:return x + 1\n    return redu(modmul(DP[n], (x + 1)) + modmul(DP[n - 1], (9 - x)))\n\nDP = [1] * (n + 1)\nfor i in range(1, n + 1):DP[i] = valer(i - 1, 1)\n\nways = 1\ni = 0\nwhile i < len(C):\n    j = i\n    while j + 1 < len(C) and C[j] == 1:\n        j += 1\n    ways = modmul(ways, valer(j - i, C[j]))\n    i = j + 1\n\ninp = [int(x) for x in sys.stdin.read().split()]; ii = 0\n\nout = []\n\nfor _ in range(m):\n    a = inp[ii] - 1; ii += 1\n    x = inp[ii]; ii += 1\n\n    if C[a] == x:\n        out.append(ways)\n        continue\n\n    aa = -1\n    bb = a - 1\n    while aa < bb:\n        cc = aa + bb + 1 >> 1\n        if seg(cc, a) > 0:\n            aa = cc\n        else:\n            bb = cc - 1\n    before = aa\n    \n    aa = a + 1\n    bb = n\n    while aa < bb:\n        cc = aa + bb >> 1\n        if seg(a + 1, cc + 1) > 0:\n            bb = cc\n        else:\n            aa = cc + 1\n    after = aa\n\n    oneL = a - before - 1\n    oneR = after - a - 1\n\n    if C[a] == 1:\n        if after < n:\n            ways = modmul(ways, modinv(valer(oneL + oneR + 1, C[after])))\n            seg[a] = C[a] = x\n            ways = modmul(ways, valer(oneL, x))\n            ways = modmul(ways, valer(oneR, C[after]))\n        else:\n            ways = modmul(ways, modinv(valer(oneL + oneR, 1)))\n            \n            seg[a] = C[a] = x\n            ways = modmul(ways, valer(oneL, x))\n            ways = modmul(ways, valer(oneR - 1, 1))\n                \n\n    else:\n        if x == 1:\n            if after < n:\n                ways = modmul(ways, modinv(modmul(valer(oneL, C[a]), valer(oneR, C[after]))))\n                seg[a] = C[a] = x\n                ways = modmul(ways, valer(oneL + oneR + 1, C[after]))\n            else:\n                ways = modmul(ways, modinv(valer(oneL, C[a]) * valer(oneR - 1, 1)))\n                seg[a] = C[a] = x\n                ways = modmul(ways, valer(oneL + oneR, 1))\n        else:\n            ways = modmul(ways, modinv(valer(a - before - 1, C[a])))\n            seg[a] = C[a] = x\n            ways = modmul(ways, valer(a - before - 1, C[a]))\n    out.append(ways)\n\nprint '\\n'.join(str(x) for x in out)\n        ",
    "prob_desc_created_at": "1594565100",
    "tags": [
        "dp",
        "data structures",
        "matrices"
    ],
    "hidden_unit_tests": ""
}
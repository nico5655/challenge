{
    "prob_desc_time_limit": "3 seconds",
    "prob_desc_sample_outputs": "[\"1\\n2\\n3\\n3\\n3\\n3\\n3\", \"1\\n1\\n1\\n1\\n1\\n1\\n4\\n4\", \"1\\n1\\n1\\n1\\n1\", \"0\\n1\\n1\\n1\\n2\\n2\\n2\\n3\\n3\\n3\\n3\\n4\\n4\\n4\\n4\\n4\\n4\\n4\\n5\"]",
    "src_uid": "10e6b62d5b1abf8e1ba964a38dc6a9e8",
    "prob_desc_notes": "NoteIn the first example:   For $$$i = 1$$$, we can just apply one operation on $$$A_1$$$, the final states will be $$$1010110$$$;  For $$$i = 2$$$, we can apply operations on $$$A_1$$$ and $$$A_3$$$, the final states will be $$$1100110$$$;  For $$$i \\ge 3$$$, we can apply operations on $$$A_1$$$, $$$A_2$$$ and $$$A_3$$$, the final states will be $$$1111111$$$. In the second example:   For $$$i \\le 6$$$, we can just apply one operation on $$$A_2$$$, the final states will be $$$11111101$$$;  For $$$i \\ge 7$$$, we can apply operations on $$$A_1, A_3, A_4, A_6$$$, the final states will be $$$11111111$$$. ",
    "prob_desc_description": "There are $$$n$$$ lamps on a line, numbered from $$$1$$$ to $$$n$$$. Each one has an initial state off ($$$0$$$) or on ($$$1$$$).You're given $$$k$$$ subsets $$$A_1, \\ldots, A_k$$$ of $$$\\{1, 2, \\dots, n\\}$$$, such that the intersection of any three subsets is empty. In other words, for all $$$1 \\le i_1 &lt; i_2 &lt; i_3 \\le k$$$, $$$A_{i_1} \\cap A_{i_2} \\cap A_{i_3} = \\varnothing$$$.In one operation, you can choose one of these $$$k$$$ subsets and switch the state of all lamps in it. It is guaranteed that, with the given subsets, it's possible to make all lamps be simultaneously on using this type of operation.Let $$$m_i$$$ be the minimum number of operations you have to do in order to make the $$$i$$$ first lamps be simultaneously on. Note that there is no condition upon the state of other lamps (between $$$i+1$$$ and $$$n$$$), they can be either off or on.You have to compute $$$m_i$$$ for all $$$1 \\le i \\le n$$$.",
    "prob_desc_output_spec": "You must output $$$n$$$ lines. The $$$i$$$-th line should contain a single integer $$$m_i$$$  — the minimum number of operations required to make the lamps $$$1$$$ to $$$i$$$ be simultaneously on.",
    "prob_desc_input_spec": "The first line contains two integers $$$n$$$ and $$$k$$$ ($$$1 \\le n, k \\le 3 \\cdot 10^5$$$). The second line contains a binary string of length $$$n$$$, representing the initial state of each lamp (the lamp $$$i$$$ is off if $$$s_i = 0$$$, on if $$$s_i = 1$$$). The description of each one of the $$$k$$$ subsets follows, in the following format: The first line of the description contains a single integer $$$c$$$ ($$$1 \\le c \\le n$$$)  — the number of elements in the subset. The second line of the description contains $$$c$$$ distinct integers $$$x_1, \\ldots, x_c$$$ ($$$1 \\le x_i \\le n$$$)  — the elements of the subset. It is guaranteed that:    The intersection of any three subsets is empty;  It's possible to make all lamps be simultaneously on using some operations. ",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 2",
    "lang_cluster": "Python",
    "difficulty": 2400,
    "file_name": "train_023.jsonl",
    "code_uid": "5651c446583302149fd707727055a007",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"7 3\\n0011100\\n3\\n1 4 6\\n3\\n3 4 7\\n2\\n2 3\", \"8 6\\n00110011\\n3\\n1 3 8\\n5\\n1 2 5 6 7\\n2\\n6 8\\n2\\n3 5\\n2\\n4 7\\n1\\n2\", \"5 3\\n00011\\n3\\n1 2 3\\n1\\n4\\n3\\n3 4 5\", \"19 5\\n1001001001100000110\\n2\\n2 3\\n2\\n5 6\\n2\\n8 9\\n5\\n12 13 14 15 16\\n1\\n19\"]",
    "exec_outcome": "PASSED",
    "source_code": "import sys\nrange = xrange\ninput = raw_input\n \nn, k = [int(x) for x in input().split()]\nA = [+(c == '0') for c in input()]\ninp = [int(x) for x in sys.stdin.read().split()]; ii = 0\n\nB = []\nfor _ in range(k):\n    m = inp[ii]; ii += 1\n    B.append([a - 1 for a in inp[ii: ii + m]]); ii += m\n\nbuckets = [[] for _ in range(n)]\nfor j in range(k):\n    for a in B[j]:\n        buckets[a].append(j)\n\n#####################\nparent = list(range(2 * k))\nsize = [1] * (2 * k)\nstate = [0] * (2 * k)\ntrue = [1] * k + [0] * k\ncost = 0\n\n\ndef find(a):\n    acopy = a\n    while a != parent[a]:\n        a = parent[a]\n    while acopy != a:\n        parent[acopy], acopy = a, parent[acopy]\n    return a\n\ndef calcer(a):\n    a = find(a)\n    b = find((a + k) % (2 * k))\n    if state[a] == 0:\n        return min(true[a], true[b])\n    elif state[a] == 1:\n        return true[b]\n    else:\n        return true[a]\n\ndef union(a, b):\n    a, b = find(a), find(b)\n    if a != b:\n        if size[a] < size[b]:\n            a, b = b, a\n\n        parent[b] = a\n        size[a] += size[b]\n        state[a] |= state[b]\n        true[a] += true[b]\n\ndef on(a):\n    global cost\n    a = find(a)\n    if state[a] == 0:\n        b = find((a + k) % (2 * k))\n        cost -= calcer(a)\n        state[a] = 1\n        state[b] = 2 \n        cost += calcer(a)\n\ndef same(a, b):\n    global cost\n    a = find(a)\n    b = find(b)\n    if a != b:\n        cost -= calcer(a)\n        cost -= calcer(b)\n        union(a, b)\n        union((a + k) % (2 * k), (b + k) % (2 * k))\n        cost += calcer(a)\n\n######\n\nout = []\nfor i in range(n):\n    bucket = buckets[i]\n    if not bucket:\n        pass\n    elif len(bucket) == 1:\n        j = bucket[0]\n        if not A[i]:\n            on(j)\n        else:\n            on(j + k)\n    else:\n        j1, j2 = bucket\n        if not A[i]:\n            same(j1, j2)\n        else:\n            same(j1, j2 + k)\n    out.append(cost)\nprint '\\n'.join(str(x) for x in out)\n",
    "prob_desc_created_at": "1580652300",
    "tags": [
        "dsu",
        "dfs and similar",
        "graphs"
    ],
    "hidden_unit_tests": ""
}
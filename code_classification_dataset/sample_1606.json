{
    "prob_desc_time_limit": "1 second",
    "prob_desc_sample_outputs": "[\"yyzz\\nbccd\\nbxxd\\nyyaa\"]",
    "src_uid": "42a51b45312be6b38f3a15949d315c67",
    "prob_desc_notes": null,
    "prob_desc_description": "We all know the problem about the number of ways one can tile a 2 × n field by 1 × 2 dominoes. You probably remember that it goes down to Fibonacci numbers. We will talk about some other problem below, there you also are going to deal with tiling a rectangular field with dominoes.You are given a 4 × n rectangular field, that is the field that contains four lines and n columns. You have to find for it any tiling by 1 × 2 dominoes such that each of the n - 1 potential vertical cuts along the grid lines intersects at least one domino, splitting it in two. No two dominoes in the sought tiling should overlap, each square of the field should be covered by exactly one domino. It is allowed to rotate the dominoes, that is, you can use 2 × 1 as well as 1 × 2 dominoes.Write a program that finds an arbitrary sought tiling. ",
    "prob_desc_output_spec": "If there's no solution, print \"-1\" (without the quotes). Otherwise, print four lines containing n characters each — that's the description of tiling, where each vertical cut intersects at least one domino. You should print the tiling, having painted the field in no more than 26 colors. Each domino should be painted a color. Different dominoes can be painted the same color, but dominoes of the same color should not be side-neighbouring. To indicate colors you should use lowercase Latin letters. Print any of the acceptable ways of tiling.",
    "prob_desc_input_spec": "The input contains one positive integer n (1 ≤ n ≤ 100) — the number of the field's columns.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "Python 3",
    "lang_cluster": "Python",
    "difficulty": 1300,
    "file_name": "train_010.jsonl",
    "code_uid": "bb08f0f2fdad2749d76b38a575d7bb50",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"4\"]",
    "exec_outcome": "PASSED",
    "source_code": "#!/usr/bin/env python3\n# vim: set fileencoding=utf-8\n\n# pylint: disable=unused-import, invalid-name, missing-docstring, bad-continuation\n\n\n\"\"\"Module docstring\n\"\"\"\n\nimport functools\nimport heapq\nimport itertools\nimport logging\nimport math\nimport random\nimport string\nimport sys\nfrom argparse import ArgumentParser\nfrom collections import defaultdict, deque\nfrom copy import deepcopy\nfrom typing import Dict, List, Optional, Set, Tuple\n\n\ndef solve(nb: int) -> Tuple[str]:\n    if nb == 1:\n        return (\"a\", \"a\", \"b\", \"b\")\n    # base pattern\n    result = ([0, 0], [1, 1], [2, None], [2, None])\n    nb_cols = 2\n    next_domino = 2\n    for _ in range(nb - 2):\n        nb_cols += 1\n        next_domino = (next_domino + 1) % 26\n        for i in (0, 2):\n            if result[i][-1] is None:\n                # append an horizontal domino\n                result[i][-1] = next_domino\n                result[i].append(next_domino)\n                next_domino = (next_domino + 1) % 26\n                result[i + 1][-1] = next_domino\n                result[i + 1].append(next_domino)\n            else:\n                # leaves room\n                result[i].append(None)\n                result[i + 1].append(None)\n    # complete the last col\n    LOG.debug((\"\\n\".join(map(str, result))))\n    next_domino = (next_domino + 1) % 26\n    for i in (0, 2):\n        if result[i][-1] is None:\n            result[i][-1] = next_domino\n            result[i + 1][-1] = next_domino\n    LOG.debug((\"\\n\".join(map(str, result))))\n    return (\"\".join(chr(i + ord(\"a\")) for i in row) for row in result)\n\n\ndef do_job():\n    \"Do the work\"\n    LOG.debug(\"Start working\")\n    N = int(input())\n    result = solve(N)\n    if result:\n        print(\"\\n\".join(result))\n    else:\n        print(-1)\n\n\ndef print_output(testcase: int, result) -> None:\n    \"Formats and print result\"\n    if result is None:\n        result = \"IMPOSSIBLE\"\n    print(\"Case #{}: {}\".format(testcase + 1, result))\n    # 6 digits float precision {:.6f} (6 is the default value)\n    # print(\"Case #{}: {:f}\".format(testcase + 1, result))\n\n\ndef configure_log(log_file: Optional[str] = None) -> None:\n    \"Configure the log output\"\n    log_formatter = logging.Formatter(\n        \"%(asctime)s - %(filename)s:%(lineno)d - \" \"%(levelname)s - %(message)s\"\n    )\n    if log_file:\n        handler = logging.FileHandler(filename=log_file)\n    else:\n        handler = logging.StreamHandler(sys.stdout)\n    handler.setFormatter(log_formatter)\n    LOG.addHandler(handler)\n\n\nLOG = None\n# for interactive call: do not add multiple times the handler\nif not LOG:\n    LOG = logging.getLogger(\"template\")\n    configure_log()\n\n\ndef main(argv=None):\n    \"Program wrapper.\"\n    if argv is None:\n        argv = sys.argv[1:]\n    parser = ArgumentParser()\n    parser.add_argument(\n        \"-v\",\n        \"--verbose\",\n        dest=\"verbose\",\n        action=\"store_true\",\n        default=False,\n        help=\"run as verbose mode\",\n    )\n    args = parser.parse_args(argv)\n    if args.verbose:\n        LOG.setLevel(logging.DEBUG)\n    do_job()\n    return 0\n\n\nif __name__ == \"__main__\":\n    sys.exit(main())\n\n\nclass memoized:\n    \"\"\"Decorator that caches a function's return value each time it is called.\n    If called later with the same arguments, the cached value is returned, and\n    not re-evaluated.\n    \"\"\"\n\n    def __init__(self, func):\n        self.func = func\n        self.cache = {}\n\n    def __call__(self, *args):\n        try:\n            return self.cache[args]\n        except KeyError:\n            value = self.func(*args)\n            self.cache[args] = value\n            return value\n        except TypeError:\n            # uncachable -- for instance, passing a list as an argument.\n            # Better to not cache than to blow up entirely.\n            return self.func(*args)\n\n    def __repr__(self):\n        \"\"\"Return the function's docstring.\"\"\"\n        return self.func.__doc__\n\n    def __get__(self, obj, objtype):\n        \"\"\"Support instance methods.\"\"\"\n        return functools.partial(self.__call__, obj)\n",
    "prob_desc_created_at": "1305903600",
    "tags": [
        "constructive algorithms",
        "implementation"
    ],
    "hidden_unit_tests": ""
}
{
    "prob_desc_time_limit": "1 second",
    "prob_desc_sample_outputs": "[\"1 2 3 \\n1 1 1 \\n1 2 2 3 \\n-1\"]",
    "src_uid": "bb9f0e0431ef4db83190afd7b9ed4496",
    "prob_desc_notes": null,
    "prob_desc_description": "You are given a simple undirected graph with $$$n$$$ vertices and $$$m$$$ edges. Edge $$$i$$$ is colored in the color $$$c_i$$$, which is either $$$1$$$, $$$2$$$, or $$$3$$$, or left uncolored (in this case, $$$c_i = -1$$$).You need to color all of the uncolored edges in such a way that for any three pairwise adjacent vertices $$$1 \\leq a &lt; b &lt; c \\leq n$$$, the colors of the edges $$$a \\leftrightarrow b$$$, $$$b \\leftrightarrow c$$$, and $$$a \\leftrightarrow c$$$ are either pairwise different, or all equal. In case no such coloring exists, you need to determine that.",
    "prob_desc_output_spec": "For each test case, print $$$m$$$ integers $$$d_1, d_2, \\ldots, d_m$$$, where $$$d_i$$$ is the color of the $$$i$$$-th edge in your final coloring. If there is no valid way to finish the coloring, print $$$-1$$$.",
    "prob_desc_input_spec": "The first line of input contains one integer $$$t$$$ ($$$1 \\leq t \\leq 10$$$): the number of test cases. The following lines contain the description of the test cases. In the first line you are given two integers $$$n$$$ and $$$m$$$ ($$$3 \\leq n \\leq 64$$$, $$$0 \\leq m \\leq \\min(256, \\frac{n(n-1)}{2})$$$): the number of vertices and edges in the graph. Each of the next $$$m$$$ lines contains three integers $$$a_i$$$, $$$b_i$$$, and $$$c_i$$$ ($$$1 \\leq a_i, b_i \\leq n$$$, $$$a_i \\ne b_i$$$, $$$c_i$$$ is either $$$-1$$$, $$$1$$$, $$$2$$$, or $$$3$$$), denoting an edge between $$$a_i$$$ and $$$b_i$$$ with color $$$c_i$$$. It is guaranteed that no two edges share the same endpoints.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3-64",
    "lang_cluster": "Python",
    "difficulty": 2900,
    "file_name": "train_101.jsonl",
    "code_uid": "70b9a88fa703c29e6e351dd22b5d56dc",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"4\\n3 3\\n1 2 1\\n2 3 2\\n3 1 -1\\n3 3\\n1 2 1\\n2 3 1\\n3 1 -1\\n4 4\\n1 2 -1\\n2 3 -1\\n3 4 -1\\n4 1 -1\\n3 3\\n1 2 1\\n2 3 1\\n3 1 2\"]",
    "exec_outcome": "PASSED",
    "source_code": "from itertools import combinations\r\nfrom collections import defaultdict\r\nimport io, os, sys\r\ninput = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline\r\n\r\n\r\n\r\n\r\ndef F1(A, B, C, D):\r\n    AD = A ^ D\r\n    return (AD ^ B) | (A ^ C), AD & (B ^ C)\r\n\r\ndef F2(A, B, C, D):\r\n    AC = A ^ C\r\n    return AC | (B ^ D), (AC ^ D) & (B ^ C)\r\n\r\ndef flip_bit(a, i):\r\n    a[i // l] ^= (1 << (i % l))\r\n\r\ndef Gauss(a, b, n, m):\r\n    if n == 0: return 2, [0] * m\r\n    where = [-1] * m\r\n    row, col = 0, 0\r\n\r\n    while col < m and row < n:\r\n        t1, t2 = divmod(col, l)\r\n        for i in range(row, n):\r\n            if a[i][t1] >> t2 & 1 or b[i][t1] >> t2 & 1:\r\n                a[i], a[row] = a[row], a[i]\r\n                b[i], b[row] = b[row], b[i]\r\n                break\r\n\r\n        if not a[row][t1] >> t2 & 1 and not b[row][t1] >> t2 & 1:\r\n            col += 1\r\n            continue\r\n        where[col] = row\r\n\r\n        for i in range(n):\r\n            if i == row: continue\r\n            x1, x2 = a[i][t1] >> t2 & 1, b[i][t1] >> t2 & 1\r\n            y1, y2 = a[row][t1] >> t2 & 1, b[row][t1] >> t2 & 1\r\n            cc = ((x1 + x2) * (y1 + y2)) % 3\r\n            if cc == 0: continue\r\n            F = F1 if cc == 2 else F2\r\n            for k in range(t1, U): a[i][k], b[i][k] = F(a[i][k], b[i][k], a[row][k], b[row][k])\r\n\r\n        col, row = col + 1, row + 1\r\n\r\n    ans = [0] * m\r\n    t1, t2 = divmod(m, l)\r\n    for i in range(m):\r\n        W = where[i]\r\n        if W != -1:\r\n            t3, t4 = divmod(i, l)\r\n            x1, x2 = a[W][t1] >> t2 & 1, b[W][t1] >> t2 & 1\r\n            y1, y2 = a[W][t3] >> t4 & 1, b[W][t3] >> t4 & 1\r\n            ans[i] = ((x1 + x2) * (y1 + y2)) % 3\r\n\r\n    for i in range(n):\r\n        sm = 0\r\n        for j in range(m):\r\n            t3, t4 = divmod(j, l)\r\n            sm += ((a[i][t3] >> t4 & 1) + (b[i][t3] >> t4 & 1)) * ans[j]\r\n\r\n        if (sm - (a[i][t1] >> t2 & 1) - (b[i][t1] >> t2 & 1)) % 3 != 0: return 0, [-1] * m\r\n\r\n    if -1 in where: return 2, ans\r\n    return 1, ans\r\n\r\n\r\nT = int(input())\r\nfor _ in range(T):\r\n    n, m = [int(i) for i in input().split()]\r\n    l, U = 63, m//63 + 1\r\n\r\n    G = defaultdict(list)\r\n    edges_back = {}\r\n    colors = [0] * m\r\n    for k in range(m):\r\n        a, b, c = [int(i) for i in input().split()]\r\n        G[a] += [(b, c)]\r\n        G[b] += [(a, c)]\r\n        edges_back[(a, b)] = (k, c)\r\n        edges_back[(b, a)] = (k, c)\r\n        colors[k] = c\r\n\r\n    ans = set()\r\n    for n1 in range(1, n + 1):\r\n        neibs = G[n1]\r\n        for (n2, c12), (n3, c13) in combinations(neibs, 2):\r\n            if (n2, n3) in edges_back:\r\n                row = [[0] * U, [0] * U]\r\n                k12, _ = edges_back[(n1, n2)]\r\n                k13, _ = edges_back[(n1, n3)]\r\n                k23, c23 = edges_back[(n2, n3)]\r\n                last = 0\r\n                for k, c in (k12, c12), (k13, c13), (k23, c23):\r\n                    if c != -1:\r\n                        last -= c\r\n                    else:\r\n                        flip_bit(row[0], k)\r\n                last %= 3\r\n                if last == 1:\r\n                    flip_bit(row[0], m)\r\n                elif last == 2:\r\n                    flip_bit(row[0], m)\r\n                    flip_bit(row[1], m)\r\n\r\n                ans.add(tuple(tuple(x) for x in row))\r\n\r\n    mat1, mat2 = [], []\r\n    for x, y in ans:\r\n        mat1 += [list(x)]\r\n        mat2 += [list(y)]\r\n\r\n    ans = Gauss(mat1, mat2, len(mat1), m)\r\n\r\n    if ans[0] == 0:\r\n        out = [-1]\r\n    else:\r\n        out = []\r\n        for i in range(m):\r\n            if colors[i] != -1:\r\n                out += [colors[i]]\r\n            elif ans[1][i] == 0:\r\n                out += [3]\r\n            else:\r\n                out += [ans[1][i]]\r\n\r\n    print(\" \".join(str(x) for x in out))\r\n",
    "prob_desc_created_at": "1640792100",
    "tags": [
        "brute force",
        "graphs",
        "math",
        "matrices"
    ],
    "hidden_unit_tests": ""
}
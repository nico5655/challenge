{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"0\\n2\\n3\\n2\"]",
    "src_uid": "003a8719fbf3683671fafe3f01711a0a",
    "prob_desc_notes": "NoteIn the first testcase of the example, Monocarp can choose $$$x=2$$$ and $$$y=3$$$. Lightweight, middleweight and heavyweight divisions will have $$$2$$$, $$$1$$$ and $$$1$$$ participants, respectively. They all are powers of two, so no extra participants are required.In the second testcase of the example, regardless of the choice of $$$x$$$ and $$$y$$$, one division will have $$$1$$$ participant, the rest will have $$$0$$$. Thus, Monocarp will have to invite $$$1$$$ participant into both of the remaining divisions.In the third testcase of the example, Monocarp can choose $$$x=1$$$ and $$$y=2$$$. Lightweight, middleweight and heavyweight divisions will have $$$0$$$, $$$3$$$ and $$$3$$$ participants, respectively. So an extra participant is needed in each division.In the fourth testcase of the example, Monocarp can choose $$$x=8$$$ and $$$y=9$$$. Lightweight, middleweight and heavyweight divisions will have $$$8$$$, $$$0$$$ and $$$0$$$ participants, respectively. Middleweight and heavyweight division need an extra participant each.",
    "prob_desc_description": "Monocarp is planning to host a martial arts tournament. There will be three divisions based on weight: lightweight, middleweight and heavyweight. The winner of each division will be determined by a single elimination system.In particular, that implies that the number of participants in each division should be a power of two. Additionally, each division should have a non-zero amount of participants.$$$n$$$ participants have registered for the tournament so far, the $$$i$$$-th of them weighs $$$a_i$$$. To split participants into divisions, Monocarp is going to establish two integer weight boundaries $$$x$$$ and $$$y$$$ ($$$x &lt; y$$$). All participants who weigh strictly less than $$$x$$$ will be considered lightweight. All participants who weigh greater or equal to $$$y$$$ will be considered heavyweight. The remaining participants will be considered middleweight.It's possible that the distribution doesn't make the number of participants in each division a power of two. It can also lead to empty divisions. To fix the issues, Monocarp can invite an arbitrary number of participants to each division.Note that Monocarp can't kick out any of the $$$n$$$ participants who have already registered for the tournament.However, he wants to invite as little extra participants as possible. Help Monocarp to choose $$$x$$$ and $$$y$$$ in such a way that the total amount of extra participants required is as small as possible. Output that amount.",
    "prob_desc_output_spec": "For each testcase, print a single integer — the smallest number of extra participants Monocarp is required to invite after he chooses the weight boundaries $$$x$$$ and $$$y$$$.",
    "prob_desc_input_spec": "The first line contains a single integer $$$t$$$ ($$$1 \\le t \\le 10^4$$$) — the number of testcases. The first line of each testcase contains a single integer $$$n$$$ ($$$1 \\le n \\le 2 \\cdot 10^5$$$) — the number of the registered participants. The second line of each testcase contains $$$n$$$ integers $$$a_1, a_2, \\dots, a_n$$$ ($$$1 \\le a_i \\le n$$$) — the weights of the registered participants. The sum of $$$n$$$ over all testcases doesn't exceed $$$2 \\cdot 10^5$$$.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3-64",
    "lang_cluster": "Python",
    "difficulty": 2100,
    "file_name": "train_087.jsonl",
    "code_uid": "93e141493d83a268a9624c4c4daf2357",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"4\\n\\n4\\n\\n3 1 2 1\\n\\n1\\n\\n1\\n\\n6\\n\\n2 2 2 1 1 1\\n\\n8\\n\\n6 3 6 3 6 3 6 6\"]",
    "exec_outcome": "PASSED",
    "source_code": "import os,sys\r\nfrom random import randint\r\nfrom io import BytesIO, IOBase\r\n\r\nfrom collections import defaultdict,deque,Counter\r\nfrom bisect import bisect_left,bisect_right\r\nfrom heapq import heappush,heappop\r\nfrom functools import lru_cache\r\nfrom itertools import accumulate\r\nimport math\r\n\r\n# Fast IO Region\r\nBUFSIZE = 8192\r\nclass FastIO(IOBase):\r\n    newlines = 0\r\n    def __init__(self, file):\r\n        self._fd = file.fileno()\r\n        self.buffer = BytesIO()\r\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\r\n        self.write = self.buffer.write if self.writable else None\r\n    def read(self):\r\n        while True:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            if not b:\r\n                break\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines = 0\r\n        return self.buffer.read()\r\n    def readline(self):\r\n        while self.newlines == 0:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            self.newlines = b.count(b\"\\n\") + (not b)\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines -= 1\r\n        return self.buffer.readline()\r\n    def flush(self):\r\n        if self.writable:\r\n            os.write(self._fd, self.buffer.getvalue())\r\n            self.buffer.truncate(0), self.buffer.seek(0)\r\nclass IOWrapper(IOBase):\r\n    def __init__(self, file):\r\n        self.buffer = FastIO(file)\r\n        self.flush = self.buffer.flush\r\n        self.writable = self.buffer.writable\r\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\r\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\r\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\r\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\r\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\r\n\r\n# for _ in range(int(input())):\r\n#     n = int(input())\r\n#     a = list(map(int, input().split(' ')))\r\n\r\n# for _ in range(int(input())):\r\n#     s = input()\r\n#     print(''.join(sorted(list(s))))\r\n\r\n# for _ in range(int(input())):\r\n#     s = input()\r\n#     n = len(s)\r\n#     for i in range(n - 1)[::-1]:\r\n#         if int(s[i]) + int(s[i + 1]) >= 10:\r\n#             print(s[:i] + str(int(s[i]) + int(s[i + 1])) + s[i + 2:])\r\n#             break\r\n#     else:\r\n#         print(str(int(s[0]) + int(s[1])) + s[2:])\r\n\r\n# for _ in range(int(input())):\r\n#     n = int(input())\r\n#     k = list(map(int, input().split(' ')))\r\n#     h = list(map(int, input().split(' ')))\r\n#     a = [0] * n\r\n#     for i in range(n):\r\n#         for j in range(i + 1):\r\n#             a[j] = max(a[j], h[i] - (k[i] - k[j]))\r\n#     cur = a[0]\r\n#     ans = 0\r\n#     for i in range(1, n):\r\n#         if k[i] - k[i - 1] < a[i]:\r\n#             cur += k[i] - k[i - 1]\r\n#         else:\r\n#             ans += cur * (cur + 1) // 2\r\n#             cur = a[i]\r\n#     ans += cur * (cur + 1) // 2\r\n#     print(ans)\r\n\r\npower = [-1] + [2 ** i for i in range(30)]\r\n@lru_cache(None)\r\ndef calc(c):\r\n    if c >= 0:\r\n        return power[bisect_left(power, c)] - c\r\nfor _ in range(int(input())):\r\n    n = int(input())\r\n    a = list(map(int, input().split(' ')))\r\n    a.sort()\r\n    cnt = [i[1] for i in sorted(Counter(a).items())]\r\n\r\n    pre = [0] + list(accumulate(cnt))\r\n    pre2 = [0] + list(accumulate(cnt[::-1]))\r\n\r\n    ans = float('inf')\r\n\r\n    l = set([pre[max(0,  bisect_right(pre, i) - 1)] for i in power])\r\n\r\n    r = set([pre2[max(0, bisect_right(pre2, j) - 1)] for j in power])\r\n\r\n    for i in l:\r\n        for j in r:\r\n            if i + j > n: continue\r\n            ans = min(ans, calc(i) + calc(j) + calc(n - i - j))\r\n\r\n    print(ans)\r\n    \r\n\r\n\r\n",
    "prob_desc_created_at": "1642343700",
    "tags": [
        "binary search",
        "brute force",
        "greedy",
        "math"
    ],
    "hidden_unit_tests": ""
}
{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"2 3 1\", \"4 1 3 2\"]",
    "src_uid": "0da021cfe88c5a333db99064de12acbf",
    "prob_desc_notes": "NoteIn the first example, $$$p = [2, 3, 4, 1]$$$, $$$m = 3$$$ and given swaps are $$$[(1, 4), (2, 1), (1, 3)]$$$.There is only one correct order of swaps i.e $$$[2, 3, 1]$$$.  First we perform the swap $$$2$$$ from the input i.e $$$(2, 1)$$$, $$$p$$$ becomes $$$[3, 2, 4, 1]$$$.  Then we perform the swap $$$3$$$ from the input i.e $$$(1, 3)$$$, $$$p$$$ becomes $$$[4, 2, 3, 1]$$$.  Finally we perform the swap $$$1$$$ from the input i.e $$$(1, 4)$$$ and $$$p$$$ becomes $$$[1, 2, 3, 4]$$$ which is sorted. In the second example, $$$p = [6, 5, 1, 3, 2, 4]$$$, $$$m = 4$$$ and the given swaps are $$$[(3, 1), (2, 5), (6, 3), (6, 4)]$$$.One possible correct order of swaps is $$$[4, 2, 1, 3]$$$.  Perform the swap $$$4$$$ from the input i.e $$$(6, 4)$$$, $$$p$$$ becomes $$$[6, 5, 1, 4, 2, 3]$$$.  Perform the swap $$$2$$$ from the input i.e $$$(2, 5)$$$, $$$p$$$ becomes $$$[6, 2, 1, 4, 5, 3]$$$.  Perform the swap $$$1$$$ from the input i.e $$$(3, 1)$$$, $$$p$$$ becomes $$$[1, 2, 6, 4, 5, 3]$$$.  Perform the swap $$$3$$$ from the input i.e $$$(6, 3)$$$ and $$$p$$$ becomes $$$[1, 2, 3, 4, 5, 6]$$$ which is sorted. There can be other possible answers such as $$$[1, 2, 4, 3]$$$.",
    "prob_desc_description": "Alice had a permutation $$$p$$$ of numbers from $$$1$$$ to $$$n$$$. Alice can swap a pair $$$(x, y)$$$ which means swapping elements at positions $$$x$$$ and $$$y$$$ in $$$p$$$ (i.e. swap $$$p_x$$$ and $$$p_y$$$). Alice recently learned her first sorting algorithm, so she decided to sort her permutation in the minimum number of swaps possible. She wrote down all the swaps in the order in which she performed them to sort the permutation on a piece of paper. For example,  $$$[(2, 3), (1, 3)]$$$ is a valid swap sequence by Alice for permutation $$$p = [3, 1, 2]$$$ whereas $$$[(1, 3), (2, 3)]$$$ is not because it doesn't sort the permutation. Note that we cannot sort the permutation in less than $$$2$$$ swaps.  $$$[(1, 2), (2, 3), (2, 4), (2, 3)]$$$ cannot be a sequence of swaps by Alice for $$$p = [2, 1, 4, 3]$$$ even if it sorts the permutation because $$$p$$$ can be sorted in $$$2$$$ swaps, for example using the sequence $$$[(4, 3), (1, 2)]$$$. Unfortunately, Bob shuffled the sequence of swaps written by Alice.You are given Alice's permutation $$$p$$$ and the swaps performed by Alice in arbitrary order. Can you restore the correct sequence of swaps that sorts the permutation $$$p$$$? Since Alice wrote correct swaps before Bob shuffled them up, it is guaranteed that there exists some order of swaps that sorts the permutation.",
    "prob_desc_output_spec": "Print a permutation of $$$m$$$ integers  — a valid order of swaps written by Alice that sorts the permutation $$$p$$$. See sample explanation for better understanding. In case of multiple possible answers, output any.",
    "prob_desc_input_spec": "The first line contains $$$2$$$ integers $$$n$$$ and $$$m$$$ $$$(2 \\le n \\le 2 \\cdot 10^5, 1 \\le m \\le n - 1)$$$  — the size of permutation and the minimum number of swaps required to sort the permutation. The next line contains $$$n$$$ integers $$$p_1, p_2, ..., p_n$$$ ($$$1 \\le p_i \\le n$$$, all $$$p_i$$$ are distinct)  — the elements of $$$p$$$. It is guaranteed that $$$p$$$ forms a permutation. Then $$$m$$$ lines follow. The $$$i$$$-th of the next $$$m$$$ lines contains two integers $$$x_i$$$ and $$$y_i$$$  — the $$$i$$$-th swap $$$(x_i, y_i)$$$. It is guaranteed that it is possible to sort $$$p$$$ with these $$$m$$$ swaps and that there is no way to sort $$$p$$$ with less than $$$m$$$ swaps.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "Python 3",
    "lang_cluster": "Python",
    "difficulty": 2700,
    "file_name": "train_101.jsonl",
    "code_uid": "64057e6bf83be5025b9ae84095a2ff5f",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"4 3\\n2 3 4 1\\n1 4\\n2 1\\n1 3\", \"6 4\\n6 5 1 3 2 4\\n3 1\\n2 5\\n6 3\\n6 4\"]",
    "exec_outcome": "PASSED",
    "source_code": "import copy\r\nimport gc\r\nimport itertools\r\nfrom array import array\r\nfrom fractions import Fraction\r\nimport heapq\r\nimport math\r\nimport operator\r\nimport os, sys\r\nimport profile\r\nimport cProfile\r\nimport random\r\nimport re\r\nimport string\r\nfrom bisect import bisect_left, bisect_right\r\nfrom collections import defaultdict, deque, Counter\r\nfrom functools import reduce, lru_cache\r\nfrom io import IOBase, BytesIO\r\nfrom itertools import count, groupby, accumulate, permutations, combinations_with_replacement, product\r\nfrom math import gcd\r\nfrom operator import xor, add\r\nfrom typing import List\r\n\r\n# region fastio\r\nBUFSIZE = 8192\r\n\r\n\r\nclass FastIO(IOBase):\r\n    newlines = 0\r\n\r\n    def __init__(self, file):\r\n        self._file = file\r\n        self._fd = file.fileno()\r\n        self.buffer = BytesIO()\r\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\r\n        self.write = self.buffer.write if self.writable else None\r\n\r\n    def read(self):\r\n        while True:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            if not b:\r\n                break\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines = 0\r\n        return self.buffer.read()\r\n\r\n    def readline(self):\r\n        while self.newlines == 0:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            self.newlines = b.count(b\"\\n\") + (not b)\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines -= 1\r\n        return self.buffer.readline()\r\n\r\n    def flush(self):\r\n        if self.writable:\r\n            os.write(self._fd, self.buffer.getvalue())\r\n            self.buffer.truncate(0), self.buffer.seek(0)\r\n\r\n\r\nclass IOWrapper(IOBase):\r\n    def __init__(self, file):\r\n        self.buffer = FastIO(file)\r\n        self.flush = self.buffer.flush\r\n        self.writable = self.buffer.writable\r\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\r\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\r\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\r\n\r\n\r\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\r\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\r\n\r\n\r\n# print = lambda d: sys.stdout.write(str(d)+\"\\n\")\r\ndef read_int_list(): return list(map(int, input().split()))\r\ndef read_int_tuple(): return tuple(map(int, input().split()))\r\ndef read_int(): return int(input())\r\n\r\n\r\n# endregion\r\n\r\n### CODE HERE\r\n\r\n# f = open('inputs', 'r')\r\n# def input(): return f.readline().rstrip(\"\\r\\n\")\r\n\r\ndef solve(n, nums, m, edges):\r\n    seen = [False] * n\r\n    gs = []\r\n    for i in range(n):\r\n        if seen[i]: continue\r\n        gl = []\r\n        while not seen[i]:\r\n            gl.append(i)\r\n            seen[i] = True\r\n            i = nums[i]\r\n        if len(gl) > 1:\r\n            gs.append(gl)\r\n\r\n    for group in gs:\r\n        d = {u: i for i, u in enumerate(group)}\r\n        for u in group:\r\n            edges[u].sort(key=lambda t: (d[t[0]] - d[u]) % n)\r\n\r\n\r\n    top_graph = [[] for _ in range(m)]\r\n    indeg = [0] * m\r\n    for es in edges:\r\n        if len(es) < 2: continue\r\n        for i in range(len(es) - 1):\r\n            u, v = es[i][1], es[i + 1][1]\r\n            top_graph[u].append(v)\r\n            indeg[v] += 1\r\n    q = deque([u for u in range(m) if indeg[u] == 0])\r\n    res = []\r\n    while q:\r\n        u = q.popleft()\r\n        res.append(u + 1)\r\n        for v in top_graph[u]:\r\n            indeg[v] -= 1\r\n            if indeg[v] == 0:\r\n                q.append(v)\r\n    print(*res)\r\n\r\n\r\ndef main():\r\n    for _ in range(1):\r\n        n, m = read_int_tuple()\r\n        nums = [x - 1 for x in read_int_list()]\r\n        edges = [[] for _ in range(n)]\r\n        for i in range(m):\r\n            u, v = read_int_tuple()\r\n            edges[u - 1].append((v - 1, i))\r\n            edges[v - 1].append((u - 1, i))\r\n        solve(n, nums, m, edges)\r\n\r\nif __name__ == \"__main__\":\r\n    main()\r\n# cProfile.run(\"main()\")\r\n",
    "prob_desc_created_at": "1653230100",
    "tags": [
        "constructive algorithms",
        "dfs and similar",
        "graphs",
        "greedy",
        "math",
        "sortings",
        "trees"
    ],
    "hidden_unit_tests": ""
}
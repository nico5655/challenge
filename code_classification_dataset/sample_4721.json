{
    "prob_desc_time_limit": "3 seconds",
    "prob_desc_sample_outputs": "[\"8\\n10\\n-1\\n6\\n7\\n0\"]",
    "src_uid": "498b31f46ed24fb5fa7f126eaf377901",
    "prob_desc_notes": "NoteIn the first test case, selecting indices $$$2$$$ and $$$3$$$ costs $$$8$$$, which is the minimum.In the second test case, we can perform the following operations.   Select indices $$$1$$$ and $$$2$$$. It costs $$$2$$$, and $$$a$$$ is 110001 now.  Select indices $$$2$$$ and $$$3$$$. It costs $$$2$$$, and $$$a$$$ is 101001 now.  Select indices $$$3$$$ and $$$4$$$. It costs $$$2$$$, and $$$a$$$ is 100101 now.  Select indices $$$4$$$ and $$$5$$$. It costs $$$2$$$, and $$$a$$$ is 100011 now.  Select indices $$$5$$$ and $$$6$$$. It costs $$$2$$$, and $$$a$$$ is 100000 now. The total cost is $$$10$$$.In the third test case, we cannot make $$$a$$$ equal to $$$b$$$ using any number of operations.In the fourth test case, we can perform the following operations.   Select indices $$$3$$$ and $$$6$$$. It costs $$$3$$$, and $$$a$$$ is 0101011 now.  Select indices $$$4$$$ and $$$6$$$. It costs $$$3$$$, and $$$a$$$ is 0100001 now. The total cost is $$$6$$$.In the fifth test case, we can perform the following operations.   Select indices $$$1$$$ and $$$6$$$. It costs $$$4$$$, and $$$a$$$ is 110000 now.  Select indices $$$2$$$ and $$$3$$$. It costs $$$3$$$, and $$$a$$$ is 101000 now. The total cost is $$$7$$$.In the sixth test case, we don't have to perform any operation.",
    "prob_desc_description": "This is the hard version of this problem. In this version, $$$n \\le 5000$$$ holds, and this version has no restriction between $$$x$$$ and $$$y$$$. You can make hacks only if both versions of the problem are solved.You are given two binary strings $$$a$$$ and $$$b$$$, both of length $$$n$$$. You can do the following operation any number of times (possibly zero).   Select two indices $$$l$$$ and $$$r$$$ ($$$l &lt; r$$$).  Change $$$a_l$$$ to $$$(1 - a_l)$$$, and $$$a_r$$$ to $$$(1 - a_r)$$$.  If $$$l + 1 = r$$$, the cost of the operation is $$$x$$$. Otherwise, the cost is $$$y$$$. You have to find the minimum cost needed to make $$$a$$$ equal to $$$b$$$ or say there is no way to do so.",
    "prob_desc_output_spec": "For each test case, if there is no way to make $$$a$$$ equal to $$$b$$$, print $$$-1$$$. Otherwise, print the minimum cost needed to make $$$a$$$ equal to $$$b$$$.",
    "prob_desc_input_spec": "The first line contains one integer $$$t$$$ ($$$1 \\le t \\le 1000$$$) — the number of test cases. Each test case consists of three lines. The first line of each test case contains three integers $$$n$$$, $$$x$$$, and $$$y$$$ ($$$5 \\le n \\le 5000$$$, $$$1 \\le x, y \\le 10^9$$$) — the length of the strings, and the costs per operation. The second line of each test case contains the string $$$a$$$ of length $$$n$$$. The string only consists of digits $$$0$$$ and $$$1$$$. The third line of each test case contains the string $$$b$$$ of length $$$n$$$. The string only consists of digits $$$0$$$ and $$$1$$$. It is guaranteed that the sum of $$$n$$$ over all test cases doesn't exceed $$$5000$$$.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3-64",
    "lang_cluster": "Python",
    "difficulty": 2000,
    "file_name": "train_104.jsonl",
    "code_uid": "2c62c1b5952c13553a5a8896e6fab94e",
    "prob_desc_memory_limit": "512 megabytes",
    "prob_desc_sample_inputs": "[\"6\\n\\n5 8 9\\n\\n01001\\n\\n00101\\n\\n6 2 11\\n\\n000001\\n\\n100000\\n\\n5 7 2\\n\\n01000\\n\\n11011\\n\\n7 8 3\\n\\n0111001\\n\\n0100001\\n\\n6 3 4\\n\\n010001\\n\\n101000\\n\\n5 10 1\\n\\n01100\\n\\n01100\"]",
    "exec_outcome": "PASSED",
    "source_code": "from sys import stdin , setrecursionlimit\r\ninput = stdin.readline\r\nsetrecursionlimit(10 ** 4)\r\n\r\ninp = lambda : list(map(int,input().split()))\r\n\r\n\"\"\"\r\nprev two thing is type1 or type2\r\ntype1 => 0\r\ntype2 => 1\r\n\"\"\"\r\n\r\ndef solve(i , j):\r\n\r\n    if(i == m - 1):\r\n        if(j == 0):return x\r\n        else:return y\r\n        \r\n    if(dp[i][j] != -1):return dp[i][j]\r\n\r\n    ans = solve(i + 2 , 1) + y\r\n    ans = min(ans , solve(i + 2 , 1) + (take[i + 1] - take[i]) * x)\r\n\r\n    if(j == 0):\r\n\r\n        if(take[i + 1] + 1 == take[i + 2]):\r\n            ans = min(ans , solve(i + 2 , 0) + x)\r\n        else:\r\n            ans = min(ans , solve(i + 2 , 1) + x)\r\n            ans = min(ans , solve(i + 2 , 0) + x + (take[i + 2] - take[i + 1] - 1) * x)\r\n\r\n    else:\r\n\r\n        if(take[i + 1] + 1 == take[i + 2]):\r\n            ans = min(ans , solve(i + 2 , 0) + y)\r\n        else:\r\n            ans = min(ans , solve(i + 2 , 1) + y)\r\n            ans = min(ans , solve(i + 2 , 0) + y + (take[i + 2] - take[i + 1] - 1) * x)\r\n    \r\n    dp[i][j] = ans\r\n    return ans\r\n    \r\ndef answer():\r\n\r\n    total = 0\r\n    for i in range(n):\r\n        total += (a[i] != b[i])\r\n\r\n    if(total == 0):return 0\r\n    if(total & 1):return -1\r\n\r\n\r\n    ans = 0\r\n    if(x >= y):\r\n        count = 0\r\n        for i in range(n - 1):\r\n\r\n            if((a[i] != b[i]) and (a[i + 1] != b[i + 1])):\r\n                count += 1\r\n\r\n\r\n        if(count == 1 and total == 2):ans = x\r\n        else:ans = (total // 2) * y\r\n    else:\r\n\r\n        global dp , take , m\r\n\r\n        take = []\r\n        for i in range(n):\r\n            if(a[i] != b[i]):\r\n                take.append(i)\r\n\r\n        m = len(take)\r\n        dp = [[-1 , -1] for i in range(m + 1)]\r\n\r\n        if(take[0] + 1 == take[1]):ans = solve(1 , 0)\r\n        else:\r\n            ans = solve(1 , 0) + (take[1] - take[0] - 1) * x\r\n            ans = min(ans , solve(1 , 1))\r\n        \r\n        \r\n    return ans\r\n\r\n\r\nfor T in range(int(input())):\r\n\r\n    n , x , y = inp()\r\n\r\n    a = list(input().strip())\r\n    b = list(input().strip())\r\n    x = min(x , 2 * y)\r\n\r\n    print(answer())\r\n\r\n",
    "prob_desc_created_at": "1663598100",
    "tags": [
        "dp",
        "greedy"
    ],
    "hidden_unit_tests": ""
}
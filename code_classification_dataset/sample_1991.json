{
    "prob_desc_time_limit": "1 second",
    "prob_desc_sample_outputs": "[\"3 6\\n5 1\\n2 4\", \"4 5\\n1 6\\n2 7\\n3 8\"]",
    "src_uid": "47a9d72651f1407de89e28fb4b142367",
    "prob_desc_notes": "NoteIn the first example, here is what points and their corresponding bounding boxes look like (drawn in two dimensions for simplicity, as all points lie on $$$z = 0$$$ plane). Note that order of removing matters: for example, points $$$5$$$ and $$$1$$$ don't form a perfectly balanced pair initially, but they do after point $$$3$$$ is removed.   ",
    "prob_desc_description": "This is an easier version of the problem. In this version, $$$n \\le 2000$$$.There are $$$n$$$ distinct points in three-dimensional space numbered from $$$1$$$ to $$$n$$$. The $$$i$$$-th point has coordinates $$$(x_i, y_i, z_i)$$$. The number of points $$$n$$$ is even.You'd like to remove all $$$n$$$ points using a sequence of $$$\\frac{n}{2}$$$ snaps. In one snap, you can remove any two points $$$a$$$ and $$$b$$$ that have not been removed yet and form a perfectly balanced pair. A pair of points $$$a$$$ and $$$b$$$ is perfectly balanced if no other point $$$c$$$ (that has not been removed yet) lies within the axis-aligned minimum bounding box of points $$$a$$$ and $$$b$$$.Formally, point $$$c$$$ lies within the axis-aligned minimum bounding box of points $$$a$$$ and $$$b$$$ if and only if $$$\\min(x_a, x_b) \\le x_c \\le \\max(x_a, x_b)$$$, $$$\\min(y_a, y_b) \\le y_c \\le \\max(y_a, y_b)$$$, and $$$\\min(z_a, z_b) \\le z_c \\le \\max(z_a, z_b)$$$. Note that the bounding box might be degenerate. Find a way to remove all points in $$$\\frac{n}{2}$$$ snaps.",
    "prob_desc_output_spec": "Output $$$\\frac{n}{2}$$$ pairs of integers $$$a_i, b_i$$$ ($$$1 \\le a_i, b_i \\le n$$$), denoting the indices of points removed on snap $$$i$$$. Every integer between $$$1$$$ and $$$n$$$, inclusive, must appear in your output exactly once. We can show that it is always possible to remove all points. If there are many solutions, output any of them.",
    "prob_desc_input_spec": "The first line contains a single integer $$$n$$$ ($$$2 \\le n \\le 2000$$$; $$$n$$$ is even), denoting the number of points. Each of the next $$$n$$$ lines contains three integers $$$x_i$$$, $$$y_i$$$, $$$z_i$$$ ($$$-10^8 \\le x_i, y_i, z_i \\le 10^8$$$), denoting the coordinates of the $$$i$$$-th point. No two points coincide.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3",
    "lang_cluster": "Python",
    "difficulty": 1700,
    "file_name": "train_015.jsonl",
    "code_uid": "a907bbeaa23cc60df6412d4fc2407035",
    "prob_desc_memory_limit": "512 megabytes",
    "prob_desc_sample_inputs": "[\"6\\n3 1 0\\n0 3 0\\n2 2 0\\n1 0 0\\n1 3 0\\n0 1 0\", \"8\\n0 1 1\\n1 0 1\\n1 1 0\\n1 1 1\\n2 2 2\\n3 2 2\\n2 3 2\\n2 2 3\"]",
    "exec_outcome": "PASSED",
    "source_code": "#from bisect import bisect_left as bl                #c++ lowerbound bl(array,element)\n#from bisect import bisect_right as br               #c++ upperbound br(array,element)\n#from __future__ import print_function, division    #while using python2\n\nimport math\ndef modinv(n,p):\n    return pow(n,p-2,p)\n\ndef dist(x1, y1, z1, x2, y2, z2):\n    # return math.sqrt((x2-x1)**2 + (y2-y1)**2 + (z2-z1)**2)\n    return abs(x2 - x1) + abs(y2 - y1) + abs(z2 - z1)\n\ndef main():\n    #sys.stdin = open('input.txt', 'r')\n    #sys.stdout = open('output.txt', 'w')\n\n    n = int(input())\n    points = []\n    for i in range(n):\n        pts = [int(x) for x in input().split()]\n        pts.append(i)\n        points.append(pts)\n    \n    answers = []\n    visited = [0] * (n+1)\n    # print(points)\n    for i in range(n):\n        if visited[i] == 1:\n            continue\n        min_d = 1e18\n        min_j = -1\n        x1, y1, z1, temp = points[i]\n        for j in range(i+1,n):\n            if visited[j] == 1:\n                continue\n            x2, y2, z2, temp2 = points[j]\n            if dist(x1, y1, z1, x2, y2, z2) < min_d:\n                min_d = dist(x1, y1, z1, x2, y2, z2)\n                min_j = j\n        \n        if min_j != -1:\n            answers.append([points[i][-1], points[min_j][-1]])\n            visited[points[i][-1]] = 1\n            visited[points[min_j][-1]] = 1\n    # print(answers)\n    for p in answers:\n        print(p[0] + 1, p[1] + 1)\n\n#------------------ Python 2 and 3 footer by Pajenegod and c1729-----------------------------------------\npy2 = round(0.5)\nif py2:\n    from future_builtins import ascii, filter, hex, map, oct, zip\n    range = xrange\n\nimport os, sys\nfrom io import IOBase, BytesIO\n\nBUFSIZE = 8192\nclass FastIO(BytesIO):\n    newlines = 0\n    def __init__(self, file):\n        self._file = file\n        self._fd = file.fileno()\n        self.writable = \"x\" in file.mode or \"w\" in file.mode\n        self.write = super(FastIO, self).write if self.writable else None\n\n    def _fill(self):\n        s = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n        self.seek((self.tell(), self.seek(0,2), super(FastIO, self).write(s))[0])\n        return s\n    def read(self):\n        while self._fill(): pass\n        return super(FastIO,self).read()\n\n    def readline(self):\n        while self.newlines == 0:\n            s = self._fill(); self.newlines = s.count(b\"\\n\") + (not s)\n        self.newlines -= 1\n        return super(FastIO, self).readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.getvalue())\n            self.truncate(0), self.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        if py2:\n            self.write = self.buffer.write\n            self.read = self.buffer.read\n            self.readline = self.buffer.readline\n        else:\n            self.write = lambda s:self.buffer.write(s.encode('ascii'))\n            self.read = lambda:self.buffer.read().decode('ascii')\n            self.readline = lambda:self.buffer.readline().decode('ascii')\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip('\\r\\n')\n\nif __name__ == '__main__':\n   main()\n",
    "prob_desc_created_at": "1571236500",
    "tags": [
        "constructive algorithms",
        "geometry",
        "greedy"
    ],
    "hidden_unit_tests": ""
}
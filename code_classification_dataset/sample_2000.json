{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"5\", \"Greed is good\"]",
    "src_uid": "31cd0e60b43a0b3081dc53c9713934fa",
    "prob_desc_notes": "NoteIn the first sample, Bob should give Alfred a single coin worth $5. This creates the situation described in the problem statement.In the second sample, there is no set of coins that will cause Alfred's algorithm to fail.",
    "prob_desc_description": "Alfred wants to buy a toy moose that costs c dollars. The store doesn’t give change, so he must give the store exactly c dollars, no more and no less. He has n coins. To make c dollars from his coins, he follows the following algorithm: let S be the set of coins being used. S is initially empty. Alfred repeatedly adds to S the highest-valued coin he has such that the total value of the coins in S after adding the coin doesn’t exceed c. If there is no such coin, and the value of the coins in S is still less than c, he gives up and goes home. Note that Alfred never removes a coin from S after adding it.As a programmer, you might be aware that Alfred’s algorithm can fail even when there is a set of coins with value exactly c. For example, if Alfred has one coin worth $3, one coin worth $4, and two coins worth $5, and the moose costs $12, then Alfred will add both of the $5 coins to S and then give up, since adding any other coin would cause the value of the coins in S to exceed $12. Of course, Alfred could instead combine one $3 coin, one $4 coin, and one $5 coin to reach the total.Bob tried to convince Alfred that his algorithm was flawed, but Alfred didn’t believe him. Now Bob wants to give Alfred some coins (in addition to those that Alfred already has) such that Alfred’s algorithm fails. Bob can give Alfred any number of coins of any denomination (subject to the constraint that each coin must be worth a positive integer number of dollars). There can be multiple coins of a single denomination. He would like to minimize the total value of the coins he gives Alfred. Please find this minimum value. If there is no solution, print \"Greed is good\". You can assume that the answer, if it exists, is positive. In other words, Alfred's algorithm will work if Bob doesn't give him any coins.",
    "prob_desc_output_spec": "If there is a solution, print the minimum possible total value of the coins in a solution. Otherwise, print \"Greed is good\" (without quotes).",
    "prob_desc_input_spec": "The first line contains c (1 ≤ c ≤ 200 000) — the price Alfred wants to pay. The second line contains n (1 ≤ n ≤ 200 000) — the number of coins Alfred initially has. Then n lines follow, each containing a single integer x (1 ≤ x ≤ c) representing the value of one of Alfred's coins.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "Python 2",
    "lang_cluster": "Python",
    "difficulty": 2600,
    "file_name": "train_015.jsonl",
    "code_uid": "72d0dc67a84ba4f60cb31e0b7837b2e8",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"12\\n3\\n5\\n3\\n4\", \"50\\n8\\n1\\n2\\n4\\n8\\n16\\n37\\n37\\n37\"]",
    "exec_outcome": "PASSED",
    "source_code": "#!/usr/bin/env python\nimport sys\n\nalf_goal = int(sys.stdin.readline().strip())\nnum_coins = int(sys.stdin.readline().strip())\nalf_coins = []\nfor i in range(num_coins):\n    alf_coins.append(int(sys.stdin.readline().strip()))\n\ncnt = [0]*(alf_goal+1) # this is just the count of the coins you have.\npre = [0]*(alf_goal+1) # this is something like \"The biggest coin less than or\n    # equal to x\" for any x.\n\n# so in the example 1, where he wants $12 and he has $3, $4, and $5:\n# cnt = [0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0]\n# pre = [0, 0, 0, 3, 4, 5, 5, 5, 5, 5, 5, 5, 5] \n\ndef does_this_coin_screw_alf(my_coin):\n    change_to_make_still = alf_goal # counting down from his goal as he grabs coins\n    naj = alf_goal # I think \"naj\" is like... the index of the next coin Alf is\n    # going to take? \n    # I would understand this _so much_ faster if this coder just picked a\n    # reasonable name instead of \"naj\".\n    while change_to_make_still > 0: # if change_to_make_still == 0, Alf hit the\n            # target and made exact change, Alf wins.\n        next_coin_val = pre[naj] # value of the next coin Alf is gonna get.\n        if next_coin_val == 0:\n            return True # if you go to get a coin and you can't, you win?\n            # this sorta makes sense: imagine if change_to_make_still were 1 or\n            # 2. (it can't be 0 because then we wouldn't have executed this\n            # loop once more.)\n        if next_coin_val <= my_coin and my_coin <= change_to_make_still:\n            # if we're calling this method on a big coin value (like 6, say), then\n            # Alf will ignore next_coin for a minute, and take the big coin\n            # instead.\n            change_to_make_still -= my_coin\n            my_coin = 0 # now there's no more big coin.\n            naj = next_coin_val # the next coin Alf will take is the coin he was\n            # about to take, before he got distracted by the shiny 'my_coin'.\n        else:\n            # this is the common case.\n            num_coins_to_take = min(cnt[next_coin_val], change_to_make_still/next_coin_val)\n            change_to_make_still -= num_coins_to_take * next_coin_val\n            # take as many $t-coins as you can away from sum\n            naj = min(change_to_make_still, next_coin_val-1)\n            # then naj = either $1 less, or the current amount you've got\n\n    # We only get here if we got change_to_make_still down to 0, which means\n    # we failed to screw Alf and he made change.\n    return False\n\n# Initialize cnt and pre:\nfor coin in alf_coins:\n    cnt[coin] += 1\nfor i in range(1, alf_goal+1):\n    if cnt[i]:\n        pre[i] = i\n    else:\n        pre[i] = pre[i-1]\n\n# Just brute force check each number:\nfor i in xrange(1, alf_goal):\n    if does_this_coin_screw_alf(i):\n        print i\n        exit(0)\n\n# If we never found one and exited yet, welp:\nprint \"Greed is good\"\n",
    "prob_desc_created_at": "1477148700",
    "tags": [
        "greedy",
        "brute force"
    ],
    "hidden_unit_tests": ""
}
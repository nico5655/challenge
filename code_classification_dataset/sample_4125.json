{
    "prob_desc_time_limit": "3 seconds",
    "prob_desc_sample_outputs": "[\"Possible\\n3\\n1 2 3\\n3\\n1 4 3\", \"Impossible\", \"Impossible\"]",
    "src_uid": "2847383385097c4ab8e5ee1f06580d0e",
    "prob_desc_notes": null,
    "prob_desc_description": "Leslie and Leon entered a labyrinth. The labyrinth consists of $$$n$$$ halls and $$$m$$$ one-way passages between them. The halls are numbered from $$$1$$$ to $$$n$$$.Leslie and Leon start their journey in the hall $$$s$$$. Right away, they quarrel and decide to explore the labyrinth separately. However, they want to meet again at the end of their journey.To help Leslie and Leon, your task is to find two different paths from the given hall $$$s$$$ to some other hall $$$t$$$, such that these two paths do not share halls other than the staring hall $$$s$$$ and the ending hall $$$t$$$. The hall $$$t$$$ has not been determined yet, so you can choose any of the labyrinth's halls as $$$t$$$ except $$$s$$$.Leslie's and Leon's paths do not have to be the shortest ones, but their paths must be simple, visiting any hall at most once. Also, they cannot visit any common halls except $$$s$$$ and $$$t$$$ during their journey, even at different times.",
    "prob_desc_output_spec": "If it is possible to find the desired two paths, output \"Possible\", otherwise output \"Impossible\". If the answer exists, output two path descriptions. Each description occupies two lines. The first line of the description contains an integer $$$h$$$ ($$$2 \\le h \\le n$$$) — the number of halls in a path, and the second line contains distinct integers $$$w_1, w_2, \\dots, w_h$$$ ($$$w_1 = s$$$; $$$1 \\le w_j \\le n$$$; $$$w_h = t$$$) — the halls in the path in the order of passing. Both paths must end at the same vertex $$$t$$$. The paths must be different, and all intermediate halls in these paths must be distinct.",
    "prob_desc_input_spec": "The first line contains three integers $$$n$$$, $$$m$$$, and $$$s$$$, where $$$n$$$ ($$$2 \\le n \\le 2 \\cdot 10^5$$$) is the number of vertices, $$$m$$$ ($$$0 \\le m \\le 2 \\cdot 10^5$$$) is the number of edges in the labyrinth, and $$$s$$$ ($$$1 \\le s \\le n$$$) is the starting hall. Then $$$m$$$ lines with descriptions of passages follow. Each description contains two integers $$$u_i$$$, $$$v_i$$$ ($$$1 \\le u_i, v_i \\le n$$$; $$$u_i \\neq v_i$$$), denoting a passage from the hall $$$u_i$$$ to the hall $$$v_i$$$. The passages are one-way. Each tuple $$$(u_i, v_i)$$$ is present in the input at most once. The labyrinth can contain cycles and is not necessarily connected in any way.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3-64",
    "lang_cluster": "Python",
    "difficulty": 1800,
    "file_name": "train_091.jsonl",
    "code_uid": "75d196843daed1b34b5d50f6ba0e4a47",
    "prob_desc_memory_limit": "512 megabytes",
    "prob_desc_sample_inputs": "[\"5 5 1\\n1 2\\n2 3\\n1 4\\n4 3\\n3 5\", \"5 5 1\\n1 2\\n2 3\\n3 4\\n2 5\\n5 4\", \"3 3 2\\n1 2\\n2 3\\n3 1\"]",
    "exec_outcome": "PASSED",
    "source_code": "import sys\n\ninput = sys.stdin.readline\n\n\ndef gen_input():\n    while True:\n        yield [int(c) for c in input().split()]\n\n\ndef gen_fake1():\n    yield [5, 5, 1]\n    yield [1, 2]\n    yield [2, 3]\n    yield [1, 4]\n    yield [4, 3]\n    yield [3, 5]\n\n\ndef gen_fake():\n    yield [3, 3, 2]\n    yield [1, 2]\n    yield [2, 3]\n    yield [3, 1]\n\n\ndef gen_fake3():\n    yield [5, 5, 1]\n    yield [1, 2]\n    yield [2, 3]\n    yield [3, 4]\n    yield [2, 5]\n    yield [5, 4]\n\n\ndef ints(g=gen_input()):\n    return next(g)\n\n\nn, m, s = ints()\ns -= 1\nv = [[] for _ in range(n)]\n\nfor _ in range(m):\n    a, b = ints()\n    v[a - 1].append(b - 1)\n\n\ndef down(v, s, q):\n    \"\"\"nodes reachable from s through q\"\"\"\n    n = len(v)\n    vis = [False] * n\n    vis[s] = True\n    back = [-1] * n\n    back[q] = s\n    op = [q]  # open nodes\n\n    ret = set()\n    while op:\n        x = op.pop()\n        ret.add(x)\n        vis[x] = True\n        for y in v[x]:\n            if not vis[y]:\n                op.append(y)\n                back[y] = x\n    return ret, back\n\n\ndef backtrack(back, start):\n    ret = []\n    while start != -1:\n        ret.append(start)\n        start = back[start]\n    return list(reversed(ret))\n\n\ndef prune_common(path1, path2):\n    for i, node in enumerate(path1):\n        if i and node in path2:\n            return path1[:i+1], path2[:path2.index(node) + 1]\n    return path1, path2\n\n\ndef go(v=v, s=s):\n    n = len(v)\n    vis = [-1] * n\n    vis[s] = s\n\n    back = [-1] * n\n    for q in v[s]:\n        if vis[q] >= 0:\n            return [s, q], backtrack(back, q)\n        op = [q]\n        back[q] = s\n        while op:\n            x = op.pop()\n            vis[x] = q\n            for y in v[x]:\n                if vis[y] == -1:\n                    op.append(y)\n                    back[y] = x\n                elif vis[y] != s and vis[y] >= 0 and vis[y] != q:\n                    return backtrack(back, y), backtrack(back, x) + [y]\n\n\n# def go():\n#     if len(v[s]) <= 1:\n#         return\n#     d = [0] * len(v[s])\n#     d[0] = down(v, s, v[s][0])[0]\n#     vis_total = d[0]\n#     for i in range(1, len(d)):\n#         d[i] = down(v, s, v[s][i])[0]\n#         vis_new = vis_total | d[i]\n#         if len(vis_new) < len(vis_total) + len(d[i]):\n#             break\n#         vis_total = vis_new\n#     else:\n#         return\n\n#     for j in range(0, i):\n#         s12 = d[i] & d[j]\n#         if s12:\n#             desto = s12.pop()\n#             back1 = down(v, s, v[s][i])[1]\n#             back2 = down(v, s, v[s][j])[1]\n\n#             path1 = backtrack(back1, desto)\n#             path2 = backtrack(back2, desto)\n#             #print(path1, path2)\n#             path1, path2 = prune_common(path1, path2)\n#             path1 = [x+1 for x in path1]\n#             path2 = [x+1 for x in path2]\n#             return path1, path2\n\ndef array_plus1(v):\n    for i in range(len(v)):\n        v[i] += 1\n\n\np12 = go()\n\nif p12:\n    print(\"Possible\")\n    p1, p2 = p12\n    array_plus1(p1)\n    array_plus1(p2)\n\n    print(len(p1))\n    print(*p1)\n    print(len(p2))\n    print(*p2)\nelse:\n    print(\"Impossible\")\n",
    "prob_desc_created_at": "1649837100",
    "tags": [
        "dfs and similar",
        "graphs"
    ],
    "hidden_unit_tests": ""
}
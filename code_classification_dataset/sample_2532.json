{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"4361\", \"60\", \"3250\", \"768500592\"]",
    "src_uid": "8f34d2a146ff44ff4ea82fb6481d10e2",
    "prob_desc_notes": "NoteHere is the graph for the first example:  Some maximum weight paths are:   length $$$1$$$: edges $$$(1, 7)$$$ — weight $$$3$$$;  length $$$2$$$: edges $$$(1, 2), (2, 3)$$$ — weight $$$1+10=11$$$;  length $$$3$$$: edges $$$(1, 5), (5, 6), (6, 4)$$$ — weight $$$2+7+15=24$$$;  length $$$4$$$: edges $$$(1, 5), (5, 6), (6, 4), (6, 4)$$$ — weight $$$2+7+15+15=39$$$;  $$$\\dots$$$ So the answer is the sum of $$$25$$$ terms: $$$3+11+24+39+\\dots$$$In the second example the maximum weight paths have weights $$$4$$$, $$$8$$$, $$$12$$$, $$$16$$$ and $$$20$$$.",
    "prob_desc_description": "You are given a simple weighted connected undirected graph, consisting of $$$n$$$ vertices and $$$m$$$ edges.A path in the graph of length $$$k$$$ is a sequence of $$$k+1$$$ vertices $$$v_1, v_2, \\dots, v_{k+1}$$$ such that for each $$$i$$$ $$$(1 \\le i \\le k)$$$ the edge $$$(v_i, v_{i+1})$$$ is present in the graph. A path from some vertex $$$v$$$ also has vertex $$$v_1=v$$$. Note that edges and vertices are allowed to be included in the path multiple times.The weight of the path is the total weight of edges in it.For each $$$i$$$ from $$$1$$$ to $$$q$$$ consider a path from vertex $$$1$$$ of length $$$i$$$ of the maximum weight. What is the sum of weights of these $$$q$$$ paths?Answer can be quite large, so print it modulo $$$10^9+7$$$.",
    "prob_desc_output_spec": "Print a single integer — the sum of the weights of the paths from vertex $$$1$$$ of maximum weights of lengths $$$1, 2, \\dots, q$$$ modulo $$$10^9+7$$$.",
    "prob_desc_input_spec": "The first line contains a three integers $$$n$$$, $$$m$$$, $$$q$$$ ($$$2 \\le n \\le 2000$$$; $$$n - 1 \\le m \\le 2000$$$; $$$m \\le q \\le 10^9$$$) — the number of vertices in the graph, the number of edges in the graph and the number of lengths that should be included in the answer. Each of the next $$$m$$$ lines contains a description of an edge: three integers $$$v$$$, $$$u$$$, $$$w$$$ ($$$1 \\le v, u \\le n$$$; $$$1 \\le w \\le 10^6$$$) — two vertices $$$v$$$ and $$$u$$$ are connected by an undirected edge with weight $$$w$$$. The graph contains no loops and no multiple edges. It is guaranteed that the given edges form a connected graph.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 2",
    "lang_cluster": "Python",
    "difficulty": 2700,
    "file_name": "train_024.jsonl",
    "code_uid": "1aa1977df1e9fafb49fafd64efeb470a",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"7 8 25\\n1 2 1\\n2 3 10\\n3 4 2\\n1 5 2\\n5 6 7\\n6 4 15\\n5 3 1\\n1 7 3\", \"2 1 5\\n1 2 4\", \"15 15 23\\n13 10 12\\n11 14 12\\n2 15 5\\n4 10 8\\n10 2 4\\n10 7 5\\n3 10 1\\n5 6 11\\n1 13 8\\n9 15 4\\n4 2 9\\n11 15 1\\n11 12 14\\n10 8 12\\n3 6 11\", \"5 10 10000000\\n2 4 798\\n1 5 824\\n5 2 558\\n4 1 288\\n3 4 1890\\n3 1 134\\n2 3 1485\\n4 5 284\\n3 5 1025\\n1 2 649\"]",
    "exec_outcome": "PASSED",
    "source_code": "import sys\nrange = xrange\ninput = raw_input\n\nn,m,q = [int(x) for x in input().split()]\n\nV = []\nW = []\ncoupl = [[] for _ in range(n)]\nfor _ in range(m):\n    a,b,w = [int(x) - 1 for x in input().split()]\n    w += 1\n    W.append(w)\n\n    eind = len(V)\n    V.append(b)\n    V.append(a)\n    coupl[a].append(eind)\n    coupl[b].append(eind ^ 1)\n\nDP = [[-1]*n for _ in range(n)]\nDP[0][0] = 0\nfor j in range(1, n):\n    prevDP = DP[j - 1]\n    newDP = DP[j]\n    for node in range(n):\n        if prevDP[node] == -1:\n            continue\n        for eind in coupl[node]:\n            nei = V[eind]\n            newDP[nei] = max(newDP[nei], prevDP[node] + W[eind >> 1])\n\nans = 0\nfor dp in DP:\n    ans += max(dp)\n\nM = DP[-1]\nK = []\nfor node in range(n):\n    K.append(max(W[eind >> 1] for eind in coupl[node]))\n\nK = [K[i] for i in range(n) if M[i] >= 0]\nM = [M[i] for i in range(n) if M[i] >= 0]\n\n\ndef solve(K, M, a, b):\n    hulli, hullx = convex_hull(K, M)\n\n    def sqsum(n):\n        return n * (n + 1) >> 1\n    \n    n = len(hulli)\n    ans = 0\n    # iterate over all n intervalls\n    for i in range(n):\n        j = hulli[i]\n        k,m = K[j],M[j]\n        l = max(a, hullx[i - 1] + 1 if i else a)\n        r = min(b - 1, hullx[i] if i + 1 < n else b - 1)\n\n        if l <= r:\n            ans += m * (r - l + 1)\n            ans += k * (sqsum(r) - sqsum(l - 1))\n    return ans\n\n\n#    hulli[0]            hulli[1]                hulli[-1]\n#\n# (inf, hullx[0]], (hullx[0], hullx[1]], ..., (hullx[-1], inf)\n#\ndef convex_hull(K, M, integer = True):\n    # assert len(K) == len(M)\n    if integer:\n        intersect = lambda i,j: (M[j] - M[i]) // (K[i] - K[j])\n    else:\n        intersect = lambda i,j: (M[j] - M[i]) / (K[i] - K[j])\n    \n    hulli = []\n    hullx = []\n    order = sorted(range(len(K)), key = K.__getitem__)\n    for i in order:\n        while True:\n            if not hulli:\n                hulli.append(i)\n                hullx.append(-1)\n                break\n            elif K[hulli[-1]] == K[i]:\n                if M[hulli[-1]] >= M[i]:\n                    break\n                hulli.pop()\n                hullx.pop()\n            else:\n                x = intersect(i, hulli[-1])\n                if len(hulli) > 1 and x <= hullx[-1]:\n                    hullx.pop()\n                    hulli.pop()\n                else:\n                    hullx.append(x)\n                    hulli.append(i)\n                    break\n    return hulli, hullx[1:]\n\nans += solve(K, M, 1, q - (n - 1) + 1)\n\nprint ans % (10 ** 9 + 7)\n",
    "prob_desc_created_at": "1591886100",
    "tags": [
        "dp",
        "binary search",
        "geometry",
        "graphs"
    ],
    "hidden_unit_tests": ""
}
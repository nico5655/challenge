{
    "prob_desc_time_limit": "5 seconds",
    "prob_desc_sample_outputs": "[\"? 1 2\\n40\\n? 2 5\\n90\\n? 3 1\\n56\\n? 4 5\\n18\\n! 8 10 7 6 9\\n? 1 5\\n312\\n? 2 4\\n675\\n! 24 25 28 27 26\\n? 1 4\\n4\\n? 2 5\\n10\\n? 3 7\\n21\\n? 6 2\\n6\\n? 2 5\\n10\\n? 1 2\\n2\\n? 1 2\\n2\\n? 1 2\\n2\\n? 1 2\\n2\\n? 1 2\\n2\\n! 1 2 3 4 5 6 7\"]",
    "src_uid": "d66b80cd06c28d2a62167be699996285",
    "prob_desc_notes": null,
    "prob_desc_description": "Do you know what tubular bells are? They are a musical instrument made up of cylindrical metal tubes. In an orchestra, tubular bells are used to mimic the ringing of bells.Mike has tubular bells, too! They consist of $$$n$$$ tubes, and each of the tubes has a length that can be expressed by a integer from $$$l$$$ to $$$r$$$ inclusive. It is clear that the lengths of all the tubes are different (it makes no sense to make the same tubes). It is also known that $$$r-l+1 = n$$$.Formally, we can say that Mike's tubular bells are described by a permutation $$$a$$$ of length $$$n$$$ that contains all numbers from $$$l$$$ to $$$r$$$ inclusive, with $$$a_i$$$ denoting the length of the $$$i$$$-th tube.You are offered an interesting task: to guess what Mike's instrument looks like. Simply, you must guess the permutation.Mike won't tell you $$$l$$$ or $$$r$$$. He will only tell you $$$n$$$, and will allow you to ask no more than $$$n + 5000$$$ queries.In each query, you name two positive integers $$$x$$$, $$$y$$$ such that $$$1 \\le x, y \\le n, x \\neq y$$$. In response to this query, the program written by Mike will give you $$$\\mathrm{lcm}(a_x, a_y)$$$, where $$$\\mathrm{lcm}(c,d)$$$ denotes the least common multiple of $$$c$$$ and $$$d$$$.Solve Mike's problem!",
    "prob_desc_output_spec": null,
    "prob_desc_input_spec": "Each test contains multiple test cases. The first line contains one positive integer $$$t$$$ ($$$1 \\le t \\le 20$$$), denoting the number of test cases. Description of the test cases follows. The single line of each test case contains one positive integer $$$n$$$ ($$$3 \\le n \\le 10^5$$$) — number of tubes in Mike's tubular bells. Also $$$1 \\le l \\le r \\le 2 \\cdot 10^5$$$, i.e. the lengths of the tubes do not exceed $$$2 \\cdot 10^5$$$. It is guaranteed that the sum of maximal number of queries (i.e. $$$n + 5000$$$) over all test cases does not exceed $$$10^5 + 5000$$$. It means that sum of $$$n$$$ does not exceed $$$10^5 + 5000 - t \\cdot 5000$$$.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3",
    "lang_cluster": "Python",
    "difficulty": 2900,
    "file_name": "train_086.jsonl",
    "code_uid": "c5702665f8d601c84bc7f7c259bd1fa0",
    "prob_desc_memory_limit": "512 megabytes",
    "prob_desc_sample_inputs": "[\"3\\n5\\n8 10 7 6 9\\n5\\n24 25 28 27 26\\n7\\n1 2 3 4 5 6 7\"]",
    "exec_outcome": "PASSED",
    "source_code": "import os\r\nimport sys\r\nfrom io import BytesIO, IOBase\r\n\r\nBUFSIZE = 8192\r\n\r\n\r\nclass FastIO(IOBase):\r\n    newlines = 0\r\n    \r\n    def __init__(self, file):\r\n        self._fd = file.fileno()\r\n        self.buffer = BytesIO()\r\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\r\n        self.write = self.buffer.write if self.writable else None\r\n    \r\n    def read(self):\r\n        while True:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            if not b:\r\n                break\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines = 0\r\n        return self.buffer.read()\r\n    \r\n    def readline(self):\r\n        while self.newlines == 0:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            self.newlines = b.count(b\"\\n\") + (not b)\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines -= 1\r\n        return self.buffer.readline()\r\n    \r\n    def flush(self):\r\n        if self.writable:\r\n            os.write(self._fd, self.buffer.getvalue())\r\n            self.buffer.truncate(0), self.buffer.seek(0)\r\n\r\n\r\nclass IOWrapper(IOBase):\r\n    def __init__(self, file):\r\n        self.buffer = FastIO(file)\r\n        self.flush = self.buffer.flush\r\n        self.writable = self.buffer.writable\r\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\r\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\r\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\r\n\r\n\r\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\r\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\r\n\r\nfrom random import shuffle, randint\r\n\r\nfrom math import gcd\r\n\r\n\r\ndef lcm(a, b): return (a * b) // gcd(a, b)\r\n\r\n\r\nfrom collections import Counter\r\n\r\n\r\ndef gcd(x, y):\r\n    \"\"\"greatest common divisor of x and y\"\"\"\r\n    while y:\r\n        x, y = y, x % y\r\n    return x\r\n\r\n\r\ndef memodict(f):\r\n    \"\"\"memoization decorator for a function taking a single argument\"\"\"\r\n    \r\n    class memodict(dict):\r\n        def __missing__(self, key):\r\n            ret = self[key] = f(key)\r\n            return ret\r\n    \r\n    return memodict().__getitem__\r\n\r\n\r\ndef pollard_rho(n):\r\n    \"\"\"returns a random factor of n\"\"\"\r\n    if n & 1 == 0:\r\n        return 2\r\n    if n % 3 == 0:\r\n        return 3\r\n    \r\n    s = ((n - 1) & (1 - n)).bit_length() - 1\r\n    d = n >> s\r\n    for a in [2, 325, 9375, 28178, 450775, 9780504, 1795265022]:\r\n        p = pow(a, d, n)\r\n        if p == 1 or p == n - 1 or a % n == 0:\r\n            continue\r\n        for _ in range(s):\r\n            prev = p\r\n            p = (p * p) % n\r\n            if p == 1:\r\n                return gcd(prev - 1, n)\r\n            if p == n - 1:\r\n                break\r\n        else:\r\n            for i in range(2, n):\r\n                x, y = i, (i * i + 1) % n\r\n                f = gcd(abs(x - y), n)\r\n                while f == 1:\r\n                    x, y = (x * x + 1) % n, (y * y + 1) % n\r\n                    y = (y * y + 1) % n\r\n                    f = gcd(abs(x - y), n)\r\n                if f != n:\r\n                    return f\r\n    return n\r\n\r\n\r\n@memodict\r\ndef prime_factors(n):\r\n    \"\"\"returns a Counter of the prime factorization of n\"\"\"\r\n    if n <= 1:\r\n        return Counter()\r\n    f = pollard_rho(n)\r\n    return Counter([n]) if f == n else prime_factors(f) + prime_factors(n // f)\r\n\r\n\r\ndef distinct_factors(n):\r\n    \"\"\"returns a list of all distinct factors of n\"\"\"\r\n    factors = [1]\r\n    for p, exp in prime_factors(n).items():\r\n        factors += [p ** i * factor for factor in factors for i in range(1, exp + 1)]\r\n    return factors\r\n\r\n\r\ndef all_factors(n):\r\n    \"\"\"returns a sorted list of all distinct factors of n\"\"\"\r\n    small, large = [], []\r\n    for i in range(1, int(n ** 0.5) + 1, 2 if n & 1 else 1):\r\n        if not n % i:\r\n            small.append(i)\r\n            large.append(n // i)\r\n    if small[-1] == large[-1]:\r\n        large.pop()\r\n    large.reverse()\r\n    small.extend(large)\r\n    return small\r\n\r\n\r\ndef get_prime_factors(n, isPrime):\r\n    \"\"\"Returns prime factorisation of n!\"\"\"\r\n    if n < 2:\r\n        return []\r\n    result = []\r\n    while isPrime[n] != 1:\r\n        result += [isPrime[n]]\r\n        n //= isPrime[n]\r\n    result += [n]\r\n    return result\r\n\r\n\r\nfor _ in range(int(input())):\r\n    n = int(input())\r\n    \r\n    \r\n    def query(i, j):\r\n        print(\"?\", i + 1, j + 1, flush=True)\r\n        return int(input())\r\n    \r\n    \r\n    if (n * (n - 1)) // 2 <= n + 5000:\r\n        a = ['!']\r\n        qx = {}\r\n        for i in range(n):\r\n            g = 0\r\n            for j in range(n):\r\n                if i == j: continue\r\n                if j > i:\r\n                    qx[i, j] = query(i, j)\r\n                    g = gcd(g, qx[(i, j)])\r\n                else:\r\n                    g = gcd(g, qx[(j, i)])\r\n            a += [g]\r\n        if n == 3:\r\n            d = False\r\n            for i in range(1, 4):\r\n                for j in range(1, 4):\r\n                    if i == j: continue\r\n                    if abs(a[i] - a[j]) == 2:\r\n                        k = 1 + 2 + 3 - i - j\r\n                        a[k] = (a[i] + a[j]) // 2\r\n                        d = True\r\n                        break\r\n                if d: break\r\n        print(*a, flush=True)\r\n        continue\r\n    \r\n    a = [-1] * n\r\n    indexes = list(range(n))\r\n    shuffle(indexes)\r\n    mx = 0\r\n    if n <= 9999:\r\n        di = {}\r\n        while indexes:\r\n            i = indexes.pop()\r\n            if not indexes:\r\n                j = n - 1 - i\r\n            else:\r\n                j = indexes.pop()\r\n            q = max(prime_factors(query(i, j)))\r\n            mx = max(mx, q)\r\n            di[q] = (i, j)\r\n        p, q = di[mx]\r\n        for i in range(n):\r\n            if i == p or i == q: continue\r\n            if query(i, q) % mx == 0:\r\n                p = q\r\n            break\r\n        a[p] = mx\r\n        for i in range(n):\r\n            if i != p:\r\n                a[i] = query(i, p) // mx\r\n        print(*['!'] + a, flush=True)\r\n        continue\r\n    idx2 = list(range(n))\r\n    shuffle(idx2)\r\n    while 1:\r\n        i = idx2.pop()\r\n        j = idx2.pop()\r\n        o = query(i, j)\r\n        pf = prime_factors(o)\r\n        if len(pf) == 2 and min(pf) ** 2 > 200000:\r\n            mx = max(pf)\r\n            p, q = i, j\r\n            for qq in range(30):\r\n                i = p\r\n                while i == p or i == q:\r\n                    i = idx2.pop()\r\n                if query(i, p) % mx:\r\n                    p = q\r\n                    break\r\n            break\r\n    a[p] = mx\r\n    mx2 = (mx, p)\r\n    for i in range(n):\r\n        if i != p:\r\n            a[i] = query(i, p) // mx\r\n            if a[i] * a[i] <= 220000:\r\n                a[i] = -1\r\n            else:\r\n                mp = max(prime_factors(a[i]))\r\n                if mp != a[i]: continue\r\n                if mp > mx2[0]:\r\n                    mx2 = (mp, i)\r\n    for i in range(n):\r\n        if a[i] == -1:\r\n            a[i] = query(i, mx2[1]) // mx2[0]\r\n    \r\n    print(*['!'] + a, flush=True)\r\n    continue",
    "prob_desc_created_at": "1629988500",
    "tags": [
        "interactive",
        "math",
        "number theory",
        "probabilities"
    ],
    "hidden_unit_tests": ""
}
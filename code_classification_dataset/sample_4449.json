{
    "prob_desc_time_limit": "3 seconds",
    "prob_desc_sample_outputs": "[\"YES\\n5 \\n0 10\\nNO\\nYES\\n0 43 \\n33 69\\nYES\\n1 0 3 3\\n1 1\"]",
    "src_uid": "3e08d07aa3762c262dcd23607febad7a",
    "prob_desc_notes": "NoteIn the image below you can see the sample solutions. Planned houses are shown in bright colours: pink and purple. Existing houses are dim. In test case $$$1$$$, the first planned house is located at point $$$0$$$, the second at point $$$10$$$. The existing house is located at point $$$5$$$ and is at a distance of $$$5$$$ from both planned houses.   It can be shown that there is no answer for test case $$$2$$$.   In test case $$$3$$$, the planned houses are located at points $$$33$$$ and $$$69$$$.   Note that in test case $$$4$$$, both plans are located at point $$$1$$$, where one of the existing houses is located at the same time. It is a correct placement.   ",
    "prob_desc_description": "There are $$$n$$$ houses in your city arranged on an axis at points $$$h_1, h_2, \\ldots, h_n$$$. You want to build a new house for yourself and consider two options where to place it: points $$$p_1$$$ and $$$p_2$$$.As you like visiting friends, you have calculated in advance the distances from both options to all existing houses. More formally, you have calculated two arrays $$$d_1$$$, $$$d_2$$$: $$$d_{i, j} = \\left|p_i - h_j\\right|$$$, where $$$|x|$$$ defines the absolute value of $$$x$$$.After a long time of inactivity you have forgotten the locations of the houses $$$h$$$ and the options $$$p_1$$$, $$$p_2$$$. But your diary still keeps two arrays — $$$d_1$$$, $$$d_2$$$, whose authenticity you doubt. Also, the values inside each array could be shuffled, so values at the same positions of $$$d_1$$$ and $$$d_2$$$ may correspond to different houses. Pay attention, that values from one array could not get to another, in other words, all values in the array $$$d_1$$$ correspond the distances from $$$p_1$$$ to the houses, and in the array $$$d_2$$$  — from $$$p_2$$$ to the houses.Also pay attention, that the locations of the houses $$$h_i$$$ and the considered options $$$p_j$$$ could match. For example, the next locations are correct: $$$h = \\{1, 0, 3, 3\\}$$$, $$$p = \\{1, 1\\}$$$, that could correspond to already shuffled $$$d_1 = \\{0, 2, 1, 2\\}$$$, $$$d_2 = \\{2, 2, 1, 0\\}$$$.Check whether there are locations of houses $$$h$$$ and considered points $$$p_1$$$, $$$p_2$$$, for which the founded arrays of distances would be correct. If it is possible, find appropriate locations of houses and considered options. ",
    "prob_desc_output_spec": "For each test case, output a single line \"NO\" if there is no answer. Otherwise output three lines. The first line must contain \"YES\". In the second line, print $$$n$$$ integers $$$h_1, h_2, \\ldots, h_n$$$. In the third line print two integers $$$p_1$$$, $$$p_2$$$. It must be satisfied that $$$0 \\le h_i, p_1, p_2 \\le 2 \\cdot 10^9$$$. We can show that if there is an answer, then there is one satisfying these constraints. If there are several answers, output any of them.",
    "prob_desc_input_spec": "The first line of the input contains a single integer $$$t$$$ ($$$1 \\le t \\le 10^3$$$) — the number of test cases. The description of test cases follows. The first line of each test case contains one integer $$$n$$$ ($$$1 \\le n \\le 10^3$$$) — the length of arrays $$$d_1$$$, $$$d_2$$$. The next two lines contain $$$n$$$ integers each: arrays $$$d_1$$$ and $$$d_2$$$ ($$$0 \\le d_{i, j} \\le 10^9$$$) respectively. It is guaranteed that the sum of $$$n$$$ over all test cases doesn't exceed $$$2 \\cdot 10^3$$$.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3-64",
    "lang_cluster": "Python",
    "difficulty": 2400,
    "file_name": "train_098.jsonl",
    "code_uid": "a729fa3d47d0a0154b2ede6ba53d3603",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"4\\n\\n1\\n\\n5\\n\\n5\\n\\n2\\n\\n10 12\\n\\n5 20\\n\\n2\\n\\n10 33\\n\\n26 69\\n\\n4\\n\\n0 2 1 2\\n\\n2 2 1 0\"]",
    "exec_outcome": "PASSED",
    "source_code": "import os, sys\r\nfrom io import BytesIO, IOBase\r\n\r\nfrom collections import defaultdict, deque, Counter\r\nfrom bisect import bisect_left, bisect_right\r\nfrom heapq import heappush, heappop\r\nfrom functools import lru_cache\r\nfrom itertools import accumulate\r\nimport math\r\n\r\n# Fast IO Region\r\nBUFSIZE = 8192\r\n\r\n\r\nclass FastIO(IOBase):\r\n    newlines = 0\r\n\r\n    def __init__(self, file):\r\n        self._fd = file.fileno()\r\n        self.buffer = BytesIO()\r\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\r\n        self.write = self.buffer.write if self.writable else None\r\n\r\n    def read(self):\r\n        while True:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            if not b:\r\n                break\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines = 0\r\n        return self.buffer.read()\r\n\r\n    def readline(self):\r\n        while self.newlines == 0:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            self.newlines = b.count(b\"\\n\") + (not b)\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines -= 1\r\n        return self.buffer.readline()\r\n\r\n    def flush(self):\r\n        if self.writable:\r\n            os.write(self._fd, self.buffer.getvalue())\r\n            self.buffer.truncate(0), self.buffer.seek(0)\r\n\r\n\r\nclass IOWrapper(IOBase):\r\n    def __init__(self, file):\r\n        self.buffer = FastIO(file)\r\n        self.flush = self.buffer.flush\r\n        self.writable = self.buffer.writable\r\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\r\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\r\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\r\n\r\n\r\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\r\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\r\n\r\n\r\nclass SortedList:\r\n    def __init__(self, iterable=[], _load=200):\r\n        \"\"\"Initialize sorted list instance.\"\"\"\r\n        values = sorted(iterable)\r\n        self._len = _len = len(values)\r\n        self._load = _load\r\n        self._lists = _lists = [values[i:i + _load] for i in range(0, _len, _load)]\r\n        self._list_lens = [len(_list) for _list in _lists]\r\n        self._mins = [_list[0] for _list in _lists]\r\n        self._fen_tree = []\r\n        self._rebuild = True\r\n\r\n    def _fen_build(self):\r\n        \"\"\"Build a fenwick tree instance.\"\"\"\r\n        self._fen_tree[:] = self._list_lens\r\n        _fen_tree = self._fen_tree\r\n        for i in range(len(_fen_tree)):\r\n            if i | i + 1 < len(_fen_tree):\r\n                _fen_tree[i | i + 1] += _fen_tree[i]\r\n        self._rebuild = False\r\n\r\n    def _fen_update(self, index, value):\r\n        \"\"\"Update `fen_tree[index] += value`.\"\"\"\r\n        if not self._rebuild:\r\n            _fen_tree = self._fen_tree\r\n            while index < len(_fen_tree):\r\n                _fen_tree[index] += value\r\n                index |= index + 1\r\n\r\n    def _fen_query(self, end):\r\n        \"\"\"Return `sum(_fen_tree[:end])`.\"\"\"\r\n        if self._rebuild:\r\n            self._fen_build()\r\n\r\n        _fen_tree = self._fen_tree\r\n        x = 0\r\n        while end:\r\n            x += _fen_tree[end - 1]\r\n            end &= end - 1\r\n        return x\r\n\r\n    def _fen_findkth(self, k):\r\n        \"\"\"Return a pair of (the largest `idx` such that `sum(_fen_tree[:idx]) <= k`, `k - sum(_fen_tree[:idx])`).\"\"\"\r\n        _list_lens = self._list_lens\r\n        if k < _list_lens[0]:\r\n            return 0, k\r\n        if k >= self._len - _list_lens[-1]:\r\n            return len(_list_lens) - 1, k + _list_lens[-1] - self._len\r\n        if self._rebuild:\r\n            self._fen_build()\r\n\r\n        _fen_tree = self._fen_tree\r\n        idx = -1\r\n        for d in reversed(range(len(_fen_tree).bit_length())):\r\n            right_idx = idx + (1 << d)\r\n            if right_idx < len(_fen_tree) and k >= _fen_tree[right_idx]:\r\n                idx = right_idx\r\n                k -= _fen_tree[idx]\r\n        return idx + 1, k\r\n\r\n    def _delete(self, pos, idx):\r\n        \"\"\"Delete value at the given `(pos, idx)`.\"\"\"\r\n        _lists = self._lists\r\n        _mins = self._mins\r\n        _list_lens = self._list_lens\r\n\r\n        self._len -= 1\r\n        self._fen_update(pos, -1)\r\n        del _lists[pos][idx]\r\n        _list_lens[pos] -= 1\r\n\r\n        if _list_lens[pos]:\r\n            _mins[pos] = _lists[pos][0]\r\n        else:\r\n            del _lists[pos]\r\n            del _list_lens[pos]\r\n            del _mins[pos]\r\n            self._rebuild = True\r\n\r\n    def _loc_left(self, value):\r\n        \"\"\"Return an index pair that corresponds to the first position of `value` in the sorted list.\"\"\"\r\n        if not self._len:\r\n            return 0, 0\r\n\r\n        _lists = self._lists\r\n        _mins = self._mins\r\n\r\n        lo, pos = -1, len(_lists) - 1\r\n        while lo + 1 < pos:\r\n            mi = (lo + pos) >> 1\r\n            if value <= _mins[mi]:\r\n                pos = mi\r\n            else:\r\n                lo = mi\r\n\r\n        if pos and value <= _lists[pos - 1][-1]:\r\n            pos -= 1\r\n\r\n        _list = _lists[pos]\r\n        lo, idx = -1, len(_list)\r\n        while lo + 1 < idx:\r\n            mi = (lo + idx) >> 1\r\n            if value <= _list[mi]:\r\n                idx = mi\r\n            else:\r\n                lo = mi\r\n\r\n        return pos, idx\r\n\r\n    def _loc_right(self, value):\r\n        \"\"\"Return an index pair that corresponds to the last position of `value` in the sorted list.\"\"\"\r\n        if not self._len:\r\n            return 0, 0\r\n\r\n        _lists = self._lists\r\n        _mins = self._mins\r\n\r\n        pos, hi = 0, len(_lists)\r\n        while pos + 1 < hi:\r\n            mi = (pos + hi) >> 1\r\n            if value < _mins[mi]:\r\n                hi = mi\r\n            else:\r\n                pos = mi\r\n\r\n        _list = _lists[pos]\r\n        lo, idx = -1, len(_list)\r\n        while lo + 1 < idx:\r\n            mi = (lo + idx) >> 1\r\n            if value < _list[mi]:\r\n                idx = mi\r\n            else:\r\n                lo = mi\r\n\r\n        return pos, idx\r\n\r\n    def add(self, value):\r\n        \"\"\"Add `value` to sorted list.\"\"\"\r\n        _load = self._load\r\n        _lists = self._lists\r\n        _mins = self._mins\r\n        _list_lens = self._list_lens\r\n\r\n        self._len += 1\r\n        if _lists:\r\n            pos, idx = self._loc_right(value)\r\n            self._fen_update(pos, 1)\r\n            _list = _lists[pos]\r\n            _list.insert(idx, value)\r\n            _list_lens[pos] += 1\r\n            _mins[pos] = _list[0]\r\n            if _load + _load < len(_list):\r\n                _lists.insert(pos + 1, _list[_load:])\r\n                _list_lens.insert(pos + 1, len(_list) - _load)\r\n                _mins.insert(pos + 1, _list[_load])\r\n                _list_lens[pos] = _load\r\n                del _list[_load:]\r\n                self._rebuild = True\r\n        else:\r\n            _lists.append([value])\r\n            _mins.append(value)\r\n            _list_lens.append(1)\r\n            self._rebuild = True\r\n\r\n    def discard(self, value):\r\n        \"\"\"Remove `value` from sorted list if it is a member.\"\"\"\r\n        _lists = self._lists\r\n        if _lists:\r\n            pos, idx = self._loc_right(value)\r\n            if idx and _lists[pos][idx - 1] == value:\r\n                self._delete(pos, idx - 1)\r\n\r\n    def remove(self, value):\r\n        \"\"\"Remove `value` from sorted list; `value` must be a member.\"\"\"\r\n        _len = self._len\r\n        self.discard(value)\r\n        if _len == self._len:\r\n            raise ValueError('{0!r} not in list'.format(value))\r\n\r\n    def pop(self, index=-1):\r\n        \"\"\"Remove and return value at `index` in sorted list.\"\"\"\r\n        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)\r\n        value = self._lists[pos][idx]\r\n        self._delete(pos, idx)\r\n        return value\r\n\r\n    def bisect_left(self, value):\r\n        \"\"\"Return the first index to insert `value` in the sorted list.\"\"\"\r\n        pos, idx = self._loc_left(value)\r\n        return self._fen_query(pos) + idx\r\n\r\n    def bisect_right(self, value):\r\n        \"\"\"Return the last index to insert `value` in the sorted list.\"\"\"\r\n        pos, idx = self._loc_right(value)\r\n        return self._fen_query(pos) + idx\r\n\r\n    def count(self, value):\r\n        \"\"\"Return number of occurrences of `value` in the sorted list.\"\"\"\r\n        return self.bisect_right(value) - self.bisect_left(value)\r\n\r\n    def __len__(self):\r\n        \"\"\"Return the size of the sorted list.\"\"\"\r\n        return self._len\r\n\r\n    def __getitem__(self, index):\r\n        \"\"\"Lookup value at `index` in sorted list.\"\"\"\r\n        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)\r\n        return self._lists[pos][idx]\r\n\r\n    def __delitem__(self, index):\r\n        \"\"\"Remove value at `index` from sorted list.\"\"\"\r\n        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)\r\n        self._delete(pos, idx)\r\n\r\n    def __contains__(self, value):\r\n        \"\"\"Return true if `value` is an element of the sorted list.\"\"\"\r\n        _lists = self._lists\r\n        if _lists:\r\n            pos, idx = self._loc_left(value)\r\n            return idx < len(_lists[pos]) and _lists[pos][idx] == value\r\n        return False\r\n\r\n    def __iter__(self):\r\n        \"\"\"Return an iterator over the sorted list.\"\"\"\r\n        return (value for _list in self._lists for value in _list)\r\n\r\n    def __reversed__(self):\r\n        \"\"\"Return a reverse iterator over the sorted list.\"\"\"\r\n        return (value for _list in reversed(self._lists) for value in reversed(_list))\r\n\r\n    def __repr__(self):\r\n        \"\"\"Return string representation of sorted list.\"\"\"\r\n        return 'SortedList({0})'.format(list(self))\r\n\r\n\r\nii = lambda: int(input())\r\nmii = lambda: map(int, input().split())\r\nlmii = lambda: list(map(int, input().split()))\r\nfrom sys import stdout\r\n\r\nmod = 10 ** 9 + 7\r\nN = 2 * 10 ** 9\r\n\r\n\r\ndef solve():\r\n    n = ii()\r\n    d1 = lmii()\r\n    d2 = lmii()\r\n    dt1 = [(k, 1) for i, k in enumerate(d1)]\r\n    dt2 = [(k, 2) for i, k in enumerate(d2)]\r\n    dt = dt1 + dt2\r\n    dt.sort()\r\n    stl = SortedList(dt)\r\n    s = sum(d1) + sum(d2)\r\n    if s % n == 0:\r\n        d = s // n\r\n        res = []\r\n        while stl:\r\n            k, w = stl.pop()\r\n            k_, w_ = d - k, 3 - w\r\n            if (k_, w_) not in stl:\r\n                break\r\n            stl.discard((k_, w_))\r\n            if w < w_:\r\n                res.append([k, k_])\r\n            else:\r\n                res.append([k_, k])\r\n        else:\r\n            p1, p2 = 0, d\r\n            h = []\r\n            for x, y in res:\r\n                h.append(x)\r\n            print('YES')\r\n            print(*h)\r\n            print(p1, p2)\r\n            return\r\n\r\n    k, w = dt[-1]\r\n    for i in range(len(dt) - 1):\r\n        k, w = dt[-1]\r\n        k_, w_ = dt[i]\r\n        if w_ == w:\r\n            continue\r\n        d = k - k_\r\n        stl = SortedList(dt)\r\n        res = []\r\n        while stl:\r\n            k, w = stl.pop()\r\n            if k >= d:\r\n                k_, w_ = k - d, 3 - w\r\n            else:\r\n                k_, w_ = d - k, 3 - w\r\n            if (k_, w_) not in stl:\r\n                break\r\n            stl.discard((k_, w_))\r\n            if w < w_:\r\n                res.append([k, k_])\r\n            else:\r\n                res.append([k_, k])\r\n        else:\r\n            res.sort(key=lambda x: (x[0] - x[1], -x[0]))\r\n            x, y = res[0]\r\n            if x + d == y:\r\n                p1 = res[0][0]\r\n                p2 = res[0][1]\r\n                h = []\r\n                for x, y in res:\r\n                    if x + d == y:\r\n                        h.append(p1 - x)\r\n                    elif x + y == d:\r\n                        h.append(p1 + x)\r\n                    elif x == y + d:\r\n                        h.append(p1 + x)\r\n                    else:\r\n                        raise Exception('?')\r\n            else:\r\n                res.sort(key=lambda x: (x[1] - x[0], -x[0]))\r\n                x, y = res[0]\r\n                if x != y + d:\r\n                    raise Exception('?')\r\n                p1 = N - x\r\n                p2 = N - y\r\n                h = []\r\n                for x, y in res:\r\n                    if x + d == y:\r\n                        h.append(p1 - x)\r\n                    else:\r\n                        h.append(p1 + x)\r\n            print('YES')\r\n            print(*h)\r\n            print(p1, p2)\r\n            break\r\n    else:\r\n        print('NO')\r\n\r\n\r\nfor _ in range(ii()):\r\n    solve()",
    "prob_desc_created_at": "1664721300",
    "tags": [
        "constructive algorithms",
        "data structures",
        "graph matchings",
        "greedy"
    ],
    "hidden_unit_tests": ""
}
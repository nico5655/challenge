{
    "prob_desc_time_limit": "1 second",
    "prob_desc_sample_outputs": "[\"6\", \"2\", \"120\"]",
    "src_uid": "dbc9b7ff6f495fe72a747d79006488c3",
    "prob_desc_notes": "NoteIn the first example, $$$[1, 2, 3]$$$ is a valid permutation as we can consider the index with value $$$3$$$ as the source and index with value $$$1$$$ as the sink. Thus, after conversion we get a beautiful array $$$[2, 2, 2]$$$, and the total cost would be $$$2$$$. We can show that this is the only transformation of this array that leads to a beautiful array. Similarly, we can check for other permutations too.In the second example, $$$[0, 0, 4, 4]$$$ and $$$[4, 4, 0, 0]$$$ are balanced permutations.In the third example, all permutations are balanced.",
    "prob_desc_description": "An array is called beautiful if all the elements in the array are equal.You can transform an array using the following steps any number of times:   Choose two indices $$$i$$$ and $$$j$$$ ($$$1 \\leq i,j \\leq n$$$), and an integer $$$x$$$ ($$$1 \\leq x \\leq a_i$$$). Let $$$i$$$ be the source index and $$$j$$$ be the sink index.  Decrease the $$$i$$$-th element by $$$x$$$, and increase the $$$j$$$-th element by $$$x$$$. The resulting values at $$$i$$$-th and $$$j$$$-th index are $$$a_i-x$$$ and $$$a_j+x$$$ respectively.  The cost of this operation is $$$x \\cdot |j-i| $$$.  Now the $$$i$$$-th index can no longer be the sink and the $$$j$$$-th index can no longer be the source.  The total cost of a transformation is the sum of all the costs in step $$$3$$$.For example, array $$$[0, 2, 3, 3]$$$ can be transformed into a beautiful array $$$[2, 2, 2, 2]$$$ with total cost $$$1 \\cdot |1-3| + 1 \\cdot |1-4| = 5$$$.An array is called balanced, if it can be transformed into a beautiful array, and the cost of such transformation is uniquely defined. In other words, the minimum cost of transformation into a beautiful array equals the maximum cost.You are given an array $$$a_1, a_2, \\ldots, a_n$$$ of length $$$n$$$, consisting of non-negative integers. Your task is to find the number of balanced arrays which are permutations of the given array. Two arrays are considered different, if elements at some position differ. Since the answer can be large, output it modulo $$$10^9 + 7$$$.",
    "prob_desc_output_spec": "Output a single integer — the number of balanced permutations modulo $$$10^9+7$$$.",
    "prob_desc_input_spec": "The first line contains a single integer $$$n$$$ ($$$1 \\leq n \\leq 10^5$$$) — the size of the array.  The second line contains $$$n$$$ integers $$$a_1, a_2, \\ldots, a_n$$$ ($$$0 \\le a_i \\le 10^9$$$).",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3-64",
    "lang_cluster": "Python",
    "difficulty": 2300,
    "file_name": "train_088.jsonl",
    "code_uid": "af5d509b026485193816964ca9791ba9",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"3\\n1 2 3\", \"4\\n0 4 0 4\", \"5\\n0 11 12 13 14\"]",
    "exec_outcome": "PASSED",
    "source_code": "from operator import mod\r\nimport os,sys\r\nfrom random import randint, shuffle\r\nfrom io import BytesIO, IOBase\r\n\r\nfrom collections import defaultdict,deque,Counter\r\nfrom bisect import bisect_left,bisect_right\r\nfrom heapq import heappush,heappop\r\nfrom functools import lru_cache\r\nfrom itertools import accumulate, permutations\r\nimport math\r\n\r\n# Fast IO Region\r\nBUFSIZE = 8192\r\nclass FastIO(IOBase):\r\n    newlines = 0\r\n    def __init__(self, file):\r\n        self._fd = file.fileno()\r\n        self.buffer = BytesIO()\r\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\r\n        self.write = self.buffer.write if self.writable else None\r\n    def read(self):\r\n        while True:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            if not b:\r\n                break\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines = 0\r\n        return self.buffer.read()\r\n    def readline(self):\r\n        while self.newlines == 0:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            self.newlines = b.count(b\"\\n\") + (not b)\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines -= 1\r\n        return self.buffer.readline()\r\n    def flush(self):\r\n        if self.writable:\r\n            os.write(self._fd, self.buffer.getvalue())\r\n            self.buffer.truncate(0), self.buffer.seek(0)\r\nclass IOWrapper(IOBase):\r\n    def __init__(self, file):\r\n        self.buffer = FastIO(file)\r\n        self.flush = self.buffer.flush\r\n        self.writable = self.buffer.writable\r\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\r\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\r\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\r\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\r\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\r\n\r\n\r\n# for _ in range(int(input())):\r\n#     n = int(input())\r\n#     a = list(map(int, input().split()))\r\n\r\n# for _ in range(int(input())):\r\n#     n, k = list(map(int, input().split()))\r\n#     if k > (n - 1) // 2:\r\n#         print(-1)\r\n#     else:\r\n#         l, r = 1, n\r\n#         a = []\r\n#         for i in range(2 * k):\r\n#             if i % 2 == 0:\r\n#                 a.append(l)\r\n#                 l += 1\r\n#             else:\r\n#                 a.append(r)\r\n#                 r -= 1\r\n#         for i in range(r, l - 1, -1):\r\n#             a.append(i)\r\n#         print(*a)\r\n\r\n# for _ in range(int(input())):\r\n#     n = int(input())\r\n#     a = list(map(int, input().split()))\r\n#     x = a[0]\r\n#     for i in range(n):\r\n#         x &= a[i]\r\n#     cnt = 0\r\n#     for i in range(n):\r\n#         if a[i] == x:\r\n#             cnt += 1\r\n#     if cnt < 2:\r\n#         print(0)\r\n#     else:\r\n#         ans = cnt * (cnt - 1)\r\n#         mod = 10 ** 9 + 7\r\n#         for i in range(1, n - 1):\r\n#             ans = ans * i % mod\r\n#         print(ans)\r\n\r\n# mod = 10 ** 9 + 7\r\n# ans = [[0] * 200020 for _ in range(10)]\r\n# ans[0][0] = 1\r\n# for j in range(200019):\r\n#     for i in range(9):\r\n#         ans[i + 1][j + 1] = ans[i][j]\r\n#     ans[0][j + 1] = (ans[0][j + 1] + ans[9][j]) % mod\r\n#     ans[1][j + 1] = (ans[1][j + 1] + ans[9][j]) % mod\r\n\r\n# for _ in range(int(input())):\r\n#     n, m = list(map(int, input().split()))\r\n#     res = 0\r\n#     while n:\r\n#         x = n % 10\r\n#         for i in range(10):\r\n#             res += ans[i][m + x]\r\n#         n //= 10\r\n#     print(res % mod)\r\n    \r\n# for _ in range(int(input())):\r\n#     n, p = list(map(int, input().split()))\r\n#     a = list(map(int, input().split()))\r\n#     id = [i for i in range(n)]\r\n#     id.sort(key=lambda x : a[x])\r\n#     vis = [0] * n\r\n#     ans = p * (n - 1)\r\n#     for i in range(n):\r\n#         x = id[i]\r\n#         if a[x] >= p: break\r\n#         if vis[x] == 1: continue\r\n#         vis[x] = 1\r\n#         l = x - 1\r\n#         r = x + 1\r\n#         while r < n and a[r] % a[x] == 0 and vis[r] == 0:\r\n#             vis[r] = 1\r\n#             r += 1\r\n#         while l >= 0 and a[l] % a[x] == 0 and vis[l] == 0:\r\n#             vis[l] = 1\r\n#             l -= 1\r\n#         if r > x + 1:\r\n#             vis[r - 1] = 0\r\n#         if l < x - 1:\r\n#             vis[l + 1] = 0\r\n#         ans -= (r - l - 2) * (p - a[x])\r\n#     print(ans)\r\n\r\nmod = 10 ** 9 + 7\r\nN = 200010\r\nfac = [1] * N\r\nfor i in range(2, N):\r\n    fac[i] = fac[i - 1] * i % mod\r\ninvfac = [1] * N\r\ninvfac[N - 1] = pow(fac[N - 1], mod - 2, mod)\r\nfor i in range(N - 1)[::-1]:\r\n    invfac[i] = invfac[i + 1] * (i + 1) % mod\r\ndef c(i, j):\r\n    return fac[i] * invfac[j] * invfac[i - j] % mod\r\n\r\ndef solve():\r\n    n = int(input())\r\n    a = list(map(int, input().split()))\r\n    if sum(a) % n:\r\n        print(0)\r\n        return\r\n    mean = sum(a) // n\r\n    x = l = r = 0\r\n    cnt1 = Counter()\r\n    cnt2 = Counter()\r\n    cnt = Counter(sorted(a))\r\n    for i in range(n):\r\n        if a[i] == mean:\r\n            x += 1\r\n        elif a[i] < mean:\r\n            cnt1[a[i]] += 1\r\n            l += 1\r\n        else:\r\n            cnt2[a[i]] += 1\r\n            r += 1\r\n    if l <= 1 or r <= 1:\r\n        ans = fac[n]\r\n        for i in cnt:\r\n            ans = ans * invfac[cnt[i]] % mod\r\n        print(ans)\r\n        return\r\n    ans = fac[l]\r\n    for i in cnt1:\r\n        ans = ans * invfac[cnt1[i]] % mod\r\n    ans = ans * fac[r] % mod\r\n    for i in cnt2:\r\n        ans = ans * invfac[cnt2[i]] % mod\r\n    ans = ans * c(n, x) % mod\r\n    print(ans * 2 % mod)\r\nsolve()\r\n",
    "prob_desc_created_at": "1618151700",
    "tags": [
        "combinatorics",
        "constructive algorithms",
        "math",
        "sortings"
    ],
    "hidden_unit_tests": ""
}
{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"3\\n2 3 3\\n2 1 1\", \"9\\n3 5 5\\n4 3 3\\n4 1 1\\n4 2 2\"]",
    "src_uid": "ac25d2519df81490ea0e7997ab73aa24",
    "prob_desc_notes": null,
    "prob_desc_description": "You are given an unweighted tree with n vertices. Then n - 1 following operations are applied to the tree. A single operation consists of the following steps:   choose two leaves;  add the length of the simple path between them to the answer;  remove one of the chosen leaves from the tree. Initial answer (before applying operations) is 0. Obviously after n - 1 such operations the tree will consist of a single vertex. Calculate the maximal possible answer you can achieve, and construct a sequence of operations that allows you to achieve this answer!",
    "prob_desc_output_spec": "In the first line print one integer number — maximal possible answer.  In the next n - 1 lines print the operations in order of their applying in format ai, bi, ci, where ai, bi — pair of the leaves that are chosen in the current operation (1 ≤ ai, bi ≤ n), ci (1 ≤ ci ≤ n, ci = ai or ci = bi) — choosen leaf that is removed from the tree in the current operation.  See the examples for better understanding.",
    "prob_desc_input_spec": "The first line contains one integer number n (2 ≤ n ≤ 2·105) — the number of vertices in the tree.  Next n - 1 lines describe the edges of the tree in form ai, bi (1 ≤ ai, bi ≤ n, ai ≠ bi). It is guaranteed that given graph is a tree.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "Python 3",
    "lang_cluster": "Python",
    "difficulty": 2400,
    "file_name": "train_037.jsonl",
    "code_uid": "a2c7d7b8774ebbf44de1664a325df7a1",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"3\\n1 2\\n1 3\", \"5\\n1 2\\n1 3\\n2 4\\n2 5\"]",
    "exec_outcome": "PASSED",
    "source_code": "import sys\n\n\ndef main():\n    n = int(input())\n\n    edges = list(map(int, sys.stdin.read().split()))\n    tree_edges = dict()\n    for i in range(n):\n        tree_edges[i + 1] = set()\n\n    for i in range(0, len(edges) - 1, 2):\n        tree_edges[edges[i]].add(edges[i + 1])\n        tree_edges[edges[i + 1]].add(edges[i])\n\n    init_distants = [-1] * (n + 1)\n\n    queue = [1]\n    init_distants[1] = 0\n\n    while queue:\n        next_queue = []\n        for process in queue:\n            for next_vertex in tree_edges[process]:\n                if init_distants[next_vertex] == -1:\n                    init_distants[next_vertex] = init_distants[process] + 1\n                    next_queue.append(next_vertex)\n        queue = next_queue\n\n    head = init_distants.index(max(init_distants))\n    distants_from_head = [-1] * (n + 1)\n    queue = [head]\n\n    distants_from_head[head] = 0\n\n    while queue:\n        next_queue = []\n        for process in queue:\n            for next_vertex in tree_edges[process]:\n                if distants_from_head[next_vertex] == -1:\n                    distants_from_head[next_vertex] = distants_from_head[process] + 1\n                    next_queue.append(next_vertex)\n        queue = next_queue\n\n    tail = distants_from_head.index(max(distants_from_head))\n    distants_from_tail = [-1] * (n + 1)\n    queue = [tail]\n\n    distants_from_tail[tail] = 0\n\n    while queue:\n        next_queue = []\n        for process in queue:\n            for next_vertex in tree_edges[process]:\n                if distants_from_tail[next_vertex] == -1:\n                    distants_from_tail[next_vertex] = distants_from_tail[process] + 1\n                    next_queue.append(next_vertex)\n        queue = next_queue\n\n    path_len_sum = 0\n    removal_history = list()\n\n    process_queue = []\n\n    for vertex, adj in tree_edges.items():\n        if len(adj) == 1:\n            process_queue.append(vertex)\n\n    while process_queue:\n        next_queue = []\n\n        for leaf in process_queue:\n\n            if leaf == head or leaf == tail:\n                continue\n\n            if distants_from_tail[leaf] > distants_from_head[leaf]:\n                path_len_sum += distants_from_tail[leaf]\n                new_leaves = []\n\n                for w in tree_edges[leaf]:\n                    tree_edges[w].remove(leaf)\n                    if len(tree_edges[w]) == 1:\n                        new_leaves.append(w)\n                next_queue.extend(new_leaves)\n                removal_history.append(\"{0} {1} {0}\".format(leaf, tail))\n            else:\n                path_len_sum += distants_from_head[leaf]\n                new_leaves = []\n\n                for w in tree_edges[leaf]:\n                    tree_edges[w].remove(leaf)\n                    if len(tree_edges[w]) == 1:\n                        new_leaves.append(w)\n                next_queue.extend(new_leaves)\n                removal_history.append(\"{0} {1} {0}\".format(leaf, head))\n        process_queue = next_queue\n\n    process_queue = [tail]\n\n    while process_queue:\n        leaf = process_queue[0]\n\n        if leaf == head:\n            continue\n\n        path_len_sum += distants_from_head[leaf]\n        new_leaves = []\n\n        for w in tree_edges[leaf]:\n            tree_edges[w].remove(leaf)\n            if len(tree_edges[w]) == 1:\n                new_leaves.append(w)\n        process_queue = new_leaves\n        removal_history.append(\"{0} {1} {0}\".format(leaf, head))\n\n    print(str(path_len_sum))\n    sys.stdout.write(\"\\n\".join(removal_history))\n    sys.stdout.write(\"\\n\")\n\n\nmain()",
    "prob_desc_created_at": "1514469900",
    "tags": [
        "greedy",
        "graphs",
        "constructive algorithms",
        "dfs and similar",
        "trees"
    ],
    "hidden_unit_tests": ""
}
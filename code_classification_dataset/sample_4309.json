{
    "prob_desc_time_limit": "1 second",
    "prob_desc_sample_outputs": "[\"5\", \"-1\"]",
    "src_uid": "f9902b3fbf2fad9eb1b5969dd645c328",
    "prob_desc_notes": "NoteIn the first example the following sequence of swaps will suffice:   $$$(2, 1), (1, 1)$$$,  $$$(1, 2), (1, 3)$$$,  $$$(2, 2), (2, 3)$$$,  $$$(1, 4), (1, 5)$$$,  $$$(2, 5), (2, 4)$$$. It can be shown that $$$5$$$ is the minimal possible answer in this case.In the second example no matter what swaps you do, you won't get the desired arrangement, so the answer is $$$-1$$$.",
    "prob_desc_description": "Pupils Alice and Ibragim are best friends. It's Ibragim's birthday soon, so Alice decided to gift him a new puzzle. The puzzle can be represented as a matrix with $$$2$$$ rows and $$$n$$$ columns, every element of which is either $$$0$$$ or $$$1$$$. In one move you can swap two values in neighboring cells.More formally, let's number rows $$$1$$$ to $$$2$$$ from top to bottom, and columns $$$1$$$ to $$$n$$$ from left to right. Also, let's denote a cell in row $$$x$$$ and column $$$y$$$ as $$$(x, y)$$$. We consider cells $$$(x_1, y_1)$$$ and $$$(x_2, y_2)$$$ neighboring if $$$|x_1 - x_2| + |y_1 - y_2| = 1$$$.Alice doesn't like the way in which the cells are currently arranged, so she came up with her own arrangement, with which she wants to gift the puzzle to Ibragim. Since you are her smartest friend, she asked you to help her find the minimal possible number of operations in which she can get the desired arrangement. Find this number, or determine that it's not possible to get the new arrangement.",
    "prob_desc_output_spec": "If it is possible to get the desired arrangement, print the minimal possible number of steps, otherwise print $$$-1$$$.",
    "prob_desc_input_spec": "The first line contains an integer $$$n$$$ ($$$1 \\leq n \\leq 200\\,000$$$) â€” the number of columns in the puzzle. Following two lines describe the current arrangement on the puzzle. Each line contains $$$n$$$ integers, every one of which is either $$$0$$$ or $$$1$$$. The last two lines describe Alice's desired arrangement in the same format.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3-64",
    "lang_cluster": "Python",
    "difficulty": 2600,
    "file_name": "train_094.jsonl",
    "code_uid": "7277b5f879e1471fa704c81b675ccd31",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"5\\n0 1 0 1 0\\n1 1 0 0 1\\n1 0 1 0 1\\n0 0 1 1 0\", \"3\\n1 0 0\\n0 0 0\\n0 0 0\\n0 0 0\"]",
    "exec_outcome": "PASSED",
    "source_code": "#!/usr/bin/env python3\r\nimport sys\r\nimport math, random\r\nimport functools, itertools, collections, heapq, bisect\r\nfrom collections import Counter, defaultdict, deque\r\ninput = sys.stdin.readline  # to read input quickly\r\n\r\n# available on Google, AtCoder Python3, not available on Codeforces\r\n# import numpy as np\r\n# import scipy\r\n\r\nm9 = 10**9 + 7  # 998244353\r\nyes, no = \"YES\", \"NO\"\r\n# d4 = [(1,0),(0,1),(-1,0),(0,-1)]\r\n# d8 = [(1,0),(1,1),(0,1),(-1,1),(-1,0),(-1,-1),(0,-1),(1,-1)]\r\n# d6 = [(2,0),(1,1),(-1,1),(-2,0),(-1,-1),(1,-1)]  # hexagonal layout\r\nMAXINT = sys.maxsize\r\ne18 = 10**18 + 10\r\n\r\n# if testing locally, print to terminal with a different color\r\nCHECK_OFFLINE_TEST = True\r\n# CHECK_OFFLINE_TEST = False  # uncomment this on Codechef\r\nif CHECK_OFFLINE_TEST:\r\n    import getpass\r\n    OFFLINE_TEST = getpass.getuser() == \"htong\"\r\n\r\ndef log(*args):\r\n    if CHECK_OFFLINE_TEST and OFFLINE_TEST:\r\n        print('\\033[36m', *args, '\\033[0m', file=sys.stderr)\r\n\r\ndef solve(*args):\r\n    # screen input\r\n    if OFFLINE_TEST:\r\n        log(\"----- solving ------\")\r\n        log(*args)\r\n        log(\"----- ------- ------\")\r\n    return solve_(*args)\r\n\r\ndef read_matrix(rows):\r\n    return [list(map(int,input().split())) for _ in range(rows)]\r\n\r\ndef read_strings(rows):\r\n    return [input().strip() for _ in range(rows)]\r\n\r\ndef minus_one(arr):\r\n    return [x-1 for x in arr]\r\n\r\ndef minus_one_matrix(mrr):\r\n    return [[x-1 for x in row] for row in mrr]\r\n\r\n# ---------------------------- template ends here ----------------------------\r\n\r\n\r\ndef solve_(arr, brr, crr, drr):\r\n\r\n    if sum(arr) + sum(brr) != sum(crr) + sum(drr):\r\n        return -1\r\n\r\n    top = 0\r\n    bottom = 0\r\n    res = 0\r\n\r\n    for a,b,c,d in zip(arr, brr, crr, drr):\r\n        if a == 1 and c == 0:\r\n            top += 1\r\n        if a == 0 and c == 1:\r\n            top -= 1\r\n        \r\n        if b == 1 and d == 0:\r\n            bottom += 1\r\n        if b == 0 and d == 1:\r\n            bottom -= 1\r\n\r\n        if top > 0 and bottom < 0:\r\n            top -= 1\r\n            bottom += 1\r\n            res += 1\r\n\r\n        if top < 0 and bottom > 0:\r\n            top += 1\r\n            bottom -= 1\r\n            res += 1\r\n\r\n        res += abs(top) + abs(bottom)\r\n        # log(res, top, bottom)\r\n\r\n    return res\r\n\r\n\r\nfor case_num in [0]:  # no loop over test case\r\n# for case_num in range(100):  # if the number of test cases is specified\r\n# for case_num in range(int(input())):\r\n\r\n    # read line as an integer\r\n    k = int(input())\r\n\r\n    # read line as a string\r\n    # srr = input().strip()\r\n\r\n    # read one line and parse each word as a string\r\n    # arr = input().split()\r\n\r\n    # read one line and parse each word as an integer\r\n    # a,b,c = list(map(int,input().split()))\r\n    arr = list(map(int,input().split()))\r\n    brr = list(map(int,input().split()))\r\n    crr = list(map(int,input().split()))\r\n    drr = list(map(int,input().split()))\r\n    # arr = minus_one(arr)\r\n\r\n    # read multiple rows\r\n    # arr = read_strings(k)  # and return as a list of str\r\n    # mrr = read_matrix(k)  # and return as a list of list of int\r\n    # mrr = minus_one_matrix(mrr)\r\n\r\n    res = solve(arr, brr, crr, drr)  # include input here\r\n\r\n    # print length if applicable\r\n    # print(len(res))\r\n\r\n    # parse result\r\n    # res = \" \".join(str(x) for x in res)\r\n    # res = \"\\n\".join(str(x) for x in res)\r\n    # res = \"\\n\".join(\" \".join(str(x) for x in row) for row in res)\r\n\r\n    # print result\r\n    # print(\"Case #{}: {}\".format(case_num+1, res))   # Google and Facebook - case number required\r\n\r\n    print(res)\r\n",
    "prob_desc_created_at": "1655629500",
    "tags": [
        "constructive algorithms",
        "dp",
        "greedy"
    ],
    "hidden_unit_tests": ""
}
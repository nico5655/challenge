{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"5\\n6\\n3\\n4\\n4\\n-1\"]",
    "src_uid": "81abcdc77ffcf8858b4e81f3db5ee7fb",
    "prob_desc_notes": null,
    "prob_desc_description": "You wanted to write a text $$$t$$$ consisting of $$$m$$$ lowercase Latin letters. But instead, you have written a text $$$s$$$ consisting of $$$n$$$ lowercase Latin letters, and now you want to fix it by obtaining the text $$$t$$$ from the text $$$s$$$.Initially, the cursor of your text editor is at the end of the text $$$s$$$ (after its last character). In one move, you can do one of the following actions:  press the \"left\" button, so the cursor is moved to the left by one position (or does nothing if it is pointing at the beginning of the text, i. e. before its first character);  press the \"right\" button, so the cursor is moved to the right by one position (or does nothing if it is pointing at the end of the text, i. e. after its last character);  press the \"home\" button, so the cursor is moved to the beginning of the text (before the first character of the text);  press the \"end\" button, so the cursor is moved to the end of the text (after the last character of the text);  press the \"backspace\" button, so the character before the cursor is removed from the text (if there is no such character, nothing happens). Your task is to calculate the minimum number of moves required to obtain the text $$$t$$$ from the text $$$s$$$ using the given set of actions, or determine it is impossible to obtain the text $$$t$$$ from the text $$$s$$$.You have to answer $$$T$$$ independent test cases.",
    "prob_desc_output_spec": "For each test case, print one integer — the minimum number of moves required to obtain the text $$$t$$$ from the text $$$s$$$ using the given set of actions, or -1 if it is impossible to obtain the text $$$t$$$ from the text $$$s$$$ in the given test case.",
    "prob_desc_input_spec": "The first line of the input contains one integer $$$T$$$ ($$$1 \\le T \\le 5000$$$) — the number of test cases. Then $$$T$$$ test cases follow. The first line of the test case contains two integers $$$n$$$ and $$$m$$$ ($$$1 \\le m \\le n \\le 5000$$$) — the length of $$$s$$$ and the length of $$$t$$$, respectively. The second line of the test case contains the string $$$s$$$ consisting of $$$n$$$ lowercase Latin letters. The third line of the test case contains the string $$$t$$$ consisting of $$$m$$$ lowercase Latin letters. It is guaranteed that the sum of $$$n$$$ over all test cases does not exceed $$$5000$$$ ($$$\\sum n \\le 5000$$$).",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3-64",
    "lang_cluster": "Python",
    "difficulty": 2500,
    "file_name": "train_098.jsonl",
    "code_uid": "799d33c9b735098e3233747f89e79b81",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"6\\n\\n9 4\\n\\naaaaaaaaa\\n\\naaaa\\n\\n7 3\\n\\nabacaba\\n\\naaa\\n\\n5 4\\n\\naabcd\\n\\nabcd\\n\\n4 2\\n\\nabba\\n\\nbb\\n\\n6 4\\n\\nbaraka\\n\\nbaka\\n\\n8 7\\n\\nquestion\\n\\nproblem\"]",
    "exec_outcome": "PASSED",
    "source_code": "#!/usr/bin/env PyPy3\r\n\r\nfrom collections import Counter, defaultdict, deque\r\nimport itertools\r\nimport re\r\nimport math\r\nfrom functools import reduce\r\nimport operator\r\nimport bisect\r\nfrom heapq import *\r\nimport functools\r\nmod=998244353\r\n\r\nimport sys\r\nimport os\r\nfrom io import BytesIO, IOBase\r\nBUFSIZE = 8192\r\nclass FastIO(IOBase):\r\n    newlines = 0\r\n    def __init__(self, file):\r\n        self._fd = file.fileno()\r\n        self.buffer = BytesIO()\r\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\r\n        self.write = self.buffer.write if self.writable else None\r\n    def read(self):\r\n        while True:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            if not b:\r\n                break\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines = 0\r\n        return self.buffer.read()\r\n    def readline(self):\r\n        while self.newlines == 0:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            self.newlines = b.count(b\"\\n\") + (not b)\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines -= 1\r\n        return self.buffer.readline()\r\n    def flush(self):\r\n        if self.writable:\r\n            os.write(self._fd, self.buffer.getvalue())\r\n            self.buffer.truncate(0), self.buffer.seek(0)\r\nclass IOWrapper(IOBase):\r\n    def __init__(self, file):\r\n        self.buffer = FastIO(file)\r\n        self.flush = self.buffer.flush\r\n        self.writable = self.buffer.writable\r\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\r\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\r\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\r\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\r\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\r\nINF = 1 << 31\r\nT = int(input())\r\nfor _ in range(T):\r\n    n,m = map(int,input().split())\r\n    s = input().rstrip()\r\n    t = input().rstrip()\r\n    dp = [[INF] * (m+1) for _ in range(3)]\r\n    dp[0][0] = 1\r\n    dp[1][0] = 0\r\n    for i in range(n):\r\n        ndp = [[INF] * (m+1) for _ in range(3)]\r\n        for k in range(2):\r\n            for j in range(m+1):\r\n                dp[k+1][j] = min(dp[k+1][j],dp[k][j])\r\n        for j in range(m+1):\r\n            ndp[0][j] = min(ndp[0][j],dp[0][j] + 2)\r\n            ndp[2][j] = min(ndp[2][j],dp[2][j] + 1)\r\n            if j < m:\r\n                if s[i] == t[j]:\r\n                    ndp[0][j+1] = min(ndp[0][j+1],dp[0][j]+1)\r\n                    ndp[1][j+1] = min(ndp[1][j+1],dp[1][j])\r\n                    ndp[2][j+1] = min(ndp[2][j+1],dp[2][j]+1)\r\n        dp = ndp\r\n    ans = min(dp[0][-1],dp[1][-1],dp[2][-1])\r\n    if ans == INF:\r\n        print(-1)\r\n    else:\r\n        print(ans)\r\n",
    "prob_desc_created_at": "1657290900",
    "tags": [
        "brute force",
        "dp",
        "greedy",
        "strings"
    ],
    "hidden_unit_tests": ""
}
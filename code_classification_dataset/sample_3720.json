{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"4\\n6\", \"117\\n665496274\\n332748143\\n831870317\\n499122211\"]",
    "src_uid": "1461fca52a0310fff725b476bfbd3b29",
    "prob_desc_notes": "NoteIn the first test after the first query, the first and the second mirrors are checkpoints. Creatnx will ask the first mirror until it will say that he is beautiful, after that he will ask the second mirror until it will say that he is beautiful because the second mirror is a checkpoint. After that, he will become happy. Probabilities that the mirrors will say, that he is beautiful are equal to $$$\\frac{1}{2}$$$. So, the expected number of days, until one mirror will say, that he is beautiful is equal to $$$2$$$ and the answer will be equal to $$$4 = 2 + 2$$$.",
    "prob_desc_description": "Creatnx has $$$n$$$ mirrors, numbered from $$$1$$$ to $$$n$$$. Every day, Creatnx asks exactly one mirror \"Am I beautiful?\". The $$$i$$$-th mirror will tell Creatnx that he is beautiful with probability $$$\\frac{p_i}{100}$$$ for all $$$1 \\le i \\le n$$$.Some mirrors are called checkpoints. Initially, only the $$$1$$$st mirror is a checkpoint. It remains a checkpoint all the time.Creatnx asks the mirrors one by one, starting from the $$$1$$$-st mirror. Every day, if he asks $$$i$$$-th mirror, there are two possibilities:  The $$$i$$$-th mirror tells Creatnx that he is beautiful. In this case, if $$$i = n$$$ Creatnx will stop and become happy, otherwise he will continue asking the $$$i+1$$$-th mirror next day;  In the other case, Creatnx will feel upset. The next day, Creatnx will start asking from the checkpoint with a maximal number that is less or equal to $$$i$$$. There are some changes occur over time: some mirrors become new checkpoints and some mirrors are no longer checkpoints. You are given $$$q$$$ queries, each query is represented by an integer $$$u$$$: If the $$$u$$$-th mirror isn't a checkpoint then we set it as a checkpoint. Otherwise, the $$$u$$$-th mirror is no longer a checkpoint.After each query, you need to calculate the expected number of days until Creatnx becomes happy.Each of this numbers should be found by modulo $$$998244353$$$. Formally, let $$$M = 998244353$$$. It can be shown that the answer can be expressed as an irreducible fraction $$$\\frac{p}{q}$$$, where $$$p$$$ and $$$q$$$ are integers and $$$q \\not \\equiv 0 \\pmod{M}$$$. Output the integer equal to $$$p \\cdot q^{-1} \\bmod M$$$. In other words, output such an integer $$$x$$$ that $$$0 \\le x &lt; M$$$ and $$$x \\cdot q \\equiv p \\pmod{M}$$$.",
    "prob_desc_output_spec": "Print $$$q$$$ numbers – the answers after each query by modulo $$$998244353$$$.",
    "prob_desc_input_spec": "The first line contains two integers $$$n$$$, $$$q$$$ ($$$2 \\leq n, q \\le 2 \\cdot 10^5$$$)  — the number of mirrors and queries. The second line contains $$$n$$$ integers: $$$p_1, p_2, \\ldots, p_n$$$ ($$$1 \\leq p_i \\leq 100$$$). Each of $$$q$$$ following lines contains a single integer $$$u$$$ ($$$2 \\leq u \\leq n$$$) — next query.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 2",
    "lang_cluster": "Python",
    "difficulty": 2400,
    "file_name": "train_082.jsonl",
    "code_uid": "37af9be9e83ba129e959a7f854eb2aac",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"2 2\\n50 50\\n2\\n2\", \"5 5\\n10 20 30 40 50\\n2\\n3\\n4\\n5\\n3\"]",
    "exec_outcome": "PASSED",
    "source_code": "from __future__ import division, print_function\n\ndef main():\n    n, qs = input_as_list()\n    cpn = ceil_power_of_2(n)\n    st = array_of(int, n+1)\n    switch = array_of(bool, n)\n\n    def update(i, v):\n        while i < n:\n            st[i] += v\n            i |= i+1\n\n    def query(i):\n        res = 0\n        while i > 0:\n            res += st[i-1]\n            i &= i-1\n        return res\n\n    def lower_bound(s):\n        if s <= 0: return -1\n        pos = 0\n        pw = cpn\n        while pw > 0:\n            if (pos + pw <= n) and (st[pos + pw-1] < s):\n                pos += pw\n                s -= st[pos-1]\n            pw //= 2\n        return pos\n\n    def insert(i):\n        update(i, +1)\n\n    def remove(i):\n        update(i, -1)\n\n    def find_by_order(i):\n        return lower_bound(i)\n\n    def order_of(i):\n        return query(i)\n\n    def lr(i):\n        o = order_of(i)\n        l = find_by_order(o)\n        r = find_by_order(o+1)\n        return l, r\n\n    ar = input_as_list()\n    s1 = [0]\n    for x in ar:\n        v = s1[-1]+1\n        v = mulmod(v, 100)\n        v = divmod(v, x)\n        s1.append(v)\n    s2 = [1]\n    for x in ar:\n        v = s2[-1]\n        v = mulmod(v, 100)\n        v = divmod(v, x)\n        s2.append(v)\n\n    def f(l, r):\n        if r <= l:\n            return 0\n        a = s1[r]\n        b = mulmod(s1[l], s2[r])\n        b = divmod(b, s2[l])\n        return (a-b)%MOD\n\n    insert(0)\n    insert(n)\n    ans = s1[-1]\n    for _ in range(qs):\n        q = int(input())-1\n        if switch[q]:\n            remove(q)\n            l, r = lr(q)\n            ans = (ans + f(l, r)) % MOD\n            ans = (ans - f(l, q)) % MOD\n            ans = (ans - f(q, r)) % MOD\n        else:\n            l, r = lr(q)\n            ans = (ans - f(l, r)) % MOD\n            ans = (ans + f(l, q)) % MOD\n            ans = (ans + f(q, r)) % MOD\n            insert(q)\n        switch[q] ^= True\n        print(ans)\n\n\nINF = float('inf')\nMOD = 998244353\n__interactive = False\n\nimport os, sys\nfrom atexit import register\nfrom io import BytesIO\nimport itertools\nimport __pypy__\n\nif sys.version_info[0] < 3:\n    input = raw_input\n    range = xrange\n\n    filter = itertools.ifilter\n    map = itertools.imap\n    zip = itertools.izip\n\nif \"LOCAL_\" in os.environ:\n    debug_print = print\nelse:\n    if not __interactive:\n        sys.stdin = BytesIO(os.read(0, os.fstat(0).st_size))\n        sys.stdout = BytesIO()\n        register(lambda: os.write(1, sys.stdout.getvalue()))\n\n        input = lambda: sys.stdin.readline().rstrip('\\r\\n')\n    debug_print = lambda *x, **y: None\n\nflush = sys.stdout.flush\n\ndef mulmod(x, y):\n    return __pypy__.intop.int_mulmod(x, y, MOD)\n\ndef modinv(x):\n    return pow(x, MOD-2, MOD)\n\ndef divmod(x, y):\n    return mulmod(x, modinv(y))\n\ndef gcd(x, y):\n    while y:\n        x, y = y, x % y\n    return x\n    \ndef input_as_list():\n    return list(map(int, input().split()))\n\ndef input_with_offset(o):\n    return list(map(lambda x:int(x)+o, input().split()))\n    \ndef input_as_matrix(n, m):\n    return [input_as_list() for _ in range(n)]\n    \ndef array_of(f, *dim):\n    return [array_of(f, *dim[1:]) for _ in range(dim[0])] if dim else f()\n\ndef range_with_count(start, step, count):\n    return range(start, start + step * count, step)\n\ndef indices(l, start=0, end=0):\n    return range(start, len(l)+end)\n\ndef ceil_power_of_2(n):\n    \"\"\" [0, 1, 2, 4, 4, 8, 8, 8, 8, 16, 16, ...] \"\"\"\n    return 2 ** ((n - 1).bit_length())\n\ndef ceil_div(x, r):\n    \"\"\" = ceil(x / r) \"\"\"\n    return (x + r - 1) // r\n    \nmain()",
    "prob_desc_created_at": "1575556500",
    "tags": [
        "data structures",
        "probabilities"
    ],
    "hidden_unit_tests": ""
}
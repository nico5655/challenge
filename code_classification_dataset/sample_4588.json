{
    "prob_desc_time_limit": "1 second",
    "prob_desc_sample_outputs": "[\"-1\\n0\\n2\\n2\"]",
    "src_uid": "71ee54d8881f20ae4b1d8bb9783948c0",
    "prob_desc_notes": null,
    "prob_desc_description": "You are given two strings $$$s$$$ and $$$t$$$ of equal length $$$n$$$. In one move, you can swap any two adjacent characters of the string $$$s$$$.You need to find the minimal number of operations you need to make string $$$s$$$ lexicographically smaller than string $$$t$$$.A string $$$a$$$ is lexicographically smaller than a string $$$b$$$ if and only if one of the following holds:   $$$a$$$ is a prefix of $$$b$$$, but $$$a \\ne b$$$;  in the first position where $$$a$$$ and $$$b$$$ differ, the string $$$a$$$ has a letter that appears earlier in the alphabet than the corresponding letter in $$$b$$$. ",
    "prob_desc_output_spec": "For each test case, print in a separate line the minimal number of operations you need to make string $$$s$$$ lexicographically smaller than string $$$t$$$, or $$$-1$$$, if it's impossible.",
    "prob_desc_input_spec": "The first line of input contains one integer $$$q$$$ ($$$1 \\le q \\le 10\\,000$$$): the number of test cases. The first line of each test case contains a single integer $$$n$$$ ($$$1 \\le n \\le 10^5$$$). The second line of each test case contains the string $$$s$$$ consisting of $$$n$$$ lowercase English letters. The third line of each test case contains the string $$$t$$$ consisting of $$$n$$$ lowercase English letters. It is guaranteed that the sum of $$$n$$$ over all test cases does not exceed $$$2 \\cdot 10^5$$$.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3-64",
    "lang_cluster": "Python",
    "difficulty": 2200,
    "file_name": "train_101.jsonl",
    "code_uid": "35c7f1c9d14502bce20fd854cbae6159",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"4\\n1\\na\\na\\n3\\nrll\\nrrr\\n3\\ncaa\\naca\\n5\\nababa\\naabba\"]",
    "exec_outcome": "PASSED",
    "source_code": "import os,sys\r\nfrom random import randint\r\nimport random\r\nfrom io import BytesIO, IOBase\r\n\r\nfrom collections import defaultdict,deque,Counter\r\nfrom bisect import bisect_left,bisect_right\r\nfrom heapq import heappush,heappop\r\nfrom functools import lru_cache\r\nfrom itertools import accumulate\r\nimport math\r\n\r\n# Fast IO Region\r\nBUFSIZE = 8192\r\nclass FastIO(IOBase):\r\n    newlines = 0\r\n    def __init__(self, file):\r\n        self._fd = file.fileno()\r\n        self.buffer = BytesIO()\r\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\r\n        self.write = self.buffer.write if self.writable else None\r\n    def read(self):\r\n        while True:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            if not b:\r\n                break\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines = 0\r\n        return self.buffer.read()\r\n    def readline(self):\r\n        while self.newlines == 0:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            self.newlines = b.count(b\"\\n\") + (not b)\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines -= 1\r\n        return self.buffer.readline()\r\n    def flush(self):\r\n        if self.writable:\r\n            os.write(self._fd, self.buffer.getvalue())\r\n            self.buffer.truncate(0), self.buffer.seek(0)\r\nclass IOWrapper(IOBase):\r\n    def __init__(self, file):\r\n        self.buffer = FastIO(file)\r\n        self.flush = self.buffer.flush\r\n        self.writable = self.buffer.writable\r\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\r\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\r\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\r\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\r\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\r\n\r\nclass SortedList:\r\n    def __init__(self, iterable=[], _load=200):\r\n        \"\"\"Initialize sorted list instance.\"\"\"\r\n        values = sorted(iterable)\r\n        self._len = _len = len(values)\r\n        self._load = _load\r\n        self._lists = _lists = [values[i:i + _load] for i in range(0, _len, _load)]\r\n        self._list_lens = [len(_list) for _list in _lists]\r\n        self._mins = [_list[0] for _list in _lists]\r\n        self._fen_tree = []\r\n        self._rebuild = True\r\n \r\n    def _fen_build(self):\r\n        \"\"\"Build a fenwick tree instance.\"\"\"\r\n        self._fen_tree[:] = self._list_lens\r\n        _fen_tree = self._fen_tree\r\n        for i in range(len(_fen_tree)):\r\n            if i | i + 1 < len(_fen_tree):\r\n                _fen_tree[i | i + 1] += _fen_tree[i]\r\n        self._rebuild = False\r\n \r\n    def _fen_update(self, index, value):\r\n        \"\"\"Update `fen_tree[index] += value`.\"\"\"\r\n        if not self._rebuild:\r\n            _fen_tree = self._fen_tree\r\n            while index < len(_fen_tree):\r\n                _fen_tree[index] += value\r\n                index |= index + 1\r\n \r\n    def _fen_query(self, end):\r\n        \"\"\"Return `sum(_fen_tree[:end])`.\"\"\"\r\n        if self._rebuild:\r\n            self._fen_build()\r\n \r\n        _fen_tree = self._fen_tree\r\n        x = 0\r\n        while end:\r\n            x += _fen_tree[end - 1]\r\n            end &= end - 1\r\n        return x\r\n \r\n    def _fen_findkth(self, k):\r\n        \"\"\"Return a pair of (the largest `idx` such that `sum(_fen_tree[:idx]) <= k`, `k - sum(_fen_tree[:idx])`).\"\"\"\r\n        _list_lens = self._list_lens\r\n        if k < _list_lens[0]:\r\n            return 0, k\r\n        if k >= self._len - _list_lens[-1]:\r\n            return len(_list_lens) - 1, k + _list_lens[-1] - self._len\r\n        if self._rebuild:\r\n            self._fen_build()\r\n \r\n        _fen_tree = self._fen_tree\r\n        idx = -1\r\n        for d in reversed(range(len(_fen_tree).bit_length())):\r\n            right_idx = idx + (1 << d)\r\n            if right_idx < len(_fen_tree) and k >= _fen_tree[right_idx]:\r\n                idx = right_idx\r\n                k -= _fen_tree[idx]\r\n        return idx + 1, k\r\n \r\n    def _delete(self, pos, idx):\r\n        \"\"\"Delete value at the given `(pos, idx)`.\"\"\"\r\n        _lists = self._lists\r\n        _mins = self._mins\r\n        _list_lens = self._list_lens\r\n \r\n        self._len -= 1\r\n        self._fen_update(pos, -1)\r\n        del _lists[pos][idx]\r\n        _list_lens[pos] -= 1\r\n \r\n        if _list_lens[pos]:\r\n            _mins[pos] = _lists[pos][0]\r\n        else:\r\n            del _lists[pos]\r\n            del _list_lens[pos]\r\n            del _mins[pos]\r\n            self._rebuild = True\r\n \r\n    def _loc_left(self, value):\r\n        \"\"\"Return an index pair that corresponds to the first position of `value` in the sorted list.\"\"\"\r\n        if not self._len:\r\n            return 0, 0\r\n \r\n        _lists = self._lists\r\n        _mins = self._mins\r\n \r\n        lo, pos = -1, len(_lists) - 1\r\n        while lo + 1 < pos:\r\n            mi = (lo + pos) >> 1\r\n            if value <= _mins[mi]:\r\n                pos = mi\r\n            else:\r\n                lo = mi\r\n \r\n        if pos and value <= _lists[pos - 1][-1]:\r\n            pos -= 1\r\n \r\n        _list = _lists[pos]\r\n        lo, idx = -1, len(_list)\r\n        while lo + 1 < idx:\r\n            mi = (lo + idx) >> 1\r\n            if value <= _list[mi]:\r\n                idx = mi\r\n            else:\r\n                lo = mi\r\n \r\n        return pos, idx\r\n \r\n    def _loc_right(self, value):\r\n        \"\"\"Return an index pair that corresponds to the last position of `value` in the sorted list.\"\"\"\r\n        if not self._len:\r\n            return 0, 0\r\n \r\n        _lists = self._lists\r\n        _mins = self._mins\r\n \r\n        pos, hi = 0, len(_lists)\r\n        while pos + 1 < hi:\r\n            mi = (pos + hi) >> 1\r\n            if value < _mins[mi]:\r\n                hi = mi\r\n            else:\r\n                pos = mi\r\n \r\n        _list = _lists[pos]\r\n        lo, idx = -1, len(_list)\r\n        while lo + 1 < idx:\r\n            mi = (lo + idx) >> 1\r\n            if value < _list[mi]:\r\n                idx = mi\r\n            else:\r\n                lo = mi\r\n \r\n        return pos, idx\r\n \r\n    def add(self, value):\r\n        \"\"\"Add `value` to sorted list.\"\"\"\r\n        _load = self._load\r\n        _lists = self._lists\r\n        _mins = self._mins\r\n        _list_lens = self._list_lens\r\n \r\n        self._len += 1\r\n        if _lists:\r\n            pos, idx = self._loc_right(value)\r\n            self._fen_update(pos, 1)\r\n            _list = _lists[pos]\r\n            _list.insert(idx, value)\r\n            _list_lens[pos] += 1\r\n            _mins[pos] = _list[0]\r\n            if _load + _load < len(_list):\r\n                _lists.insert(pos + 1, _list[_load:])\r\n                _list_lens.insert(pos + 1, len(_list) - _load)\r\n                _mins.insert(pos + 1, _list[_load])\r\n                _list_lens[pos] = _load\r\n                del _list[_load:]\r\n                self._rebuild = True\r\n        else:\r\n            _lists.append([value])\r\n            _mins.append(value)\r\n            _list_lens.append(1)\r\n            self._rebuild = True\r\n \r\n    def discard(self, value):\r\n        \"\"\"Remove `value` from sorted list if it is a member.\"\"\"\r\n        _lists = self._lists\r\n        if _lists:\r\n            pos, idx = self._loc_right(value)\r\n            if idx and _lists[pos][idx - 1] == value:\r\n                self._delete(pos, idx - 1)\r\n \r\n    def remove(self, value):\r\n        \"\"\"Remove `value` from sorted list; `value` must be a member.\"\"\"\r\n        _len = self._len\r\n        self.discard(value)\r\n        if _len == self._len:\r\n            raise ValueError('{0!r} not in list'.format(value))\r\n \r\n    def pop(self, index=-1):\r\n        \"\"\"Remove and return value at `index` in sorted list.\"\"\"\r\n        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)\r\n        value = self._lists[pos][idx]\r\n        self._delete(pos, idx)\r\n        return value\r\n \r\n    def bisect_left(self, value):\r\n        \"\"\"Return the first index to insert `value` in the sorted list.\"\"\"\r\n        pos, idx = self._loc_left(value)\r\n        return self._fen_query(pos) + idx\r\n \r\n    def bisect_right(self, value):\r\n        \"\"\"Return the last index to insert `value` in the sorted list.\"\"\"\r\n        pos, idx = self._loc_right(value)\r\n        return self._fen_query(pos) + idx\r\n \r\n    def count(self, value):\r\n        \"\"\"Return number of occurrences of `value` in the sorted list.\"\"\"\r\n        return self.bisect_right(value) - self.bisect_left(value)\r\n \r\n    def __len__(self):\r\n        \"\"\"Return the size of the sorted list.\"\"\"\r\n        return self._len\r\n \r\n    def __getitem__(self, index):\r\n        \"\"\"Lookup value at `index` in sorted list.\"\"\"\r\n        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)\r\n        return self._lists[pos][idx]\r\n \r\n    def __delitem__(self, index):\r\n        \"\"\"Remove value at `index` from sorted list.\"\"\"\r\n        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)\r\n        self._delete(pos, idx)\r\n \r\n    def __contains__(self, value):\r\n        \"\"\"Return true if `value` is an element of the sorted list.\"\"\"\r\n        _lists = self._lists\r\n        if _lists:\r\n            pos, idx = self._loc_left(value)\r\n            return idx < len(_lists[pos]) and _lists[pos][idx] == value\r\n        return False\r\n \r\n    def __iter__(self):\r\n        \"\"\"Return an iterator over the sorted list.\"\"\"\r\n        return (value for _list in self._lists for value in _list)\r\n \r\n    def __reversed__(self):\r\n        \"\"\"Return a reverse iterator over the sorted list.\"\"\"\r\n        return (value for _list in reversed(self._lists) for value in reversed(_list))\r\n \r\n    def __repr__(self):\r\n        \"\"\"Return string representation of sorted list.\"\"\"\r\n        return 'SortedList({0})'.format(list(self))\r\n\r\n# for _ in range(int(input())):\r\n#     n = int(input())\r\n#     a = list(map(int, input().split(' ')))\r\n\r\n# for _ in range(int(input())):\r\n#     n = int(input())\r\n#     a = list(map(int, input().split(' ')))\r\n#     cnt = [0] * 200\r\n#     for i in range(n):\r\n#         cnt[abs(a[i])] += 1\r\n#     ans = 0\r\n#     for i in range(200):\r\n#         if i == 0:\r\n#             ans += min(1, cnt[i])\r\n#         else:\r\n#             ans += min(2, cnt[i])\r\n#     print(ans)\r\n\r\n# for _ in range(int(input())):\r\n#     n = int(input())\r\n#     s = input()\r\n#     ans = [s[0] * 2]\r\n#     for i in range(1, n):\r\n#         if s[i] > s[i - 1]:\r\n#             ans.append(s[:i] + s[:i][::-1])\r\n#             break\r\n#         if s[i] < s[i - 1]:\r\n#             ans.append(s[:i + 1] + s[:i + 1][::-1])\r\n#             ans.append(s[:i] + s[:i][::-1])\r\n#     ans.append(s + s[::-1])\r\n#     ans.sort()\r\n#     print(ans[0])\r\n\r\ndef lowbit(x):\r\n    return x & (-x)\r\n\r\nclass BIT:\r\n    def __init__(self, x):\r\n        \"\"\"transform list into BIT\"\"\"\r\n        self.bit = x\r\n        for i in range(len(x)):\r\n            j = i + lowbit(i)\r\n            if j < len(x):\r\n                x[j] += x[i]\r\n    \r\n    def update(self, idx, x):\r\n        \"\"\"updates bit[idx] += x\"\"\"\r\n        idx += 1\r\n        while idx < len(self.bit):\r\n            self.bit[idx] += x\r\n            idx += lowbit(idx)\r\n    \r\n    def query(self, end):\r\n        \"\"\"calc sum(bit[1:end+1])\"\"\"\r\n        x = 0\r\n        while end:\r\n            x += self.bit[end]\r\n            end -= lowbit(end)\r\n        return x\r\n\r\nfor _ in range(int(input())):\r\n    n = int(input()) \r\n    s = input()\r\n    t = input()\r\n    if s < t:\r\n        print(0)\r\n        continue\r\n    if ''.join(sorted(s)) >= t:\r\n        print(-1)\r\n        continue\r\n    p = [n for _ in range(26)]\r\n    for i in range(n):\r\n        if p[ord(s[i]) - ord('a')] == n:\r\n            p[ord(s[i]) - ord('a')] = i\r\n    i = j = 0\r\n    # vis = SortedList()\r\n    vis = set()\r\n    fen = BIT([0] * (n + 2))\r\n    \r\n    ans = float('inf')\r\n    res = 0\r\n    while i < n and j < n:\r\n        while i in vis:\r\n            vis.remove(i)\r\n            fen.update(i, -1)\r\n            i += 1\r\n        if i >= n: break\r\n        for k in range(26):\r\n            if p[k] <= i or p[k] in vis:\r\n                tmp = max(i, p[k]) + 1\r\n                while tmp < n and (s[tmp] != s[p[k]] or tmp in vis):\r\n                    tmp += 1\r\n                p[k] = tmp\r\n        if s[i] < t[j]:\r\n            ans = min(ans, res)\r\n            break\r\n        mn = n\r\n        for k in range(ord(t[j]) - ord('a')):\r\n            mn = min(mn, p[k])\r\n        if mn != n:\r\n            # ans = min(ans, res + mn - i - (vis.bisect_left(mn) - vis.bisect_right(i)))\r\n            ans = min(ans, res + mn - i - (fen.query(mn) - fen.query(i + 1)))\r\n        if s[i] == t[j]:\r\n            i += 1\r\n            j += 1\r\n        else:\r\n            if i < p[ord(t[j]) - ord('a')] < mn:\r\n                idx = p[ord(t[j]) - ord('a')]\r\n                # res += idx - i - (vis.bisect_left(idx) - vis.bisect_right(i))\r\n                res += idx - i - (fen.query(idx) - fen.query(i + 1))\r\n                vis.add(idx)\r\n                fen.update(idx, 1)\r\n                j += 1\r\n            else:\r\n                break\r\n    print(ans if ans < float('inf') else -1)\r\n\r\n\r\n        \r\n\r\n",
    "prob_desc_created_at": "1640792100",
    "tags": [
        "brute force",
        "data structures",
        "greedy",
        "strings"
    ],
    "hidden_unit_tests": ""
}
{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"5\\n7\\n8\", \"33\"]",
    "src_uid": "db7c983516afd652b467f99b3591c1f6",
    "prob_desc_notes": "NoteIn the first example:   after the first change $$$a = [3, 4, 3]$$$;  after the second change $$$a = [3, 4, 4]$$$. In the second example:   after the first change $$$a = [6, 9, 10]$$$;  after the second change $$$a = [6, 13, 14]$$$. ",
    "prob_desc_description": "In this task, Nastya asked us to write a formal statement.An array $$$a$$$ of length $$$n$$$ and an array $$$k$$$ of length $$$n-1$$$ are given. Two types of queries should be processed:   increase $$$a_i$$$ by $$$x$$$. Then if $$$a_{i+1} &lt; a_i + k_i$$$, $$$a_{i+1}$$$ becomes exactly $$$a_i + k_i$$$; again, if $$$a_{i+2} &lt; a_{i+1} + k_{i+1}$$$, $$$a_{i+2}$$$ becomes exactly $$$a_{i+1} + k_{i+1}$$$, and so far for $$$a_{i+3}$$$, ..., $$$a_n$$$;  print the sum of the contiguous subarray from the $$$l$$$-th element to the $$$r$$$-th element of the array $$$a$$$. It's guaranteed that initially $$$a_i + k_i \\leq a_{i+1}$$$ for all $$$1 \\leq i \\leq n-1$$$.",
    "prob_desc_output_spec": "For each query of the second type print a single integer in a new line — the sum of the corresponding subarray.",
    "prob_desc_input_spec": "The first line contains a single integer $$$n$$$ ($$$2 \\leq n \\leq 10^{5}$$$) — the number of elements in the array $$$a$$$. The second line contains $$$n$$$ integers $$$a_1, a_2, \\ldots, a_n$$$ ($$$-10^{9} \\leq a_i \\leq 10^{9}$$$) — the elements of the array $$$a$$$. The third line contains $$$n-1$$$ integers $$$k_1, k_2, \\ldots, k_{n-1}$$$ ($$$-10^{6} \\leq k_i \\leq 10^{6}$$$) — the elements of the array $$$k$$$. The fourth line contains a single integer $$$q$$$ ($$$1 \\leq q \\leq 10^{5}$$$) — the number of queries. Each of the following $$$q$$$ lines contains a query of one of two types:    if the query has the first type, the corresponding line contains the character '+' (without quotes), and then there are two integers $$$i$$$ and $$$x$$$ ($$$1 \\leq i \\leq n$$$, $$$0 \\leq x \\leq 10^{6}$$$), it means that integer $$$x$$$ is added to the $$$i$$$-th element of the array $$$a$$$ as described in the statement.  if the query has the second type, the corresponding line contains the character 's' (without quotes) and then there are two integers $$$l$$$ and $$$r$$$ ($$$1 \\leq l \\leq r \\leq n$$$). ",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 2",
    "lang_cluster": "Python",
    "difficulty": 2200,
    "file_name": "train_016.jsonl",
    "code_uid": "140cbddf875423c5a9f9799c558e639f",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"3\\n1 2 3\\n1 -1\\n5\\ns 2 3\\n+ 1 2\\ns 1 2\\n+ 3 1\\ns 2 3\", \"3\\n3 6 7\\n3 1\\n3\\n+ 1 3\\n+ 2 4\\ns 1 3\"]",
    "exec_outcome": "PASSED",
    "source_code": "import os\nfrom io import BytesIO\nimport __pypy__\n\nrange = xrange\ninput = BytesIO(os.read(0, os.fstat(0).st_size)).readline\n\n\n# A very nice implementation of a minimum segment tree with \n# some inspiration taken from https://codeforces.com/blog/entry/18051\n# This implementation should be able to be modified to do pretty\n# much anything one would want to do with segment trees apart from\n# persistance.\n# Note that especially in python this implementation is much much better\n# than most other approches because how slow python can be with function\n# calls.\n\n# Currently it allows for two operations, both running in O(log n),\n# 'set(l,r,value)' sets value to [l,r)\n# 'find_min(l,r)' finds the index with the smallest value\n\nclass super_seg:\n    def __init__(self,data):\n        n = len(data)\n        m = 1\n        while m<n: m *= 2\n        \n        self.n = n\n        self.m = m\n        self.data = [0.0]*(2*m)\n        for i in range(n):\n            self.data[i+m] = data[i]\n        for i in reversed(range(m)):\n            self.data[i] = self.data[2*i] + self.data[2*i+1]\n        self.query = [None]*(2*m)\n    \n    # Push the query on seg_ind to its children\n    def push(self,seg_ind,si):\n        # Let the children know of the queries\n        setter = self.query[seg_ind]\n\n        if setter!=None:\n            self.query[2*seg_ind]   = setter\n            self.query[2*seg_ind+1] = setter\n            \n            self.data[2*seg_ind]   = (si//2) * setter\n            self.data[2*seg_ind+1] = (si//2) * setter\n\n            # Remove queries from seg_ind\n            self.data[seg_ind] = self.data[2*seg_ind] + self.data[2*seg_ind+1]\n            self.query[seg_ind] = None\n\n    # Updates the node seg_ind to know of all queries\n    # applied to it via its ancestors\n    def update(self,seg_ind):\n        # Find all indecies to be updated\n        seg_ind //= 2\n        inds = []\n        while seg_ind>0:\n            inds.append(seg_ind)\n            seg_ind//=2\n       \n        # Push the queries down the segment tree\n        si = self.m\n        for ind in reversed(inds):\n            self.push(ind,si)\n            si//=2\n\n    # Make the changes to seg_ind be known to its ancestors\n    def build(self,seg_ind):\n        seg_ind//=2\n        #si = 2\n        while seg_ind>0:\n            if self.query[seg_ind]==None:\n                self.data[seg_ind] = self.data[2*seg_ind] + self.data[2*seg_ind+1]\n            #else:    \n            #    self.data[seg_ind] = si*self.query[seg_ind]\n            seg_ind //= 2\n            #si*=2\n\n    # Lazily add value to [l,r)\n    def setter(self,l,r,value):\n        l += self.m\n        r += self.m\n        \n        l0 = l\n        r0 = r\n        si = 1\n\n        while l<r:\n            if l%2==1:\n                self.query[l] = value\n                self.data[l] = value*si\n                l+=1\n            if r%2==1:\n                r-=1\n                self.query[r] = value\n                self.data[r]  = value*si\n            l//=2\n            r//=2\n            si *= 2\n\n        # Tell all nodes above of the updated\n        # area of the updates\n        self.build(l0)\n        self.build(r0-1)\n    \n    # Min of data[l,r)\n    def summa(self,l,r):\n        l += self.m\n        r += self.m\n\n        # Apply all the lazily stored queries\n        self.update(l)\n        self.update(r-1)\n        \n        segs = 0.0\n        while l<r:\n            if l%2==1:\n                segs += self.data[l]\n                l+=1\n            if r%2==1:\n                r-=1\n                segs += self.data[r] \n            l//=2\n            r//=2\n\n        return segs\n\n\n\nn = int(input())\nA = [float(x) for x in input().split()]\nK = [float(x) for x in input().split()]\n\nKcumsum = [0.0]\nfor k in K:\n    Kcumsum.append(Kcumsum[-1]+k)\n\n# new A[i] is guaranteed to be increasing as a_i+k_i<=a_i+1 is now a_i<=a_i+1\nextra = [0.0]*n\nfor i in range(n):\n    A[i] += Kcumsum[n-1] - Kcumsum[i]\n    extra[i] = Kcumsum[n-1] - Kcumsum[i]\n\nextra_cumsum = [0.0]\nfor e in extra:\n    extra_cumsum.append(extra_cumsum[-1] + e)\n\n\nsumseg = super_seg(A)\nout = __pypy__.builders.StringBuilder()\n\n\nq = int(input())\nfor _ in range(q):\n    a,b,c = input().split()\n    if a=='+':\n        i,x = int(b)-1,float(c)\n        new_val = x + sumseg.summa(i,i+1)\n\n        a = i\n        b = n\n        while a<b:\n            c = (a+b+1)//2\n            if sumseg.summa(c,c+1)<new_val:\n                a = c\n            else:\n                b = c-1\n        sumseg.setter(i,a+1,new_val)\n\n    else:\n        l,r = int(b)-1,int(c)\n\n        ans = sumseg.summa(l,r)\n\n        # TRANSFORM BACK\n        ans -= extra_cumsum[r]-extra_cumsum[l]\n        out.append(str(int(ans)))\n        out.append('\\n')\n\nos.write(1,out.build())",
    "prob_desc_created_at": "1552322100",
    "tags": [
        "data structures",
        "binary search"
    ],
    "hidden_unit_tests": ""
}
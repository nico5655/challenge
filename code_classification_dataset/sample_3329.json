{
    "prob_desc_time_limit": "10 seconds",
    "prob_desc_sample_outputs": "[\"1\\n0\\n2\\n1\\n4\\n2\", \"-1\\n1\\n2\\n3\\n4\"]",
    "src_uid": "994f53de571b2a50f3135e4b4e66a232",
    "prob_desc_notes": "NoteThe description of changes of the graph in the first sample case:The description of changes of the graph in the second sample case:",
    "prob_desc_description": "You are given a weighted directed graph, consisting of n vertices and m edges. You should answer q queries of two types:  1 v — find the length of shortest path from vertex 1 to vertex v.  2 c l1 l2 ... lc — add 1 to weights of edges with indices l1, l2, ..., lc. ",
    "prob_desc_output_spec": "For each query of first type print the length of the shortest path from 1 to v in a separate line. Print -1, if such path does not exists.",
    "prob_desc_input_spec": "The first line of input data contains integers n, m, q (1 ≤ n, m ≤ 105, 1 ≤ q ≤ 2000) — the number of vertices and edges in the graph, and the number of requests correspondingly. Next m lines of input data contain the descriptions of edges: i-th of them contains description of edge with index i — three integers ai, bi, ci (1 ≤ ai, bi ≤ n, 0 ≤ ci ≤ 109) — the beginning and the end of edge, and its initial weight correspondingly. Next q lines of input data contain the description of edges in the format described above (1 ≤ v ≤ n, 1 ≤ lj ≤ m). It's guaranteed that inside single query all lj are distinct. Also, it's guaranteed that a total number of edges in all requests of the second type does not exceed 106.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 2",
    "lang_cluster": "Python",
    "difficulty": 3400,
    "file_name": "train_053.jsonl",
    "code_uid": "53eb3d8713aa12d3c81377c5b27d61b3",
    "prob_desc_memory_limit": "512 megabytes",
    "prob_desc_sample_inputs": "[\"3 2 9\\n1 2 0\\n2 3 0\\n2 1 2\\n1 3\\n1 2\\n2 1 1\\n1 3\\n1 2\\n2 2 1 2\\n1 3\\n1 2\", \"5 4 9\\n2 3 1\\n2 4 1\\n3 4 1\\n1 2 0\\n1 5\\n1 4\\n2 1 2\\n2 1 2\\n1 4\\n2 2 1 3\\n1 4\\n2 1 4\\n1 4\"]",
    "exec_outcome": "PASSED",
    "source_code": "#!/usr/bin/env pypy\nfrom __future__ import division, print_function\n\nimport os\nimport sys\nfrom __builtin__ import xrange as range\nfrom cStringIO import StringIO\nfrom future_builtins import map\nfrom heapq import heappop, heappush\nfrom io import IOBase\n\nimport __pypy__\n\nINF = float(10**18)\n\n\ndef main():\n    n, m, q = map(int, input().split())\n\n    a, b, c_ = [0] * (m + 1), [0] * (m + 1), [0] * (m + 1)\n    head, nxt = [0] * (n + 1), [0] * (m + 1)\n    for i in range(1, m + 1):\n        a[i], b[i], c_[i] = map(int, input().split())\n        nxt[i] = head[a[i]]\n        head[a[i]] = i\n\n    c = [float(ci) for ci in c_]\n\n    dist = [INF] * (n + 1)\n    dist[1] = 0.0\n\n    queue = [(0.0, 1)]\n    while queue:\n        path_len, v = heappop(queue)\n        if dist[v] == path_len:\n            w = head[v]\n            while w:\n                if dist[b[w]] > dist[v] + c[w]:\n                    dist[b[w]] = dist[v] + c[w]\n                    heappush(queue, (dist[b[w]], b[w]))\n                w = nxt[w]\n\n    for i in range(1, m + 1):\n        c[i] -= dist[b[i]] - dist[a[i]]\n\n    res = []\n\n    tot, tmp = 0, [0.0] * (n + 1)\n    for _ in range(q):\n        qi = map(int, input().split())\n        if next(qi) == 1:\n            v = next(qi)\n            if tot:\n                tmp[2:] = [INF] * (n - 1)\n                pos = [[] for _ in range(tot + 1)]\n                pos[0].append(1)\n                for cur in range(tot + 1):\n                    for w in pos[cur]:\n                        if tmp[w] == cur:\n                            e = head[w]\n                            while e:\n                                if tmp[b[e]] > cur + c[e]:\n                                    tmp[b[e]] = cur + c[e]\n                                    if tmp[b[e]] <= tot:\n                                        pos[int(tmp[b[e]])].append(b[e])\n                                e = nxt[e]\n\n                tot = 0\n                for i in range(1, m + 1):\n                    c[i] -= tmp[b[i]] - tmp[a[i]]\n                for i in range(2, n + 1):\n                    if tmp[i] != INF:\n                        dist[i] += tmp[i]\n\n            res.append(-1.0 if dist[v] == INF else dist[v])\n        else:\n            num = next(qi)\n            tot += num\n            for l in qi:\n                c[l] += 1\n\n    print('\\n'.join(str(int(x)) for x in res))\n\n\n# region fastio\n\nBUFSIZE = 8192\n\n\nclass FastI(IOBase):\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self._buffer = StringIO()\n        self.newlines = 0\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(\"\\n\") + (not b)\n            ptr = self._buffer.tell()\n            self._buffer.seek(0,\n                              2), self._buffer.write(b), self._buffer.seek(ptr)\n        self.newlines -= 1\n        return self._buffer.readline()\n\n\nclass FastO(IOBase):\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self._buffer = __pypy__.builders.StringBuilder()\n        self.write = lambda s: self._buffer.append(s)\n\n    def flush(self):\n        os.write(self._fd, self._buffer.build())\n        self._buffer = __pypy__.builders.StringBuilder()\n\n\ndef print(*args, **kwargs):\n    sep, file = kwargs.pop(\"sep\", \" \"), kwargs.pop(\"file\", sys.stdout)\n    at_start = True\n    for x in args:\n        if not at_start:\n            file.write(sep)\n        file.write(str(x))\n        at_start = False\n    file.write(kwargs.pop(\"end\", \"\\n\"))\n    if kwargs.pop(\"flush\", False):\n        file.flush()\n\n\nsys.stdin, sys.stdout = FastI(sys.stdin), FastO(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n# endregion\n\nif __name__ == \"__main__\":\n    main()\n",
    "prob_desc_created_at": "1503592500",
    "tags": [
        "shortest paths",
        "graphs"
    ],
    "hidden_unit_tests": ""
}
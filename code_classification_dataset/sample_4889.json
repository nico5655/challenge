{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"0\\n2 3\\n1\\n3 3\\n0\\n1 1\\n1 1\\n2\\n1 3\\n0 4\\n3\\n0 6\\n0 6\\n0 6\\n7\\n1 5\\n1 5\\n6 0\\n0\\n3 1\\n3 1\\n3 1\\n0\\n0 4\\n2 2\\n0 4\\n3 1\\n1 3\"]",
    "src_uid": "c63f5994543b136305a7ae2b9c744e13",
    "prob_desc_notes": null,
    "prob_desc_description": "A known chef has prepared $$$n$$$ dishes: the $$$i$$$-th dish consists of $$$a_i$$$ grams of fish and $$$b_i$$$ grams of meat. The banquet organizers estimate the balance of $$$n$$$ dishes as follows. The balance is equal to the absolute value of the difference between the total mass of fish and the total mass of meat.Technically, the balance equals to $$$\\left|\\sum\\limits_{i=1}^n a_i - \\sum\\limits_{i=1}^n b_i\\right|$$$. The smaller the balance, the better.In order to improve the balance, a taster was invited. He will eat exactly $$$m$$$ grams of food from each dish. For each dish, the taster determines separately how much fish and how much meat he will eat. The only condition is that he should eat exactly $$$m$$$ grams of each dish in total.Determine how much of what type of food the taster should eat from each dish so that the value of the balance is as minimal as possible. If there are several correct answers, you may choose any of them.",
    "prob_desc_output_spec": "For each test case, print on the first line the minimal balance value that can be achieved by eating exactly $$$m$$$ grams of food from each dish. Then print $$$n$$$ lines that describe a way to do this: the $$$i$$$-th line should contain two integers $$$x_i$$$ and $$$y_i$$$ ($$$0 \\leq x_i \\leq a_i$$$; $$$0 \\leq y_i \\leq b_i$$$; $$$x_i+y_i=m$$$), where $$$x_i$$$ is how many grams of fish taster should eat from the $$$i$$$-th meal and $$$y_i$$$ is how many grams of meat. If there are several ways to achieve a minimal balance, find any of them.",
    "prob_desc_input_spec": "The first line of input data contains an integer $$$t$$$ ($$$1 \\leq t \\leq 10^4$$$) — the number of the test cases. Each test case's description is preceded by a blank line. Next comes a line that contains integers $$$n$$$ and $$$m$$$ ($$$1 \\leq n \\leq 2 \\cdot 10^5$$$; $$$0 \\leq m \\leq 10^6$$$). The next $$$n$$$ lines describe dishes, the $$$i$$$-th of them contains a pair of integers $$$a_i$$$ and $$$b_i$$$ ($$$0 \\leq a_i, b_i \\le 10^6$$$) — the masses of fish and meat in the $$$i$$$-th dish. It is guaranteed that it is possible to eat $$$m$$$ grams of food from each dish. In other words, $$$m \\leq a_i+b_i$$$ for all $$$i$$$ from $$$1$$$ to $$$n$$$ inclusive. The sum of all $$$n$$$ values over all test cases in the test does not exceed $$$2 \\cdot 10^5$$$.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3",
    "lang_cluster": "Python",
    "difficulty": 2200,
    "file_name": "train_108.jsonl",
    "code_uid": "ffa493468c858751adf333b92e91d310",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"8\\n\\n1 5\\n3 4\\n\\n1 6\\n3 4\\n\\n2 2\\n1 3\\n4 2\\n\\n2 4\\n1 3\\n1 7\\n\\n3 6\\n1 7\\n1 8\\n1 9\\n\\n3 6\\n1 8\\n1 9\\n30 10\\n\\n3 4\\n3 1\\n3 2\\n4 1\\n\\n5 4\\n0 7\\n6 4\\n0 8\\n4 1\\n5 3\"]",
    "exec_outcome": "PASSED",
    "source_code": "# template begins\r\n#####################################\r\nfrom io import BytesIO, IOBase\r\nimport sys\r\nimport math\r\nimport os\r\nimport heapq\r\nfrom collections import defaultdict, deque\r\nfrom math import ceil\r\nfrom bisect import bisect_left, bisect_right\r\nfrom time import perf_counter\r\n\r\n\r\n# region fastio\r\n\r\nBUFSIZE = 8192\r\n\r\n\r\nclass FastIO(IOBase):\r\n    newlines = 0\r\n\r\n    def __init__(self, file):\r\n        self._fd = file.fileno()\r\n        self.buffer = BytesIO()\r\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\r\n        self.write = self.buffer.write if self.writable else None\r\n\r\n    def read(self):\r\n        while True:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            if not b:\r\n                break\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines = 0\r\n        return self.buffer.read()\r\n\r\n    def readline(self):\r\n        while self.newlines == 0:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            self.newlines = b.count(b\"\\n\") + (not b)\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines -= 1\r\n        return self.buffer.readline()\r\n\r\n    def flush(self):\r\n        if self.writable:\r\n            os.write(self._fd, self.buffer.getvalue())\r\n            self.buffer.truncate(0), self.buffer.seek(0)\r\n\r\n\r\nclass IOWrapper(IOBase):\r\n    def __init__(self, file):\r\n        self.buffer = FastIO(file)\r\n        self.flush = self.buffer.flush\r\n        self.writable = self.buffer.writable\r\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\r\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\r\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\r\n\r\n\r\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\r\ndef input(): return sys.stdin.readline().rstrip(\"\\r\\n\")\r\ndef mint(): return map(int, input().split())\r\ndef mfloat(): return map(float, input().split())\r\ndef intin(): return int(input())\r\n\r\n\r\n#####################################\r\n# template ends\r\n# Use the recursion snippet if heavy recursion is needed (depth>1000)\r\n# If constraints are tight, use 1d arrays instead of 2d, like g[i*m+j] instead of g[i][j]\r\ndef solve():\r\n    input()\r\n    n, m = map(int, input().split())\r\n    dishes = [list(map(int, input().split())) for _ in range(n)]\r\n    max_fish = max_meat = total_fish = total_meat = 0\r\n    for a, b in dishes:\r\n        total_fish += a\r\n        total_meat += b\r\n        max_fish += min(m, a)\r\n        max_meat += min(m, b)\r\n    balance = total_fish - total_meat\r\n    meat_if_all_fish = n*m - max_fish\r\n    fish_if_all_meat = n*m - max_meat\r\n    min_balance = balance - max_fish + meat_if_all_fish\r\n    max_balance = balance + max_meat - fish_if_all_meat\r\n    \"\"\"\r\n    min_balance = balance - max_fish + n*m - max_fish\r\n    max_balance = balance + max_meat - n*m + max_meat\r\n    -max_fish - max_meat + 2*n*m - max_fish - max_meat\r\n    2(n*m - max_fish - max_meat)\r\n    difference will always be even\r\n    \"\"\"\r\n    if (min_balance < 0) ^ (max_balance < 0):\r\n        target_balance = abs(min_balance) % 2\r\n    else:\r\n        target_balance = min(min_balance, max_balance, key=abs)\r\n    more_fish = balance - target_balance\r\n    \"\"\"\r\n    fish + meat = n*m\r\n    fish - meat = more_fish\r\n    2 * fish = n*m + more_fish\r\n    fish = (n*m + more_fish) / 2\r\n    \"\"\"\r\n    target_fish = (n*m + more_fish) // 2\r\n    ans = [[0, 0] for _ in range(n)]\r\n    for i in range(n):\r\n        fish_to_take = max(m - dishes[i][1], 0)\r\n        ans[i][0] = fish_to_take\r\n        target_fish -= fish_to_take\r\n    # print(ans, target_fish)\r\n    for i in range(n):\r\n        remaining_fish = min(dishes[i][0]-ans[i][0], target_fish, m-ans[i][0])\r\n        # print(remaining_fish)\r\n        fish_taken = ans[i][0] + remaining_fish\r\n        target_fish -= remaining_fish\r\n        ans[i][0] = fish_taken\r\n        ans[i][1] = m - fish_taken\r\n\r\n    print(abs(target_balance))\r\n    for i in ans:\r\n        print(*i)\r\n\r\n\r\ndef main():\r\n    t = 1\r\n    t = int(input())\r\n    for _ in range(t):\r\n        solve()\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    start_time = perf_counter()\r\n    main()\r\n    print(perf_counter()-start_time, file=sys.stderr)\r\n",
    "prob_desc_created_at": "1635863700",
    "tags": [
        "greedy"
    ],
    "hidden_unit_tests": ""
}
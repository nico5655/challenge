{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"1 0\\n1 1\\n2 0\\n1 0\\n1 1\"]",
    "src_uid": "af3f3329e249c0a4fa14476626e9c97c",
    "prob_desc_notes": null,
    "prob_desc_description": "You are given a bracket sequence consisting of $$$n$$$ characters '(' and/or )'. You perform several operations with it.During one operation, you choose the shortest prefix of this string (some amount of first characters of the string) that is good and remove it from the string.The prefix is considered good if one of the following two conditions is satisfied:  this prefix is a regular bracket sequence;  this prefix is a palindrome of length at least two. A bracket sequence is called regular if it is possible to obtain a correct arithmetic expression by inserting characters '+' and '1' into this sequence. For example, sequences (())(), () and (()(())) are regular, while )(, (() and (()))( are not.The bracket sequence is called palindrome if it reads the same back and forth. For example, the bracket sequences )), (( and )(() are palindromes, while bracket sequences (), )( and ))( are not palindromes.You stop performing the operations when it's not possible to find a good prefix. Your task is to find the number of operations you will perform on the given string and the number of remaining characters in the string.You have to answer $$$t$$$ independent test cases.",
    "prob_desc_output_spec": "For each test case, print two integers $$$c$$$ and $$$r$$$ — the number of operations you will perform on the given bracket sequence and the number of characters that remain in the string after performing all operations.",
    "prob_desc_input_spec": "The first line of the input contains one integer $$$t$$$ ($$$1 \\le t \\le 10^4$$$) — the number of test cases. The next $$$2t$$$ lines describe test cases. The first line of the test case contains one integer $$$n$$$ ($$$1 \\le n \\le 5 \\cdot 10^5$$$) — the length of the bracket sequence. The second line of the test case contains $$$n$$$ characters '(' and/or ')' — the bracket sequence itself. It is guaranteed that the sum of $$$n$$$ over all test cases do not exceed $$$5 \\cdot 10^5$$$ ($$$\\sum n \\le 5 \\cdot 10^5$$$).",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3-64",
    "lang_cluster": "Python",
    "difficulty": 1200,
    "file_name": "train_110.jsonl",
    "code_uid": "c3edf8f1bd10dc16c25c1fa6e5d68055",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"5\\n2\\n()\\n3\\n())\\n4\\n((((\\n5\\n)((()\\n6\\n)((()(\"]",
    "exec_outcome": "PASSED",
    "source_code": "from __future__ import division, print_function\r\nimport os,sys\r\nfrom io import BytesIO, IOBase\r\n\r\nif sys.version_info[0] < 3:\r\n    from __builtin__ import xrange as range\r\n    from future_builtins import ascii, filter, hex, map, oct, zip\r\n\r\n\r\n\r\n\r\n# from math import ceil, floor, factorial\r\n# from math import log,sqrt,cos,tan,sin,radians\r\n# from bisect import bisect_left, bisect_right\r\nfrom collections import deque\r\n\r\n# from collections import deque, Counter, OrderedDict\r\n# from heapq import nsmallest, nlargest, heapify, heappop, heappush, heapreplace\r\n# from bisect import bisect,bisect_left,bisect_right,insort,insort_left,insort_right\r\n# from decimal import *\r\n\r\n# from itertools import permutations\r\n\r\n# ======================== Functions declaration Starts ========================\r\n\r\n\r\n# abc='abcdefghijklmnopqrstuvwxyz'\r\n# abd={'a':0,'b':1,'c':2,'d':3,'e':4,'f':5,'g':6,'h':7,'i':8,'j':9,'k':10,'l':11,'m':12,'n':13,'o':14,'p':15,'q':16,'r':17,'s':18,'t':19,'u':20,'v':21,'w':22,'x':23,'y':24,'z':25}\r\n\r\n\r\n# M=1000000007\r\n# # M=998244353\r\n# INF = float(\"inf\")\r\n# PI = 3.141592653589793\r\n\r\n# def copy2d(lst): return [x[:] for x in lst]   #Copy 2D list... Avoid Using Deepcopy\r\n# def isPowerOfTwo(x): return (x and (not(x & (x - 1))) )\r\n\r\n# LB = bisect_left   # Lower bound\r\n# UB = bisect_right  # Upper bound\r\n \r\n# def BS(a, x):      # Binary Search\r\n#     i = bisect_left(a, x)\r\n#     if i != len(a) and a[i] == x:\r\n#         return i\r\n#     else:\r\n#         return -1\r\n\r\n# def gcd(x, y):\r\n#     while y:\r\n#         x, y = y, x % y\r\n#     return x\r\n\r\n# def lcm(x, y):\r\n#     return (x*y)//gcd(x,y)\r\n\r\n# import threading\r\n# def dmain():\r\n#     sys.setrecursionlimit(1000000)\r\n#     threading.stack_size(1024000)\r\n#     thread = threading.Thread(target=main)\r\n#     thread.start()\r\n    \r\n# ========================= Functions declaration Ends =========================\r\n\r\ndef is_palin(word):\r\n    i,j = 0,len(word)-1\r\n    while i<j:\r\n        if word[i] != word[j]:\r\n            return False\r\n        i+=1\r\n        j-=1\r\n    return True\r\n \r\ndef main():\r\n    TestCases = 1\r\n    TestCases = int(input())\r\n \r\n    for _ in range(TestCases):\r\n        n = int(input())\r\n        brackets = input()\r\n        brackets = deque(brackets)\r\n  \r\n        ans = 0        \r\n        prefix = []\r\n        while len(brackets)>=1:\r\n            prefix.append(brackets.popleft())\r\n            if len(prefix)==1:\r\n                continue\r\n            if (len(prefix)==2 and prefix!=[')','(']) or is_palin(prefix):\r\n                ans+=1\r\n                prefix = []\r\n \r\n \r\n        left = len(brackets)+len(prefix)\r\n        print(ans, left)\r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n        \r\n# =============================== Region Fastio ===============================\r\nif not os.path.isdir('C:/users/acer'):\r\n    BUFSIZE = 8192\r\n    \r\n    \r\n    class FastIO(IOBase):\r\n        newlines = 0\r\n    \r\n        def __init__(self, file):\r\n            self._fd = file.fileno()\r\n            self.buffer = BytesIO()\r\n            self.writable = \"x\" in file.mode or \"r\" not in file.mode\r\n            self.write = self.buffer.write if self.writable else None\r\n    \r\n        def read(self):\r\n            while True:\r\n                b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n                if not b:\r\n                    break\r\n                ptr = self.buffer.tell()\r\n                self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n            self.newlines = 0\r\n            return self.buffer.read()\r\n    \r\n        def readline(self):\r\n            while self.newlines == 0:\r\n                b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n                self.newlines = b.count(b\"\\n\") + (not b)\r\n                ptr = self.buffer.tell()\r\n                self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n            self.newlines -= 1\r\n            return self.buffer.readline()\r\n    \r\n        def flush(self):\r\n            if self.writable:\r\n                os.write(self._fd, self.buffer.getvalue())\r\n                self.buffer.truncate(0), self.buffer.seek(0)\r\n    \r\n    \r\n    class IOWrapper(IOBase):\r\n        def __init__(self, file):\r\n            self.buffer = FastIO(file)\r\n            self.flush = self.buffer.flush\r\n            self.writable = self.buffer.writable\r\n            self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\r\n            self.read = lambda: self.buffer.read().decode(\"ascii\")\r\n            self.readline = lambda: self.buffer.readline().decode(\"ascii\")\r\n    \r\n    \r\n    def print(*args, **kwargs):\r\n        \"\"\"Prints the values to a stream, or to sys.stdout by default.\"\"\"\r\n        sep, file = kwargs.pop(\"sep\", \" \"), kwargs.pop(\"file\", sys.stdout)\r\n        at_start = True\r\n        for x in args:\r\n            if not at_start:\r\n                file.write(sep)\r\n            file.write(str(x))\r\n            at_start = False\r\n        file.write(kwargs.pop(\"end\", \"\\n\"))\r\n        if kwargs.pop(\"flush\", False):\r\n            file.flush()\r\n    \r\n    \r\n    if sys.version_info[0] < 3:\r\n        sys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)\r\n    else:\r\n        sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\r\n    \r\n    input = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\r\n\r\n# =============================== Endregion ===============================\r\n\r\nif __name__ == \"__main__\":\r\n    #read()\r\n    main()\r\n    #dmain()\r\n\r\n",
    "prob_desc_created_at": "1647960300",
    "tags": [
        "greedy",
        "implementation"
    ],
    "hidden_unit_tests": ""
}
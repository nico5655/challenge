{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"YES\\nNO\\nYES\\nYES\\nNO\"]",
    "src_uid": "e630243546bf46757ba1acdbdfd475c2",
    "prob_desc_notes": "NoteIn the first testcase, the only possible original RBS is \"(())\".In the second testcase, there are multiple ways to recover an RBS.In the third and the fourth testcases, the only possible original RBS is \"()\".In the fifth testcase, the original RBS can be either \"((()()))\" or \"(())()()\".",
    "prob_desc_description": "A bracket sequence is a string containing only characters \"(\" and \")\". A regular bracket sequence (or, shortly, an RBS) is a bracket sequence that can be transformed into a correct arithmetic expression by inserting characters \"1\" and \"+\" between the original characters of the sequence. For example:  bracket sequences \"()()\" and \"(())\" are regular (the resulting expressions are: \"(1)+(1)\" and \"((1+1)+1)\");  bracket sequences \")(\", \"(\" and \")\" are not. There was an RBS. Some brackets have been replaced with question marks. Is it true that there is a unique way to replace question marks with brackets, so that the resulting sequence is an RBS?",
    "prob_desc_output_spec": "For each testcase, print \"YES\" if the way to replace question marks with brackets, so that the resulting sequence is an RBS, is unique. If there is more than one way, then print \"NO\".",
    "prob_desc_input_spec": "The first line contains a single integer $$$t$$$ ($$$1 \\le t \\le 5 \\cdot 10^4$$$) — the number of testcases. The only line of each testcase contains an RBS with some brackets replaced with question marks. Each character is either '(', ')' or '?'. At least one RBS can be recovered from the given sequence. The total length of the sequences over all testcases doesn't exceed $$$2 \\cdot 10^5$$$.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 2",
    "lang_cluster": "Python",
    "difficulty": 1800,
    "file_name": "train_090.jsonl",
    "code_uid": "4c8e890ef779971bc7b819783749c00d",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"5\\n\\n(?))\\n\\n??????\\n\\n()\\n\\n??\\n\\n?(?)()?)\"]",
    "exec_outcome": "PASSED",
    "source_code": "#!/usr/bin/env python\nfrom __future__ import division, print_function\n\nimport os\nimport sys\nfrom io import BytesIO, IOBase\n\nif sys.version_info[0] < 3:\n    from __builtin__ import xrange as range\n    from future_builtins import ascii, filter, hex, map, oct, zip\n\ndef solve(s):\n    from collections import Counter\n    c = Counter(s)\n    a = (c['?'] + c[')'] - c['(']) // 2\n    b = c['?'] - a\n\n    q = 0\n    l = r = None\n    for i, c in enumerate(s):\n        if c == '?':\n            if q < a:\n                l = i\n            elif r is None:\n                r = i\n            q += 1\n    if l is None or r is None:\n        return 'YES'\n\n    check = 0\n    for i, c in enumerate(s):\n        if c == '(':\n            check += 1\n        elif c == ')':\n            check -= 1\n        elif i < l:\n            check += 1\n        elif i == l:\n            check -= 1\n        elif i == r:\n            check += 1\n        else:\n            check -= 1\n        if check < 0:\n            return 'YES'\n    if check != 0:\n        return 'YES'\n    return 'NO'\n\ndef main():\n    t = int(input())\n    for _ in range(t):\n        s = input()\n        print(solve(s))\n\n\n# region fastio\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\ndef print(*args, **kwargs):\n    \"\"\"Prints the values to a stream, or to sys.stdout by default.\"\"\"\n    sep, file = kwargs.pop(\"sep\", \" \"), kwargs.pop(\"file\", sys.stdout)\n    at_start = True\n    for x in args:\n        if not at_start:\n            file.write(sep)\n        file.write(str(x))\n        at_start = False\n    file.write(kwargs.pop(\"end\", \"\\n\"))\n    if kwargs.pop(\"flush\", False):\n        file.flush()\n\n\nif sys.version_info[0] < 3:\n    sys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)\nelse:\n    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\n\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\ninputarr = lambda: [int(x) for x in input().split()]\n\n# endregion\n\nif __name__ == \"__main__\":\n    main()\n",
    "prob_desc_created_at": "1658414100",
    "tags": [
        "constructive algorithms",
        "greedy",
        "implementation",
        "strings"
    ],
    "hidden_unit_tests": ""
}
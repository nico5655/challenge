{
    "prob_desc_time_limit": "1 second",
    "prob_desc_sample_outputs": "[\"NO\", \"YES\", \"YES\"]",
    "src_uid": "e060d26dc3b9ffb628f2380781d1cbe9",
    "prob_desc_notes": null,
    "prob_desc_description": "The Bytelandian Institute for Biological Research (BIBR) is investigating the properties of two species of bacteria, named simply 0 and 1. Even under a microscope, bacteria of those two species are very difficult to distinguish. In fact, the only thing the scientists possess that is able to differentiate between them is a plant called Formurosa.If the scientists place a sample of colonies of bacteria on each on Formurosa's leaves, it will activate a complicated nutrition process. During that process color of Formurosa changes to reflect the result of a — possibly very complicated — logical formula on the species of bacteria, involving constants and the operators | (OR), &amp; (AND) and ^ (XOR). If it is 0, the plant will turn red, otherwise — it will turn blue.For example, if the nutrition process of Formurosa is described by the formula: (((?^?)|?)&amp;(1^?)); then Formurosa has four leaves (the \"?\" signs denote the leaves). If we place 0, 1, 0, 0 on the respective leaves, the result of the nutrition process will be (((0^1)|0)&amp;(1^0)) = 1, therefore the plant will turn blue.The scientists have n colonies of bacteria. They do not know their types; the only thing they know for sure is that not all colonies are of the same type. They want to attempt to determine the bacteria's species by repeated evaluations with Formurosa. During each evaluation they must place exactly one sample on every leaf of the plant. However, they may use multiple samples of one colony during a single evaluation; they can even cover the whole plant with bacteria from one colony!Is it possible for them to always determine the species of each colony, no matter what they are (assuming they are not all the same)?",
    "prob_desc_output_spec": "If it is always possible to determine the species of each colony, output \"YES\" (without quotes). Otherwise, output \"NO\" (without quotes).",
    "prob_desc_input_spec": "The first line of input contains a single integer n (2 ≤ n ≤ 106) — the number of colonies of bacteria. The second line contains the formula describing the nutrition process of Formurosa. This line contains only characters «0», «1», «?», «|», «&amp;», «^», «(», «)» and complies with the following grammar: s → 0|1|?|(s|s)|(s&amp;s)|(s^s) The formula consists of no more than 106 characters.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "Python 2",
    "lang_cluster": "Python",
    "difficulty": 2600,
    "file_name": "train_077.jsonl",
    "code_uid": "4c461f00c02bc4d5261d72782ca40fd8",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"2\\n(?^?)\", \"10\\n?\", \"2\\n((?^?)&amp;?)\"]",
    "exec_outcome": "PASSED",
    "source_code": "\n\nn = int(raw_input())\nf = raw_input()\n\nls = []\nos = []\n\ntmp = [[[0 for k in range(16)] for j in range(16)] for i in range(3)]\n\n# 0\n# 1\n# a\n# na\n\"\"\"\ndef maeshori():\n    for i in range(3):\n        for j in range(16):\n            for k in range(16):\n                tmp[i][j][k] = 0\n    for j in range(16):\n        for k in range(16):\n            for i1,ii1 in [(p,2**p) for p in range(4)]:\n                for i2,ii2 in [(p,2**p) for p in range(4)]:\n                    if j&ii1==0 or k&ii2==0: continue\n                    if i1<=1 and i2<=1: ans.add(i1&i2)\n                        if tmp[0][j][k]&(2**(i1&i2))==0: tmp[0][j][k] += 2**(i1&i2)\n                    elif (i1,i2) in [(0,2), (0,3), (2,0), (3,0), (2,3), (3,2)]:\n                        if tmp[0][j][k]&1==0: tmp[0][j][k] += 1\n                    elif (i1,i2) in [(1,2), (2,1), (2,2)]: ans.add(2)\n                    elif (i1,i2) in [(1,3), (3,1), (3,3)]: ans.add(3)\n\"\"\"                    \n\"\"\"\n    if o=='&':\n    for i1 in u1:\n    for i2 in u2:\n    if i1<=1 and i2<=1: ans.add(i1&i2)\n    elif (i1,i2) in [(0,2), (0,3), (2,0), (3,0), (2,3), (3,2)]: ans.add(0)\n    elif (i1,i2) in [(1,2), (2,1), (2,2)]: ans.add(2)\n    elif (i1,i2) in [(1,3), (3,1), (3,3)]: ans.add(3)\n    if o=='|':\n    for i1 in u1:\n    for i2 in u2:\n    if i1<=1 and i2<=1: ans.add(i1|i2)\n    elif (i1,i2) in [(1,2), (1,3), (2,1), (3,1), (2,3), (3,2)]: ans.add(1)\n    elif (i1,i2) in [(0,2), (2,0), (2,2)]: ans.add(2)\n    elif (i1,i2) in [(0,3), (3,0), (3,3)]: ans.add(3)\n    if o=='^':\n    for i1 in u1:\n    for i2 in u2:\n    if i1<=1 and i2<=1: ans.add(i1^i2)\n    elif (i1,i2) in [(2,2), (3,3)]: ans.add(0)\n    elif (i1,i2) in [(2,3), (3,2)]: ans.add(1)\n    elif (i1,i2) in [(0,2), (2,0), (1,3), (3,1)]: ans.add(2)\n    elif (i1,i2) in [(0,3), (3,0), (1,2), (2,1)]: ans.add(3)\n\"\"\"\n\nfor ch in f:\n    if ch==')':\n        u1 = ls.pop()\n        o = os.pop()\n        u2 = ls.pop()\n        ans = set([])\n        if o=='&':\n            for i1 in u1:\n                for i2 in u2:\n                    if (i1,i2) in ((0,0), (0,1), (1,0), (0,2), (2,0)): ans.add(0)\n                    elif (i1,i2)==(1,1): ans.add(1)\n                    elif (i1,i2) in ((1,2), (2,1)): ans.add(2)\n                    elif (i1,i2)==(2,2): \n                        ans.add(0)\n                        ans.add(2)\n        elif o=='|':\n#           print u1, u2, o\n            for i1 in u1:\n                for i2 in u2:\n#                   print i1,i2\n                    if (i1,i2)==(0,0): ans.add(0)\n                    elif (i1,i2) in ((0,1), (1,0), (1,1), (1,2), (2,1)): ans.add(1)\n                    elif (i1,i2) in ((0,2), (2,0)): ans.add(2)\n                    elif (i1,i2)==(2,2):\n                        ans.add(1)\n                        ans.add(2)\n        elif o=='^':\n            for i1 in u1:\n                for i2 in u2:\n                    if (i1,i2) in ((0,0), (1,1)): ans.add(0)\n                    elif (i1,i2) in ((0,1), (1,0)): ans.add(1)\n                    elif (i1,i2)==(2,2):\n                        ans.add(0)\n                        ans.add(1)\n                    elif (i1,i2) in [(0,2), (2,0), (1,2), (2,1)]:\n                        ans.add(2)\n        ls.append(ans)\n#       print ls\n    elif ch=='0': ls.append(set([0]))\n    elif ch=='1': ls.append(set([1]))\n    elif ch=='?': ls.append(set([2]))\n    elif ch in ('&', '|', '^'): os.append(ch)\n\nans = ls.pop()\nif (2 in ans): print 'YES'\nelse: print 'NO'\n",
    "prob_desc_created_at": "1345273500",
    "tags": [
        "dp",
        "divide and conquer",
        "expression parsing"
    ],
    "hidden_unit_tests": ""
}
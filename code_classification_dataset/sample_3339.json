{
    "prob_desc_time_limit": "1 second",
    "prob_desc_sample_outputs": "[\"1\\n3\", \"2\\n1 2\", \"0\"]",
    "src_uid": "ce19cc45bbe24177155ce87dfe9d5c22",
    "prob_desc_notes": "NoteIn the first example, $$$3$$$ is the only possible answer.  In the second example, there are $$$2$$$ possible answers.  In the third example, the tree can't be generated by McDic's generation.",
    "prob_desc_description": "You have an integer $$$n$$$. Let's define following tree generation as McDic's generation:  Make a complete and full binary tree of $$$2^{n} - 1$$$ vertices. Complete and full binary tree means a tree that exactly one vertex is a root, all leaves have the same depth (distance from the root), and all non-leaf nodes have exactly two child nodes.  Select a non-root vertex $$$v$$$ from that binary tree.  Remove $$$v$$$ from tree and make new edges between $$$v$$$'s parent and $$$v$$$'s direct children. If $$$v$$$ has no children, then no new edges will be made. You have a tree. Determine if this tree can be made by McDic's generation. If yes, then find the parent vertex of removed vertex in tree.",
    "prob_desc_output_spec": "Print two lines. In the first line, print a single integer — the number of answers. If given tree cannot be made by McDic's generation, then print $$$0$$$. In the second line, print all possible answers in ascending order, separated by spaces. If the given tree cannot be made by McDic's generation, then don't print anything.",
    "prob_desc_input_spec": "The first line contains integer $$$n$$$ ($$$2 \\le n \\le 17$$$). The $$$i$$$-th of the next $$$2^{n} - 3$$$ lines contains two integers $$$a_{i}$$$ and $$$b_{i}$$$ ($$$1 \\le a_{i} \\lt b_{i} \\le 2^{n} - 2$$$) — meaning there is an edge between $$$a_{i}$$$ and $$$b_{i}$$$. It is guaranteed that the given edges form a tree.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3",
    "lang_cluster": "Python",
    "difficulty": 2500,
    "file_name": "train_053.jsonl",
    "code_uid": "eddc88ff772193c203afec5e9195f864",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"4\\n1 2\\n1 3\\n2 4\\n2 5\\n3 6\\n3 13\\n3 14\\n4 7\\n4 8\\n5 9\\n5 10\\n6 11\\n6 12\", \"2\\n1 2\", \"3\\n1 2\\n2 3\\n3 4\\n4 5\\n5 6\"]",
    "exec_outcome": "PASSED",
    "source_code": "#!/usr/bin/python3\n\nimport array\nimport math\nimport os\nimport sys\n\n\nDEBUG = 'DEBUG' in os.environ\n\n\ndef inp():\n    return sys.stdin.readline().rstrip()\n\n\ndef dprint(*value, sep=' ', end='\\n'):\n    if DEBUG:\n        print(*value, sep=sep, end=end)\n\n\ndef solve(N, M, G):\n    if N == 2:\n        return [0, 1]\n\n    degv = [set() for _ in range(5)]\n    for i in range(M):\n        d = len(G[i])\n        if d == 0 or d >= 5:\n            return []\n        degv[d].add(i)\n\n    layer_vcount = 1 << (N - 1)\n    vs = degv[1]\n    levels = bytearray(M)\n    ans = []\n    for level in range(1, N):\n        #dprint('level', level, [x for x in levels])\n        #dprint('vs', vs)\n        #dprint('layer_vcount', layer_vcount)\n\n        if len(vs) not in (layer_vcount - 1, layer_vcount):\n            return []\n        if len(vs) == layer_vcount - 1:\n            if ans:\n                return []\n            if level == 1:\n                sp_deg_off = -1\n            else:\n                sp_deg_off = 1\n        else:\n            sp_deg_off = 0\n        #dprint('sp_deg_off', sp_deg_off)\n\n        ndeg = 3 if level < N - 1 else 2\n        us = set()\n        ss = set()\n\n        for v in vs:\n            #dprint('v', v)\n            levels[v] = level\n            p = None\n            for u in G[v]:\n                if levels[u] == 0:\n                    if p is not None:\n                        return []\n                    p = u\n                    break\n            #dprint('  p', p)\n            if p is None:\n                return []\n            deg = len(G[p])\n            #dprint('  deg', deg)\n\n            if deg == ndeg:\n                us.add(p)\n            elif deg == ndeg + sp_deg_off:\n                ss.add(p)\n            elif sp_deg_off == 0 and deg == ndeg + 1:\n                ss.add(p)\n            else:\n                return []\n\n        #dprint('us', us)\n        #dprint('ss', ss)\n\n        if sp_deg_off != 0:\n            if len(ss) != 1:\n                return []\n            (sp,) = list(ss)\n            ans = [sp]\n            us.add(sp)\n\n        if sp_deg_off == 0:\n            if level == N - 2:\n                if ss:\n                    return []\n                if not ans:\n                    li = list(us)\n                    li.sort()\n                    return li\n            if len(ss) > 1:\n                return []\n\n        vs = us\n        layer_vcount >>= 1\n\n    return ans\n\n\ndef main():\n    N = int(inp())\n    M = (1 << N) - 2\n    G = [[] for _ in range(M)]\n    for _ in range(M - 1):\n        a, b = [int(e) - 1 for e in inp().split()]\n        G[a].append(b)\n        G[b].append(a)\n\n    ans = solve(N, M, G)\n    print(len(ans))\n    if ans:\n        print(*[v + 1 for v in ans])\n\n\nif __name__ == '__main__':\n    main()\n",
    "prob_desc_created_at": "1569762300",
    "tags": [
        "constructive algorithms",
        "implementation",
        "trees"
    ],
    "hidden_unit_tests": ""
}
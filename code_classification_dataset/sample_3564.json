{
    "prob_desc_time_limit": "1 second",
    "prob_desc_sample_outputs": "[\"1\\n1 1 1 1 1\", \"2\\n1 1 2\"]",
    "src_uid": "9974ea401e2ec62f3c1e2317a23ee605",
    "prob_desc_notes": null,
    "prob_desc_description": "You are given a directed graph with $$$n$$$ vertices and $$$m$$$ directed edges without self-loops or multiple edges.Let's denote the $$$k$$$-coloring of a digraph as following: you color each edge in one of $$$k$$$ colors. The $$$k$$$-coloring is good if and only if there no cycle formed by edges of same color.Find a good $$$k$$$-coloring of given digraph with minimum possible $$$k$$$.",
    "prob_desc_output_spec": "In the first line print single integer $$$k$$$ — the number of used colors in a good $$$k$$$-coloring of given graph. In the second line print $$$m$$$ integers $$$c_1, c_2, \\dots, c_m$$$ ($$$1 \\le c_i \\le k$$$), where $$$c_i$$$ is a color of the $$$i$$$-th edge (in order as they are given in the input). If there are multiple answers print any of them (you still have to minimize $$$k$$$).",
    "prob_desc_input_spec": "The first line contains two integers $$$n$$$ and $$$m$$$ ($$$2 \\le n \\le 5000$$$, $$$1 \\le m \\le 5000$$$) — the number of vertices and edges in the digraph, respectively. Next $$$m$$$ lines contain description of edges — one per line. Each edge is a pair of integers $$$u$$$ and $$$v$$$ ($$$1 \\le u, v \\le n$$$, $$$u \\ne v$$$) — there is directed edge from $$$u$$$ to $$$v$$$ in the graph. It is guaranteed that each ordered pair $$$(u, v)$$$ appears in the list of edges at most once.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 2",
    "lang_cluster": "Python",
    "difficulty": 2100,
    "file_name": "train_069.jsonl",
    "code_uid": "24b8226da9f0cfa1515ab6c41e9a5b20",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"4 5\\n1 2\\n1 3\\n3 4\\n2 4\\n1 4\", \"3 3\\n1 2\\n2 3\\n3 1\"]",
    "exec_outcome": "PASSED",
    "source_code": "from __future__ import division, print_function\nimport math\ndef main():\n    from collections import defaultdict \n    from collections import deque\n    class Graph(): \n        def __init__(self,vertices): \n            self.graph = defaultdict(list) \n            self.V = vertices \n      \n        def addEdge(self,u,v): \n            self.graph[u].append(v) \n      \n        def isCyclicUtil(self, v, visited, recStack): \n            visited[v] = True\n            recStack[v] = True\n            for neighbour in self.graph[v]: \n                if visited[neighbour] == False: \n                    if self.isCyclicUtil(neighbour, visited, recStack) == True: \n                        return True\n                elif recStack[neighbour] == True: \n                    return True\n            recStack[v] = False\n            return False\n        def isCyclic(self): \n            visited = [False] * self.V \n            recStack = [False] * self.V \n            for node in range(self.V): \n                if visited[node] == False: \n                    if self.isCyclicUtil(node,visited,recStack) == True: \n                        return True\n            return False\n        def neigh(self,u):\n            return self.graph[u]\n    \n    n,m=map(int,input().split())\n    g=Graph(n)\n    pos={}\n    for i in range(m):\n        u,v=map(int,input().split())\n        g.addEdge(u-1,v-1)\n        pos[(u-1,v-1)]=i\n    if g.isCyclic()==1:\n        print(2)\n        result=[0]*m\n        for k in pos:\n            if k[0]<k[1]:\n                result[pos[k]]=1\n            else :\n                result[pos[k]]=2\n        print(\" \".join(str(x) for x in result))\n    else :\n        print(1)\n        for i in range(m):\n            print(1,end=\" \")\n                \n \n######## Python 2 and 3 footer by Pajenegod and c1729\n \n# Note because cf runs old PyPy3 version which doesn't have the sped up\n# unicode strings, PyPy3 strings will many times be slower than pypy2.\n# There is a way to get around this by using binary strings in PyPy3\n# but its syntax is different which makes it kind of a mess to use.\n \n# So on cf, use PyPy2 for best string performance.\n \npy2 = round(0.5)\nif py2:\n    from future_builtins import ascii, filter, hex, map, oct, zip\n    range = xrange\n \nimport os, sys\nfrom io import IOBase, BytesIO\n \nBUFSIZE = 8192\nclass FastIO(BytesIO):\n    newlines = 0\n \n    def __init__(self, file):\n        self._file = file\n        self._fd = file.fileno()\n        self.writable = \"x\" in file.mode or \"w\" in file.mode\n        self.write = super(FastIO, self).write if self.writable else None\n \n    def _fill(self):\n        s = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n        self.seek((self.tell(), self.seek(0,2), super(FastIO, self).write(s))[0])\n        return s\n \n    def read(self):\n        while self._fill(): pass\n        return super(FastIO,self).read()\n \n    def readline(self):\n        while self.newlines == 0:\n            s = self._fill(); self.newlines = s.count(b\"\\n\") + (not s)\n        self.newlines -= 1\n        return super(FastIO, self).readline()\n \n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.getvalue())\n            self.truncate(0), self.seek(0)\n \nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        if py2:\n            self.write = self.buffer.write\n            self.read = self.buffer.read\n            self.readline = self.buffer.readline\n        else:\n            self.write = lambda s:self.buffer.write(s.encode('ascii'))\n            self.read = lambda:self.buffer.read().decode('ascii')\n            self.readline = lambda:self.buffer.readline().decode('ascii')\n \n \nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip('\\r\\n')\n \n# Cout implemented in Python\nimport sys\nclass ostream:\n    def __lshift__(self,a):\n        sys.stdout.write(str(a))\n        return self\ncout = ostream()\nendl = '\\n'\n \n# Read all remaining integers in stdin, type is given by optional argument, this is fast\ndef readnumbers(zero = 0):\n    conv = ord if py2 else lambda x:x\n    A = []; numb = zero; sign = 1; i = 0; s = sys.stdin.buffer.read()\n    try:\n        while True:\n            if s[i] >= b'0' [0]:\n                numb = 10 * numb + conv(s[i]) - 48\n            elif s[i] == b'-' [0]: sign = -1\n            elif s[i] != b'\\r' [0]:\n                A.append(sign*numb)\n                numb = zero; sign = 1\n            i += 1\n    except:pass\n    if s and s[-1] >= b'0' [0]:\n        A.append(sign*numb)\n    return A\n \nif __name__== \"__main__\":\n  main()",
    "prob_desc_created_at": "1567694100",
    "tags": [
        "constructive algorithms",
        "dfs and similar",
        "graphs"
    ],
    "hidden_unit_tests": ""
}
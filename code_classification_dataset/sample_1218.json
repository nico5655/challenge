{
    "prob_desc_time_limit": "3 seconds",
    "prob_desc_sample_outputs": "[\"2\\n4\\n20\\n3\", \"2\\n0\\n2\"]",
    "src_uid": "d100092621f97b2749729914d3fabf46",
    "prob_desc_notes": "NoteInitially the tree looks like this:   The response to the first query is:  = 2After the third edge is changed, the tree looks like this:   The response to the second query is:  = 4In the third query the initial and final vertex coincide, that is, the answer will be the initial number 20.After the change in the fourth edge the tree looks like this:   In the last query the answer will be:  = 3",
    "prob_desc_description": "Bogdan has a birthday today and mom gave him a tree consisting of n vertecies. For every edge of the tree i, some number xi was written on it. In case you forget, a tree is a connected non-directed graph without cycles. After the present was granted, m guests consecutively come to Bogdan's party. When the i-th guest comes, he performs exactly one of the two possible operations:   Chooses some number yi, and two vertecies ai and bi. After that, he moves along the edges of the tree from vertex ai to vertex bi using the shortest path (of course, such a path is unique in the tree). Every time he moves along some edge j, he replaces his current number yi by , that is, by the result of integer division yi div xj.  Chooses some edge pi and replaces the value written in it xpi by some positive integer ci &lt; xpi. As Bogdan cares about his guests, he decided to ease the process. Write a program that performs all the operations requested by guests and outputs the resulting value yi for each i of the first type.",
    "prob_desc_output_spec": "For each guest who chooses the operation of the first type, print the result of processing the value yi through the path from ai to bi.",
    "prob_desc_input_spec": "The first line of the input contains integers, n and m (2 ≤ n ≤ 200 000, 1 ≤ m ≤ 200 000) — the number of vertecies in the tree granted to Bogdan by his mom and the number of guests that came to the party respectively. Next n - 1 lines contain the description of the edges. The i-th of these lines contains three integers ui, vi and xi (1 ≤ ui, vi ≤ n, ui ≠ vi, 1 ≤ xi ≤ 1018), denoting an edge that connects vertecies ui and vi, with the number xi initially written on it. The following m lines describe operations, requested by Bogdan's guests. Each description contains three or four integers and has one of the two possible forms:    1 ai bi yi corresponds to a guest, who chooses the operation of the first type.  2 pi ci corresponds to a guests, who chooses the operation of the second type.  1 ≤ ai, bi ≤ n 1 ≤ pi ≤ n - 1 1 ≤ yi ≤ 1018 1 ≤ ci &lt; xpi xpi pi xpi 1 n - 1",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 2",
    "lang_cluster": "Python",
    "difficulty": 2400,
    "file_name": "train_007.jsonl",
    "code_uid": "5f6f7acfedded416b3ef352553189db5",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"6 6\\n1 2 1\\n1 3 7\\n1 4 4\\n2 5 5\\n2 6 2\\n1 4 6 17\\n2 3 2\\n1 4 6 17\\n1 5 5 20\\n2 4 1\\n1 5 1 3\", \"5 4\\n1 2 7\\n1 3 3\\n3 4 2\\n3 5 5\\n1 4 2 100\\n1 5 4 1\\n2 2 2\\n1 1 3 4\"]",
    "exec_outcome": "PASSED",
    "source_code": "from collections import deque\nimport sys\n#import time\nsys.setrecursionlimit(200000) \n\ndef bfs(v, d):\n\tglobal q1, edges, m, n, mark, dep, p, gf\n\tmark[v] = True\n\tp[v] = v\n\t#pp[v] = v\n\tdep[v] = d\n\tdd = deque([v])\n\tmaxdepth = 0\n\twhile dd:\n\t\tv = dd.popleft()\n\t\tfor ui in l[v]:\n\t\t\tu = ui[0]\n\t\t\tif not mark[u]:\n\t\t\t\tmark[u] = True\n\t\t\t\tp[u] = v\n\t\t\t\t#pp[u] = v\n\t\t\t\tdep[u] = dep[v]+1\n\t\t\t\tfc[u] = ui[1]\n\t\t\t\t#if dep[u] > maxdepth:\n\t\t\t\t\t#maxdepth = dep[u]\n\t\t\t\tdd.append(u)\n\tif gf:\n\t\tprint maxdepth\n\ndef merge22(x, y, level):\n\tglobal ld, p, mergeflag#, pp\n\tif dep[x] < dep[y]:\n\t\tt = x; x = y; y = t\n\tif p[y] == y or fc[y][1] > 1 or level > 2600:\n\t\tif level<2:\n\t\t\tmergeflag = False\n\t\treturn y\n\tp[x] = merge22(y, p[y], level+1)\n\treturn p[x]\n\ndef preprocess():\n\tglobal q1, edges, m, n, mark, dep, p#, pp\n\tk = (n+1)//2\n\tp[k] = k\n\t#pp[k] = k\n\tp[1] = k\n\t#pp[1] = k\n\tbfs(k, 0)\n\t#print fc\n\tfor u in range(1, n+1):\n\t\tmerge22(u, p[u], 0)\n\n\ndef process(a, b, co):\n\tglobal q1, edges, n, m, output, mergeflag\n\tif a == b:\n\t\tq1.append(str(co))\n\t\treturn\n\tx = a; y = b\n\tmergeflag = True\n\twhile mergeflag:\n\t\tmerge22(x, p[x], 0)\n\t\tmerge22(y, p[y], 0)\n\tdiv = 1\n\twhile x != y:\n\t\tif dep[x] > dep[y]:\n\t\t\t#co //= ld[x][pp[x]][1] \n\t\t\tdiv *= fc[x][1]\n\t\t\tx = p[x]\n\t\telse:\n\t\t\t#co //= ld[y][pp[y]][1] \n\t\t\tdiv *= fc[y][1]\n\t\t\ty = p[y]\n\t\t#if co == 0:\n\t\tif div > co:\n\t\t\tbreak\n\tq1.append(str(co//div))\n\n\treturn ###############################################################\n\n#tt = time.clock()\nn, m = map(int, raw_input().split())\noutput = ''\ngf = False\nif n == 200000 and m == 199991:\n\tgf = True #global flag (for printing debug info)\ngf = False\nl = [ [] for i in range(n+1) ]\nmark = [ False for i in range(n+1) ]\ndep = [ 0 for i in range(n+1) ]\np = [ 1 for i in range(n+1) ]\n#pp = [ 1 for i in range(n+1) ]\nfc = [ 0 for i in range(n+1) ] #father cost\nq = [ i for i in range(n+1) ]\nedges = [0 for i in range(n)]\noperations = [[] for i in range(m)]\nmergeflag = False\nq1 = [] #query type 1\nstageflag = False\n\ndata = sys.stdin.readlines()\ni = 0\nfor li in data:\n\tif not stageflag:\t\n\t\tx, y, c = map(int,li.split())\n\t\tedges[i+1] = [ (x,y),c ]\n\t\tl[x].append( (y,edges[i+1]) )\n\t\tl[y].append( (x,edges[i+1]) )\n\t\t#edges[i+1][2] = l[x][-1]\n\t\t#edges[i+1][3] = l[y][-1]\n\t\t#ld[x][y] = edges[i+1]\n\t\t#ld[y][x] = edges[i+1]\n\telse:\n\t\toperations[i] = map(int, li.split())\n\ti+=1\n\tif i >= n-1 and not stageflag:\n\t\tpreprocess()\n\t\tstageflag = True\n\t\ti = 0\nif gf and m > 10000:\n\tprint time.clock()-tt\n\t#if gf and m > 10000 and i%10000 == 0:\n\t\t#print i, time.clock()-tt\n\t\nfor i in range(m):\n\tinp = operations[i]\n\tif inp[0] == 2:\n\t\tedges[inp[1]][1] = inp[2]\n\t\tif inp[2] == 1:\n\t\t\tmergeflag = True\n\t\t\te = edges[inp[1]]\n\t\t\tx = e[0][0]; y = e[0][1]\n\t\t\twhile mergeflag:\n\t\t\t\tmerge22(x, y, 0)\n\telse:\n\t\tprocess(inp[1], inp[2], inp[3])\n\t\tif gf and m > 10000 and i%1000 == 0:\n\t\t\tprint i\n\nprint '\\n'.join(q1)\n#print '\\n'.join([str(x) for x in q1])\n\nif gf:\n\tprint time.clock()-tt\n\n\n\n\n\n\n",
    "prob_desc_created_at": "1446655500",
    "tags": [
        "graphs",
        "math",
        "data structures",
        "dfs and similar",
        "trees"
    ],
    "hidden_unit_tests": ""
}
{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"8000\\n0179\\n3159\\n3210\\n0112\\n0123\"]",
    "src_uid": "ad56be6638b54bc91e6e9e25f0cfb2d9",
    "prob_desc_notes": "NoteThe secret string s in the example is \"0123\".",
    "prob_desc_description": "The only difference from the previous problem is the constraint on the number of requests. In this problem your program should guess the answer doing at most 7 requests.This problem is a little bit unusual. Here you are to implement an interaction with a testing system. That means that you can make queries and get responses in the online mode. Please be sure to use the stream flushing operation after each query's output in order not to leave part of your output in some buffer. For example, in C++ you've got to use the fflush(stdout) function, in Java — call System.out.flush(), and in Pascal — flush(output).Bulls and Cows (also known as Cows and Bulls or Pigs and Bulls or Bulls and Cleots) is an old code-breaking paper and pencil game for two players, predating the similar commercially marketed board game Mastermind.On a sheet of paper, the first player thinks a secret string. This string consists only of digits and has the length 4. The digits in the string must be all different, no two or more equal digits are allowed.Then the second player tries to guess his opponent's string. For every guess the first player gives the number of matches. If the matching digits are on their right positions, they are \"bulls\", if on different positions, they are \"cows\". Thus a response is a pair of numbers — the number of \"bulls\" and the number of \"cows\". A try can contain equal digits.More formally, let's the secret string is s and the second player are trying to guess it with a string x. The number of \"bulls\" is a number of such positions i (1 ≤ i ≤ 4) where s[i] = x[i]. The number of \"cows\" is a number of such digits c that s contains c in the position i (i.e. s[i] = c), x contains c, but x[i] ≠ c.For example, the secret string is \"0427\", the opponent's try is \"0724\", then the answer is 2 bulls and 2 cows (the bulls are \"0\" and \"2\", the cows are \"4\" and \"7\"). If the secret string is \"0123\", the opponent's try is \"0330\", then the answer is 1 bull and 1 cow.In this problem you are to guess the string s that the system has chosen. You only know that the chosen string consists of 4 distinct digits.You can make queries to the testing system, each query is the output of a single 4-digit string. The answer to the query is the number of bulls and number of cows. If the system's response equals \"4 0\", that means the interaction with your problem is over and the program must terminate. That is possible for two reasons — the program either guessed the number x or made an invalid action (for example, printed letters instead of digits).Your program is allowed to do at most 7 queries.You can hack solutions of other participants providing a 4-digit string containing distinct digits — the secret string.",
    "prob_desc_output_spec": "The program must use the standard output to print queries. Your program must output requests — 4-digit strings x1, x2, ..., one per line. After the output of each line the program must execute flush operation. The program should read the answer to the query from the standard input. Your program is allowed to do at most 7 queries.",
    "prob_desc_input_spec": "To read answers to the queries, the program must use the standard input. The program will receive pairs of non-negative integers in the input, one pair per line. The first number in a pair is a number of bulls and the second one is a number of cows of the string s and the string xi printed by your program. If the system response equals \"4 0\", then your solution should terminate. The testing system will let your program read the i-th pair of integers from the input only after your program displays the corresponding system query in the output: prints value xi in a single line and executes operation flush.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "Python 3",
    "lang_cluster": "Python",
    "difficulty": 2500,
    "file_name": "train_010.jsonl",
    "code_uid": "fff90d8a1ca815ffc22183face6f7c0b",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"0 1\\n2 0\\n1 1\\n0 4\\n2 1\\n4 0\"]",
    "exec_outcome": "PASSED",
    "source_code": "import random\nimport sys\n\ndef valid(st) :\n  return len(set(x for x in st)) == 4\n\ndef comp(guess, secret) :\n  b, c = 0, 0\n  for i in range(4) : \n    if secret[i] == guess[i] : \n      b += 1\n    elif secret[i] in guess :\n      c += 1\n  return (b, c)\n\ndef check(guess, secret, bulls, cows) :\n  b, c = comp(guess, secret)\n  return bulls == b and cows == c\n\ndef filtered(candidates, history) :\n  ret = []\n  for c in candidates :\n    good = True\n    for query, res in history :\n      if not check(c, query, res[0], res[1]) :\n        good = False\n    if good :\n      ret.append(c)\n  return ret\n\ndef next_guess(candidates, step) :\n  if step < 2 :\n    return candidates[random.randint(0, len(candidates)-1)]\n    # Can get an accuracy of 99% if go random each step\n  best = 5040\n  if len(candidates) == 1 :\n    return candidates[0]\n  now = candidates[0]\n  for g in candidates :\n    poss = [ [0] * 5 for x in range(5)]\n    for s in candidates :\n      b, c = comp(g, s)\n      poss[b][c] += 1\n    penalty = max( max(arr) for arr in poss )\n    if penalty < best :\n      best = penalty\n      now = g\n  return now\n\ndef generate_all_initial() :\n  ret = list(filter(valid, map( lambda x : \"%04d\" % x, range(9999))))\n  return ret\n\neveryone = generate_all_initial()\ndef test(true_secret) :\n  global everyone\n  choices, history = everyone[:], []\n  for step in range(6) :\n    take_guess = next_guess(choices, step)\n    if not valid(take_guess) :\n      print(\"Crashed\", true_secret)\n      break\n    result = comp(take_guess, true_secret)\n    history.append((take_guess,result))\n    choices = filtered(choices, history)\n  if len(choices) != 1 :\n    print(\"Failed\", true_secret)\n    print(len(choices),history)\n    return False\n  else :\n    print(\"Pass\", true_secret)\n    return True\n\ndef run() :\n  global everyone\n  choices, history = everyone[:], []\n  for step in range(7) :\n    take_guess = next_guess(choices, step)\n    print(take_guess)\n    sys.stdout.flush()\n    b, c = map(int, input().split())\n    if b == 4 and c == 0 :\n      return\n    history.append((take_guess,(b,c)))\n    choices = filtered(choices, history)\n\n#### Main ####\n#true_secret = start[random.randint(0,5039)]\n\"\"\"\ncount = 0\nfor true_secret in everyone :\n  if not test(true_secret) :\n    count += 1\nprint(count, count / 5040.0)\n\"\"\"\n\nrun()\n",
    "prob_desc_created_at": "1483002300",
    "tags": [
        "constructive algorithms",
        "brute force",
        "interactive"
    ],
    "hidden_unit_tests": ""
}
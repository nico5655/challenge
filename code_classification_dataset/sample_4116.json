{
    "prob_desc_time_limit": "1 second",
    "prob_desc_sample_outputs": "[\"YES\\nNO\"]",
    "src_uid": "2627417136abced8481ea5728d5c1f06",
    "prob_desc_notes": "NoteTest case 1:One possible way of turning $$$a$$$ to $$$b$$$:First, select $$$[1,3]$$$. After the operation, $$$a=[3,2,5,2,3]$$$.Then, select $$$[2,5]$$$. After the operation, $$$a=[3,2,5,4,1]=b$$$.Test case 2:It can be shown that it is impossible to turn $$$a$$$ into $$$b$$$. ",
    "prob_desc_description": "Is it really?! The robot only existing in my imagination?! The Colossal Walking Robot?!!— Kochiya Sanae Sanae made a giant robot — Hisoutensoku, but something is wrong with it. To make matters worse, Sanae can not figure out how to stop it, and she is forced to fix it on-the-fly.The state of a robot can be represented by an array of integers of length $$$n$$$. Initially, the robot is at state $$$a$$$. She wishes to turn it into state $$$b$$$. As a great programmer, Sanae knows the art of copy-and-paste. In one operation, she can choose some segment from given segments, copy the segment from $$$b$$$ and paste it into the same place of the robot, replacing the original state there. However, she has to ensure that the sum of $$$a$$$ does not change after each copy operation in case the robot go haywire. Formally, Sanae can choose segment $$$[l,r]$$$ and assign $$$a_i = b_i$$$ ($$$l\\le i\\le r$$$) if $$$\\sum\\limits_{i=1}^n a_i$$$ does not change after the operation.Determine whether it is possible for Sanae to successfully turn the robot from the initial state $$$a$$$ to the desired state $$$b$$$ with any (possibly, zero) operations.",
    "prob_desc_output_spec": "For each test case, print \"YES\" (without quotes) if $$$a$$$ can be turned into $$$b$$$, or \"NO\" (without quotes) otherwise. You can output \"YES\" and \"NO\" in any case (for example, strings \"yEs\", \"yes\" and \"Yes\" will be recognized as a positive response).",
    "prob_desc_input_spec": "Each test contains multiple test cases. The first line contains a single integer $$$t$$$ ($$$1 \\leq t \\leq 2\\cdot 10^4$$$) — the number of test cases. The descriptions of the test cases follow. The first line of each test case contains two integers $$$n$$$, $$$m$$$ ($$$2 \\leq n\\leq 2\\cdot 10^5$$$, $$$1 \\leq m\\leq 2\\cdot 10^5$$$) — the length of $$$a$$$, $$$b$$$ and the number of segments. The second line contains $$$n$$$ intergers $$$a_1,a_2,\\ldots,a_n$$$ ($$$1 \\leq a_i \\leq 10^9$$$) — the initial state $$$a$$$. The third line contains $$$n$$$ intergers $$$b_1,b_2,\\ldots,b_n$$$ ($$$1 \\leq b_i \\leq 10^9$$$) — the desired state $$$b$$$. Then $$$m$$$ lines follow, the $$$i$$$-th line contains two intergers $$$l_i,r_i$$$ ($$$1 \\leq l_i &lt; r_i \\leq n$$$) — the segments that can be copy-pasted by Sanae. It is guaranteed that both the sum of $$$n$$$ and the sum of $$$m$$$ over all test cases does not exceed $$$2 \\cdot 10 ^ 5$$$.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3-64",
    "lang_cluster": "Python",
    "difficulty": 2500,
    "file_name": "train_090.jsonl",
    "code_uid": "743b4d21622739553103e2b001298f1e",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"2\\n\\n5 2\\n\\n1 5 4 2 3\\n\\n3 2 5 4 1\\n\\n1 3\\n\\n2 5\\n\\n5 2\\n\\n1 5 4 2 3\\n\\n3 2 4 5 1\\n\\n1 2\\n\\n2 4\"]",
    "exec_outcome": "PASSED",
    "source_code": "\r\n\r\n# ---------------------------------------- fast io ----------------------------------------\r\nimport os, sys\r\nfrom io import BytesIO, IOBase\r\n\r\nBUFSIZE = 8192\r\n\r\n\r\nclass FastIO(IOBase):\r\n    newlines = 0\r\n\r\n    def __init__(self, file):\r\n        self._fd = file.fileno()\r\n        self.buffer = BytesIO()\r\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\r\n        self.write = self.buffer.write if self.writable else None\r\n\r\n    def read(self):\r\n        while True:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            if not b:\r\n                break\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines = 0\r\n        return self.buffer.read()\r\n\r\n    def readline(self):\r\n        while self.newlines == 0:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            self.newlines = b.count(b\"\\n\") + (not b)\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines -= 1\r\n        return self.buffer.readline()\r\n\r\n    def flush(self):\r\n        if self.writable:\r\n            os.write(self._fd, self.buffer.getvalue())\r\n            self.buffer.truncate(0), self.buffer.seek(0)\r\n\r\n\r\nclass IOWrapper(IOBase):\r\n    def __init__(self, file):\r\n        self.buffer = FastIO(file)\r\n        self.flush = self.buffer.flush\r\n        self.writable = self.buffer.writable\r\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\r\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\r\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\r\n\r\n\r\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\r\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\r\n# ---------------------------------------- fast io ----------------------------------------\r\n\r\n\r\nclass DisJoinUnion:\r\n    def __init__(self,n):\r\n        self.parent=list(range(n))\r\n        self.rank=[1]*n\r\n\r\n    def find(self,x):\r\n        while x!=self.parent[x]:\r\n            self.parent[x]=self.parent[self.parent[x]]\r\n            x=self.parent[x]\r\n        return x\r\n\r\n    def union(self,x,y):\r\n        fx,fy=self.find(x),self.find(y)\r\n        if fx==fy:\r\n            return\r\n\r\n        self.parent[fy]=fx\r\n        self.rank[fx]+=self.rank[fy]\r\n\r\n\r\n\r\nt = int(input())\r\n\r\nfor _ in range(t):\r\n    n, m = [int(x) for x in input().split()]\r\n    a = [int(x) for x in input().split()]\r\n    b = [int(x) for x in input().split()]\r\n\r\n    sa=[0]*(n+1)\r\n    sb=[0]*(n+1)\r\n    for i in range(1,n+1):\r\n        sa[i]=sa[i-1]+a[i-1]\r\n        sb[i]=sb[i-1]+b[i-1]\r\n\r\n    dsu=DisJoinUnion(n+2)\r\n\r\n    l=[0]*m\r\n    r=[0]*m\r\n    deg=[2]*m\r\n    g=[[] for _ in range(n+1)]\r\n\r\n    for i in range(m):\r\n        l[i],r[i]=[int(x) for x in input().split()]\r\n        l[i]-=1\r\n        g[l[i]].append(i)\r\n        g[r[i]].append(i)\r\n\r\n    def dfs(i):\r\n        dsu.union(i+1,i)\r\n\r\n        for j in g[i]:\r\n            deg[j]-=1\r\n            if deg[j]==0:\r\n                x=dsu.find(l[j])\r\n                while x<=r[j]:\r\n                    dfs(x)\r\n                    x=dsu.find(x)\r\n\r\n\r\n    for i in range(n+1):\r\n        if sa[i]==sb[i]:\r\n            dfs(i)\r\n\r\n    if dsu.find(0)==n+1:\r\n        print('YES')\r\n    else:\r\n        print('NO')\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
    "prob_desc_created_at": "1654266900",
    "tags": [
        "brute force",
        "data structures",
        "dsu"
    ],
    "hidden_unit_tests": ""
}
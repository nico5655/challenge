{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"FTT\\n\\nTTF\", \"FTFF\\n\\nTTTT\\n\\nTFTT\"]",
    "src_uid": "f4a5815ecbdf744b80791cf728abf8c6",
    "prob_desc_notes": "NoteThe empty lines in the example are just for you to better understand the interaction process. You're not required to print them.In the first example, there are $$$3$$$ questions, and the answer to each question is 'true', 'true', and 'false', respectively.   The first query, guessing the answers to be 'false', 'true', and 'true', respectively, guesses only one question — the $$$2$$$-nd question — correctly.  Then, in the second query, the program correctly guesses the answer key. The interaction ends here. In the second example, there are $$$4$$$ questions, and the answer to each question is 'true', 'false', 'true', and 'true', respectively.   The first query guessed none of the questions correctly, resulting in the answer $$$0$$$.  The second query guessed the $$$1$$$-st, $$$3$$$-rd, and $$$4$$$-th question correctly, resulting in the answer $$$3$$$.  In the third query, the program correctly guesses the answer key. Then, the interaction ends. ",
    "prob_desc_description": "Mark is administering an online exam consisting of $$$n$$$ true-false questions. However, he has lost all answer keys. He needs a way to retrieve the answers before his client gets infuriated.Fortunately, he has access to the grading system. Thus, for each query, you can input the answers to all $$$n$$$ questions, and the grading system will output how many of them are correct.He doesn't have much time, so he can use the grading system at most $$$675$$$ times. Help Mark determine the answer keys.Note that answer keys are fixed in advance and will not change depending on your queries.",
    "prob_desc_output_spec": null,
    "prob_desc_input_spec": "The first line of the input consists of an integer $$$n$$$ ($$$1\\leq n\\leq 1000$$$) — the number of questions.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3-64",
    "lang_cluster": "Python",
    "difficulty": 2900,
    "file_name": "train_100.jsonl",
    "code_uid": "ca36f072329928a1e913611d4699aa74",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"3\\n\\n1\\n\\n3\", \"4\\n\\n0\\n\\n3\\n\\n4\"]",
    "exec_outcome": "PASSED",
    "source_code": "#from math import ceil, floor #, gcd, log, factorial, comb, perm,\r\n#log10, log2, log, sin, asin, tan, atan,\r\n#from heapq import heappop,heappush,heapify #heappop(hq), heapify(list)\r\n#from collections import defaultdict as dd\r\n#mydd=dd(list) for .append\r\n#from collections import deque as dq #deque  e.g. myqueue=dq(list)\r\n#append/appendleft/appendright/pop/popleft\r\n\r\nimport sys\r\ninput = sys.stdin.readline\r\n#sys.setrecursionlimit(100000) #default is 1000 \r\n############ ---- Input Functions ---- ############\r\ndef inp():\r\n    return(int(input()))\r\n#def inlt():\r\n#    return(list(map(int,input().split())))   #.split(','), default is space\r\ndef insr():\r\n    s = input().strip(\"\\n\")\r\n    return(list(s))\r\n#def invr():\r\n#    return(map(int,input().split()))\r\n####################################################\r\n#1) inp — For taking integer inputs.\r\n#2) inlt — For taking List inputs.\r\n#3) insr — For taking string inputs. Returns a List of Characters.\r\n#4) invr — For taking space seperated integer variable inputs.\r\n####################################################\r\n\r\ndef solve():\r\n    n=inp()\r\n    s1=['T']*n;s2=['T','F']*(n//2)+['T']*(n%2)\r\n    print(\"\".join(s1));sys.stdout.flush()\r\n    a1=inp()\r\n    if a1==n:return\r\n    print(\"\".join(s2));sys.stdout.flush()\r\n    a2=inp()\r\n    if a2==n:return\r\n\r\n    ans=[]\r\n\r\n    for i in range(n//3):\r\n        s1[3*i]='F';s1[3*i+1]='F'\r\n        print(\"\".join(s1));sys.stdout.flush()\r\n        ax=inp()\r\n        if ax==n:return\r\n        if ax-a1==2:\r\n            ans.append('FF')\r\n            s1[3*i+2]='F'\r\n            print(\"\".join(s1));sys.stdout.flush()\r\n            ay=inp()\r\n            if ay==n:return\r\n            if ay>ax:\r\n                ans.append('F')\r\n            else:\r\n                ans.append('T')\r\n        elif a1-ax==2:\r\n            ans.append('TT')\r\n            s1[3*i+2]='F'\r\n            print(\"\".join(s1));sys.stdout.flush()\r\n            ay=inp()\r\n            if ay==n:return\r\n            if ay>ax:\r\n                ans.append('F')\r\n            else:\r\n                ans.append('T')\r\n        else:\r\n            if i%2==0:\r\n                s2[3*i],s2[3*i+1],s2[3*i+2]='F','T','F'\r\n            else:\r\n                s2[3*i],s2[3*i+1],s2[3*i+2]='T','F','T'\r\n            print(\"\".join(s2));sys.stdout.flush()\r\n            az=inp()\r\n            if az==n:return\r\n            if az-a2==3:\r\n                ans.append(s2[3*i]+s2[3*i+1]+s2[3*i])\r\n            elif a2-az==3:\r\n                ans.append(s2[3*i+1]+s2[3*i]+s2[3*i+1])\r\n            elif az-a2==1:\r\n                ans.append(s2[3*i]+s2[3*i+1]+s2[3*i+1])\r\n            else:\r\n                ans.append(s2[3*i+1]+s2[3*i]+s2[3*i])\r\n        s1[3*i],s1[3*i+1],s1[3*i+2]='T','T','T'\r\n        if i%2==0:\r\n            s2[3*i],s2[3*i+1],s2[3*i+2]='T','F','T'\r\n        else:\r\n            s2[3*i],s2[3*i+1],s2[3*i+2]='F','T','F'\r\n    for i in range(3*(n//3),n):\r\n        s1[i]='F'\r\n        print(\"\".join(s1));sys.stdout.flush()\r\n        ax=inp()\r\n        if ax==n:return\r\n        if ax>a1:\r\n            ans.append('F')\r\n        else:\r\n            ans.append('T')\r\n        s1[i]='T'\r\n    print(\"\".join(ans));sys.stdout.flush()\r\n\r\nsolve()\r\n\r\n#print(*ans,sep=' ')##print(\"{:.3f}\".format(ans)+\"%\")\r\n#:b binary :% eg print(\"{:6.2%}\".format(ans))\r\n#print(\" \".join(str(i) for i in ans))\r\n#print(\" \".join(map(str,ans))) #seems faster\r\n#prefixsum a=[a1...an] #psa=[0]*(n+1)\r\n#for i in range(n): psa[i+1]=psa[i]+a[i]\r\n#sum[:ax]=psa[x+1] e.g. sum 1st 5 items in psa[5]\r\n#ASCII<->number ord('f')=102 chr(102)='f'\r\n#def binary_search(li, val, lb, ub):\r\n#    while ((ub-lb)>1):\r\n#        mid = (lb + ub) // 2\r\n#        if li[mid] >= val:\r\n#            ub = mid\r\n#        else:\r\n#            lb = mid\r\n#    return lb+1 #return index of elements <val in li\r\n#def binary_search(li, val, lb, ub):\r\n#    ans = -1\r\n#    while (lb <= ub):\r\n#        mid = (lb + ub) // 2\r\n#        if li[mid] > val:\r\n#            ub = mid - 1\r\n#        elif val > li[mid]:\r\n#            lb = mid + 1\r\n#        else:\r\n#            ans = mid  # return index\r\n#            break\r\n#    return ans\r\n##########\r\n#def pref(li):\r\n#    pref_sum = [0]\r\n#    for i in li:\r\n#        pref_sum.append(pref_sum[-1] + i)\r\n#    return pref_sum\r\n##########\r\n#def suff(li):\r\n#    suff_sum = [0]\r\n#    for i in range(len(li)-1,-1,-1):\r\n#        suff_sum.insert(0,suff_sum[0] + li[i])\r\n#    return suff_sum\r\n#############\r\n#def maxSubArraySumI(arr): #Kadane's algorithm with index\r\n#    max_till_now=arr[0];max_ending=0;size=len(arr)\r\n#    start=0;end=0;s=0\r\n#    for i in range(0, size):\r\n#        max_ending = max_ending + arr[i]\r\n#        if max_till_now < max_ending:\r\n#            max_till_now=max_ending\r\n#            start=s;end=i\r\n#        if max_ending<0:\r\n#            max_ending=0\r\n#            s=i+1\r\n#    return max_till_now,start,end\r\n############# avoid max for 2 elements - slower than direct if\r\n#def maxSubArraySum(arr): #Kadane's algorithm\r\n#    max_till_now=arr[0];max_ending=0;size=len(arr)\r\n#    for i in range(0, size):\r\n#        max_ending = max_ending + arr[i]\r\n#        if max_till_now < max_ending:max_till_now=max_ending\r\n#        if max_ending<0:max_ending=0\r\n#    return max_till_now\r\n#############\r\n#def findbits(x):\r\n#    tmp=[]\r\n#    while x>0:tmp.append(x%2);x//=2\r\n#    tmp.reverse()\r\n#    return tmp\r\n##############Dijkstra algorithm example\r\n#dg=[999999]*(n+1);dg[n]=0;todo=[(0,n)];chkd=[0]*(n+1)\r\n#while todo:#### find x with min dg in todo\r\n#    _,x=hq.heappop(todo)\r\n#    if chkd[x]:continue\r\n#    for i in coming[x]:going[i]-=1\r\n#    for i in coming[x]:\r\n#        tmp=1+dg[x]+going[i]\r\n#        if tmp<dg[i]:dg[i]=tmp;hq.heappush(todo,(dg[i],i))   \r\n#    chkd[x]=1\r\n################ \r\n## moves to match 2 binary strings: sum_{i=1}^n(abs(diff in i-th prefix sums))\r\n###############\r\n##s=[2, 3, 1, 4, 5, 3]\r\n##sorted(range(len(s)), key=lambda k: s[k])\r\n##gives sorted indices [2, 0, 1, 5, 3, 4]\r\n##m= [[3, 4, 6], [2, 4, 8], [2, 3, 4], [1, 2, 3], [7, 6, 7], [1, 8, 2]]\r\n##m.sort(reverse=True,key=lambda k:k[2]) #sorts m according to 3rd elements\r\n\r\n",
    "prob_desc_created_at": "1657892100",
    "tags": [
        "bitmasks",
        "constructive algorithms",
        "interactive",
        "probabilities"
    ],
    "hidden_unit_tests": ""
}
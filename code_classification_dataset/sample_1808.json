{
    "prob_desc_time_limit": "1 second",
    "prob_desc_sample_outputs": "[\"3 1 1 1 2 1 3\\n3 2 1 2 2 2 3\\n3 3 1 3 2 3 3\", \"6 1 1 1 2 1 3 2 3 2 2 2 1\"]",
    "src_uid": "779e73c2f5eba950a20e6af9b53a643a",
    "prob_desc_notes": "NotePicture for the first sample:   Picture for the second sample:   ",
    "prob_desc_description": "Valera has got a rectangle table consisting of n rows and m columns. Valera numbered the table rows starting from one, from top to bottom and the columns – starting from one, from left to right. We will represent cell that is on the intersection of row x and column y by a pair of integers (x, y).Valera wants to place exactly k tubes on his rectangle table. A tube is such sequence of table cells (x1, y1), (x2, y2), ..., (xr, yr), that:   r ≥ 2;  for any integer i (1 ≤ i ≤ r - 1) the following equation |xi - xi + 1| + |yi - yi + 1| = 1 holds;  each table cell, which belongs to the tube, must occur exactly once in the sequence. Valera thinks that the tubes are arranged in a fancy manner if the following conditions are fulfilled:   no pair of tubes has common cells;  each cell of the table belongs to some tube. Help Valera to arrange k tubes on his rectangle table in a fancy manner.",
    "prob_desc_output_spec": "Print k lines. In the i-th line print the description of the i-th tube: first print integer ri (the number of tube cells), then print 2ri integers xi1, yi1, xi2, yi2, ..., xiri, yiri (the sequence of table cells). If there are multiple solutions, you can print any of them. It is guaranteed that at least one solution exists. ",
    "prob_desc_input_spec": "The first line contains three space-separated integers n, m, k (2 ≤ n, m ≤ 300; 2 ≤ 2k ≤ n·m) — the number of rows, the number of columns and the number of tubes, correspondingly. ",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 2",
    "lang_cluster": "Python",
    "difficulty": 1500,
    "file_name": "train_013.jsonl",
    "code_uid": "acd8b07c3b8575e2cfb82688bfdb2366",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"3 3 3\", \"2 3 1\"]",
    "exec_outcome": "PASSED",
    "source_code": "\"\"\"Template for Python Competitive Programmers prepared by Mayank Chaudhary \"\"\"\n\n# to use the print and division function of Python3\nfrom __future__ import division, print_function\n\n\"\"\"value of mod\"\"\"\nMOD = 998244353\nmod = 10**9 + 7\n\n\"\"\"use resource\"\"\"\n# import resource\n# resource.setrlimit(resource.RLIMIT_STACK, [0x100000000, resource.RLIM_INFINITY])\n\n\"\"\"for factorial\"\"\"\n\n# def prepare_factorial():\n#     fact = [1]\n#     for i in range(1, 1000005):\n#         fact.append((fact[-1] * i) % mod)\n#     ifact = [0] * 1000005\n#     ifact[1000004] = pow(fact[1000004], mod - 2, mod)\n#     for i in range(1000004, 0, -1):\n#         ifact[i - 1] = (i * ifact[i]) % mod\n#\n#     return fact, ifact\n\n\"\"\"uncomment next 4 lines while doing recursion based question\"\"\"\n# import threading\n# threading.stack_size(2**27)\nimport sys\n# sys.setrecursionlimit(30000)\n\n\n\"\"\"uncomment modules according to your need\"\"\"\n# from bisect import bisect_left, bisect_right, insort\n# import itertools\n# from math import floor, ceil, sqrt, degrees, atan, pi\n# from heapq import heappop, heapify, heappush\n# from random import randint as rn\n# from Queue import Queue as Q\n# from collections import Counter, defaultdict, deque\nfrom copy import deepcopy\n'''\ndef modinv(n, p):\n    return pow(n, p - 2, p)\n'''\n\n\n# def ncr(n, r,  fact, ifact):  # for using this uncomment the lines calculating fact and ifact\n#     t = (fact[n] * (ifact[r]*ifact[n-r]) % mod)% mod\n#     return t\n\n\n\ndef get_ints(): return map(int, sys.stdin.readline().strip().split())\ndef get_array(): return list(map(int, sys.stdin.readline().strip().split()))\ndef input(): return sys.stdin.readline().strip()\n\n\ndef GCD(x, y):\n    while (y):\n        x, y = y, x % y\n    return x\n\ndef lcm(x, y):\n    return (x*y)//(GCD(x, y))\n\n# def get_xor(n):\n#     return [n,1,n+1,0][n%4]\n\n# def binary_expo(a, b):\n#\n#     result = 1\n#     while b:\n#         if b&1:\n#             result *= a\n#             b-=1\n#         else:\n#             a *= a\n#             b >>= 1\n#     return result\n\n\n\n\"\"\"*******************************************************\"\"\"\n\n\ndef main():\n\n    rows, cols, k = get_ints()\n\n    curr_x = curr_y = 0\n    turn = 0\n    store = []\n    for i in range(rows):\n        if not turn:\n            for j in range(cols):\n                store.append([i+1, j+1])\n        else:\n            for j in range(cols-1, -1, -1):\n                store.append([i+1, j+1])\n        turn ^= 1\n\n    i = 0\n    count = 0\n    while count<(k-1):\n        print(2, end = ' ')\n        print(*store[i], end = ' ')\n        print(*store[i+1])\n        i += 2\n        count += 1\n    print(rows*cols - 2*(k-1), end = ' ')\n    while i<(rows*cols):\n        if i==(rows*cols - 1):\n            print(*store[i])\n        else:\n            print(*store[i], end = ' ')\n        i += 1\n\n\n\n\n\n\n\n\"\"\" -------- Python 2 and 3 footer by Pajenegod and c1729 ---------\"\"\"\n\npy2 = round(0.5)\nif py2:\n    from future_builtins import ascii, filter, hex, map, oct, zip\n\n    range = xrange\n\nimport os, sys\nfrom io import IOBase, BytesIO\n\nBUFSIZE = 8192\n\n\nclass FastIO(BytesIO):\n    newlines = 0\n\n    def __init__(self, file):\n        self._file = file\n        self._fd = file.fileno()\n        self.writable = \"x\" in file.mode or \"w\" in file.mode\n        self.write = super(FastIO, self).write if self.writable else None\n\n    def _fill(self):\n        s = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n        self.seek((self.tell(), self.seek(0, 2), super(FastIO, self).write(s))[0])\n        return s\n\n    def read(self):\n        while self._fill(): pass\n        return super(FastIO, self).read()\n\n    def readline(self):\n        while self.newlines == 0:\n            s = self._fill();\n            self.newlines = s.count(b\"\\n\") + (not s)\n        self.newlines -= 1\n        return super(FastIO, self).readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.getvalue())\n            self.truncate(0), self.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        if py2:\n            self.write = self.buffer.write\n            self.read = self.buffer.read\n            self.readline = self.buffer.readline\n        else:\n            self.write = lambda s: self.buffer.write(s.encode('ascii'))\n            self.read = lambda: self.buffer.read().decode('ascii')\n            self.readline = lambda: self.buffer.readline().decode('ascii')\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip('\\r\\n')\n\n\"\"\" main function\"\"\"\n\nif __name__ == '__main__':\n    main()\n    # threading.Thread(target=main).start()",
    "prob_desc_created_at": "1402241400",
    "tags": [
        "constructive algorithms",
        "implementation",
        "dfs and similar"
    ],
    "hidden_unit_tests": ""
}
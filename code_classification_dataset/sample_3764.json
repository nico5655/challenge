{
    "prob_desc_time_limit": "4 seconds",
    "prob_desc_sample_outputs": "[\"? 4 6\\n\\n? 1 1\\n\\n? 1 2\\n\\n? 5 5\\n\\n! 5\\n\\n? 2 2\\n\\n! 2\"]",
    "src_uid": "75c953eeb2a664b38bf65917715276c8",
    "prob_desc_notes": "NoteIn the first test, the array $$$[1, 0, 1, 1, 0, 1]$$$ is hidden. After answering the query $$$k=2$$$, the array changed to $$$[1, 0, 1, 1, 1, 1]$$$.",
    "prob_desc_description": "This is an interactive problem.This is a hard version of the problem. The difference from the easy version is that in the hard version $$$1 \\le t \\le \\min(n, 10^4)$$$ and the total number of queries is limited to $$$6 \\cdot 10^4$$$.Polycarp is playing a computer game. In this game, an array consisting of zeros and ones is hidden. Polycarp wins if he guesses the position of the $$$k$$$-th zero from the left $$$t$$$ times.Polycarp can make no more than $$$6 \\cdot 10^4$$$ requests totally of the following type:   ? $$$l$$$ $$$r$$$ — find out the sum of all elements in positions from $$$l$$$ to $$$r$$$ ($$$1 \\le l \\le r \\le n$$$) inclusive. To make the game more interesting, each guessed zero turns into one and the game continues on the changed array. More formally, if the position of the $$$k$$$-th zero was $$$x$$$, then after Polycarp guesses this position, the $$$x$$$-th element of the array will be replaced from $$$0$$$ to $$$1$$$.Help Polycarp win the game.",
    "prob_desc_output_spec": null,
    "prob_desc_input_spec": null,
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3-64",
    "lang_cluster": "Python",
    "difficulty": 2200,
    "file_name": "train_083.jsonl",
    "code_uid": "08c0f83e83fca7f367ca45bdbf1bf292",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"6 2\\n\\n2\\n\\n2\\n\\n1\\n\\n1\\n\\n0\\n\\n1\\n\\n0\"]",
    "exec_outcome": "PASSED",
    "source_code": "import sys,os,io\r\ninput = sys.stdin.readline # for strings\r\n# input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline # for non-strings\r\n\r\nPI = 3.141592653589793238460\r\nINF =  float('inf')\r\nMOD  = 1000000007\r\n# MOD = 998244353\r\n\r\n\r\ndef bin32(num):\r\n    return '{0:032b}'.format(num)\r\n\r\ndef add(x,y):\r\n    return (x+y)%MOD\r\n\r\ndef sub(x,y):\r\n    return (x-y+MOD)%MOD\r\n\r\ndef mul(x,y):\r\n    return (x*y)%MOD\r\n\r\ndef gcd(x,y):\r\n    if y == 0:\r\n        return x\r\n    return gcd(y,x%y)\r\n\r\ndef lcm(x,y):\r\n    return (x*y)//gcd(x,y)\r\n\r\ndef power(x,y):\r\n    res = 1\r\n    x%=MOD\r\n    while y!=0:\r\n        if y&1 :\r\n            res = mul(res,x)\r\n        y>>=1\r\n        x = mul(x,x)\r\n        \r\n    return res\r\n        \r\ndef mod_inv(n):\r\n    return power(n,MOD-2)\r\n\r\ndef prob(p,q):\r\n    return mul(p,power(q,MOD-2))    \r\n  \r\ndef ii():\r\n    return int(input())\r\n\r\ndef li():\r\n    return [int(i) for i in input().split()]\r\n\r\ndef ls():\r\n    return [i for i in input().split()]\r\ndef summ(a ,b):\r\n    return a + b\r\n# ========= SEGMENT TREE ==========\r\nINF = float('inf')\r\nclass SegmentTree:\r\n    def __init__(self, data, default=0, func=summ):\r\n        \"\"\"initialize the segment tree with data\"\"\"\r\n        self._default = default\r\n        self._func = func\r\n        self._len = len(data)\r\n        self._size = _size = 1 << (self._len - 1).bit_length()\r\n\r\n        self.data = [default] * (2 * _size)\r\n        self.data[_size:_size + self._len] = data\r\n        for i in reversed(range(_size)):\r\n            self.data[i] = func(self.data[i + i], self.data[i + i + 1])\r\n\r\n    def __delitem__(self, idx):\r\n        self[idx] = self._default\r\n\r\n    def __getitem__(self, idx):\r\n        return self.data[idx + self._size]\r\n\r\n    def __setitem__(self, idx, value):\r\n        idx += self._size\r\n        self.data[idx] = value\r\n        idx >>= 1\r\n        while idx:\r\n            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])\r\n            idx >>= 1\r\n\r\n    def __len__(self):\r\n        return self._len\r\n\r\n    def query(self, start, stop):\r\n        \"\"\"func of data[start, stop)\"\"\"\r\n        start += self._size\r\n        stop += self._size + 1\r\n        \r\n        res_left = res_right = self._default\r\n        while start < stop:\r\n            if start & 1:\r\n                res_left = self._func(res_left, self.data[start])\r\n                start += 1\r\n            if stop & 1:\r\n                stop -= 1\r\n                res_right = self._func(self.data[stop], res_right)\r\n            start >>= 1\r\n            stop >>= 1\r\n\r\n        return self._func(res_left, res_right)\r\n\r\n    def __repr__(self):\r\n        return \"SegmentTree({0})\".format(self.data)\r\n\r\n# data = [1,1,0,1,0,1,0,0,0,1,1]\r\n# 101101\r\ndef ask(l , r):\r\n    print(\"?\",l,r,flush = 1)\r\n    return ii()\r\n    # return sum(data[l-1:r])\r\n\r\nn , t= li()\r\n# n = len(data)\r\nstore = []\r\nsize = 32\r\n\r\nfor _ in range(t):\r\n    k = ii()\r\n\r\n    if _ == 0:\r\n        l = 0\r\n        r = size - 1\r\n        while l < n:\r\n            if r >=n:\r\n                r = n-1\r\n\r\n            out = ask(l+1 , r+1)\r\n            store.append((r - l + 1-out))\r\n            l+=size\r\n            r+=size\r\n        st = SegmentTree(store)\r\n    \r\n    l = 0\r\n    r = len(store)-1\r\n    while l < r:\r\n        \r\n        mid = (l + r )//2\r\n        \r\n        total = st.query(0,mid)\r\n        # print(_ , store, l , r , mid,total)\r\n        if total >= k:\r\n            r = mid\r\n        else:\r\n            l = mid + 1\r\n    \r\n    group = l\r\n    # print(l , r)\r\n    prev = 0\r\n    if l >= 1:\r\n        prev+= st.query(0,l-1)\r\n    \r\n    k-=prev\r\n    # print(prev,  k)\r\n    L = size*l + 1\r\n    R = n\r\n    if l != len(store)-1:\r\n        R = size*(l + 1) \r\n    while L != R:\r\n        mid = (L + R)//2\r\n        cnt = ask(L , mid)\r\n        cnt = mid - L - cnt + 1\r\n        if cnt >= k:\r\n            R = mid\r\n        else:\r\n            k-=cnt\r\n            L= mid + 1\r\n    print('!',L,flush = 1)\r\n    st.__setitem__(l,st.__getitem__(l)-1)\r\n    store[l]-=1\r\n    # data[L-1] = 1\r\n\r\n\r\n    # print(data)\r\n\r\n\r\n    \r\n\r\n\r\n\r\n\r\n\r\n    ",
    "prob_desc_created_at": "1620225300",
    "tags": [
        "binary search",
        "constructive algorithms",
        "data structures",
        "interactive"
    ],
    "hidden_unit_tests": ""
}
{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"17\", \"27\", \"0\"]",
    "src_uid": "11031ad43c34d4dca79eddab2342dce0",
    "prob_desc_notes": "NoteIn the second test case all possible three-nucleotide DNAs are permitted. Each nucleotide can take one of three values, thus in total there are 27 distinct three nucleotide DNAs.In the third test sample we cannot make any DNA of two nucleotides — the only possible nucleotide \"a\" cannot occur two times consecutively.",
    "prob_desc_description": "Recently a top secret mission to Mars has taken place. As a result, scientists managed to obtain some information about the Martian DNA. Now we know that any Martian DNA contains at most m different nucleotides, numbered from 1 to m. Special characteristics of the Martian DNA prevent some nucleotide pairs from following consecutively in this chain. For example, if the nucleotide 1 and nucleotide 2 can not follow consecutively in the Martian DNA, then the chain of nucleotides [1, 2] is not a valid chain of Martian DNA, but the chain of nucleotides [2, 1] can be a valid chain (if there is no corresponding restriction). The number of nucleotide pairs that can't follow in the DNA chain consecutively, is k. The needs of gene research required information about the quantity of correct n-long chains of the Martian DNA. Your task is to write a program that will calculate this value.",
    "prob_desc_output_spec": "Print a single integer — the sought number modulo 1000000007 (109 + 7).",
    "prob_desc_input_spec": "The first line contains three space-separated integers n, m, k (1 ≤ n ≤ 1015, 1 ≤ m ≤ 52, 0 ≤ k ≤ m2). Next k lines contain two characters each, without a space between them, representing a forbidden nucleotide pair. The first character represents the first nucleotide in the forbidden pair, the second character represents the second nucleotide. The nucleotides with assigned numbers from 1 to 26 are represented by English alphabet letters from \"a\" to \"z\" (1 is an \"a\", 2 is a \"b\", ..., 26 is a \"z\"). Nucleotides with assigned numbers from 27 to 52 are represented by English alphabet letters from \"A\" to \"Z\" (27 is an \"A\", 28 is a \"B\", ..., 52 is a \"Z\"). It is guaranteed that each forbidden pair occurs at most once in the input. It is guaranteed that nucleotide's numbers in all forbidden pairs cannot be more than m. Note that order is important in nucleotide pairs. Please, do not use the %lld specifier to read or write 64-bit integers in С++. It is preferred to use cin, cout streams or the %I64d specifier.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 2",
    "lang_cluster": "Python",
    "difficulty": 1900,
    "file_name": "train_017.jsonl",
    "code_uid": "8916f8d25c55cd602d8f8df47cff6c0b",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"3 3 2\\nab\\nba\", \"3 3 0\", \"2 1 1\\naa\"]",
    "exec_outcome": "PASSED",
    "source_code": "import sys\n\n\ndef pyes_no(condition) :\n  if condition :\n    print \"YES\"\n  else :\n    print \"NO\"\n\ndef plist(a, s = ' ') :\n  print s.join(map(str, a))\n\ndef rint() :\n  return int(sys.stdin.readline())\n\ndef rints() :\n  return map(int, sys.stdin.readline().split())\n\ndef rfield(n, m = None) :\n  if m == None :\n    m = n\n  \n  field = []\n  for i in xrange(n) :\n    chars = sys.stdin.readline().strip()\n    assert(len(chars) == m)\n    field.append(chars)\n  return field\n\ndef pfield(field, separator = '') :\n  print '\\n'.join(map(lambda x: separator.join(x), field)) \n\ndef check_field_equal(field, i, j, value) :\n  if i >= 0 and i < len(field) and j >= 0 and j < len(field[i]) :\n    return value == field[i][j]\n  return None \n\ndef digits(x, p) :\n  digits = []\n  while x > 0 :\n    digits.append(x % p)\n    x /= p\n  return digits\n\ndef modpower(a, n, mod) :\n  r = a ** (n % 2)\n  if n > 1 :\n    r *= modpower(a, n / 2, mod) ** 2\n  return r % mod\n\ndef modmatrixproduct(a, b, mod) :\n  n, m1 = len(a), len(a[0])\n  m2, k = len(b), len(b[0])\n\n  assert(m1 == m2)\n  m = m1\n\n  r = [[0] * k for i in range(n)]\n  for i in range(n) :\n    for j in range(k) :\n      for l in range(m) :\n        r[i][j] += a[i][l] * b[l][j]\n      r[i][j] %= mod\n  return r\n\ndef modmatrixpower(a, n, mod) :\n  magic = 2\n  for m in [2, 3, 5, 7] :\n    if n % m == 0 :\n      magic = m\n      break\n\n  r = None\n  if n < magic : \n    r = a\n    n -= 1\n  else :\n    s = modmatrixpower(a, n / magic, mod)\n    r = s\n    for i in range(magic - 1) :\n      r = modmatrixproduct(r, s, mod)\n\n  for i in range(n % magic) : \n    r = modmatrixproduct(r, a, mod)\n  \n  return r\n\ndef gcd(a, b) :\n  if a > b :\n    a, b = b, a\n  \n  while a > 0 :\n    a, b = b % a, a\n\n  return b\n\nn, m, k = rints()\n\ncharn = dict(zip('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ', range(52)))\nmatrix = [[1] * m for i in range(m)]\nfor i in range(k) :\n  a, b = map(lambda c: charn[c], list(sys.stdin.readline().strip()))\n  matrix[a][b] = 0\n\nmod = 1000000007\nif n > 1 :\n  matrix = modmatrixpower(matrix, n - 1, mod)\n  results = modmatrixproduct([[1] * m], matrix, mod)\n  print sum(map(sum, results)) % mod\nelse :\n  print m\n\n",
    "prob_desc_created_at": "1347291900",
    "tags": [
        "dp",
        "matrices"
    ],
    "hidden_unit_tests": ""
}
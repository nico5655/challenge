{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"4\", \"6\"]",
    "src_uid": "1a11a87e16cd71d1a4cb404986ece956",
    "prob_desc_notes": "NoteIn the first test case correct pairs are $$$(1, 1)$$$, $$$(1, 2)$$$, $$$(1, 3)$$$ and $$$(2, 3)$$$.In the second test case correct pairs are $$$(1, 3)$$$, $$$(1, 4)$$$, $$$(2, 3)$$$, $$$(2, 4)$$$, $$$(3, 3)$$$ and $$$(3, 4)$$$.",
    "prob_desc_description": "You are given an array consisting of $$$n$$$ integers $$$a_1, a_2, \\dots , a_n$$$ and an integer $$$x$$$. It is guaranteed that for every $$$i$$$, $$$1 \\le a_i \\le x$$$.Let's denote a function $$$f(l, r)$$$ which erases all values such that $$$l \\le a_i \\le r$$$ from the array $$$a$$$ and returns the resulting array. For example, if $$$a = [4, 1, 1, 4, 5, 2, 4, 3]$$$, then $$$f(2, 4) = [1, 1, 5]$$$.Your task is to calculate the number of pairs $$$(l, r)$$$ such that $$$1 \\le l \\le r \\le x$$$ and $$$f(l, r)$$$ is sorted in non-descending order. Note that the empty array is also considered sorted.",
    "prob_desc_output_spec": "Print the number of pairs $$$1 \\le l \\le r \\le x$$$ such that $$$f(l, r)$$$ is sorted in non-descending order.",
    "prob_desc_input_spec": "The first line contains two integers $$$n$$$ and $$$x$$$ ($$$1 \\le n, x \\le 10^6$$$) â€” the length of array $$$a$$$ and the upper limit for its elements, respectively. The second line contains $$$n$$$ integers $$$a_1, a_2, \\dots a_n$$$ ($$$1 \\le a_i \\le x$$$).",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 2",
    "lang_cluster": "Python",
    "difficulty": 2100,
    "file_name": "train_063.jsonl",
    "code_uid": "813ac45817c63d4d5c4b62a5b663907f",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"3 3\\n2 3 1\", \"7 4\\n1 3 1 2 2 4 3\"]",
    "exec_outcome": "PASSED",
    "source_code": "import heapq\n\ndef main():\n    inp = readnumbers()\n    ii = 0\n\n    n = inp[ii]\n    ii += 1\n\n    x = inp[ii]\n    ii += 1\n\n    A = [y-1 for y in inp[ii:]]\n\n    buckets = [[] for _ in range(x)]\n    for i in range(n):\n        buckets[A[i]].append(i)\n    \n    smallr = x - 1\n    maxind = n\n    while smallr>0:\n        for ind in buckets[smallr]:\n            if ind > maxind:\n                break\n        else:\n            if buckets[smallr]:\n                maxind = min(maxind, min(buckets[smallr]))\n            smallr -= 1\n            continue\n        break\n\n    bigl = 0\n    maxind = 0\n    while bigl+1<x:\n        for ind in buckets[bigl]:\n            if ind < maxind:\n                break\n        else:\n            if buckets[bigl]:\n                maxind = max(maxind, max(buckets[bigl]))\n            bigl += 1\n            continue\n        break\n\n    bigA = [0]*n\n    for i in range(n):\n        bigA[i] = max(A[i],bigA[i-1])\n\n    ans = 0\n    worst = smallr\n    for l in range(bigl+1):\n        worst = max(l, worst) \n        ans += max(x - worst, 0)\n        \n        for ind in buckets[l]:\n            worst = max(worst, bigA[ind])\n \n    print ans\n        \n\n\n#    badcount = [0]*x\n#    badheap = []\n#    \n#    L = [i-1 for i in range(n)]\n#    R = [i+1 for i in range(n)]\n#\n#\n#\n#    def dell(i):\n#        val = A[i]\n#        l = L[i]\n#        r = R[i]\n#\n#\n#        if l!=-1: \n#            if A[l]>A[i]:\n#                badcount[A[l]] -= 1\n#            R[l] = r\n#            if r!=n and A[l] > A[r]:\n#                badcount[A[l]] += 1\n#                heapq.heappush(badheap, A[l])\n#\n#        if r!=n:\n#            if A[i]>A[r]:\n#                badcount[A[i]] -= 1\n#            L[r] = l\n#\n#    for i in range(n-1):\n#        if A[i]>A[i+1]:\n#            badcount[A[i]] += 1\n#            badheap.append(A[i])\n#    heapq.heapify(badheap)\n#    \n#    ans = 0\n#    for l in reversed(range(x)):\n#        for ind in buckets[l]:\n#            dell(ind)\n#\n#        while badheap and badcount[badheap[0]]==0:\n#            heapq.heappop(badheap)\n#\n#        r = 1 + badheap[0] if badheap else l\n#        \n#        for h in range(r,x):\n#            print(l,h)\n#        ans += x - r\n#    print ans\n\n\n\n\n\n######## Python 2 and 3 footer by Pajenegod and c1729\n\n# Note because cf runs old PyPy3 version which doesn't have the sped up\n# unicode strings, PyPy3 strings will many times be slower than pypy2.\n# There is a way to get around this by using binary strings in PyPy3\n# but its syntax is different which makes it kind of a mess to use.\n\n# So on cf, use PyPy2 for best string performance.\n\npy2 = round(0.5)\nif py2:\n    from future_builtins import ascii, filter, hex, map, oct, zip\n    range = xrange\n\nimport os, sys\nfrom io import IOBase, BytesIO\n\nBUFSIZE = 8192\nclass FastIO(BytesIO):\n    newlines = 0\n\n    def __init__(self, file):\n        self._file = file\n        self._fd = file.fileno()\n        self.writable = \"x\" in file.mode or \"w\" in file.mode\n        self.write = super(FastIO, self).write if self.writable else None\n\n    def _fill(self):\n        s = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n        self.seek((self.tell(), self.seek(0,2), super(FastIO, self).write(s))[0])\n        return s\n\n    def read(self):\n        while self._fill(): pass\n        return super(FastIO,self).read()\n\n    def readline(self):\n        while self.newlines == 0:\n            s = self._fill(); self.newlines = s.count(b\"\\n\") + (not s)\n        self.newlines -= 1\n        return super(FastIO, self).readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.getvalue())\n            self.truncate(0), self.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        if py2:\n            self.write = self.buffer.write\n            self.read = self.buffer.read\n            self.readline = self.buffer.readline\n        else:\n            self.write = lambda s:self.buffer.write(s.encode('ascii'))\n            self.read = lambda:self.buffer.read().decode('ascii')\n            self.readline = lambda:self.buffer.readline().decode('ascii')\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip('\\r\\n')\n\n# Cout implemented in Python\nimport sys\nclass ostream:\n    def __lshift__(self,a):\n        sys.stdout.write(str(a))\n        return self\ncout = ostream()\nendl = '\\n'\n\n# Read all remaining integers in stdin, type is given by optional argument, this is fast\ndef readnumbers(zero = 0):\n    conv = ord if py2 else lambda x:x\n    A = []; numb = zero; sign = 1; i = 0; s = sys.stdin.buffer.read()\n    try:\n        while True:\n            if s[i] >= b'0' [0]:\n                numb = 10 * numb + conv(s[i]) - 48\n            elif s[i] == b'-' [0]: sign = -1\n            elif s[i] != b'\\r' [0]:\n                A.append(sign*numb)\n                numb = zero; sign = 1\n            i += 1\n    except:pass\n    if s and s[-1] >= b'0' [0]:\n        A.append(sign*numb)\n    return A\n\nif __name__== \"__main__\":\n  main()\n",
    "prob_desc_created_at": "1557930900",
    "tags": [
        "data structures",
        "combinatorics",
        "binary search",
        "two pointers"
    ],
    "hidden_unit_tests": ""
}
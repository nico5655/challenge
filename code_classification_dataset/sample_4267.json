{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"6\\n15\\n-2\"]",
    "src_uid": "93fb13c40ab03700ef9a827796bd3d9d",
    "prob_desc_notes": "NoteIn the first example, it is enough to delete the entire string, then we will get $$$2 \\cdot 3 + 0 = 6$$$ points.In the second example, if we delete characters one by one, then for each deleted character we will get $$$(-2) \\cdot 1 + 5 = 3$$$ points, i. e. $$$15$$$ points in total.In the third example, we can delete the substring 00 from the string 100111, we get $$$1 \\cdot 2 + (-4) = -2$$$ points, and the string will be equal to 1111, removing it entirely we get $$$1 \\cdot 4 + (-4) = 0$$$ points. In total, we got $$$-2$$$ points for $$$2$$$ operations.",
    "prob_desc_description": "You are given a string $$$s$$$ of length $$$n$$$ consisting only of the characters 0 and 1.You perform the following operation until the string becomes empty: choose some consecutive substring of equal characters, erase it from the string and glue the remaining two parts together (any of them can be empty) in the same order. For example, if you erase the substring 111 from the string 111110, you will get the string 110. When you delete a substring of length $$$l$$$, you get $$$a \\cdot l + b$$$ points.Your task is to calculate the maximum number of points that you can score in total, if you have to make the given string empty.",
    "prob_desc_output_spec": "For each testcase, print a single integer — the maximum number of points that you can score.",
    "prob_desc_input_spec": "The first line contains a single integer $$$t$$$ ($$$1 \\le t \\le 2000$$$) — the number of testcases. The first line of each testcase contains three integers $$$n$$$, $$$a$$$ and $$$b$$$ ($$$1 \\le n \\le 100; -100 \\le a, b \\le 100$$$) — the length of the string $$$s$$$ and the parameters $$$a$$$ and $$$b$$$. The second line contains the string $$$s$$$. The string $$$s$$$ consists only of the characters 0 and 1.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3-64",
    "lang_cluster": "Python",
    "difficulty": 1000,
    "file_name": "train_094.jsonl",
    "code_uid": "5500e25cef752be2d521ce1d7a287ea3",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"3\\n3 2 0\\n000\\n5 -2 5\\n11001\\n6 1 -4\\n100111\"]",
    "exec_outcome": "PASSED",
    "source_code": "# ------------------- fast io --------------------\r\nfrom itertools import count\r\nimport os\r\nimport sys\r\nfrom io import BytesIO, IOBase\r\nimport math\r\n \r\nBUFSIZE = 8192\r\n \r\n \r\nclass FastIO(IOBase):\r\n    newlines = 0\r\n    \r\n    def __init__(self, file):\r\n        self._fd = file.fileno()\r\n        self.buffer = BytesIO()\r\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\r\n        self.write = self.buffer.write if self.writable else None\r\n    \r\n    def read(self):\r\n        while True:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            if not b:\r\n                break\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines = 0\r\n        return self.buffer.read()\r\n    \r\n    def readline(self):\r\n        while self.newlines == 0:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            self.newlines = b.count(b\"\\n\") + (not b)\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines -= 1\r\n        return self.buffer.readline()\r\n    \r\n    def flush(self):\r\n        if self.writable:\r\n            os.write(self._fd, self.buffer.getvalue())\r\n            self.buffer.truncate(0), self.buffer.seek(0)\r\n \r\n \r\nclass IOWrapper(IOBase):\r\n    def __init__(self, file):\r\n        self.buffer = FastIO(file)\r\n        self.flush = self.buffer.flush\r\n        self.writable = self.buffer.writable\r\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\r\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\r\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\r\n \r\n \r\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\r\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\r\n \r\n# ------------------- fast io --------------------\r\ndef gcd(x, y):\r\n    while y:\r\n        x, y = y, x % y\r\n    return x\r\n \r\n \r\ndef lcm(a, b): return a * b // gcd(a, b)\r\n\r\ndef is_prime(n):\r\n    if (n <= 1):\r\n        return False\r\n    for i in range(2, int(math.sqrt(n))+1):\r\n        if (n % i == 0):\r\n            return False\r\n    return True\r\n\r\n# ------------------- write code from here --------------------\r\nt= int(input())\r\n# l=0\r\nfor _ in range(t):\r\n    # l+=1\r\n    # n = int(input())\r\n    n, a,b = map(int, input().split())\r\n    arr= list(map(int, input()))\r\n    # print(*arr)\r\n    # if l==56:\r\n    #     print(n,a,b)\r\n    #     print(*arr)\r\n    # output_arr =[]\r\n    if b>=0:\r\n        print(n*a+n*b)\r\n    else:\r\n        count=0\r\n        tu=[]\r\n        t=0\r\n        z= arr[0]\r\n        for i in range(len(arr)):\r\n            if z!=arr[i]:\r\n                count+=1\r\n                if i==len(arr)-1:\r\n                    tu.append(count)\r\n            elif z==arr[i] and count>0:\r\n                tu.append(count)\r\n                count=0\r\n        tu.append(len(arr)-sum(tu))\r\n        # print((a*count)+b)\r\n        ans=0\r\n        # print(*tu)\r\n        for i in tu:\r\n            ans+= i*a+b\r\n        print(ans)",
    "prob_desc_created_at": "1626273300",
    "tags": [
        "greedy",
        "math"
    ],
    "hidden_unit_tests": ""
}
{
    "prob_desc_time_limit": "1 second",
    "prob_desc_sample_outputs": "[\"1\\n2\\n-1\\n2\"]",
    "src_uid": "1042641f46ec636ca8820f0509c77a6f",
    "prob_desc_notes": "NoteIn the first test case the sequence doesn't satisfy the desired condition, but it can be provided by deleting the first element, hence the sequence will be $$$[1, 2, 3, 4, 5, 6]$$$ and $$$6$$$ elements will be equal to their indices.In the second test case there are two ways to get the desired result in $$$2$$$ moves: the first one is to delete the $$$1$$$-st and the $$$3$$$-rd elements so that the sequence will be $$$[1, 2, 3]$$$ and have $$$3$$$ elements equal to their indices; the second way is to delete the $$$2$$$-nd and the $$$3$$$-rd elements to get the sequence $$$[5, 2, 3]$$$ with $$$2$$$ desired elements.",
    "prob_desc_description": "Consider a sequence of integers $$$a_1, a_2, \\ldots, a_n$$$. In one move, you can select any element of the sequence and delete it. After an element is deleted, all elements to the right are shifted to the left by $$$1$$$ position, so there are no empty spaces in the sequence. So after you make a move, the sequence's length decreases by $$$1$$$. The indices of the elements after the move are recalculated.E. g. let the sequence be $$$a=[3, 2, 2, 1, 5]$$$. Let's select the element $$$a_3=2$$$ in a move. Then after the move the sequence will be equal to $$$a=[3, 2, 1, 5]$$$, so the $$$3$$$-rd element of the new sequence will be $$$a_3=1$$$ and the $$$4$$$-th element will be $$$a_4=5$$$.You are given a sequence $$$a_1, a_2, \\ldots, a_n$$$ and a number $$$k$$$. You need to find the minimum number of moves you have to make so that in the resulting sequence there will be at least $$$k$$$ elements that are equal to their indices, i. e. the resulting sequence $$$b_1, b_2, \\ldots, b_m$$$ will contain at least $$$k$$$ indices $$$i$$$ such that $$$b_i = i$$$.",
    "prob_desc_output_spec": "For each test case output in a single line:   $$$-1$$$ if there's no desired move sequence;  otherwise, the integer $$$x$$$ ($$$0 \\le x \\le n$$$) — the minimum number of the moves to be made so that the resulting sequence will contain at least $$$k$$$ elements that are equal to their indices. ",
    "prob_desc_input_spec": "The first line contains one integer $$$t$$$ ($$$1 \\le t \\le 100$$$) — the number of test cases. Then $$$t$$$ test cases follow. Each test case consists of two consecutive lines. The first line contains two integers $$$n$$$ and $$$k$$$ ($$$1 \\le k \\le n \\le 2000$$$). The second line contains a sequence of integers $$$a_1, a_2, \\ldots, a_n$$$ ($$$1 \\le a_i \\le n$$$). The numbers in the sequence are not necessarily different. It is guaranteed that the sum of $$$n$$$ over all test cases doesn't exceed $$$2000$$$.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3",
    "lang_cluster": "Python",
    "difficulty": 2000,
    "file_name": "train_099.jsonl",
    "code_uid": "d534d8911ef08289e7a4f0885526bdb6",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"4\\n7 6\\n1 1 2 3 4 5 6\\n5 2\\n5 1 3 2 3\\n5 2\\n5 5 5 5 4\\n8 4\\n1 2 3 3 2 2 5 5\"]",
    "exec_outcome": "PASSED",
    "source_code": "t=int(input())\r\nfor pro in range(t):\r\n  n, k=map(int, input().split())\r\n  a=list(map(int, input().split(\" \")))\r\n  dp=[[0 for i in range(n+1)] for kk in range(n)]\r\n  dp[0][0]=1 if a[0]==1 else 0\r\n  for i in range(1, n):\r\n    for j in range(i+2):\r\n      if(a[i]==i+1-j):\r\n        dp[i][j]=max(1+dp[i-1][j], dp[i-1][j-1])\r\n      else:\r\n        dp[i][j]=max(dp[i-1][j], dp[i-1][j-1])\r\n  ans=-1\r\n  for truck in range(n+1):\r\n    if(dp[-1][truck]>=k):\r\n      ans=truck\r\n      break\r\n  print(ans)",
    "prob_desc_created_at": "1627050900",
    "tags": [
        "binary search",
        "brute force",
        "dp"
    ],
    "hidden_unit_tests": ""
}
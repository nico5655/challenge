{
    "prob_desc_time_limit": "7 seconds",
    "prob_desc_sample_outputs": "[\"5927\", \"24812\", \"25267\"]",
    "src_uid": "88607047027bab73ea56352969b02242",
    "prob_desc_notes": "NoteIn the first example, any two events form a line, and the table will be winning if any two events happen. The probability of this is $$$\\frac{11}{16}$$$, and $$$5927 \\cdot 16 \\equiv 11 \\pmod{31\\,607}$$$.",
    "prob_desc_description": "Getting ready for VK Fest 2021, you prepared a table with $$$n$$$ rows and $$$n$$$ columns, and filled each cell of this table with some event related with the festival that could either happen or not: for example, whether you will win a prize on the festival, or whether it will rain.Forecasting algorithms used in VK have already estimated the probability for each event to happen. Event in row $$$i$$$ and column $$$j$$$ will happen with probability $$$a_{i, j} \\cdot 10^{-4}$$$. All of the events are mutually independent.Let's call the table winning if there exists a line such that all $$$n$$$ events on it happen. The line could be any horizontal line (cells $$$(i, 1), (i, 2), \\ldots, (i, n)$$$ for some $$$i$$$), any vertical line (cells $$$(1, j), (2, j), \\ldots, (n, j)$$$ for some $$$j$$$), the main diagonal (cells $$$(1, 1), (2, 2), \\ldots, (n, n)$$$), or the antidiagonal (cells $$$(1, n), (2, n - 1), \\ldots, (n, 1)$$$).Find the probability of your table to be winning, and output it modulo $$$31\\,607$$$ (see Output section).",
    "prob_desc_output_spec": "Print the probability that your table will be winning, modulo $$$31\\,607$$$. Formally, let $$$M = 31\\,607$$$. It can be shown that the answer can be expressed as an irreducible fraction $$$\\frac{p}{q}$$$, where $$$p$$$ and $$$q$$$ are integers and $$$q \\not \\equiv 0 \\pmod{M}$$$. Output the integer equal to $$$p \\cdot q^{-1} \\bmod M$$$. In other words, output such an integer $$$x$$$ that $$$0 \\le x &lt; M$$$ and $$$x \\cdot q \\equiv p \\pmod{M}$$$.",
    "prob_desc_input_spec": "The first line contains a single integer $$$n$$$ ($$$2 \\le n \\le 21$$$) — the dimensions of the table. The $$$i$$$-th of the next $$$n$$$ lines contains $$$n$$$ integers $$$a_{i, 1}, a_{i, 2}, \\ldots, a_{i, n}$$$ ($$$0 &lt; a_{i, j} &lt; 10^4$$$). The probability of event in cell $$$(i, j)$$$ to happen is $$$a_{i, j} \\cdot 10^{-4}$$$.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3",
    "lang_cluster": "Python",
    "difficulty": 2600,
    "file_name": "train_105.jsonl",
    "code_uid": "5ebb98f747554df336d581b08b363fe3",
    "prob_desc_memory_limit": "512 megabytes",
    "prob_desc_sample_inputs": "[\"2\\n5000 5000\\n5000 5000\", \"2\\n2500 6000\\n3000 4000\", \"3\\n1000 2000 3000\\n4000 5000 6000\\n7000 8000 9000\"]",
    "exec_outcome": "PASSED",
    "source_code": "import sys,random,bisect\r\nfrom collections import deque,defaultdict\r\nfrom heapq import heapify,heappop,heappush\r\nfrom itertools import permutations\r\nfrom math import gcd,log\r\ninput = lambda :sys.stdin.readline().rstrip()\r\ndef cmb(n, r, mod):\r\n    if r < 0 or r > n:return 0\r\n    r = min(r, n-r);return g1[n] * g2[r] * g2[n-r] % mod\r\nmod = 31607;N = 31606;g1 = [1]*(N+1);g2 = [1]*(N+1);inverse = [1]*(N+1)\r\nfor i in range(2, N + 1):g1[i] = ((g1[i-1]*i) % mod);inverse[i] = ((-inverse[mod % i]*(mod//i)) % mod);g2[i] = ((g2[i-1]*inverse[i]) % mod)\r\ninverse[0]=0;ans = 1;N = int(input());A = [list(map(int,input().split())) for i in range(N)];P = [1 for i in range(N)];Q = [1 for j in range(N)]\r\nfor i in range(N):\r\n    for j in range(N):A[i][j] *= inverse[10**4];A[i][j] %= mod\r\nfor i in range(N):\r\n    for j in range(N):P[i] *= A[i][j];P[i] %= mod;Q[j] *= A[i][j];Q[j] %= mod\r\nres = 0;tmp = [1 for j in range(1<<N)];bit_prod = [0]*(1<<N)\r\nfor j in range(1<<N):\r\n    for i in range(N):\r\n        if j>>i & 1:tmp[j] = (-tmp[j]) * Q[i] % mod\r\nfor i in range(N):\r\n    bit_prod[0] = P[i];tmp[0] = tmp[0] * (1-bit_prod[0]) % mod\r\n    for n in range(N):\r\n        for j in range(2**n,2**(n+1)):bit_prod[j] = bit_prod[j-2**n] * inverse[A[i][n]] % mod;tmp[j] = tmp[j] * (1-bit_prod[j]) % mod\r\nans -= (sum([tmp[j] for j in range(1<<N)]) % mod);ans %= mod;P = [1 for i in range(N)];Q = [1 for j in range(N)];R = 1\r\nfor i in range(N):\r\n    for j in range(N):\r\n        if j != i:P[i] *= A[i][j];P[i] %= mod\r\n        if j != i:Q[j] *= A[i][j];Q[j] %= mod\r\n        else:R *= A[i][j];R %= mod\r\nres = 0;tmp = [R for j in range(1<<N)]\r\nfor j in range(1<<N):\r\n    for i in range(N):\r\n        if j>>i & 1:tmp[j] = (-tmp[j]) * Q[i] % mod\r\nfor i in range(N):\r\n    bit_prod[0] = P[i];tmp[0] = tmp[0] * (1-bit_prod[0]) % mod\r\n    for n in range(N):\r\n        for j in range(2**n,2**(n+1)):bit_prod[j] = (bit_prod[j-2**n] * inverse[A[i][n]] % mod if n != i else bit_prod[j-2**n] % mod);tmp[j] = tmp[j] * (1-bit_prod[j]) % mod\r\nans += (sum([tmp[j] for j in range(1<<N)]) % mod);ans %= mod;P = [1 for i in range(N)];Q = [1 for j in range(N)];R = 1\r\nfor i in range(N):\r\n    for j in range(N):\r\n        if j != N-1-i:P[i] *= A[i][j];P[i] %= mod\r\n        if j != N-1-i:Q[j] *= A[i][j];Q[j] %= mod\r\n        else:R *= A[i][j];R %= mod\r\nres = 0;tmp = [R for j in range(1<<N)]\r\nfor j in range(1<<N):\r\n    for i in range(N):\r\n        if j>>i & 1:tmp[j] = (-tmp[j]) * Q[i] % mod\r\nfor i in range(N):\r\n    bit_prod[0] = P[i];tmp[0] = tmp[0] * (1-bit_prod[0]) % mod\r\n    for n in range(N):\r\n        for j in range(2**n,2**(n+1)):bit_prod[j] = (bit_prod[j-2**n] * inverse[A[i][n]] % mod if n != N-1-i else bit_prod[j-2**n] % mod);tmp[j] = tmp[j] * (1-bit_prod[j]) % mod\r\nans += (sum([tmp[j] for j in range(1<<N)]) % mod);ans %= mod;P = [1 for i in range(N)];Q = [1 for j in range(N)];R = 1\r\nfor i in range(N):\r\n    for j in range(N):\r\n        if j != N-1-i and j != i:P[i] *= A[i][j];P[i] %= mod\r\n        if j != N-1-i and j != i:Q[j] *= A[i][j];Q[j] %= mod\r\n        else:R *= A[i][j];R %= mod\r\nres = 0;tmp = [R for j in range(1<<N)]\r\nfor j in range(1<<N):\r\n    for i in range(N):\r\n        if j>>i & 1:tmp[j] = (-tmp[j]) * Q[i] % mod\r\nfor i in range(N):\r\n    bit_prod[0] = P[i];tmp[0] = tmp[0] * (1-bit_prod[0]) % mod\r\n    for n in range(N):\r\n        for j in range(2**n,2**(n+1)):bit_prod[j] = (bit_prod[j-2**n] * inverse[A[i][n]] % mod if n != N-1-i and n != i else bit_prod[j-2**n] % mod);tmp[j] = tmp[j] * (1-bit_prod[j]) % mod\r\nans -= (sum([tmp[j] for j in range(1<<N)]) % mod);print(ans%mod)",
    "prob_desc_created_at": "1626532500",
    "tags": [
        "bitmasks",
        "combinatorics",
        "dp",
        "math",
        "probabilities"
    ],
    "hidden_unit_tests": ""
}
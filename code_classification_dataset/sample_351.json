{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"1\\n2\\n2\\n2\"]",
    "src_uid": "3b8678d118c90d34c99ffa9259cc611f",
    "prob_desc_notes": "NoteIn the first test case, $$$s_1$$$ is palindrome, so the answer is $$$1$$$.In the second test case you can't make all three strings palindromic at the same time, but you can make any pair of strings palindromic. For example, let's make $$$s_1 = \\text{0110}$$$, $$$s_2 = \\text{111111}$$$ and $$$s_3 = \\text{010000}$$$.In the third test case we can make both strings palindromic. For example, $$$s_1 = \\text{11011}$$$ and $$$s_2 = \\text{100001}$$$.In the last test case $$$s_2$$$ is palindrome and you can make $$$s_1$$$ palindrome, for example, by swapping $$$s_1[2]$$$ and $$$s_1[3]$$$.",
    "prob_desc_description": "A palindrome is a string $$$t$$$ which reads the same backward as forward (formally, $$$t[i] = t[|t| + 1 - i]$$$ for all $$$i \\in [1, |t|]$$$). Here $$$|t|$$$ denotes the length of a string $$$t$$$. For example, the strings 010, 1001 and 0 are palindromes.You have $$$n$$$ binary strings $$$s_1, s_2, \\dots, s_n$$$ (each $$$s_i$$$ consists of zeroes and/or ones). You can swap any pair of characters any number of times (possibly, zero). Characters can be either from the same string or from different strings — there are no restrictions.Formally, in one move you:  choose four integer numbers $$$x, a, y, b$$$ such that $$$1 \\le x, y \\le n$$$ and $$$1 \\le a \\le |s_x|$$$ and $$$1 \\le b \\le |s_y|$$$ (where $$$x$$$ and $$$y$$$ are string indices and $$$a$$$ and $$$b$$$ are positions in strings $$$s_x$$$ and $$$s_y$$$ respectively),  swap (exchange) the characters $$$s_x[a]$$$ and $$$s_y[b]$$$. What is the maximum number of strings you can make palindromic simultaneously?",
    "prob_desc_output_spec": "Print $$$Q$$$ integers — one per test case. The $$$i$$$-th integer should be the maximum number of palindromic strings you can achieve simultaneously performing zero or more swaps on strings from the $$$i$$$-th test case.",
    "prob_desc_input_spec": "The first line contains single integer $$$Q$$$ ($$$1 \\le Q \\le 50$$$) — the number of test cases. The first line on each test case contains single integer $$$n$$$ ($$$1 \\le n \\le 50$$$) — the number of binary strings you have. Next $$$n$$$ lines contains binary strings $$$s_1, s_2, \\dots, s_n$$$ — one per line. It's guaranteed that $$$1 \\le |s_i| \\le 50$$$ and all strings constist of zeroes and/or ones.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3",
    "lang_cluster": "Python",
    "difficulty": 1400,
    "file_name": "train_001.jsonl",
    "code_uid": "2b752b2bd363a0151af8db9e5d90d9af",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"4\\n1\\n0\\n3\\n1110\\n100110\\n010101\\n2\\n11111\\n000001\\n2\\n001\\n11100111\"]",
    "exec_outcome": "PASSED",
    "source_code": "#!/usr/bin/env python\nimport os\nimport operator\nfrom collections import defaultdict\nimport sys\nfrom io import BytesIO, IOBase\nimport bisect\n\n# def power(x, p):\n#     res = 1\n#     while p:\n#         if p & 1:\n#             res = res * x % 1000000007\n#         x = x * x % 1000000007\n#         p >>= 1\n#     return res;\n\ndef main():\n    # n,m,k=map(int,input().split())\n    # A=[int(k) for k in input().split()]\n    # B=[int(k) for k in input().split()]\n    # a=[0]\n    # b=[0]\n    # for i in range(n):\n    #     a.append(a[i]+A[i])\n    # for i in range(m):\n    #     b.append(b[i]+B[i])\n    # ans=0\n    # j=m\n    # for i in range(n+1):\n    #     if a[i]>k:\n    #         break\n    #     while b[j]>k-a[i]:\n    #         j-=1\n    #     ans=max(ans,i+j)\n    #     #print(i,j)\n    # print(ans)\n\n    for _ in range(int(input())):\n        n=int(input())\n        even_odd=0\n        ans=0\n        odd=0\n        for i in range(n):\n            st=input()\n            if len(st)&1:\n                odd+=1\n                ans+=1\n                continue\n            o=0\n            z=0\n            for j in range(len(st)):\n                if st[j]==\"1\":\n                    o+=1\n                else:\n                    z+=1\n            if z&1==0:\n                ans+=1\n            else:\n                even_odd+=1\n        if even_odd & 1==1:\n            if odd==0:\n                even_odd-=1\n        print(ans+even_odd)\n\n\n\n                # n=int(input())\n        # arr=[int(k) for k in input().split()]\n        # odd=[]\n        # even=[]\n        # for i in range(2*n):\n        #     if arr[i]%2==0:\n        #         even.append(i+1)\n        #     else:\n        #         odd.append(i+1)\n        # if len(odd)%2!=0 and len(even)%2!=0:\n        #     odd.pop()\n        #     even.pop()\n        #     for i in range(0,len(odd),2):\n        #         print(odd[i],odd[i+1])\n        #     for i in range(0,len(even),2):\n        #         print(even[i],even[i+1])\n        # else:\n        #     if len(odd)!=0 and len(even)!=0:\n        #         odd.pop()\n        #         odd.pop()\n        #         for i in range(0, len(odd), 2):\n        #             print(odd[i], odd[i + 1])\n        #         for i in range(0, len(even), 2):\n        #             print(even[i], even[i + 1])\n        #     else:\n        #         for i in range(0,2*n-2,2):\n        #             print(i+1,i+2)\n\n\n\n\n\n\n\n\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nif __name__ == \"__main__\":\n    main()",
    "prob_desc_created_at": "1571929500",
    "tags": [
        "greedy",
        "strings"
    ],
    "hidden_unit_tests": ""
}
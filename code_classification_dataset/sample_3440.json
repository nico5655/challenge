{
    "prob_desc_time_limit": "3 seconds",
    "prob_desc_sample_outputs": "[\"2\", \"19\", \"0\"]",
    "src_uid": "f8f84cec87b3bb8c046d8a45f2c4a071",
    "prob_desc_notes": "NoteIn the first sample the whole first layer of CPUs is malfunctional. In the second layer when CPU (2, 1, 2) turns off, it disrupts the control by CPU (2, 1, 3) over CPU (2, 1, 1), and when CPU (2, 2, 2) is turned off, it disrupts the control over CPU (2, 2, 3) by CPU (2, 2, 1).In the second sample all processors except for the corner ones are critical.In the third sample there is not a single processor controlling another processor, so the answer is 0.",
    "prob_desc_description": "A super computer has been built in the Turtle Academy of Sciences. The computer consists of n·m·k CPUs. The architecture was the paralellepiped of size n × m × k, split into 1 × 1 × 1 cells, each cell contains exactly one CPU. Thus, each CPU can be simultaneously identified as a group of three numbers from the layer number from 1 to n, the line number from 1 to m and the column number from 1 to k.In the process of the Super Computer's work the CPUs can send each other messages by the famous turtle scheme: CPU (x, y, z) can send messages to CPUs (x + 1, y, z), (x, y + 1, z) and (x, y, z + 1) (of course, if they exist), there is no feedback, that is, CPUs (x + 1, y, z), (x, y + 1, z) and (x, y, z + 1) cannot send messages to CPU (x, y, z).Over time some CPUs broke down and stopped working. Such CPUs cannot send messages, receive messages or serve as intermediates in transmitting messages. We will say that CPU (a, b, c) controls CPU (d, e, f) , if there is a chain of CPUs (xi, yi, zi), such that (x1 = a, y1 = b, z1 = c), (xp = d, yp = e, zp = f) (here and below p is the length of the chain) and the CPU in the chain with number i (i &lt; p) can send messages to CPU i + 1.Turtles are quite concerned about the denial-proofness of the system of communication between the remaining CPUs. For that they want to know the number of critical CPUs. A CPU (x, y, z) is critical, if turning it off will disrupt some control, that is, if there are two distinctive from (x, y, z) CPUs: (a, b, c) and (d, e, f), such that (a, b, c) controls (d, e, f) before (x, y, z) is turned off and stopped controlling it after the turning off.",
    "prob_desc_output_spec": "Print a single integer — the number of critical CPUs, that is, such that turning only this CPU off will disrupt some control.",
    "prob_desc_input_spec": "The first line contains three integers n, m and k (1 ≤ n, m, k ≤ 100) — the dimensions of the Super Computer.  Then n blocks follow, describing the current state of the processes. The blocks correspond to the layers of the Super Computer in the order from 1 to n. Each block consists of m lines, k characters in each — the description of a layer in the format of an m × k table. Thus, the state of the CPU (x, y, z) is corresponded to the z-th character of the y-th line of the block number x. Character \"1\" corresponds to a working CPU and character \"0\" corresponds to a malfunctioning one. The blocks are separated by exactly one empty line.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "Python 3",
    "lang_cluster": "Python",
    "difficulty": 1800,
    "file_name": "train_059.jsonl",
    "code_uid": "b40f5d2b84e935c9ec128a4dabaac81d",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"2 2 3\\n000\\n000\\n\\n111\\n111\", \"3 3 3\\n111\\n111\\n111\\n\\n111\\n111\\n111\\n\\n111\\n111\\n111\", \"1 1 10\\n0101010101\"]",
    "exec_outcome": "PASSED",
    "source_code": "def main():\n    s = input().split()\n    n, m, k = int(s[0]), int(s[1]), int(s[2])\n    processor = []\n    for x in range(n):\n        for y in range(m):\n            s = input()\n            for z in s:\n                processor.append(int(z) == 1)\n        if x < n - 1:\n            emptyLine = input()\n    counter = 0\n    mk = m * k\n    nmk = n * mk\n    for i in range(nmk):\n        if not processor[i]:\n            continue\n        # back\n        if i >= mk:\n            if processor[i - mk]:\n                # front\n                if i < (nmk - mk):\n                    if processor[i + mk]:\n                        counter += 1\n                        continue\n                # right\n                if (i % k) < (k - 1):\n                    if processor[i + 1]:\n                        if not processor[i - mk + 1]:\n                            counter += 1\n                            continue\n                # down\n                if (i % mk) < (mk - k):\n                    if processor[i + k]:\n                        if not processor[i - mk + k]:\n                            counter += 1\n                            continue\n        # left\n        if (i % k) > 0:\n            if processor[i - 1]:\n                # front\n                if i < (nmk - mk):\n                    if processor[i + mk]:\n                        if not processor[i + mk - 1]:\n                            counter += 1\n                            continue\n                # right\n                if (i % k) < (k - 1):\n                    if processor[i + 1]:\n                        counter += 1\n                        continue\n                # down\n                if (i % mk) < (mk - k):\n                    if processor[i + k]:\n                        if not processor[i + k - 1]:\n                            counter += 1\n                            continue\n        # up\n        if (i % mk) >= k:\n            if processor[i - k]:\n                # front\n                if i < (nmk - mk):\n                    if processor[i + mk]:\n                        if not processor[i + mk - k]:\n                            counter += 1\n                            continue\n                # right\n                if (i % k) < (k - 1):\n                    if processor[i + 1]:\n                        if not processor[i - k + 1]:\n                            counter += 1\n                            continue\n                # down\n                if (i % mk) < (mk - k):\n                    if processor[i + k]:\n                        counter += 1\n                        continue\n    print(counter)\n\n\nmain()\n",
    "prob_desc_created_at": "1458475200",
    "tags": [
        "dfs and similar",
        "brute force",
        "graphs"
    ],
    "hidden_unit_tests": ""
}
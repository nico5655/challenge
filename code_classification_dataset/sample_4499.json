{
    "prob_desc_time_limit": "1 second",
    "prob_desc_sample_outputs": "[\"No\\nYes\\nYes\\nNo\\nYes\"]",
    "src_uid": "bd95629c1698cf1d0cfd338afcf1ca93",
    "prob_desc_notes": "NoteConsider example. After the first two queries the board will look like the following picture (the letter $$$R$$$ denotes cells in which rooks are located, the subrectangle of the query of the third type is highlighted in green):  Chessboard after performing the third and the fourth queries:  Chessboard after performing the fifth and the sixth queries:  Chessboard after performing the seventh and the eighth queries:  Chessboard after performing the last two queries:  ",
    "prob_desc_description": "You have a square chessboard of size $$$n \\times n$$$. Rows are numbered from top to bottom with numbers from $$$1$$$ to $$$n$$$, and columns — from left to right with numbers from $$$1$$$ to $$$n$$$. So, each cell is denoted with pair of integers $$$(x, y)$$$ ($$$1 \\le x, y \\le n$$$), where $$$x$$$ is a row number and $$$y$$$ is a column number.You have to perform $$$q$$$ queries of three types:  Put a new rook in cell $$$(x, y)$$$.  Remove a rook from cell $$$(x, y)$$$. It's guaranteed that the rook was put in this cell before.  Check if each cell of subrectangle $$$(x_1, y_1) - (x_2, y_2)$$$ of the board is attacked by at least one rook. Subrectangle is a set of cells $$$(x, y)$$$ such that for each cell two conditions are satisfied: $$$x_1 \\le x \\le x_2$$$ and $$$y_1 \\le y \\le y_2$$$.Recall that cell $$$(a, b)$$$ is attacked by a rook placed in cell $$$(c, d)$$$ if either $$$a = c$$$ or $$$b = d$$$. In particular, the cell containing a rook is attacked by this rook.",
    "prob_desc_output_spec": "Print the answer for each query of the third type in a separate line. Print \"Yes\" (without quotes) if each cell of the subrectangle is attacked by at least one rook. Otherwise print \"No\" (without quotes).",
    "prob_desc_input_spec": "The first line contains two integers $$$n$$$ and $$$q$$$ ($$$1 \\le n \\le 10^5$$$, $$$1 \\le q \\le 2 \\cdot 10^5$$$) — the size of the chessboard and the number of queries, respectively. Each of the following $$$q$$$ lines contains description of a query. Description begins with integer $$$t$$$ ($$$t \\in \\{1, 2, 3\\}$$$) which denotes type of a query:   If $$$t = 1$$$, two integers $$$x$$$ and $$$y$$$ follows ($$$1 \\le x, y \\le n$$$) — coordinated of the cell where the new rook should be put in. It's guaranteed that there is no rook in the cell $$$(x, y)$$$ at the moment of the given query.  If $$$t = 2$$$, two integers $$$x$$$ and $$$y$$$ follows ($$$1 \\le x, y \\le n$$$) — coordinates of the cell to remove a rook from. It's guaranteed that there is a rook in the cell $$$(x, y)$$$ at the moment of the given query.  If $$$t = 3$$$, four integers $$$x_1, y_1, x_2$$$ and $$$y_2$$$ follows ($$$1 \\le x_1 \\le x_2 \\le n$$$, $$$1 \\le y_1 \\le y_2 \\le n$$$) — subrectangle to check if each cell of it is attacked by at least one rook.  It's guaranteed that among $$$q$$$ queries there is at least one query of the third type.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3-64",
    "lang_cluster": "Python",
    "difficulty": 1400,
    "file_name": "train_099.jsonl",
    "code_uid": "895b2057f6b899583fb5fc781c4625ae",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"8 10\\n1 2 4\\n3 6 2 7 2\\n1 3 2\\n3 6 2 7 2\\n1 4 3\\n3 2 6 4 8\\n2 4 3\\n3 2 6 4 8\\n1 4 8\\n3 2 6 4 8\"]",
    "exec_outcome": "PASSED",
    "source_code": "import sys\nimport os\nimport io\n\n\nclass Tree(object):\n    def __init__(self, data, default=0, func=max):\n        self._len = len(data)\n        self._default = default\n        self._func = func\n\n        self._size = _size = 1 << (self._len - 1).bit_length()\n\n        self.tree = [default] * (2 * _size)\n        self.tree[_size:_size + self._len] = data\n        for i in reversed(range(_size)):\n            self.tree[i] = self._func(self.tree[i + i], self.tree[i + i + 1])\n\n    def __delitem__(self, idx):\n        self[idx] = self._default\n\n    def __getitem__(self, idx):\n        return self.tree[idx + self._size]\n\n    def __setitem__(self, idx, value):\n        idx += self._size\n        self.tree[idx] = value\n        idx >>= 1\n        while idx:\n            self.tree[idx] = self._func(\n                self.tree[2 * idx], self.tree[2 * idx + 1])\n            idx >>= 1\n\n    def query(self, start, stop):\n        start += self._size\n        stop += self._size\n\n        res_left = res_right = self._default\n        while start < stop:\n            if start & 1:\n                res_left = self._func(res_left, self.tree[start])\n                start += 1\n            if stop & 1:\n                stop -= 1\n                res_right = self._func(self.tree[stop], res_right)\n            start >>= 1\n            stop >>= 1\n\n        return self._func(res_left, res_right)\n\n\ninput = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline\n\n\ndef main():\n    n, q = map(int, input().split())\n    treeX = Tree([False]*n, True, lambda a, b: a and b)\n    treeY = Tree([False]*n, True, lambda a, b: a and b)\n    countX = [0]*(n)\n    countY = [0]*(n)\n    ans = []\n    for qi in range(q):\n        query = list(map(int, input().split()))\n        if query[0] == 1:\n            x, y = query[1:]\n            x -= 1\n            y -= 1\n            if countX[x] == 0:\n                treeX[x] = True\n            if countY[y] == 0:\n                treeY[y] = True\n            countX[x] += 1\n            countY[y] += 1\n        elif query[0] == 2:\n            x, y = query[1:]\n            x -= 1\n            y -= 1\n            countX[x] -= 1\n            countY[y] -= 1\n            if countX[x] == 0:\n                treeX[x] = False\n            if countY[y] == 0:\n                treeY[y] = False\n        elif query[0] == 3:\n            x1, y1, x2, y2 = query[1:]\n            x1 -= 1\n            y1 -= 1\n            qx = treeX.query(x1, x2)\n            if qx:\n                ans.append(\"Yes\")\n            else:\n                qy = treeY.query(y1, y2)\n                if qy:\n                    ans.append(\"Yes\")\n                else:\n                    ans.append(\"No\")\n    sys.stdout.write(\"\\n\".join(ans))\n    sys.stdout.write(\"\\n\")\n\n\ndef test():\n\n    treeX = Tree([False]*4, True, lambda a, b: a and b)\n    treeX[0] = True\n    treeX[1] = True\n    print(treeX.tree)\n    print(treeX.query(0, 1))\n\n\nmain()\n",
    "prob_desc_created_at": "1652520900",
    "tags": [
        "data structures",
        "implementation"
    ],
    "hidden_unit_tests": ""
}
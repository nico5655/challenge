{
    "prob_desc_time_limit": "1 second",
    "prob_desc_sample_outputs": "[\"11\", \"-1\", \"1000000003\"]",
    "src_uid": "bf60899aa2bd7350c805437d0fee1583",
    "prob_desc_notes": "NoteConsider the first example. The flights from A to B depart at time moments $$$1$$$, $$$3$$$, $$$5$$$, and $$$7$$$ and arrive at B at time moments $$$2$$$, $$$4$$$, $$$6$$$, $$$8$$$, respectively. The flights from B to C depart at time moments $$$1$$$, $$$2$$$, $$$3$$$, $$$9$$$, and $$$10$$$ and arrive at C at time moments $$$2$$$, $$$3$$$, $$$4$$$, $$$10$$$, $$$11$$$, respectively. You can cancel at most two flights. The optimal solution is to cancel the first flight from A to B and the fourth flight from B to C. This way Arkady has to take the second flight from A to B, arrive at B at time moment $$$4$$$, and take the last flight from B to C arriving at C at time moment $$$11$$$.In the second example you can simply cancel all flights from A to B and you're done.In the third example you can cancel only one flight, and the optimal solution is to cancel the first flight from A to B. Note that there is still just enough time to catch the last flight from B to C.",
    "prob_desc_description": "Arkady bought an air ticket from a city A to a city C. Unfortunately, there are no direct flights, but there are a lot of flights from A to a city B, and from B to C.There are $$$n$$$ flights from A to B, they depart at time moments $$$a_1$$$, $$$a_2$$$, $$$a_3$$$, ..., $$$a_n$$$ and arrive at B $$$t_a$$$ moments later.There are $$$m$$$ flights from B to C, they depart at time moments $$$b_1$$$, $$$b_2$$$, $$$b_3$$$, ..., $$$b_m$$$ and arrive at C $$$t_b$$$ moments later.The connection time is negligible, so one can use the $$$i$$$-th flight from A to B and the $$$j$$$-th flight from B to C if and only if $$$b_j \\ge a_i + t_a$$$.You can cancel at most $$$k$$$ flights. If you cancel a flight, Arkady can not use it.Arkady wants to be in C as early as possible, while you want him to be in C as late as possible. Find the earliest time Arkady can arrive at C, if you optimally cancel $$$k$$$ flights. If you can cancel $$$k$$$ or less flights in such a way that it is not possible to reach C at all, print $$$-1$$$.",
    "prob_desc_output_spec": "If you can cancel $$$k$$$ or less flights in such a way that it is not possible to reach C at all, print $$$-1$$$. Otherwise print the earliest time Arkady can arrive at C if you cancel $$$k$$$ flights in such a way that maximizes this time.",
    "prob_desc_input_spec": "The first line contains five integers $$$n$$$, $$$m$$$, $$$t_a$$$, $$$t_b$$$ and $$$k$$$ ($$$1 \\le n, m \\le 2 \\cdot 10^5$$$, $$$1 \\le k \\le n + m$$$, $$$1 \\le t_a, t_b \\le 10^9$$$) — the number of flights from A to B, the number of flights from B to C, the flight time from A to B, the flight time from B to C and the number of flights you can cancel, respectively. The second line contains $$$n$$$ distinct integers in increasing order $$$a_1$$$, $$$a_2$$$, $$$a_3$$$, ..., $$$a_n$$$ ($$$1 \\le a_1 &lt; a_2 &lt; \\ldots &lt; a_n \\le 10^9$$$) — the times the flights from A to B depart. The third line contains $$$m$$$ distinct integers in increasing order $$$b_1$$$, $$$b_2$$$, $$$b_3$$$, ..., $$$b_m$$$ ($$$1 \\le b_1 &lt; b_2 &lt; \\ldots &lt; b_m \\le 10^9$$$) — the times the flights from B to C depart.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3",
    "lang_cluster": "Python",
    "difficulty": 1600,
    "file_name": "train_000.jsonl",
    "code_uid": "1e327c3c2df59ac803edccf18c165046",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"4 5 1 1 2\\n1 3 5 7\\n1 2 3 9 10\", \"2 2 4 4 2\\n1 10\\n10 20\", \"4 3 2 3 1\\n1 999999998 999999999 1000000000\\n3 4 1000000000\"]",
    "exec_outcome": "PASSED",
    "source_code": "from bisect import bisect_left, bisect_right\n\nclass Result:\n    def __init__(self, index, value):\n        self.index = index\n        self.value = value\n\nclass BinarySearch:\n    def __init__(self):\n        pass\n\n    @staticmethod\n    def greater_than(num: int, func, size: int = 1):\n        \"\"\"Searches for smallest element greater than num!\"\"\"\n        if isinstance(func, list):\n            index = bisect_right(func, num)\n            if index == len(func):\n                return Result(None, None)\n            else:\n                return Result(index, func[index])\n        else:\n            alpha, omega = 0, size - 1\n            if func(omega) <= num:\n                return Result(None, None)\n            while alpha < omega:\n                if func(alpha) > num:\n                    return Result(alpha, func(alpha))\n                if omega == alpha + 1:\n                    return Result(omega, func(omega))\n                mid = (alpha + omega) // 2\n                if func(mid) > num:\n                    omega = mid\n                else:\n                    alpha = mid\n\n    @staticmethod\n    def less_than(num: int, func, size: int = 1):\n        \"\"\"Searches for largest element less than num!\"\"\"\n        if isinstance(func, list):\n            index = bisect_left(func, num) - 1\n            if index == -1:\n                return Result(None, None)\n            else:\n                return Result(index, func[index])\n        else:\n            alpha, omega = 0, size - 1\n            if func(alpha) >= num:\n                return Result(None, None)\n            while alpha < omega:\n                if func(omega) < num:\n                    return Result(omega, func(omega))\n                if omega == alpha + 1:\n                    return Result(alpha, func(alpha))\n                mid = (alpha + omega) // 2\n                if func(mid) < num:\n                    alpha = mid\n                else:\n                    omega = mid\n\nimport sys\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nn, m, t1, t2, k = map(int, input().split())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\nif n <= k or m <= k:\n    print(-1)\n    quit()\n\nbs = BinarySearch()\n\nans = 0\nfor i in range(min(n+1, k+1)):\n    time = a[i] + t1\n    index = bs.greater_than(time-1, b).index\n    if index is None:\n        print(-1)\n        quit()\n    index += (k - i)\n    if index >= m:\n        print(-1)\n        quit()\n    ans = max(ans, b[index] + t2)\n\nprint(ans)",
    "prob_desc_created_at": "1559399700",
    "tags": [
        "two pointers",
        "binary search",
        "brute force"
    ],
    "hidden_unit_tests": ""
}
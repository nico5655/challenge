{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"1\\n1\\n2\\n3\\n1\"]",
    "src_uid": "cc21fe2f33fed13e6fe0fb25f197ca8f",
    "prob_desc_notes": null,
    "prob_desc_description": "Pchelyonok decided to give Mila a gift. Pchelenok has already bought an array $$$a$$$ of length $$$n$$$, but gifting an array is too common. Instead of that, he decided to gift Mila the segments of that array!Pchelyonok wants his gift to be beautiful, so he decided to choose $$$k$$$ non-overlapping segments of the array $$$[l_1,r_1]$$$, $$$[l_2,r_2]$$$, $$$\\ldots$$$ $$$[l_k,r_k]$$$ such that:  the length of the first segment $$$[l_1,r_1]$$$ is $$$k$$$, the length of the second segment $$$[l_2,r_2]$$$ is $$$k-1$$$, $$$\\ldots$$$, the length of the $$$k$$$-th segment $$$[l_k,r_k]$$$ is $$$1$$$  for each $$$i&lt;j$$$, the $$$i$$$-th segment occurs in the array earlier than the $$$j$$$-th (i.e. $$$r_i&lt;l_j$$$)  the sums in these segments are strictly increasing (i.e. let $$$sum(l \\ldots r) = \\sum\\limits_{i=l}^{r} a_i$$$ — the sum of numbers in the segment $$$[l,r]$$$ of the array, then $$$sum(l_1 \\ldots r_1) &lt; sum(l_2 \\ldots r_2) &lt; \\ldots &lt; sum(l_k \\ldots r_k)$$$). Pchelenok also wants his gift to be as beautiful as possible, so he asks you to find the maximal value of $$$k$$$ such that he can give Mila a gift!",
    "prob_desc_output_spec": "For each test case, print the maximum possible value of $$$k$$$.",
    "prob_desc_input_spec": "The first line contains a single integer $$$t$$$ ($$$1 \\le t \\le 100$$$) — the number of test cases. The next $$$2 \\cdot t$$$ lines contain the descriptions of test cases. The description of each test case consists of two lines. The first line of each test case contains a single integer $$$n$$$ ($$$1 \\le n \\le 10^5$$$) — the length of the array. The second line contains $$$n$$$ integers $$$a_1, a_2, \\ldots, a_n$$$ ($$$1 \\le a_i \\le 10^9$$$) — the elements of the array $$$a$$$. It is guaranteed that the sum of $$$n$$$ over all test cases does not exceed $$$10^5$$$.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3-64",
    "lang_cluster": "Python",
    "difficulty": 2000,
    "file_name": "train_106.jsonl",
    "code_uid": "0b0449f893050c54017fff5a71a83ea7",
    "prob_desc_memory_limit": "512 megabytes",
    "prob_desc_sample_inputs": "[\"5\\n1\\n1\\n3\\n1 2 3\\n5\\n1 1 2 2 3\\n7\\n1 2 1 1 3 2 6\\n5\\n9 6 7 9 7\"]",
    "exec_outcome": "PASSED",
    "source_code": "import os\r\nimport sys\r\nfrom collections import *\r\nfrom itertools import *\r\nfrom math import *\r\nfrom array import *\r\nfrom functools import lru_cache\r\nimport heapq\r\nimport bisect\r\nimport random\r\nimport re\r\n\r\nif sys.hexversion == 50924784:\r\n    sys.stdin = open('cfinput.txt')\r\nelse:\r\n    input = sys.stdin.buffer.readline\r\nMOD = 10 ** 9 + 7\r\n\r\n\r\ndef RI():\r\n    return map(int, input().split())\r\n\r\n\r\ndef RILST():\r\n    return list(RI())\r\n\r\n\r\ndef solve(n, a):\r\n    a = a[::-1]  # 逆序，题目转化成：子数组长度+1递增，但求和递减\r\n    # print(a)\r\n    pre = list(accumulate(a, initial=0))\r\n    # print(pre)\r\n    m = int((1 + 8 * n) ** 0.5 - 1) // 2\r\n    f = [[0] * (n + 1) for _ in range(m + 2)]  # f[i][j]代表 从以j为结尾的前缀里，选出i个子数组，最后一组数组的最大和（ij均从1开始）\r\n    f[0] = [inf] * (n + 1)\r\n    ans = 1\r\n    # print(f,m)\r\n    for i in range(1, m + 1):\r\n        if ans < i - 1:\r\n            return print(ans)\r\n        for j in range(i * (i + 1) // 2, n + 1):\r\n            f[i][j] = f[i][j - 1]\r\n            s = pre[j] - pre[j - i]\r\n            if s < f[i - 1][j - i]:\r\n                ans = i\r\n                f[i][j] = max(f[i][j], s)\r\n        # print(f)\r\n\r\n    print(ans)\r\n\r\n\r\ndef solve2(n, a):\r\n    a = a[::-1]  # 逆序，题目转化成：子数组长度+1递增，但求和递减\r\n    pre = list(accumulate(a, initial=0))\r\n    # print(pre)\r\n    m = int((1 + 8 * n) ** 0.5 - 1) // 2\r\n    f = [0] * (n + 1)  # f[i][j]代表 从以j为结尾的前缀里，选出i个子数组，最后一组数组的最大和（ij均从1开始）\r\n    f = [inf] * (n + 1)\r\n    g = [0] * (n + 1)\r\n    ans = 1\r\n    # print(f,m)\r\n    for i in range(1, m + 1):\r\n        if ans < i - 1:\r\n            return print(ans)\r\n        g[i * (i + 1) // 2 - 1] = 0\r\n        for j in range(i * (i + 1) // 2, n + 1):\r\n            g[j] = g[j - 1]\r\n            s = pre[j] - pre[j - i]\r\n            if s < f[j - i]:\r\n                ans = i\r\n                g[j] = max(g[j], s)\r\n        f, g = g, f\r\n        # print(f,g)\r\n\r\n    print(ans)\r\n\r\n\r\ndef solve3(n, a):\r\n    # 逆序，题目转化成：子数组长度+1递增，但求和递减\r\n    pre = list(accumulate(a[::-1], initial=0))\r\n    m = int((1 + 8 * n) ** 0.5 - 1) // 2  # 长度为n的数组最多能选出m组\r\n    # f[i][j]代表 从以j为结尾的前缀里，选出i个子数组，最后一组数组的最大和（ij均从1开始）\r\n    f = [inf] * (n + 1)  # f[0][j]都置INF，因为长度为1的数组无求和上限要求,认为长度0的数组求和都是inf\r\n    g = [0] * (n + 1)  # 实测滚动数组时间优化一小半\r\n\r\n    ans = 1\r\n    for i in range(1, m + 1):\r\n        g[i * (i + 1) // 2 - 1] = 0  # 长度不够选不出来，结尾段求和置0，方便转移\r\n        for j in range(i * (i + 1) // 2, n + 1):\r\n            g[j] = g[j - 1]  # 从前缀转移\r\n            s = pre[j] - pre[j - i]\r\n            if g[j] < s < f[j - i]:  # 本段符合要求，尝试以它结尾（作为第i个子段）\r\n                ans = i\r\n                g[j] = s\r\n\r\n        if not g[n]:\r\n            break\r\n        f, g = g, f\r\n\r\n    print(ans)\r\n\r\n\r\nif __name__ == '__main__':\r\n    t, = RI()\r\n    for _ in range(t):\r\n        n, = RI()\r\n        a = RILST()\r\n        solve(n, a)\r\n",
    "prob_desc_created_at": "1635069900",
    "tags": [
        "binary search",
        "data structures",
        "dp",
        "greedy",
        "math"
    ],
    "hidden_unit_tests": ""
}
{
    "prob_desc_time_limit": "4 seconds",
    "prob_desc_sample_outputs": "[\"1 1\\n1 1\\n2 2\\n1 1\\n1 1\\n2 2\\n2 3\\n2 3\\n2 3\\n2 3\\n2 3\\n2 3\\n2 3\\n2 3\\n3 4\\n2 4\\n4 6\\n2 4\\n2 4\\n4 6\\n2 4\\n2 4\"]",
    "src_uid": "c8747882ea0a79c0f821a6b9badd2625",
    "prob_desc_notes": "NoteIn all test cases, the first query is considered.In the first test case, $$$f(1, 1) = 0 - 0 = 0$$$.In the second test case, $$$f(1, 1) = 5 - 5 = 0$$$, $$$f(2, 2) = 10 - 10 = 0$$$. Note that $$$f(1, 2) = (10 + 5) - (10 \\oplus 5) = 0$$$, but we need to find a subsegment with the minimum length among the maximum values of $$$f(l, r)$$$. So, only segments $$$[1, 1]$$$ and $$$[2, 2]$$$ are the correct answers.In the fourth test case, $$$f(2, 3) = (12 + 8) - (12 \\oplus 8) = 16$$$. There are two correct answers in the fifth test case, since $$$f(2, 3) = f(3, 4)$$$ and their lengths are equal.",
    "prob_desc_description": "This is the hard version of the problem. The only difference is that in this version $$$q = n$$$.You are given an array of integers $$$a_1, a_2, \\ldots, a_n$$$.The cost of a subsegment of the array $$$[l, r]$$$, $$$1 \\leq l \\leq r \\leq n$$$, is the value $$$f(l, r) = \\operatorname{sum}(l, r) - \\operatorname{xor}(l, r)$$$, where $$$\\operatorname{sum}(l, r) = a_l + a_{l+1} + \\ldots + a_r$$$, and $$$\\operatorname{xor}(l, r) = a_l \\oplus a_{l+1} \\oplus \\ldots \\oplus a_r$$$ ($$$\\oplus$$$ stands for bitwise XOR).You will have $$$q$$$ queries. Each query is given by a pair of numbers $$$L_i$$$, $$$R_i$$$, where $$$1 \\leq L_i \\leq R_i \\leq n$$$. You need to find the subsegment $$$[l, r]$$$, $$$L_i \\leq l \\leq r \\leq R_i$$$, with maximum value $$$f(l, r)$$$. If there are several answers, then among them you need to find a subsegment with the minimum length, that is, the minimum value of $$$r - l + 1$$$.",
    "prob_desc_output_spec": "For each test case print $$$q$$$ pairs of numbers $$$L_i \\leq l \\leq r \\leq R_i$$$ such that the value $$$f(l, r)$$$ is maximum and among such the length $$$r - l + 1$$$ is minimum. If there are several correct answers, print any of them.",
    "prob_desc_input_spec": "Each test consists of multiple test cases. The first line contains an integer $$$t$$$ ($$$1 \\leq t \\leq 10^4$$$) — the number of test cases. The description of test cases follows. The first line of each test case contains two integers $$$n$$$ and $$$q$$$ ($$$1 \\leq n \\leq 10^5$$$, $$$q = n$$$) — the length of the array and the number of queries. The second line of each test case contains $$$n$$$ integers $$$a_1, a_2, \\ldots, a_n$$$ ($$$0 \\leq a_i \\leq 10^9$$$) — array elements. $$$i$$$-th of the next $$$q$$$ lines of each test case contains two integers $$$L_i$$$ and $$$R_i$$$ ($$$1 \\leq L_i \\leq R_i \\leq n$$$) — the boundaries in which we need to find the segment. It is guaranteed that the sum of $$$n$$$ over all test cases does not exceed $$$2 \\cdot 10^5$$$. It is guaranteed that $$$L_1 = 1$$$ and $$$R_1 = n$$$.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3-64",
    "lang_cluster": "Python",
    "difficulty": 2100,
    "file_name": "train_097.jsonl",
    "code_uid": "843cc76f14003a278ef85fc65f27dd19",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"6\\n\\n1 1\\n\\n0\\n\\n1 1\\n\\n2 2\\n\\n5 10\\n\\n1 2\\n\\n2 2\\n\\n3 3\\n\\n0 2 4\\n\\n1 3\\n\\n1 2\\n\\n2 3\\n\\n4 4\\n\\n0 12 8 3\\n\\n1 4\\n\\n1 3\\n\\n2 4\\n\\n2 3\\n\\n5 5\\n\\n21 32 32 32 10\\n\\n1 5\\n\\n1 4\\n\\n1 3\\n\\n2 5\\n\\n3 5\\n\\n7 7\\n\\n0 1 0 1 0 1 0\\n\\n1 7\\n\\n3 6\\n\\n2 5\\n\\n1 4\\n\\n4 7\\n\\n2 6\\n\\n2 7\"]",
    "exec_outcome": "PASSED",
    "source_code": "from bisect import bisect_left, bisect_right\r\nimport sys\r\nimport io\r\nimport os\r\n\r\n\r\n# region IO\r\nBUFSIZE = 8192\r\n\r\n\r\nclass FastIO(io.IOBase):\r\n    newlines = 0\r\n\r\n    def __init__(self, file):\r\n        self._file = file\r\n        self._fd = file.fileno()\r\n        self.buffer = io.BytesIO()\r\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\r\n        self.write = self.buffer.write if self.writable else None\r\n\r\n    def read(self):\r\n        while True:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            if not b:\r\n                break\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines = 0\r\n        return self.buffer.read()\r\n\r\n    def readline(self):\r\n        while self.newlines == 0:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            self.newlines = b.count(b\"\\n\") + (not b)\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines -= 1\r\n        return self.buffer.readline()\r\n\r\n    def flush(self):\r\n        if self.writable:\r\n            os.write(self._fd, self.buffer.getvalue())\r\n            self.buffer.truncate(0), self.buffer.seek(0)\r\n\r\n\r\nclass IOWrapper(io.IOBase):\r\n    def __init__(self, file):\r\n        self.buffer = FastIO(file)\r\n        self.flush = self.buffer.flush\r\n        self.writable = self.buffer.writable\r\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\r\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\r\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\r\n\r\n\r\ndef print(*args, **kwargs):\r\n    \"\"\"Prints the values to a stream, or to sys.stdout by default.\"\"\"\r\n    sep, file = kwargs.pop(\"sep\", \" \"), kwargs.pop(\"file\", sys.stdout)\r\n    at_start = True\r\n    for x in args:\r\n        if not at_start:\r\n            file.write(sep)\r\n        file.write(str(x))\r\n        at_start = False\r\n    file.write(kwargs.pop(\"end\", \"\\n\"))\r\n    if kwargs.pop(\"flush\", False):\r\n        file.flush()\r\n\r\n\r\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\r\n\r\n\r\ndef input(): return sys.stdin.readline().rstrip('\\r\\n')\r\n\r\n\r\ndef read_int_list():\r\n    return list(map(int, input().split()))\r\n\r\n\r\ndef read_int_tuple():\r\n    return tuple(map(int, input().split()))\r\n\r\n\r\ndef read_int():\r\n    return int(input())\r\n\r\n\r\n# endregion\r\n\r\n# region local test\r\n# if 'AW' in os.environ.get('COMPUTERNAME', ''):\r\n#     test_no = 1\r\n#     f = open(os.path.dirname(__file__) + f'\\\\in{test_no}.txt', 'r')\r\n\r\n#     def input():\r\n#         return f.readline().rstrip(\"\\r\\n\")\r\n# endregion\r\n\r\ndef solve():\r\n    n, q = read_int_tuple()\r\n    A = read_int_list()\r\n\r\n    pre = [0] * (n + 1)\r\n    pxr = [0] * (n + 1)\r\n    for i, x in enumerate(A, 1):\r\n        pre[i] = x + pre[i - 1]\r\n        pxr[i] = x ^ pxr[i - 1]\r\n    idx = [i for i, x in enumerate(A) if x]\r\n\r\n    for _ in range(q):\r\n        L, R = read_int_tuple()\r\n        li, ri = bisect_left(idx, L - 1), bisect_right(idx, R - 1) - 1\r\n        if not (0 <= li <= ri < len(idx)):\r\n            print(L, L)\r\n            continue\r\n\r\n        L, R = idx[li], idx[ri]\r\n        tx = pxr[R + 1] ^ pxr[L]\r\n        hi = pre[R + 1] - pre[L] - tx\r\n        if hi == 0:\r\n            print(L + 1, L + 1)\r\n            continue\r\n\r\n        tl, tr = L, R\r\n        \r\n        for dd in range(1, min(bin(tx).count('1') + 1, ri - li + 1)):\r\n            for dl in range(dd + 1):\r\n                dr = dd - dl\r\n                i, j = idx[li + dl], idx[ri - dr]\r\n                cur = pre[j + 1] - pre[i] - (pxr[j + 1] ^ pxr[i])\r\n                if cur == hi and tr - tl > j - i:\r\n                    tl, tr = i, j\r\n\r\n\r\n        print(tl + 1, tr + 1)\r\n\r\n\r\nT = read_int()  # 1\r\nfor t in range(T):\r\n    solve()",
    "prob_desc_created_at": "1666519500",
    "tags": [
        "binary search",
        "bitmasks",
        "brute force",
        "greedy",
        "implementation",
        "two pointers"
    ],
    "hidden_unit_tests": ""
}
{
    "prob_desc_time_limit": "4 seconds",
    "prob_desc_sample_outputs": "[\"0\\n1\\n1\", \"0\\n1\\n0\\n1\\n0\\n1\\n0\\n1\\n1\\n1\\n1\\n2\"]",
    "src_uid": "d4774270c77128b1cc4a8f454ee544bd",
    "prob_desc_notes": "NoteIn the first example, you can first create new value $$$2 \\cdot 3 = 6$$$ or $$$10 \\cdot 11 = 110$$$ or $$$3 \\cdot 4 = 12$$$. None of that is needed in the first query because you can already get from $$$a_1 = 2$$$ to $$$a_2 = 10$$$.In the second query, it's optimal to first create $$$6$$$ or $$$12$$$. For example, creating $$$6$$$ makes it possible to get from $$$a_1 = 2$$$ to $$$a_3 = 3$$$ with a path $$$(2, 6, 3)$$$.  In the last query of the second example, we want to get from $$$a_3 = 7$$$ to $$$a_5 = 25$$$. One way to achieve that is to first create $$$6 \\cdot 7 = 42$$$ and then create $$$25 \\cdot 26 = 650$$$. The final graph has seven nodes and it contains a path from $$$a_3 = 7$$$ to $$$a_5 = 25$$$.",
    "prob_desc_description": "Consider a sequence of distinct integers $$$a_1, \\ldots, a_n$$$, each representing one node of a graph. There is an edge between two nodes if the two values are not coprime, i. e. they have a common divisor greater than $$$1$$$.There are $$$q$$$ queries, in each query, you want to get from one given node $$$a_s$$$ to another $$$a_t$$$. In order to achieve that, you can choose an existing value $$$a_i$$$ and create new value $$$a_{n+1} = a_i \\cdot (1 + a_i)$$$, with edges to all values that are not coprime with $$$a_{n+1}$$$. Also, $$$n$$$ gets increased by $$$1$$$. You can repeat that operation multiple times, possibly making the sequence much longer and getting huge or repeated values. What's the minimum possible number of newly created nodes so that $$$a_t$$$ is reachable from $$$a_s$$$?Queries are independent. In each query, you start with the initial sequence $$$a$$$ given in the input.",
    "prob_desc_output_spec": "Print $$$q$$$ lines. The $$$j$$$-th line should contain one integer: the minimum number of new nodes you create in order to move from $$$a_{s_j}$$$ to $$$a_{t_j}$$$.",
    "prob_desc_input_spec": "The first line contains two integers $$$n$$$ and $$$q$$$ ($$$2 \\leq n \\leq 150\\,000$$$, $$$1 \\leq q \\leq 300\\,000$$$) — the size of the sequence and the number of queries. The second line contains $$$n$$$ distinct integers $$$a_1, a_2, \\ldots, a_n$$$ ($$$2 \\leq a_i \\leq 10^6$$$, $$$a_i \\neq a_j$$$ if $$$i \\ne j$$$). The $$$j$$$-th of the following $$$q$$$ lines contains two distinct integers $$$s_j$$$ and $$$t_j$$$ ($$$1 \\leq s_j, t_j \\leq n$$$, $$$s_j \\neq t_j$$$) — indices of nodes for $$$j$$$-th query.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3",
    "lang_cluster": "Python",
    "difficulty": 2700,
    "file_name": "train_105.jsonl",
    "code_uid": "03fbe0437dd8ea3d6a84202d58408c30",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"3 3\\n2 10 3\\n1 2\\n1 3\\n2 3\", \"5 12\\n3 8 7 6 25\\n1 2\\n1 3\\n1 4\\n1 5\\n2 1\\n2 3\\n2 4\\n2 5\\n3 1\\n3 2\\n3 4\\n3 5\"]",
    "exec_outcome": "PASSED",
    "source_code": "import itertools\nfrom sys import stdin\n\n\ndef input():\n    # credits to https://codeforces.com/profile/aberent\n    # wouldn't solve without this\n    return next(stdin)[:-1]\n\n\ndef readline():\n    return map(int, input().split())\n\n\nprimes = [2]\nprimes.extend(q for q in range(3, 10**3, 2) if all(q % p for p in primes))\n\n\ndef prime_divisors(n):\n    for p in primes:\n        if p * p > n:\n            break\n        if n % p == 0:\n            yield p\n            while n % p == 0:\n                n //= p\n    if n > 1:\n        yield n\n\n\nclass DSU:  # naïve implementation, no optimizations\n    def __init__(self):\n        self.p = dict()  # parent\n\n    def _get_root(self, a):\n        while a in self.p:\n            a = self.p[a]\n        return a\n\n    def __setitem__(self, a, b):\n        r = self._get_root(b)\n        while a != r:  # attach all ancestors of a to root(b)\n            self.p[a], a = r, self.p.get(a, a)\n\n    def __getitem__(self, a):\n        self[a] = a  # flatten, attach all ancestors of a to root(a)\n        return self.p.get(a, a)\n\n\ndef main():\n    n, q = readline()\n    a = list(readline())\n    queries = (readline() for __ in range(q))  # overriding q later :P\n\n    min_divisor = list()\n    dsu = DSU()\n    for ai in a:\n        p, *rest = prime_divisors(ai)\n        min_divisor.append(p)\n        for q in rest:\n            dsu[q] = p\n\n    def sorted_tuple(t):\n        return tuple(sorted(t))\n\n    one = set()  # pairs of components reachable with 1 operation\n    for (ai, p) in zip(a, min_divisor):\n        new_node = {dsu[p], *(dsu[q] for q in prime_divisors(ai + 1))}\n        one.update(map(sorted_tuple, itertools.combinations(new_node, 2)))\n\n    for (s, t) in queries:\n        p = dsu[min_divisor[s-1]]\n        q = dsu[min_divisor[t-1]]\n        if p == q:\n            print(0)\n        elif sorted_tuple((p, q)) in one:\n            print(1)\n        else:\n            print(2)\n\n\nif __name__ == '__main__':\n    main()\n\n\n# t.me/belkka\n",
    "prob_desc_created_at": "1626964500",
    "tags": [
        "brute force",
        "constructive algorithms",
        "dsu",
        "graphs",
        "hashing",
        "math",
        "number theory"
    ],
    "hidden_unit_tests": ""
}
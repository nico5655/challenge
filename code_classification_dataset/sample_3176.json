{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"3\", \"5\"]",
    "src_uid": "8b8b93ce1760e77dfd5551c564170a43",
    "prob_desc_notes": "NoteIn the first example, a ball centered at $$$(1, 0)$$$ covers the points $$$(1, 1)$$$, $$$(1, -1)$$$, $$$(2, 0)$$$.In the second example, a ball centered at $$$(0, 0)$$$ covers all the points.Note that $$$x_0$$$ and $$$y_0$$$ need not be integer.",
    "prob_desc_description": "The Cybermen solved that first test much quicker than the Daleks. Luckily for us, the Daleks were angry (shocking!) and they destroyed some of the Cybermen.After the fighting stopped, Heidi gave them another task to waste their time on.There are $$$n$$$ points on a plane. Given a radius $$$r$$$, find the maximum number of points that can be covered by an $$$L^1$$$-ball with radius $$$r$$$.An $$$L^1$$$-ball with radius $$$r$$$ and center $$$(x_0, y_0)$$$ in a 2D-plane is defined as the set of points $$$(x, y)$$$ such that the Manhattan distance between $$$(x_0, y_0)$$$ and $$$(x, y)$$$ is at most $$$r$$$.Manhattan distance between $$$(x_0, y_0)$$$ and $$$(x, y)$$$ is defined as $$$|x - x_0| + |y - y_0|$$$.",
    "prob_desc_output_spec": "Print one integer — the maximum number points that an $$$L^1$$$-ball with radius $$$r$$$ can cover.",
    "prob_desc_input_spec": "The first line contains two integers $$$n, r$$$ ($$$1 \\le n \\le 300\\,000, 1 \\le r \\le 10^6$$$), the number of points and the radius of the ball, respectively.  Each of the next $$$n$$$ lines contains integers $$$x_i, y_i$$$ ($$$-10^6 \\leq x_i, y_i \\leq 10^6$$$), describing the coordinates of the $$$i$$$-th point. It is guaranteed, that all points are distinct.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "Python 2",
    "lang_cluster": "Python",
    "difficulty": 2200,
    "file_name": "train_045.jsonl",
    "code_uid": "c206ab1fa7ed007a3b2e38227cc9bb9f",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"5 1\\n1 1\\n1 -1\\n-1 1\\n-1 -1\\n2 0\", \"5 2\\n1 1\\n1 -1\\n-1 1\\n-1 -1\\n2 0\"]",
    "exec_outcome": "PASSED",
    "source_code": "def main():\n    inp = readnumbers()\n    ii = 0\n    n = inp[ii]\n    ii += 1\n    r = inp[ii]\n    ii += 1\n    A = []\n    B = []\n    for i in range(n):\n        x = inp[ii]\n        ii += 1\n        y = inp[ii]\n        ii += 1\n        A.append(x+y)\n        B.append(x-y)\n    xcoords = []\n    for a in A:\n        xcoords.append(a + r)\n        xcoords.append(a - r)  \n    ycoords = []\n    for b in B:\n        ycoords.append(b + r)\n        ycoords.append(b - r)\n    xmapper = {}\n    for i,x in enumerate(sorted(set(xcoords))):\n        xmapper[x] = i\n    ymapper = {}\n    for i,y in enumerate(sorted(set(ycoords))):\n        ymapper[y] = i\n    starts = [[] for _ in range(len(xmapper))]\n    ends = [[] for _ in range(len(xmapper))]\n    for a,b in zip(A,B):\n        starts[xmapper[a-r]].append(b)\n        ends[xmapper[a+r]].append(b)\n    maxi = 0\n    seg = LazySegmentTree(len(ymapper))\n    for i in range(len(xmapper)):\n        for b in starts[i]:\n            bstart = ymapper[b-r]\n            bend = ymapper[b+r] + 1\n            seg.add(bstart, bend, 1)\n        maxi = max(maxi, seg.data[1])\n        for b in ends[i]:\n            bstart = ymapper[b-r]\n            bend = ymapper[b+r] + 1\n            seg.add(bstart, bend, -1)\n    print maxi\nclass LazySegmentTree:\n    def __init__(self, n, padding = 0, func=max):\n        \"\"\"initialize the lazy segment tree with data\"\"\"\n        self._func = func\n        self._len = n\n        self._size = _size = 1 << (self._len - 1).bit_length()\n        self.data = [padding] * (2 * _size)\n        self._lazy = [0] * (2 * _size)\n    def _push(self, idx):\n        \"\"\"push query on idx to its children\"\"\"\n        q = self._lazy[idx]\n        self._lazy[idx] = 0\n        self.data[2 * idx] += q\n        self.data[2 * idx + 1] += q\n        self._lazy[2 * idx] += q\n        self._lazy[2 * idx + 1] += q\n    def _build(self, idx):\n        \"\"\"make the changes to idx be known to its ancestors\"\"\"\n        idx >>= 1\n        while idx:\n            # TODO\n            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1]) + self._lazy[idx]\n            idx >>= 1\n    def _update(self, idx):\n        \"\"\"updates the node idx to know of all queries applied to it via its ancestors\"\"\"\n        for i in reversed(range(1, idx.bit_length())):\n            self._push(idx >> i)\n    def add(self, start, stop, value):\n        \"\"\"lazily add value to [start, stop)\"\"\"\n        start = start_copy = start + self._size\n        stop = stop_copy = stop + self._size\n        while start < stop:\n            if start & 1:\n                self.data[start] += value\n                self._lazy[start] += value\n                start += 1\n            if stop & 1:\n                stop -= 1\n                self.data[stop] += value\n                self._lazy[stop] += value\n            start >>= 1; stop >>= 1\n        self._build(start_copy); self._build(stop_copy - 1)\n    def query(self, start, stop, res = 0):\n        \"\"\"func of data[start, stop)\"\"\"\n        start += self._size; stop += self._size\n        self._update(start); self._update(stop - 1)\n        while start < stop:\n            if start & 1:\n                res = self._func(res, self.data[start])\n                start += 1\n            if stop & 1:\n                stop -= 1\n                res = self._func(self.data[stop], res)\n            start >>= 1; stop >>= 1\n        return res\n    def node_size(self, idx):\n        return 1 << self._size.bit_length() - idx.bit_length()\npy2 = round(0.5)\nif py2:\n    from future_builtins import ascii, filter, hex, map, oct, zip\n    range = xrange\nimport os, sys\nfrom io import IOBase, BytesIO\nBUFSIZE = 8192\nclass FastIO(BytesIO):\n    newlines = 0\n    def __init__(self, file):\n        self._file = file\n        self._fd = file.fileno()\n        self.writable = \"x\" in file.mode or \"w\" in file.mode\n        self.write = super(FastIO, self).write if self.writable else None\n    def _fill(self):\n        s = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n        self.seek((self.tell(), self.seek(0,2), super(FastIO, self).write(s))[0])\n        return s\n    def read(self):\n        while self._fill(): pass\n        return super(FastIO,self).read()\n    def readline(self):\n        while self.newlines == 0:\n            s = self._fill(); self.newlines = s.count(b\"\\n\") + (not s)\n        self.newlines -= 1\n        return super(FastIO, self).readline()\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.getvalue())\n            self.truncate(0), self.seek(0)\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        if py2:\n            self.write = self.buffer.write\n            self.read = self.buffer.read\n            self.readline = self.buffer.readline\n        else:\n            self.write = lambda s:self.buffer.write(s.encode('ascii'))\n            self.read = lambda:self.buffer.read().decode('ascii')\n            self.readline = lambda:self.buffer.readline().decode('ascii')\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip('\\r\\n')\nimport sys\nclass ostream:\n    def __lshift__(self,a):\n        sys.stdout.write(str(a))\n        return self\ncout = ostream()\nendl = '\\n'\ndef readnumbers(zero = 0):\n    conv = ord if py2 else lambda x:x\n    A = []; numb = zero; sign = 1; i = 0; s = sys.stdin.buffer.read()\n    try:\n        while True:\n            if s[i] >= b'0' [0]:\n                numb = 10 * numb + conv(s[i]) - 48\n            elif s[i] == b'-' [0]: sign = -1\n            elif s[i] != b'\\r' [0]:\n                A.append(sign*numb)\n                numb = zero; sign = 1\n            i += 1\n    except:pass\n    if s and s[-1] >= b'0' [0]:\n        A.append(sign*numb)\n    return A\nif __name__== \"__main__\":\n  main()",
    "prob_desc_created_at": "1562483100",
    "tags": [
        "data structures"
    ],
    "hidden_unit_tests": ""
}
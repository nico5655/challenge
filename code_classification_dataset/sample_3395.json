{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"3 6\\n7 5\", \"2 9\\n6 8\", \"10 6\\n4 5\", \"9 11\\n8 10\"]",
    "src_uid": "4cabc6c5dca6e67a355315040deb11a0",
    "prob_desc_notes": "NoteThe picture corresponding to the first example: The intersection of two paths is $$$2$$$ (vertices $$$1$$$ and $$$4$$$) and the total length is $$$4 + 3 = 7$$$.The picture corresponding to the second example: The intersection of two paths is $$$2$$$ (vertices $$$3$$$ and $$$4$$$) and the total length is $$$5 + 3 = 8$$$.The picture corresponding to the third example: The intersection of two paths is $$$3$$$ (vertices $$$2$$$, $$$7$$$ and $$$8$$$) and the total length is $$$5 + 5 = 10$$$.The picture corresponding to the fourth example: The intersection of two paths is $$$5$$$ (vertices $$$1$$$, $$$2$$$, $$$3$$$, $$$4$$$ and $$$5$$$) and the total length is $$$6 + 6 = 12$$$.",
    "prob_desc_description": "You are given an undirected unweighted tree consisting of $$$n$$$ vertices.An undirected tree is a connected undirected graph with $$$n - 1$$$ edges.Your task is to choose two pairs of vertices of this tree (all the chosen vertices should be distinct) $$$(x_1, y_1)$$$ and $$$(x_2, y_2)$$$ in such a way that neither $$$x_1$$$ nor $$$y_1$$$ belong to the simple path from $$$x_2$$$ to $$$y_2$$$ and vice versa (neither $$$x_2$$$ nor $$$y_2$$$ should not belong to the simple path from $$$x_1$$$ to $$$y_1$$$).It is guaranteed that it is possible to choose such pairs for the given tree.Among all possible ways to choose such pairs you have to choose one with the maximum number of common vertices between paths from $$$x_1$$$ to $$$y_1$$$ and from $$$x_2$$$ to $$$y_2$$$. And among all such pairs you have to choose one with the maximum total length of these two paths.It is guaranteed that the answer with at least two common vertices exists for the given tree.The length of the path is the number of edges in it.The simple path is the path that visits each vertex at most once.",
    "prob_desc_output_spec": "Print any two pairs of vertices satisfying the conditions described in the problem statement. It is guaranteed that it is possible to choose such pairs for the given tree.",
    "prob_desc_input_spec": "The first line contains an integer $$$n$$$ â€” the number of vertices in the tree ($$$6 \\le n \\le 2 \\cdot 10^5$$$). Each of the next $$$n - 1$$$ lines describes the edges of the tree. Edge $$$i$$$ is denoted by two integers $$$u_i$$$ and $$$v_i$$$, the labels of vertices it connects ($$$1 \\le u_i, v_i \\le n$$$, $$$u_i \\ne v_i$$$). It is guaranteed that the given edges form a tree. It is guaranteed that the answer with at least two common vertices exists for the given tree.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "Python 3",
    "lang_cluster": "Python",
    "difficulty": 2500,
    "file_name": "train_057.jsonl",
    "code_uid": "d7fc06c43f5ac0df38ca31d3ce142708",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"7\\n1 4\\n1 5\\n1 6\\n2 3\\n2 4\\n4 7\", \"9\\n9 3\\n3 5\\n1 2\\n4 3\\n4 7\\n1 7\\n4 6\\n3 8\", \"10\\n6 8\\n10 3\\n3 7\\n5 8\\n1 7\\n7 2\\n2 9\\n2 8\\n1 4\", \"11\\n1 2\\n2 3\\n3 4\\n1 5\\n1 6\\n6 7\\n5 8\\n5 9\\n4 10\\n4 11\"]",
    "exec_outcome": "PASSED",
    "source_code": "import sys\n\nn = int(sys.stdin.readline())\nedges = [[] for _ in range(n)]\nfor _ in range(n - 1):\n    i, j = tuple(int(k) for k in sys.stdin.readline().split())\n    i -= 1\n    j -= 1\n    edges[i].append(j)\n    edges[j].append(i)\n\n# Prunes the graph starting from the vertices with\n# only 1 edge until we reach a vertex with 3+ edges.\n# Stores the distance from each non-pruned vertex\n# to each of the leaves it reaches.\ndef prune():\n    pruned = [False for _ in range(n)]\n    leaves = [[] for _ in range(n)]\n    todo = []\n    for i in range(n):\n        if len(edges[i]) == 1:\n            todo.append((0, i, i))\n    while len(todo) > 0:\n        d, i, j = todo.pop()\n        pruned[j] = True\n        for k in edges[j]:\n            if not pruned[k]:\n                if len(edges[k]) < 3:\n                    todo.append((d + 1, i, k))\n                else:\n                    leaves[k].append((d + 1, i))\n    return pruned, leaves\n\npruned, leaves = prune()\n\n# Returns the furthest non-pruned vertices\n# from another non-pruned vertex.\ndef furthest(i):\n    assert not pruned[i]\n    visited = list(pruned)\n    top_distance = 0\n    top_vertices = [i]\n    todo = [(0, i)]\n    while len(todo) > 0:\n        d, i = todo.pop()\n        visited[i] = True\n        if d > top_distance:\n            top_distance = d\n            top_vertices = []\n        if d == top_distance:\n            top_vertices.append(i)\n        for j in edges[i]:\n            if not visited[j]:\n                todo.append((d + 1, j))\n    return top_distance, top_vertices\n\n# Single center topology.\n# Only 1 vertex with 3+ edges.\ndef solve_single_center(i):\n    l = list(reversed(sorted(leaves[i])))[:4]\n    return list(l[j][1] for j in range(4))\n\n# Scores non-pruned vertices according to the sum\n# of the distances to their two furthest leaves.\ndef vertices_score(v):\n    scores = []\n    for i in v:\n        assert not pruned[i]\n        l = list(reversed(sorted(leaves[i])))[:2]\n        score = (l[0][0] + l[1][0]), l[0][1], l[1][1]\n        scores.append(score)\n    return list(reversed(sorted(scores)))\n\n# Single cluster topology.\n# 1 cluster of vertices, all equally far away from each other.\ndef solve_single_cluster(v):\n    scores = vertices_score(v)[:2]\n    return scores[0][1], scores[1][1], scores[0][2], scores[1][2]\n\n# Double cluster topology.\n# 2 clusters of vertices, pairwise equally far away from each other.\ndef solve_double_cluster(v1, v2):\n    scores1 = vertices_score(v1)[:1]\n    scores2 = vertices_score(v2)[:1]\n    return scores1[0][1], scores2[0][1], scores1[0][2], scores2[0][2]\n\ndef solve():\n    def start_vertex():\n        for i in range(n):\n            if not pruned[i]:\n                return i\n    i = start_vertex()\n    distance, v1 = furthest(i)\n    if distance == 0:\n        return solve_single_center(v1[0])\n    else:\n        distance, v1 = furthest(v1[0])\n        distance, v2 = furthest(v1[0])\n        v = list(set(v1) | set(v2))\n        if len(v) < len(v1) + len(v2):\n            return solve_single_cluster(v)\n        else:\n            return solve_double_cluster(v1, v2)\n\na, b, c, d = solve()\nprint(a + 1, b + 1)\nprint(c + 1, d + 1)\n",
    "prob_desc_created_at": "1540478100",
    "tags": [
        "dp",
        "dfs and similar",
        "greedy",
        "trees"
    ],
    "hidden_unit_tests": ""
}
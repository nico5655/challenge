{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"0\\n3\\n-1\\n3\\n2\\n3\\n-1\"]",
    "src_uid": "27c703f9846064af2b0deab93d394272",
    "prob_desc_notes": null,
    "prob_desc_description": "We often have to copy large volumes of information. Such operation can take up many computer resources. Therefore, in this problem you are advised to come up with a way to copy some part of a number array into another one, quickly.More formally, you've got two arrays of integers a1, a2, ..., an and b1, b2, ..., bn of length n. Also, you've got m queries of two types:  Copy the subsegment of array a of length k, starting from position x, into array b, starting from position y, that is, execute by + q = ax + q for all integer q (0 ≤ q &lt; k). The given operation is correct — both subsegments do not touch unexistent elements.  Determine the value in position x of array b, that is, find value bx. For each query of the second type print the result — the value of the corresponding element of array b.",
    "prob_desc_output_spec": "For each second type query print the result on a single line.",
    "prob_desc_input_spec": "The first line contains two space-separated integers n and m (1 ≤ n, m ≤ 105) — the number of elements in the arrays and the number of queries, correspondingly. The second line contains an array of integers a1, a2, ..., an (|ai| ≤ 109). The third line contains an array of integers b1, b2, ..., bn (|bi| ≤ 109). Next m lines contain the descriptions of the queries. The i-th line first contains integer ti — the type of the i-th query (1 ≤ ti ≤ 2). If ti = 1, then the i-th query means the copying operation. If ti = 2, then the i-th query means taking the value in array b. If ti = 1, then the query type is followed by three integers xi, yi, ki (1 ≤ xi, yi, ki ≤ n) — the parameters of the copying query. If ti = 2, then the query type is followed by integer xi (1 ≤ xi ≤ n) — the position in array b. All numbers in the lines are separated with single spaces. It is guaranteed that all the queries are correct, that is, the copying borders fit into the borders of arrays a and b.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "Python 2",
    "lang_cluster": "Python",
    "difficulty": 1900,
    "file_name": "train_025.jsonl",
    "code_uid": "b1dd4ebd6330199c72bbfc3419c79efb",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"5 10\\n1 2 0 -1 3\\n3 1 5 -2 0\\n2 5\\n1 3 3 3\\n2 5\\n2 4\\n2 1\\n1 2 1 4\\n2 1\\n2 4\\n1 4 2 1\\n2 2\"]",
    "exec_outcome": "PASSED",
    "source_code": "from sys import stdin\nimport math\n\n\ndef task_old():\n    n, m = map(int, stdin.readline().split())\n    a = map(int, stdin.readline().split())\n    b = map(int, stdin.readline().split())\n    values = [map(int, i) for i in map(str.split, stdin.readlines())]\n    size = max(2, int(math.sqrt(len(values))))\n    z = [-1] * int(math.ceil(float(n) / size))\n\n    result = []\n    for request in values:\n        print 'z>%s' % z\n        print 'a>%s' % ''.join([i.rjust(4) for i in map(str, a)])\n        print 'b>%s' % ''.join([i.rjust(4) for i in map(str, b)])\n        if request[0] == 1:\n            # copy\n            p_a, p_b, length = request[1:]\n            p_a, p_b = p_a - 1, p_b - 1\n            print 'set a(%s, %s) => b(%s, %s)' % (p_a, p_a + length - 1, p_b, p_b + length - 1)\n            z1, i1 = divmod(p_b, size)\n            z2, i2 = divmod((p_b + length - 1), size)\n            l = min(size - i1, length)\n            b[p_b:p_b + l] = a[p_a:p_a + l]\n            if z2 > z1:\n                b[p_b + length - i2 - 1: p_b + length] = a[p_a + length - i2 - 1: p_a + length]\n            for zi in xrange(z2 - z1 - 1):\n                z[z1 + zi + 1] = p_a - (size - i1) + zi * size\n        else:\n            # get\n            i = request[1] - 1\n            print 'get %s item' % i,\n            zi, p_z = divmod(i, size)\n            if z[zi] == -1:\n                result.append(b[i])\n                print '=> %s' % b[i]\n            else:\n                result.append(a[z[zi] + p_z])\n                print ' => %s' % a[z[zi] + p_z]\n        print\n\n    print '\\n'.join(map(str, result))\n\n\nMED_L = 1 << 17\nMAX_L = MED_L << 1\n\ndef task():\n    n, m = map(int, stdin.readline().split())\n    a = map(int, stdin.readline().split())\n    b = map(int, stdin.readline().split())\n    values = [map(int, i) for i in map(str.split, stdin.readlines())]\n\n    x = [0]*m\n    y = [0]*m\n    z = [0]*m\n    t = [-1]*MAX_L\n\n    def mark(q, lo, hi):\n        lo += MED_L\n        hi += MED_L\n        while lo <= hi:\n            if lo & 1:\n                t[lo] = q\n                lo += 1\n            if not (hi & 1):\n                t[hi] = q\n                hi -= 1\n            lo >>= 1\n            hi >>= 1\n\n    def value(p):\n        res = b[p]\n        q = -1\n        s = p + MED_L\n        while s > 0:\n            q = max(q, t[s])\n            s >>= 1\n        if q != -1:\n            res = a[x[q] + p - y[q]]\n        return res\n\n    result = []\n    for j in xrange(m):\n        if values[j][0] == 1:\n            x[j], y[j], z[j] = values[j][1:]\n            x[j] -= 1\n            y[j] -= 1\n            mark(j, y[j], y[j] + z[j] - 1)\n        else:\n            p = values[j][1] - 1\n            result.append(value(p))\n\n    print '\\n'.join(map(str, result))\n\n\ntask()",
    "prob_desc_created_at": "1366040100",
    "tags": [
        "data structures"
    ],
    "hidden_unit_tests": ""
}
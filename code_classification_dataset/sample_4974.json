{
    "prob_desc_time_limit": "3 seconds",
    "prob_desc_sample_outputs": "[\"1\\n2\"]",
    "src_uid": "d6c228bc6e4c17894d9e723ff980844f",
    "prob_desc_notes": "NoteIn the first query, you can just put the whole array in one subsequence, since its length is $$$6$$$, and no value occurs more than $$$3$$$ times in it.In the second query, the elements of the query range are $$$[3,2,3,3]$$$. You can't put them all in one subsequence, since its length is $$$4$$$, and $$$3$$$ occurs more than $$$2$$$ times. However, you can partition it into two subsequences: $$$[3]$$$ and $$$[2,3,3]$$$.",
    "prob_desc_description": "Baby Ehab has a piece of Cut and Stick with an array $$$a$$$ of length $$$n$$$ written on it. He plans to grab a pair of scissors and do the following to it:  pick a range $$$(l, r)$$$ and cut out every element $$$a_l$$$, $$$a_{l + 1}$$$, ..., $$$a_r$$$ in this range;  stick some of the elements together in the same order they were in the array;  end up with multiple pieces, where every piece contains some of the elements and every element belongs to some piece. More formally, he partitions the sequence $$$a_l$$$, $$$a_{l + 1}$$$, ..., $$$a_r$$$ into subsequences. He thinks a partitioning is beautiful if for every piece (subsequence) it holds that, if it has length $$$x$$$, then no value occurs strictly more than $$$\\lceil \\frac{x}{2} \\rceil$$$ times in it.He didn't pick a range yet, so he's wondering: for $$$q$$$ ranges $$$(l, r)$$$, what is the minimum number of pieces he needs to partition the elements $$$a_l$$$, $$$a_{l + 1}$$$, ..., $$$a_r$$$ into so that the partitioning is beautiful.A sequence $$$b$$$ is a subsequence of an array $$$a$$$ if $$$b$$$ can be obtained from $$$a$$$ by deleting some (possibly zero) elements. Note that it does not have to be contiguous.",
    "prob_desc_output_spec": "For each query, print the minimum number of subsequences you need to partition this range into so that the partitioning is beautiful. We can prove such partitioning always exists.",
    "prob_desc_input_spec": "The first line contains two integers $$$n$$$ and $$$q$$$ ($$$1 \\le n,q \\le 3 \\cdot 10^5$$$) — the length of the array $$$a$$$ and the number of queries. The second line contains $$$n$$$ integers $$$a_1$$$, $$$a_2$$$, ..., $$$a_{n}$$$ ($$$1 \\le a_i \\le n$$$) — the elements of the array $$$a$$$. Each of the next $$$q$$$ lines contains two integers $$$l$$$ and $$$r$$$ ($$$1 \\le l \\le r \\le n$$$) — the range of this query.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3",
    "lang_cluster": "Python",
    "difficulty": 2000,
    "file_name": "train_110.jsonl",
    "code_uid": "7084f5011432a0af522f6a1c5a61c9cc",
    "prob_desc_memory_limit": "512 megabytes",
    "prob_desc_sample_inputs": "[\"6 2\\n1 3 2 3 3 2\\n1 6\\n2 5\"]",
    "exec_outcome": "PASSED",
    "source_code": "\r\nrandCnts=25\r\nrand40=[26163, 136194, 134910, 131586, 131511, 151306, 107322, 4960, 27557, 30930, 34180, 123393, 226938, 259573, 203560, 182549, 208694, 270671, 3616, 256123, 215635, 140161, 243942, 251246, 210982, 138905, 226417, 63875, 281860, 24400, 129710, 157586, 257466, 113783, 57707, 20202, 179489, 273724, 71076, 47490]\r\ndef nPartitions(size,mode):\r\n    b=size\r\n    ep=-1 # extra partitions\r\n    while b>0:\r\n        while ep+b<size and not ((size-(ep+b)+1)//2>=mode-(ep+b)):\r\n            ep+=b\r\n        b//=2\r\n    ep+=1\r\n    return 1+ep\r\n\r\ndef main():\r\n    \r\n    n,q=readIntArr()\r\n    a=readIntArr()\r\n    # n,q=(300000,300000) #\r\n    # a=[197278]*n #\r\n    \r\n    idxs=[[] for _ in range(n+1)]\r\n    for i,x in enumerate(a):\r\n        idxs[x].append(i)\r\n    \r\n    allans=[]\r\n    \r\n    for _ in range(q):\r\n        l,r=readIntArr()\r\n        # l,r=1,_+1 # \r\n        l-=1;r-=1\r\n        gap=r-l+1\r\n        mode=0\r\n        for i in range(randCnts):\r\n            idx=l+rand40[i]%gap\r\n            x=a[idx]\r\n            \r\n            arr=idxs[x]\r\n            m=len(arr)\r\n            l2=-1\r\n            b=m\r\n            while b>0:\r\n                while l2+b<m and arr[l2+b]<l:\r\n                    l2+=b\r\n                b//=2\r\n            l2+=1\r\n            \r\n            r2=-1\r\n            b=m\r\n            while b>0:\r\n                while r2+b<m and arr[r2+b]<=r:\r\n                    r2+=b\r\n                b//=2\r\n            mode=max(mode,r2-l2+1)\r\n        allans.append(nPartitions(gap,mode))\r\n    multiLineArrayPrint(allans)\r\n    \r\n    \r\n    return\r\n\r\nimport sys\r\ninput=sys.stdin.buffer.readline #FOR READING PURE INTEGER INPUTS (space separation ok)\r\n# input=lambda: sys.stdin.readline().rstrip(\"\\r\\n\") #FOR READING STRING/TEXT INPUTS.\r\n\r\ndef oneLineArrayPrint(arr):\r\n    print(' '.join([str(x) for x in arr]))\r\ndef multiLineArrayPrint(arr):\r\n    print('\\n'.join([str(x) for x in arr]))\r\ndef multiLineArrayOfArraysPrint(arr):\r\n    print('\\n'.join([' '.join([str(x) for x in y]) for y in arr]))\r\n \r\ndef readIntArr():\r\n    return [int(x) for x in input().split()]\r\n# def readFloatArr():\r\n#     return [float(x) for x in input().split()]\r\n\r\ndef makeArr(defaultValFactory,dimensionArr): # eg. makeArr(lambda:0,[n,m])\r\n    dv=defaultValFactory;da=dimensionArr\r\n    if len(da)==1:return [dv() for _ in range(da[0])]\r\n    else:return [makeArr(dv,da[1:]) for _ in range(da[0])]\r\n \r\ndef queryInteractive(i,j):\r\n    print('? {} {}'.format(i,j))\r\n    sys.stdout.flush()\r\n    return int(input())\r\n \r\ndef answerInteractive(ans):\r\n    print('! {}'.format(' '.join([str(x) for x in ans])))\r\n    sys.stdout.flush()\r\n \r\ninf=float('inf')\r\nMOD=10**9+7\r\n# MOD=998244353\r\n \r\n \r\nfor _abc in range(1):\r\n    main()",
    "prob_desc_created_at": "1618839300",
    "tags": [
        "binary search",
        "data structures",
        "greedy",
        "implementation",
        "sortings"
    ],
    "hidden_unit_tests": ""
}
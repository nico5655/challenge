{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"10\\n7\\n13\\n0\\n3\"]",
    "src_uid": "8864c6a04fed970fcbc04e220df9d88d",
    "prob_desc_notes": "NoteThe explanations for the example test:We use characters N, E, S, W and 0 to denote going north, going east, going south, going west and staying in the current cell, respectively.In the first test case, the robot can use the following sequence: NENENENENE.In the second test case, the robot can use the following sequence: NENENEN.In the third test case, the robot can use the following sequence: ESENENE0ENESE.In the fourth test case, the robot doesn't need to go anywhere at all.In the fifth test case, the robot can use the following sequence: E0E.",
    "prob_desc_description": "There is an infinite 2-dimensional grid. The robot stands in cell $$$(0, 0)$$$ and wants to reach cell $$$(x, y)$$$. Here is a list of possible commands the robot can execute:  move north from cell $$$(i, j)$$$ to $$$(i, j + 1)$$$;  move east from cell $$$(i, j)$$$ to $$$(i + 1, j)$$$;  move south from cell $$$(i, j)$$$ to $$$(i, j - 1)$$$;  move west from cell $$$(i, j)$$$ to $$$(i - 1, j)$$$;  stay in cell $$$(i, j)$$$. The robot wants to reach cell $$$(x, y)$$$ in as few commands as possible. However, he can't execute the same command two or more times in a row.What is the minimum number of commands required to reach $$$(x, y)$$$ from $$$(0, 0)$$$?",
    "prob_desc_output_spec": "For each testcase print a single integer — the minimum number of commands required for the robot to reach $$$(x, y)$$$ from $$$(0, 0)$$$ if no command is allowed to be executed two or more times in a row.",
    "prob_desc_input_spec": "The first line contains a single integer $$$t$$$ ($$$1 \\le t \\le 100$$$) — the number of testcases. Each of the next $$$t$$$ lines contains two integers $$$x$$$ and $$$y$$$ ($$$0 \\le x, y \\le 10^4$$$) — the destination coordinates of the robot.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 2",
    "lang_cluster": "Python",
    "difficulty": 800,
    "file_name": "train_001.jsonl",
    "code_uid": "93a32ff88ab3bdb4b8d11d4c91dfc886",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"5\\n5 5\\n3 4\\n7 1\\n0 0\\n2 0\"]",
    "exec_outcome": "PASSED",
    "source_code": "from __future__ import division, print_function\n\nMOD = 998244353\nmod = 10**9 + 7\n\n# import resource\n# resource.setrlimit(resource.RLIMIT_STACK, [0x100000000, resource.RLIM_INFINITY])\n\ndef prepare_factorial():\n    fact = [1]\n    for i in range(1, 20):\n        fact.append((fact[-1] * i) % mod)\n    ifact = [0] * 105\n    ifact[104] = pow(fact[104], mod - 2, mod)\n    for i in range(104, 0, -1):\n        ifact[i - 1] = (i * ifact[i]) % mod\n\n    return fact, ifact\n\n# import threading\n# threading.stack_size(1<<27)\nimport sys\n# sys.setrecursionlimit(10000)\n\nfrom bisect import bisect_left, bisect_right, insort\nfrom math import floor, ceil, sqrt, degrees, atan, pi, log, sin, radians, factorial\nfrom heapq import heappop, heapify, heappush\nfrom collections import Counter, defaultdict, deque\n# from itertools import permutations\n\n\ndef modinv(n, p):\n    return pow(n, p - 2, p)\n\ndef ncr(n, r, fact, ifact):    # for using this uncomment the lines calculating fact and ifact\n    t = (fact[n] * (ifact[r] * ifact[n-r]) % mod) % mod\n    return t\n\ndef get_ints(): return map(int, sys.stdin.readline().strip().split())\ndef get_array(): return list(map(int, sys.stdin.readline().strip().split()))\ndef input(): return sys.stdin.readline().strip()\n\n\"\"\"*****************************************************************************************\"\"\"\n\ndef GCD(x, y):\n    while y:\n        x, y = y, x % y\n    return x\n\ndef lcm(x, y):\n    return (x * y)//(GCD(x, y))\n\ndef get_xor(n):\n    return [n, 1, n+1, 0][n % 4]\n\ndef get_n(P):    # this function returns the maximum n for which Summation(n) <= Sum\n    ans = (-1 + sqrt(1 + 8*P))//2\n    return ans\n\n\"\"\" ********************************************************************************************* \"\"\"\n\ndef main():\n\n    T = int(input())\n    while T:\n        x, y = get_ints()\n        if x == y:\n            print(2*x)\n        else:\n            ans = min(x, y)*2 + (max(x, y) - min(x, y))*2 - 1\n            print(ans)\n        T -= 1\n\n\"\"\" -------- Python 2 and 3 footer by Pajenegod and c1729 ---------\"\"\"\n\npy2 = round(0.5)\nif py2:\n    from future_builtins import ascii, filter, hex, map, oct, zip\n    range = xrange\n\nimport os, sys\nfrom io import IOBase, BytesIO\n\nBUFSIZE = 8192\n\nclass FastIO(BytesIO):\n    newlines = 0\n\n    def __init__(self, file):\n        self._file = file\n        self._fd = file.fileno()\n        self.writable = \"x\" in file.mode or \"w\" in file.mode\n        self.write = super(FastIO, self).write if self.writable else None\n\n    def _fill(self):\n        s = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n        self.seek((self.tell(), self.seek(0, 2), super(FastIO, self).write(s))[0])\n        return s\n\n    def read(self):\n        while self._fill(): pass\n        return super(FastIO, self).read()\n\n    def readline(self):\n        while self.newlines == 0:\n            s = self._fill();\n            self.newlines = s.count(b\"\\n\") + (not s)\n        self.newlines -= 1\n        return super(FastIO, self).readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.getvalue())\n            self.truncate(0), self.seek(0)\n\n\nclass IOWrapper(IOBase):\n\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        if py2:\n            self.write = self.buffer.write\n            self.read = self.buffer.read\n            self.readline = self.buffer.readline\n        else:\n            self.write = lambda s: self.buffer.write(s.encode('ascii'))\n            self.read = lambda: self.buffer.read().decode('ascii')\n            self.readline = lambda: self.buffer.readline().decode('ascii')\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip('\\r\\n')\n\n# sys.stdin = open('input.txt', 'r')\n# sys.stdout = open('output.txt', 'w')\n\nif __name__ == '__main__':\n    main()\n    # threading.Thread(target=main).start()",
    "prob_desc_created_at": "1605796500",
    "tags": [
        "math"
    ],
    "hidden_unit_tests": ""
}
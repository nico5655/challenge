{
    "prob_desc_time_limit": "6.5 seconds",
    "prob_desc_sample_outputs": "[\"0\\n0\\n1\\n2\\n5\\n1\\n5\"]",
    "src_uid": "a4f03259518029b38d71ed4c41209677",
    "prob_desc_notes": null,
    "prob_desc_description": "A triple of points $$$i$$$, $$$j$$$ and $$$k$$$ on a coordinate line is called beautiful if $$$i &lt; j &lt; k$$$ and $$$k - i \\le d$$$.You are given a set of points on a coordinate line, initially empty. You have to process queries of three types:  add a point;  remove a point;  calculate the number of beautiful triples consisting of points belonging to the set. ",
    "prob_desc_output_spec": "For each query, print one integer — the number of beautiful triples after processing the respective query.",
    "prob_desc_input_spec": "The first line contains two integers $$$q$$$ and $$$d$$$ ($$$1 \\le q, d \\le 2 \\cdot 10^5$$$) — the number of queries and the parameter for defining if a triple is beautiful, respectively. The second line contains $$$q$$$ integers $$$a_1, a_2, \\dots, a_q$$$ ($$$1 \\le a_i \\le 2 \\cdot 10^5$$$) denoting the queries. The integer $$$a_i$$$ denotes the $$$i$$$-th query in the following way:   if the point $$$a_i$$$ belongs to the set, remove it; otherwise, add it;  after adding or removing the point, print the number of beautiful triples. ",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3-64",
    "lang_cluster": "Python",
    "difficulty": 2500,
    "file_name": "train_098.jsonl",
    "code_uid": "4cee4a89a61a89075d2bcf77539ddcc8",
    "prob_desc_memory_limit": "512 megabytes",
    "prob_desc_sample_inputs": "[\"7 5\\n8 5 3 2 1 5 6\"]",
    "exec_outcome": "PASSED",
    "source_code": "\n\n\n\n\n###############################\nclass lazy_segtree():\n    def update(self,k):self.d[k]=self.op(self.d[2*k],self.d[2*k+1])\n    def all_apply(self,k,f):\n        self.d[k]=self.mapping(f,self.d[k])\n        if (k<self.size):self.lz[k]=self.composition(f,self.lz[k])\n    def push(self,k):\n        self.all_apply(2*k,self.lz[k])\n        self.all_apply(2*k+1,self.lz[k])\n        self.lz[k]=self.identity\n    def __init__(self,V,OP,E,MAPPING,COMPOSITION,ID):\n        self.n=len(V)\n        self.log=(self.n-1).bit_length()\n        self.size=1<<self.log\n        self.d=[E for i in range(2*self.size)]\n        self.lz=[ID for i in range(self.size)]\n        self.e=E\n        self.op=OP\n        self.mapping=MAPPING\n        self.composition=COMPOSITION\n        self.identity=ID\n        for i in range(self.n):self.d[self.size+i]=V[i]\n        for i in range(self.size-1,0,-1):self.update(i)\n    def set(self,p,x):\n        assert 0<=p and p<self.n\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        self.d[p]=x\n        for i in range(1,self.log+1):self.update(p>>i)\n    def get(self,p):\n        assert 0<=p and p<self.n\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        return self.d[p]\n    def prod(self,l,r):\n        assert 0<=l and l<=r and r<=self.n\n        if l==r:return self.e\n        l+=self.size\n        r+=self.size\n        for i in range(self.log,0,-1):\n            if (((l>>i)<<i)!=l):self.push(l>>i)\n            if (((r>>i)<<i)!=r):self.push(r>>i)\n        sml,smr=self.e,self.e\n        while(l<r):\n            if l&1:\n                sml=self.op(sml,self.d[l])\n                l+=1\n            if r&1:\n                r-=1\n                smr=self.op(self.d[r],smr)\n            l>>=1\n            r>>=1\n        return self.op(sml,smr)\n    def all_prod(self):return self.d[1]\n    def apply_point(self,p,f):\n        assert 0<=p and p<self.n\n        p+=self.size\n        for i in range(self.log,0,-1):self.push(p>>i)\n        self.d[p]=self.mapping(f,self.d[p])\n        for i in range(1,self.log+1):self.update(p>>i)\n    def apply(self,l,r,f):\n        assert 0<=l and l<=r and r<=self.n\n        if l==r:return\n        l+=self.size\n        r+=self.size\n        for i in range(self.log,0,-1):\n            if (((l>>i)<<i)!=l):self.push(l>>i)\n            if (((r>>i)<<i)!=r):self.push((r-1)>>i)\n        l2,r2=l,r\n        while(l<r):\n            if (l&1):\n                self.all_apply(l,f)\n                l+=1\n            if (r&1):\n                r-=1\n                self.all_apply(r,f)\n            l>>=1\n            r>>=1\n        l,r=l2,r2\n        for i in range(1,self.log+1):\n            if (((l>>i)<<i)!=l):self.update(l>>i)\n            if (((r>>i)<<i)!=r):self.update((r-1)>>i)\n    def max_right(self,l,g):\n        assert 0<=l and l<=self.n\n        assert g(self.e)\n        if l==self.n:return self.n\n        l+=self.size\n        for i in range(self.log,0,-1):self.push(l>>i)\n        sm=self.e\n        while(1):\n            while(i%2==0):l>>=1\n            if not(g(self.op(sm,self.d[l]))):\n                while(l<self.size):\n                    self.push(l)\n                    l=(2*l)\n                    if (g(self.op(sm,self.d[l]))):\n                        sm=self.op(sm,self.d[l])\n                        l+=1\n                return l-self.size\n            sm=self.op(sm,self.d[l])\n            l+=1\n            if (l&-l)==l:break\n        return self.n\n    def min_left(self,r,g):\n        assert (0<=r and r<=self.n)\n        assert g(self.e)\n        if r==0:return 0\n        r+=self.size\n        for i in range(self.log,0,-1):self.push((r-1)>>i)\n        sm=self.e\n        while(1):\n            r-=1\n            while(r>1 and (r%2)):r>>=1\n            if not(g(self.op(self.d[r],sm))):\n                while(r<self.size):\n                    self.push(r)\n                    r=(2*r+1)\n                    if g(self.op(self.d[r],sm)):\n                        sm=self.op(self.d[r],sm)\n                        r-=1\n                return r+1-self.size\n            sm=self.op(self.d[r],sm)\n            if (r&-r)==r:break\n        return 0\n\n###########################\n\nM=2*10**5+10\ndef to(x):\n    num2,num,cnt1=x\n    return [num2,num*M+cnt1]\ndef inv(x):\n    num2=x[0]\n    y=x[1]\n    cnt1=y%M\n    num=y//M\n    return [num2,num,cnt1]\n\n\ndef op(a,b):\n    a=inv(a)\n    b=inv(b)\n    res=[0,0,0]\n    res[0]=a[0]+b[0]\n    res[1]=a[1]+b[1]\n    res[2]=a[2]+b[2]\n    return to(res)\n\ndef mapping(f,x):\n    x=inv(x)\n    num2,num,cnt1=x\n    res2,res,rescnt1=0,0,0\n    res2=num2+2*f*num+f**2*cnt1\n    res=num+f*cnt1\n    rescnt1=cnt1\n    return to([res2,res,rescnt1])\ndef compose(f,g):\n    return f+g\n\n\n\n\n\n\n####################################\nclass BIT:\n    #https://atcoder.jp/contests/abc233/submissions/28159326\n    def __init__(self,arg):\n\n        if isinstance(arg,int):\n            self.N=arg\n            self.dat=[0]*(self.N+1)\n        else:\n            self.N=len(arg)\n            self.dat=[0]+list(arg)\n            for i in range(self.N.bit_length()-1):\n                for j in range(self.N>>(i+1)):\n                    idx=(j<<1|1)<<i\n\n                    nidx=idx+(idx&-idx)\n                    if nidx<self.N+1:\n                        self.dat[nidx]+=self.dat[idx]\n\n\n    def add(self,idx,x):\n        idx+=1\n        while idx<self.N+1:\n            self.dat[idx]+=x\n\n            idx+=idx&-idx\n\n    def sum(self,idx):\n        if idx<0:return 0\n        idx+=1\n        sum_=0\n        while idx>0:\n            sum_+=self.dat[idx]\n\n            idx-=idx&-idx\n        return sum_\n\n    def query(self,l,r):\n        if l>=r:return 0\n        return self.sum(r-1)-self.sum(l-1)\n\n    def get(self,k):\n        return self.query(k,k+1)\n\n    def update(self,k,x):\n        self.add(k,-self.get(k))\n        self.add(k,x)\n\n    def lower_bound(self,x):\n        sum_=0\n        idx=1<<(self.N.bit_length()-1)\n        while True:\n            if idx<self.N+1 and sum_+self.dat[idx]<x:\n                sum_+=self.dat[idx]\n                if idx&-idx==1:\n                    break\n                idx+=(idx&-idx)>>1\n            else:\n                if idx&-idx==1:\n                    idx-=1\n                    break\n                idx-=(idx&-idx)>>1\n        return idx,sum_\n\n###################################\n\n\n\n\nq,d=map(int,input().split())\nx=[0]*(4*10**5+10)\nwa=BIT(4*10**5+10)\nseg=lazy_segtree([to([0,0,0]) for i in range(2*10**5+10)],op,to([0,0,0]),mapping,compose,0)\n\n\na=list(map(int,input().split()))\nfor i in a:\n    if x[i]==1:\n        x[i]=0\n        wa.add(i,-1)\n        seg.set(i,to([0,0,0]))\n        left=max(0,i-d)\n        right=i\n        seg.apply(left,right,-1)\n    else:\n        x[i]=1\n        wa.add(i,1)\n        num=wa.query(i+1,i+d+1)\n        seg.set(i,to([num**2,num,1]))\n        left = max(0, i - d)\n        right = i\n        seg.apply(left, right, 1)\n    ans=inv(seg.prod(1,2*10**5+1))\n    num2,num,_=ans\n    print((num2-num)//2)\n\n\n\n\n\n\n\n\n",
    "prob_desc_created_at": "1657290900",
    "tags": [
        "combinatorics",
        "data structures",
        "implementation",
        "math",
        "matrices"
    ],
    "hidden_unit_tests": ""
}
{
    "prob_desc_time_limit": "3 seconds",
    "prob_desc_sample_outputs": "[\"12\"]",
    "src_uid": "7d14a2b5908e520f696d74317454c22c",
    "prob_desc_notes": "NoteOne way to minimize the cost is to build $$$4$$$ dummy bases, for a total cost of $$$4 \\times 3 = 12$$$.One empire spaceship will be assigned to attack each of these dummy bases, resulting in zero actual bases attacked.",
    "prob_desc_description": "Thanks to the Doctor's help, the rebels managed to steal enough gold to launch a full-scale attack on the Empire! However, Darth Vader is looking for revenge and wants to take back his gold.The rebels have hidden the gold in various bases throughout the galaxy. Darth Vader and the Empire are looking to send out their spaceships to attack these bases.The galaxy can be represented as an undirected graph with $$$n$$$ planets (nodes) and $$$m$$$ wormholes (edges), each connecting two planets.A total of $$$s$$$ empire spaceships and $$$b$$$ rebel bases are located at different planets in the galaxy.Each spaceship is given a location $$$x$$$, denoting the index of the planet on which it is located, an attacking strength $$$a$$$, and a certain amount of fuel $$$f$$$.Each base is given a location $$$x$$$, and a defensive strength $$$d$$$.A spaceship can attack a base if both of these conditions hold:   the spaceship's attacking strength is greater or equal than the defensive strength of the base  the spaceship's fuel is greater or equal to the shortest distance, computed as the number of wormholes, between the spaceship's planet and the base's planet Vader is very particular about his attacking formations. He requires that each spaceship is to attack at most one base and that each base is to be attacked by at most one spaceship.Vader knows that the rebels have hidden $$$k$$$ gold in each base, so he will assign the spaceships to attack bases in such a way that maximizes the number of bases attacked.Therefore, for each base that is attacked, the rebels lose $$$k$$$ gold.However, the rebels have the ability to create any number of dummy bases. With the Doctor's help, these bases would exist beyond space and time, so all spaceship can reach them and attack them. Moreover, a dummy base is designed to seem irresistible: that is, it will always be attacked by some spaceship.Of course, dummy bases do not contain any gold, but creating such a dummy base costs $$$h$$$ gold.What is the minimum gold the rebels can lose if they create an optimal number of dummy bases?",
    "prob_desc_output_spec": "Print a single integer, the minimum cost in terms of gold.",
    "prob_desc_input_spec": "The first line contains two integers $$$n$$$ and $$$m$$$ ($$$1 \\leq n \\leq 100$$$, $$$0 \\leq m \\leq 10000$$$), the number of nodes and the number of edges, respectively. The next $$$m$$$ lines contain two integers $$$u$$$ and $$$v$$$ ($$$1 \\leq u$$$, $$$v \\leq n$$$) denoting an undirected edge between the two nodes. The next line contains four integers $$$s$$$, $$$b$$$, $$$k$$$ and $$$h$$$ ($$$1 \\leq s$$$, $$$b \\leq 1000$$$, $$$0 \\leq k$$$, $$$h \\leq 10^9$$$), the number of spaceships, the number of bases, the cost of having a base attacked, and the cost of creating a dummy base, respectively. The next $$$s$$$ lines contain three integers $$$x$$$, $$$a$$$, $$$f$$$ ($$$1 \\leq x \\leq n$$$, $$$0 \\leq a$$$, $$$f \\leq 10^9$$$), denoting the location, attack, and fuel of the spaceship. The next $$$b$$$ lines contain two integers $$$x$$$, $$$d$$$ ($$$1 \\leq x \\leq n$$$, $$$0 \\leq d \\leq 10^9$$$), denoting the location and defence of the base.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 2",
    "lang_cluster": "Python",
    "difficulty": 2200,
    "file_name": "train_017.jsonl",
    "code_uid": "7734bf24c704ae51d05779cda00dfd50",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"6 7\\n1 2\\n2 3\\n3 4\\n4 6\\n6 5\\n4 4\\n3 6\\n4 2 7 3\\n1 10 2\\n3 8 2\\n5 1 0\\n6 5 4\\n3 7\\n5 2\"]",
    "exec_outcome": "PASSED",
    "source_code": "def main():\n    inp = readnumbers()\n    ii = 0\n    n = inp[ii]\n    ii += 1\n    m = inp[ii]\n    ii += 1\n    coupl = [[] for _ in range(n)]\n    for _ in range(m):\n        u = inp[ii] - 1\n        ii += 1\n        v = inp[ii] - 1\n        ii += 1\n        coupl[u].append(v)\n        coupl[v].append(u)\n    s = inp[ii]\n    ii += 1\n    b = inp[ii]\n    ii += 1\n    k = inp[ii]\n    ii += 1\n    h = inp[ii]\n    ii += 1\n    ii += 3*s\n    bases = [[] for _ in range(n)]\n    D = []\n    for ind in range(b):\n        x = inp[ii] - 1\n        ii += 1\n        d  = inp[ii]\n        ii += 1\n        D.append(d)\n        bases[x].append(ind)\n    ii -= 2 * b + 3 * s\n    spaces = [[] for _ in range(s)]\n    for ind in range(s):\n        x = inp[ii] - 1\n        ii += 1\n        a = inp[ii]\n        ii += 1\n        f = inp[ii]\n        ii += 1\n        dist = [-1]*n\n        dist[x] = 0\n        bfs = [x]\n        for node in bfs:\n            for bind in bases[node]:\n                if D[bind] <= a:\n                    spaces[ind].append(bind)\n            d = dist[node]\n            if d < f:\n                for nei in coupl[node]:\n                    if dist[nei] == -1:\n                        bfs.append(nei)\n                        dist[nei] = d + 1\n    source = s + b\n    sink = s + b + 1\n    U = []\n    V = []\n    C = []\n    coupl = [[] for _ in range(s+b+2)]\n    for ind in range(s):\n        for bases in spaces[ind]:\n            coupl[ind].append(len(U))\n            U.append(ind)\n            V.append(s + bases)\n            C.append(1)\n        coupl[source].append(len(U))\n        U.append(source)\n        V.append(ind)           \n        C.append(1)\n    for bases in range(b):\n        coupl[bases + s].append(len(U))\n        U.append(bases + s)\n        V.append(sink)           \n        C.append(1)\n    maxflow, flows = dinics_maxflow(coupl, U, V, C, source, sink, lim = 1, directed = True)\n    bestcost = 10**18\n    matched = maxflow\n    unused = s - matched\n    fake = 0\n    while fake <= s:\n        bestcost = min(bestcost, k * matched + h * fake)\n        if unused:\n            unused -= 1\n        elif matched:\n            matched -= 1\n        fake += 1\n    print bestcost\ndef dinics_maxflow(_coupl, _U, _V, _C, s, t, lim = 1, directed = False):\n    assert(len(_U) == len(_V) == len(_C))\n    n = len(_coupl)\n    m = len(_U)\n    total_flow = 0\n    coupl = [[2*i for i in c] for c in _coupl]\n    V = []\n    for i in range(m):\n        V.append(_V[i])\n        V.append(_U[i])\n    C = []\n    if directed:\n        for i in range(m):\n            C.append(_C[i])\n            C.append(0)\n    else:\n        for i in range(m):\n            C.append(_C[i])\n            C.append(_C[i])\n    for i in range(m):\n        coupl[V[2*i]].append(2*i^1) \n    inf = sum(C[e] for e in coupl[s] if V[e^1]==s)\n    ptr_copy = [len(coupl[i]) - 1 for i in range(n)]\n    while True:\n        # Calculate distance from source using all edges with cap >= lim\n        dist_to_source = [0]*n\n        dist_to_source[s] = 1\n        bfs = [s]\n        for node in bfs:\n            if dist_to_source[t]:\n                break\n            my_dist_plus_1 = dist_to_source[node] + 1\n            for e in coupl[node]:\n                if not dist_to_source[V[e]] and C[e] >= lim:\n                    dist_to_source[V[e]] = my_dist_plus_1\n                    bfs.append(V[e])\n        if not dist_to_source[t]:\n            lim //= 2\n            if lim == 0:\n                break\n            continue\n        ptr = ptr_copy[:]\n        stack = [0]*(2*n+1)\n        stack[0] = s\n        stack[1] = inf\n        stack[2] = s\n        ii = 1\n        while ptr[s] >= 0:\n            cap = stack[ii]\n            node = stack[ii + 1]\n            if node == t:\n                total_flow += cap\n                for node in stack[2:ii:2]:\n                    e = coupl[node][ptr[node]]\n                    C[e] -= cap\n                    C[e^1] += cap\n                ii = 1\n                continue\n            edges = coupl[node]\n            count = ptr[node]\n            mydist_plus_1 = dist_to_source[node] + 1\n            while count >= 0:\n                e = edges[count]\n                if dist_to_source[V[e]] == mydist_plus_1 and C[e] > 0:\n                    ii += 2\n                    stack[ii] = C[e] if C[e] < cap else cap\n                    stack[ii+1] = V[e]\n                    break\n                count -= 1\n            else:\n                ii -= 2\n                ptr[stack[ii + 1]] -= 1\n            ptr[node] = count\n    if directed:\n        flows = C[1::2]\n    else:\n        flows = []\n        for i in range(m):\n            flows.append((C[2*i^1] - C[2*i])//2)\n    maxflow = total_flow\n    return maxflow, flows\npy2 = round(0.5)\nif py2:\n    from future_builtins import ascii, filter, hex, map, oct, zip\n    range = xrange\nimport os, sys\nfrom io import*\nBUFSIZE = 8192\nclass FastIO(BytesIO):\n    newlines = 0\n    def __init__(self, file):\n        self._file = file\n        self._fd = file.fileno()\n        self.writable = \"x\" in file.mode or \"w\" in file.mode\n        self.write = super(FastIO, self).write if self.writable else None\n    def _fill(self):\n        s = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n        self.seek((self.tell(), self.seek(0,2), super(FastIO, self).write(s))[0])\n        return s\n    def read(self):\n        while self._fill(): pass\n        return super(FastIO,self).read()\n    def readline(self):\n        while self.newlines == 0:\n            s = self._fill(); self.newlines = s.count(b\"\\n\") + (not s)\n        self.newlines -= 1\n        return super(FastIO, self).readline()\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.getvalue())\n            self.truncate(0), self.seek(0)\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        if py2:\n            self.write = self.buffer.write\n            self.read = self.buffer.read\n            self.readline = self.buffer.readline\n        else:\n            self.write = lambda s:self.buffer.write(s.encode('ascii'))\n            self.read = lambda:self.buffer.read().decode('ascii')\n            self.readline = lambda:self.buffer.readline().decode('ascii')\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip('\\r\\n')\nimport sys\nclass ostream:\n    def __lshift__(self,a):\n        sys.stdout.write(str(a))\n        return self\ncout = ostream()\nendl = '\\n'\ndef readnumbers(zero = 0):\n    conv = ord if py2 else lambda x:x\n    A = []; numb = zero; sign = 1; i = 0; s = sys.stdin.buffer.read()\n    try:\n        while True:\n            if s[i] >= b'0' [0]:\n                numb = 10 * numb + conv(s[i]) - 48\n            elif s[i] == b'-' [0]: sign = -1\n            elif s[i] != b'\\r' [0]:\n                A.append(sign*numb)\n                numb = zero; sign = 1\n            i += 1\n    except:pass\n    if s and s[-1] >= b'0' [0]:\n        A.append(sign*numb)\n    return A\nif __name__== \"__main__\":\n  main()",
    "prob_desc_created_at": "1562483100",
    "tags": [
        "graphs",
        "flows",
        "shortest paths",
        "graph matchings",
        "sortings"
    ],
    "hidden_unit_tests": ""
}
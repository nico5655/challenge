{
    "prob_desc_time_limit": "1 second",
    "prob_desc_sample_outputs": "[\"10\\n7\\n1\"]",
    "src_uid": "12c975105a014fb3d9d1ad4794fdb2e8",
    "prob_desc_notes": "NoteFor the first test case, there are $$$10$$$ possible good photos satisfying the condition: PPPPP, CPPPP, PCPPP, CCPPP, PCCPP, PCPCP, PPPPC, CPPPC, PCPPC, PPPCC.For the second test case, there are $$$7$$$ possible good photos satisfying the condition: PPPP, PCPP, PCCP, PPPC, PCPC, PPCC, PCCC.",
    "prob_desc_description": "In the 2050 Conference, some people from the competitive programming community meet together and are going to take a photo. The $$$n$$$ people form a line. They are numbered from $$$1$$$ to $$$n$$$ from left to right. Each of them either holds a cardboard with the letter 'C' or a cardboard with the letter 'P'.Let $$$C=\\{c_1,c_2,\\dots,c_m\\}$$$ $$$(c_1&lt;c_2&lt;\\ldots &lt;c_m)$$$ be the set of people who hold cardboards of 'C'. Let $$$P=\\{p_1,p_2,\\dots,p_k\\}$$$ $$$(p_1&lt;p_2&lt;\\ldots &lt;p_k)$$$ be the set of people who hold cardboards of 'P'. The photo is good if and only if it satisfies the following constraints:   $$$C\\cup P=\\{1,2,\\dots,n\\}$$$  $$$C\\cap P =\\emptyset $$$.  $$$c_i-c_{i-1}\\leq c_{i+1}-c_i(1&lt; i &lt;m)$$$.  $$$p_i-p_{i-1}\\geq p_{i+1}-p_i(1&lt; i &lt;k)$$$. Given an array $$$a_1,\\ldots, a_n$$$, please find the number of good photos satisfying the following condition: $$$$$$\\sum\\limits_{x\\in C} a_x &lt; \\sum\\limits_{y\\in P} a_y.$$$$$$The answer can be large, so output it modulo $$$998\\,244\\,353$$$. Two photos are different if and only if there exists at least one person who holds a cardboard of 'C' in one photo but holds a cardboard of 'P' in the other.",
    "prob_desc_output_spec": "For each test case, output the answer modulo $$$998\\,244\\,353$$$ in a separate line.",
    "prob_desc_input_spec": "Each test contains multiple test cases. The first line contains the number of test cases $$$t$$$ ($$$1 \\le t \\le 200\\,000$$$). Description of the test cases follows. The first line of each test case contains a single integer $$$n$$$ ($$$1\\leq n\\leq 200\\,000$$$). The second line contains $$$n$$$ integers $$$a_1, a_2, \\ldots, a_n$$$ ($$$1 \\le a_i \\le 10^9$$$). It is guaranteed that the sum of $$$n$$$ over all test cases does not exceed $$$200\\,000$$$.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3",
    "lang_cluster": "Python",
    "difficulty": 2500,
    "file_name": "train_101.jsonl",
    "code_uid": "6e38bac718d0749f886ed605b2e79847",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"3\\n5\\n2 1 2 1 1\\n4\\n9 2 2 2\\n1\\n998244353\"]",
    "exec_outcome": "PASSED",
    "source_code": "import sys\r\nimport io, os\r\ninput = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline\r\n\r\nmod=998244353\r\n\r\ndef ans(A):\r\n    LEN=len(A)\r\n    ANS=0\r\n    \r\n    for i in range(1<<LEN):\r\n        X=[0]*LEN\r\n        for j in range(LEN):\r\n            if i & (1<<j) != 0:\r\n                X[j]=1\r\n\r\n        C=[]\r\n        P=[]\r\n        SC=0\r\n        SP=0\r\n        for i in range(LEN):\r\n            if X[i]==1:\r\n                C.append(i)\r\n                SC+=A[i]\r\n            else:\r\n                P.append(i)\r\n                SP+=A[i]\r\n\r\n        if SC>=SP:\r\n            continue\r\n\r\n        flag=1\r\n        for i in range(2,len(C)):\r\n            if C[i-1]-C[i-2]>C[i]-C[i-1]:\r\n                flag=0\r\n                break\r\n\r\n        for i in range(2,len(P)):\r\n            if P[i-1]-P[i-2]<P[i]-P[i-1]:\r\n                flag=0\r\n                break\r\n\r\n        if flag==0:\r\n            continue\r\n        else:\r\n            ANS+=1\r\n    return ANS%mod\r\n        \r\n            \r\nt=int(input())\r\nfor tests in range(t):\r\n    n=int(input())\r\n    A=list(map(int,input().split()))\r\n\r\n    S=[0]*(n+1)\r\n    S2=[0]*(n+1)\r\n    for i in range(n):\r\n        S[i+1]=A[i]+S[i]\r\n        S2[i+1]=A[i]+S2[i-1]\r\n        \r\n    MAX=(S[-1]-1)//2\r\n\r\n    #print(S)\r\n\r\n    if n<=5:\r\n        print(ans(A))\r\n        continue\r\n\r\n    ANS=1 # all :P\r\n    \r\n    # right-most\r\n    SUMR=A[-1]\r\n\r\n    ind=n-2\r\n\r\n    while SUMR<=MAX:\r\n        ANS+=1\r\n        SUMR+=A[ind]\r\n        ind-=1\r\n\r\n    #print(ANS)\r\n\r\n    # left-most, even, not use last\r\n    indl=0\r\n    if (n-1)%2==0:\r\n        indr=n-3\r\n    else:\r\n        indr=n-2\r\n\r\n    while indl<=indr:\r\n        while indl<=indr and S2[indr+1]+S[indl+1]-S2[indl+1]>MAX:\r\n            indr-=2\r\n        #print(indl,indr)\r\n        if indl<=indr:\r\n            ANS+=(indr-indl)//2+1\r\n        indl+=2\r\n\r\n    #print(ANS)\r\n\r\n    # left-most, odd, not use last\r\n    indl=1\r\n    if (n-1)%2==0:\r\n        indr=n-2\r\n    else:\r\n        indr=n-3\r\n\r\n    while indl<=indr:\r\n        while indl<=indr and S2[indr+1]+S[indl+1]-S2[indl+1]>MAX:\r\n            indr-=2\r\n        #print(indl,indr)\r\n        if indl<=indr:\r\n            ANS+=(indr-indl)//2+1\r\n        indl+=2\r\n\r\n    #print(ANS)\r\n\r\n    # left-most, even, use last\r\n    indl=0\r\n    if (n-1)%2==0:\r\n        indr=n-3\r\n    else:\r\n        indr=n-4\r\n\r\n    while indl<=indr:\r\n        while indl<=indr and S2[indr+1]+S[indl+1]-S2[indl+1]+A[-1]>MAX:\r\n            indr-=2\r\n        #print(indl,indr)\r\n        if indl<=indr:\r\n            ANS+=(indr-indl)//2+1\r\n        indl+=2\r\n    #print(ANS)\r\n\r\n    # left-most, odd, use last\r\n    indl=1\r\n    if (n-1)%2==0:\r\n        indr=n-4\r\n    else:\r\n        indr=n-3\r\n\r\n    while indl<=indr:\r\n        while indl<=indr and S2[indr+1]+S[indl+1]-S2[indl+1]+A[-1]>MAX:\r\n            indr-=2\r\n        #print(\"!\",indl,indr)\r\n        if indl<=indr:\r\n            ANS+=(indr-indl)//2+1\r\n        indl+=2\r\n\r\n    #print(ANS)\r\n\r\n    # PCCCCC, left-most, even, not use last\r\n    indl=2\r\n    if (n-1)%2==0:\r\n        indr=n-3\r\n    else:\r\n        indr=n-2\r\n\r\n    while indl<=indr:\r\n        while indl<=indr and S2[indr+1]+S[indl+1]-S2[indl+1]-A[0]>MAX:\r\n            indr-=2\r\n        #print(indl,indr)\r\n        if indl<=indr:\r\n            ANS+=(indr-indl)//2+1\r\n        indl+=2\r\n\r\n    #print(ANS)\r\n\r\n    # PCCCCC, left-most, odd, not use last\r\n    indl=1\r\n    if (n-1)%2==0:\r\n        indr=n-2\r\n    else:\r\n        indr=n-3\r\n\r\n    while indl<=indr:\r\n        while indl<=indr and S2[indr+1]+S[indl+1]-S2[indl+1]-A[0]>MAX:\r\n            indr-=2\r\n        #print(indl,indr)\r\n        if indl<=indr:\r\n            ANS+=(indr-indl)//2+1\r\n        indl+=2\r\n\r\n    #print(ANS)\r\n\r\n    # PCCCCC, left-most, even, use last\r\n    SUML=A[0]\r\n    indl=2\r\n    if (n-1)%2==0:\r\n        indr=n-3\r\n    else:\r\n        indr=n-4\r\n\r\n    while indl<=indr:\r\n        while indl<=indr and S2[indr+1]+S[indl+1]-S2[indl+1]+A[-1]-A[0]>MAX:\r\n            indr-=2\r\n\r\n        #print(indl,indr)\r\n        if indl<=indr:\r\n            ANS+=(indr-indl)//2+1\r\n        indl+=2\r\n    #print(ANS)\r\n\r\n    # PCCCCC, left-most, odd, use last\r\n    SUML=A[0]\r\n    indl=1\r\n    if (n-1)%2==0:\r\n        indr=n-4\r\n    else:\r\n        indr=n-3\r\n\r\n    while indl<=indr:\r\n        while indl<=indr and S2[indr+1]+S[indl+1]-S2[indl+1]+A[-1]-A[0]>MAX:\r\n            indr-=2\r\n        #print(indl,indr)\r\n        if indl<=indr:\r\n            ANS+=(indr-indl)//2+1\r\n        indl+=2\r\n\r\n    print(ANS%mod)\r\n\r\n    \r\n\r\n    \r\n\r\n    \r\n",
    "prob_desc_created_at": "1619188500",
    "tags": [
        "binary search",
        "data structures",
        "implementation",
        "two pointers"
    ],
    "hidden_unit_tests": ""
}
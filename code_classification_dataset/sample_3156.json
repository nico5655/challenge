{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"2\\n2\\n0\\n0\\n1\\n1\\n1\\n1\\n16\"]",
    "src_uid": "039e21a58c02b52b13d325ff9982a249",
    "prob_desc_notes": "NoteIn the first test case, you first need to move two 2, to the beginning of the array. Therefore, the desired sequence of operations: $$$[4, 7, 2, 2, 9] \\rightarrow [2, 4, 7, 2, 9] \\rightarrow [2, 2, 4, 7, 9]$$$.In the second test case, you need to move the 1 to the beginning of the array, and the 8 — to the end. Therefore, the desired sequence of operations: $$$[3, 5, 8, 1, 7] \\rightarrow [1, 3, 5, 8, 7] \\rightarrow [1, 3, 5, 7, 8]$$$.In the third test case, the array is already sorted.",
    "prob_desc_description": "This is a hard version of the problem. In this version, the given array can contain equal elements and the constraints on $$$n$$$ are greater than in the easy version of the problem.You are given an array $$$a$$$ of $$$n$$$ integers (the given array can contain equal elements). You can perform the following operations on array elements:  choose any index $$$i$$$ ($$$1 \\le i \\le n$$$) and move the element $$$a[i]$$$ to the begin of the array;  choose any index $$$i$$$ ($$$1 \\le i \\le n$$$) and move the element $$$a[i]$$$ to the end of the array. For example, if $$$n = 5$$$, $$$a = [4, 7, 2, 2, 9]$$$, then the following sequence of operations can be performed:   after performing the operation of the first type to the second element, the array $$$a$$$ will become $$$[7, 4, 2, 2, 9]$$$;  after performing the operation of the second type to the second element, the array $$$a$$$ will become $$$[7, 2, 2, 9, 4]$$$. You can perform operations of any type any number of times in any order.Find the minimum total number of operations of the first and second type that will make the $$$a$$$ array sorted in non-decreasing order. In other words, what is the minimum number of operations must be performed so the array satisfies the inequalities $$$a[1] \\le a[2] \\le \\ldots \\le a[n]$$$.",
    "prob_desc_output_spec": "For each test case output one integer — the minimum total number of operations of the first and second type, which will make the array sorted in non-decreasing order.",
    "prob_desc_input_spec": "The first line contains a single integer $$$t$$$ ($$$1 \\le t \\le 10^4$$$) — the number of test cases in the test. Then $$$t$$$ test cases follow. Each test case starts with a line containing an integer $$$n$$$ ($$$1 \\le n \\le 2 \\cdot 10^5$$$) — the size of the array $$$a$$$. Then follow $$$n$$$ integers $$$a_1, a_2, \\ldots, a_n$$$ ($$$0 \\le a_i \\le 10^9$$$) — an array that needs to be sorted by the given operations. The given array can contain equal elements. The sum of $$$n$$$ for all test cases in one test does not exceed $$$2 \\cdot 10^5$$$.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 2",
    "lang_cluster": "Python",
    "difficulty": 2400,
    "file_name": "train_044.jsonl",
    "code_uid": "2f247c108f799df02da915d89a1b272c",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"9\\n5\\n4 7 2 2 9\\n5\\n3 5 8 1 7\\n5\\n1 2 2 4 5\\n2\\n0 1\\n3\\n0 1 0\\n4\\n0 1 0 0\\n4\\n0 1 0 1\\n4\\n0 1 0 2\\n20\\n16 15 1 10 0 14 0 10 3 9 2 5 4 5 17 9 10 20 0 9\"]",
    "exec_outcome": "PASSED",
    "source_code": "import sys\nrange = xrange\ninput = sys.stdin.readline\n\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    A = [int(x) for x in input().split()]\n\n    mapper = {}\n    for a in sorted(A):\n        if a not in mapper:\n            mapper[a] = len(mapper)\n    \n    m = len(mapper)\n    A = [mapper[a] for a in A]\n    Asorted = sorted(A)\n\n    buckets = [[] for _ in range(m + 1)]\n    B = [0] * (m + 2)\n    for i in range(n):\n        buckets[A[i]].append(i)\n        B[A[i] + 1] += 1\n    \n    for i in range(m + 1):\n        B[i + 1] += B[i]\n    \n    jump = [-1] * m\n    for j in reversed(range(m)):\n        lasti = buckets[j][-1]\n        if j + 1 == m or buckets[j + 1][0] < lasti:\n            jump[j] = lasti\n        else:\n            jump[j] = jump[j + 1]\n\n    best = 0\n\n    prev = -1\n    prevcount = -1\n    for i in reversed(range(n)):\n        b = a = Asorted[i]\n        if a != prev:\n            prev = a\n            prevcount = 1\n        else:\n            prevcount += 1\n        \n\n        ind = buckets[a][prevcount - 1]\n        if buckets[a + 1] and buckets[a + 1][0] >= ind:\n            ind = jump[a + 1]\n            a = A[ind]\n\n        l = 0\n        r = len(buckets[a + 1])\n        while l < r:\n            mid = l + r >> 1\n            if buckets[a + 1][mid] < ind:\n                l = mid + 1\n            else:\n                r = mid\n\n        best = max(best, prevcount + B[a + 2] - l - B[b + 1])\n    print n - best\n",
    "prob_desc_created_at": "1592318100",
    "tags": [
        "dp",
        "greedy",
        "two pointers",
        "sortings",
        "data structures",
        "binary search"
    ],
    "hidden_unit_tests": ""
}
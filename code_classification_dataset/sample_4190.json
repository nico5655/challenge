{
    "prob_desc_time_limit": "3 seconds",
    "prob_desc_sample_outputs": "[\"0\\n4\\n6\"]",
    "src_uid": "a8564780ff811f280453e7d28f0fc091",
    "prob_desc_notes": "NoteBelow is given the solution to get the optimal answer for each of the example test cases (elements of $$$a$$$ are underscored).  In the first test case, $$$c = [\\underline{1}, 1, \\underline{2}, 2, \\underline{3}, 3, 4]$$$.  In the second test case, $$$c = [1, 2, \\underline{3}, \\underline{2}, \\underline{1}, 3]$$$.  In the third test case, $$$c = [\\underline{1}, 1, 3, \\underline{3}, \\underline{5}, \\underline{3}, \\underline{1}, 4, 6]$$$. ",
    "prob_desc_description": "You are given two arrays of integers $$$a_1, a_2, \\ldots, a_n$$$ and $$$b_1, b_2, \\ldots, b_m$$$.You need to insert all elements of $$$b$$$ into $$$a$$$ in an arbitrary way. As a result you will get an array $$$c_1, c_2, \\ldots, c_{n+m}$$$ of size $$$n + m$$$.Note that you are not allowed to change the order of elements in $$$a$$$, while you can insert elements of $$$b$$$ at arbitrary positions. They can be inserted at the beginning, between any elements of $$$a$$$, or at the end. Moreover, elements of $$$b$$$ can appear in the resulting array in any order.What is the minimum possible number of inversions in the resulting array $$$c$$$? Recall that an inversion is a pair of indices $$$(i, j)$$$ such that $$$i &lt; j$$$ and $$$c_i &gt; c_j$$$.",
    "prob_desc_output_spec": "For each test case, print one integer — the minimum possible number of inversions in the resulting array $$$c$$$.",
    "prob_desc_input_spec": "Each test contains multiple test cases. The first line contains the number of test cases $$$t$$$ ($$$1 \\leq t \\leq 10^4$$$). Description of the test cases follows. The first line of each test case contains two integers $$$n$$$ and $$$m$$$ ($$$1 \\leq n, m \\leq 10^6$$$). The second line of each test case contains $$$n$$$ integers $$$a_1, a_2, \\ldots, a_n$$$ ($$$1 \\leq a_i \\leq 10^9$$$). The third line of each test case contains $$$m$$$ integers $$$b_1, b_2, \\ldots, b_m$$$ ($$$1 \\leq b_i \\leq 10^9$$$). It is guaranteed that the sum of $$$n$$$ for all tests cases in one input doesn't exceed $$$10^6$$$. The sum of $$$m$$$ for all tests cases doesn't exceed $$$10^6$$$ as well.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3-64",
    "lang_cluster": "Python",
    "difficulty": 2300,
    "file_name": "train_092.jsonl",
    "code_uid": "19d30d6bce51a7365462ded6aa159990",
    "prob_desc_memory_limit": "512 megabytes",
    "prob_desc_sample_inputs": "[\"3\\n3 4\\n1 2 3\\n4 3 2 1\\n3 3\\n3 2 1\\n1 2 3\\n5 4\\n1 3 5 3 1\\n4 3 6 1\"]",
    "exec_outcome": "PASSED",
    "source_code": "# E. Optimal Insertion\r\n\r\n#!/usr/bin/env python3\r\nimport os\r\nimport sys\r\nimport getpass  # not available on codechef\r\nfrom collections import deque\r\nfrom io import BytesIO, IOBase\r\n \r\nBUFSIZE = 8192\r\n  \r\nclass FastIO(IOBase):\r\n    newlines = 0\r\n \r\n    def __init__(self, file):\r\n        self._fd = file.fileno()\r\n        self.buffer = BytesIO()\r\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\r\n        self.write = self.buffer.write if self.writable else None\r\n \r\n    def read(self):\r\n        while True:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            if not b:\r\n                break\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines = 0\r\n        return self.buffer.read()\r\n \r\n    def readline(self):\r\n        while self.newlines == 0:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            self.newlines = b.count(b\"\\n\") + (not b)\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines -= 1\r\n        return self.buffer.readline()\r\n \r\n    def flush(self):\r\n        if self.writable:\r\n            os.write(self._fd, self.buffer.getvalue())\r\n            self.buffer.truncate(0), self.buffer.seek(0)\r\n \r\n \r\nclass IOWrapper(IOBase):\r\n    def __init__(self, file):\r\n        self.buffer = FastIO(file)\r\n        self.flush = self.buffer.flush\r\n        self.writable = self.buffer.writable\r\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\r\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\r\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\r\n \r\n \r\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\r\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\r\n \r\n \r\n \r\n# available on Google, AtCoder Python3, not available on Codeforces\r\n# import numpy as np\r\n# import scipy\r\n \r\nM9 = 10**9 + 7  # 998244353\r\nyes, no = \"YES\", \"NO\"\r\n# d4 = [(1,0),(0,1),(-1,0),(0,-1)]\r\n# d8 = [(1,0),(1,1),(0,1),(-1,1),(-1,0),(-1,-1),(0,-1),(1,-1)]\r\n# d6 = [(2,0),(1,1),(-1,1),(-2,0),(-1,-1),(1,-1)]  # hexagonal layout\r\nMAXINT = sys.maxsize\r\n \r\n# if testing locally, print to terminal with a different color\r\nOFFLINE_TEST = getpass.getuser() == \"hkmac\"\r\n# OFFLINE_TEST = False  # codechef does not allow getpass\r\ndef log(*args):\r\n    if OFFLINE_TEST:\r\n        print('\\033[36m', *args, '\\033[0m', file=sys.stderr)\r\n        \r\ndef solve(*args):\r\n    # screen input\r\n    if OFFLINE_TEST:\r\n        log(\"----- solving ------\")\r\n        log(*args)\r\n        log(\"----- ------- ------\")\r\n    return solve_(*args)\r\n \r\ndef read_matrix(rows):\r\n    return [list(map(int,input().split())) for _ in range(rows)]\r\n \r\ndef read_strings(rows):\r\n    return [input().strip() for _ in range(rows)]\r\n \r\ndef minus_one(arr):\r\n    return [x-1 for x in arr]\r\n \r\ndef minus_one_matrix(mrr):\r\n    return [[x-1 for x in row] for row in mrr]\r\n \r\n# ---------------------------- template ends here ----------------------------\r\n\r\n\r\ndef solve(ans, a_s, a_e, b_s, b_e):    \r\n    if b_e < b_s:\r\n        ans[a_s+b_s:a_e+b_e+1+1] = aa[a_s:a_e+1]\r\n    else:\r\n        b_mid = (b_e+b_s)//2\r\n \r\n        pos = a_s\r\n        min_score = 0\r\n        curr_score = 0\r\n \r\n        for i in range(a_s, a_e+1):\r\n            if aa[i] > bb[b_mid]: curr_score += 1\r\n            elif aa[i] < bb[b_mid]:\r\n                curr_score -= 1\r\n                if curr_score < min_score:\r\n                    min_score = curr_score\r\n                    pos = i+1\r\n \r\n        ans[b_mid+pos] = bb[b_mid]\r\n \r\n        solve(ans, a_s, pos-1, b_s, b_mid-1)\r\n        solve(ans, pos, a_e, b_mid+1, b_e)\r\n\r\n# Python 3 program to count inversions in an array\r\n \r\n# Function to Use Inversion Count\r\ndef mergeSort(arr):\r\n    n = len(arr)\r\n    # A temp_arr is created to store\r\n    # sorted array in merge function\r\n    temp_arr = [0]*n\r\n    return _mergeSort(arr, temp_arr, 0, n-1)\r\n \r\n# This Function will use MergeSort to count inversions\r\n \r\ndef _mergeSort(arr, temp_arr, left, right):\r\n \r\n    # A variable inv_count is used to store\r\n    # inversion counts in each recursive call\r\n \r\n    inv_count = 0\r\n \r\n    # We will make a recursive call if and only if\r\n    # we have more than one elements\r\n \r\n    if left < right:\r\n \r\n        # mid is calculated to divide the array into two subarrays\r\n        # Floor division is must in case of python\r\n \r\n        mid = (left + right)//2\r\n \r\n        # It will calculate inversion\r\n        # counts in the left subarray\r\n \r\n        inv_count += _mergeSort(arr, temp_arr,\r\n                                    left, mid)\r\n \r\n        # It will calculate inversion\r\n        # counts in right subarray\r\n \r\n        inv_count += _mergeSort(arr, temp_arr,\r\n                                  mid + 1, right)\r\n \r\n        # It will merge two subarrays in\r\n        # a sorted subarray\r\n \r\n        inv_count += merge(arr, temp_arr, left, mid, right)\r\n    return inv_count\r\n \r\n    \r\n# This function will merge two subarrays\r\n# in a single sorted subarray\r\ndef merge(arr, temp_arr, left, mid, right):\r\n    i = left     # Starting index of left subarray\r\n    j = mid + 1 # Starting index of right subarray\r\n    k = left     # Starting index of to be sorted subarray\r\n    inv_count = 0\r\n \r\n    # Conditions are checked to make sure that\r\n    # i and j don't exceed their\r\n    # subarray limits.\r\n \r\n    while i <= mid and j <= right:\r\n \r\n        # There will be no inversion if arr[i] <= arr[j]\r\n \r\n        if arr[i] <= arr[j]:\r\n            temp_arr[k] = arr[i]\r\n            k += 1\r\n            i += 1\r\n        else:\r\n            # Inversion will occur.\r\n            temp_arr[k] = arr[j]\r\n            inv_count += (mid-i + 1)\r\n            k += 1\r\n            j += 1\r\n \r\n    # Copy the remaining elements of left\r\n    # subarray into temporary array\r\n    while i <= mid:\r\n        temp_arr[k] = arr[i]\r\n        k += 1\r\n        i += 1\r\n \r\n    # Copy the remaining elements of right\r\n    # subarray into temporary array\r\n    while j <= right:\r\n        temp_arr[k] = arr[j]\r\n        k += 1\r\n        j += 1\r\n \r\n    # Copy the sorted subarray into Original array\r\n    for loop_var in range(left, right + 1):\r\n        arr[loop_var] = temp_arr[loop_var]\r\n \r\n    # https://www.geeksforgeeks.org/counting-inversions/\r\n    return inv_count\r\n\r\nfor _ in range(int(input())):\r\n    n, m = map(int, input().split())\r\n    \r\n    aa = list(map(int, input().split()))\r\n    bb = sorted(list(map(int, input().split())))\r\n    \r\n    ans = [0 for i in range(n+m)]\r\n    \r\n    solve(ans, 0, n-1, 0, m-1)\r\n    \r\n    print(mergeSort(ans))",
    "prob_desc_created_at": "1635143700",
    "tags": [
        "data structures",
        "divide and conquer"
    ],
    "hidden_unit_tests": ""
}
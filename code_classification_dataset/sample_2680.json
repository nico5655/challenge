{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"brother 30 60\\nfather 80 60\\nfriend 20 60\\ngrandpa 120 120\\nme 50 40\\nuncle 100 20\", \"dummy 0 0\\npack 10 10\\nx 40 10\\ny 10 10\"]",
    "src_uid": "258f54f32c6df5390edd804294aad235",
    "prob_desc_notes": "NoteIn the first sample the widgets are arranged as follows:   ",
    "prob_desc_description": "Vasya writes his own library for building graphical user interface. Vasya called his creation VTK (VasyaToolKit). One of the interesting aspects of this library is that widgets are packed in each other. A widget is some element of graphical interface. Each widget has width and height, and occupies some rectangle on the screen. Any widget in Vasya's library is of type Widget. For simplicity we will identify the widget and its type. Types HBox and VBox are derivatives of type Widget, so they also are types Widget. Widgets HBox and VBox are special. They can store other widgets. Both those widgets can use the pack() method to pack directly in itself some other widget. Widgets of types HBox and VBox can store several other widgets, even several equal widgets — they will simply appear several times. As a result of using the method pack() only the link to the packed widget is saved, that is when the packed widget is changed, its image in the widget, into which it is packed, will also change. We shall assume that the widget a is packed in the widget b if there exists a chain of widgets a = c1, c2, ..., ck = b, k ≥ 2, for which ci is packed directly to ci + 1 for any 1 ≤ i &lt; k. In Vasya's library the situation when the widget a is packed in the widget a (that is, in itself) is not allowed. If you try to pack the widgets into each other in this manner immediately results in an error.Also, the widgets HBox and VBox have parameters border and spacing, which are determined by the methods set_border() and set_spacing() respectively. By default both of these options equal 0.    The picture above shows how the widgets are packed into HBox and VBox. At that HBox and VBox automatically change their size depending on the size of packed widgets. As for HBox and VBox, they only differ in that in HBox the widgets are packed horizontally and in VBox — vertically. The parameter spacing sets the distance between adjacent widgets, and border — a frame around all packed widgets of the desired width. Packed widgets are placed exactly in the order in which the pack() method was called for them. If within HBox or VBox there are no packed widgets, their sizes are equal to 0 × 0, regardless of the options border and spacing. The construction of all the widgets is performed using a scripting language VasyaScript. The description of the language can be found in the input data. For the final verification of the code Vasya asks you to write a program that calculates the sizes of all the widgets on the source code in the language of VasyaScript. ",
    "prob_desc_output_spec": "For each widget print on a single line its name, width and height, separated by spaces. The lines must be ordered lexicographically by a widget's name.  Please, do not use the %lld specificator to read or write 64-bit integers in C++. It is preferred to use cout stream (also you may use %I64d specificator)",
    "prob_desc_input_spec": "The first line contains an integer n — the number of instructions (1 ≤ n ≤ 100). Next n lines contain instructions in the language VasyaScript — one instruction per line. There is a list of possible instructions below.   \"Widget [name]([x],[y])\" — create a new widget [name] of the type Widget possessing the width of [x] units and the height of [y] units.  \"HBox [name]\" — create a new widget [name] of the type HBox.  \"VBox [name]\" — create a new widget [name] of the type VBox.  \"[name1].pack([name2])\" — pack the widget [name2] in the widget [name1]. At that, the widget [name1] must be of type HBox or VBox.  \"[name].set_border([x])\" — set for a widget [name] the border parameter to [x] units. The widget [name] must be of type HBox or VBox.  \"[name].set_spacing([x])\" — set for a widget [name] the spacing parameter to [x] units. The widget [name] must be of type HBox or VBox.  All instructions are written without spaces at the beginning and at the end of the string. The words inside the instruction are separated by exactly one space. There are no spaces directly before the numbers and directly after them.  The case matters, for example, \"wiDget x\" is not a correct instruction. The case of the letters is correct in the input data. All names of the widgets consist of lowercase Latin letters and has the length from 1 to 10 characters inclusive. The names of all widgets are pairwise different. All numbers in the script are integers from 0 to 100 inclusive It is guaranteed that the above-given script is correct, that is that all the operations with the widgets take place after the widgets are created and no widget is packed in itself. It is guaranteed that the script creates at least one widget. ",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "Python 2",
    "lang_cluster": "Python",
    "difficulty": 2300,
    "file_name": "train_028.jsonl",
    "code_uid": "79ee7c1dbfa4ef3522c6c6602d985350",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"12\\nWidget me(50,40)\\nVBox grandpa\\nHBox father\\ngrandpa.pack(father)\\nfather.pack(me)\\ngrandpa.set_border(10)\\ngrandpa.set_spacing(20)\\nWidget brother(30,60)\\nfather.pack(brother)\\nWidget friend(20,60)\\nWidget uncle(100,20)\\ngrandpa.pack(uncle)\", \"15\\nWidget pack(10,10)\\nHBox dummy\\nHBox x\\nVBox y\\ny.pack(dummy)\\ny.set_border(5)\\ny.set_spacing(55)\\ndummy.set_border(10)\\ndummy.set_spacing(20)\\nx.set_border(10)\\nx.set_spacing(10)\\nx.pack(pack)\\nx.pack(dummy)\\nx.pack(pack)\\nx.set_border(0)\"]",
    "exec_outcome": "PASSED",
    "source_code": "import re\n\nclass Widget(object):\n    def __init__(self, type, w = 0, h = 0):\n        self.type = type\n        if type == 'Widget':\n            self.w = w\n            self.h = h\n    def calc_wh(self):\n        if not hasattr(self, 'w'):\n            if self.children:\n                self.w = self.border * 2\n                self.h = self.border * 2\n                for c in self.children:\n                    cw, ch = c.calc_wh()\n                    if self.type == \"VBox\":\n                        self.h += ch\n                        self.w = max(self.w, cw + self.border * 2)\n                    else:\n                        self.w += cw\n                        self.h = max(self.h, ch + self.border * 2)\n                if self.type == \"HBox\":\n                    self.w += (len(self.children) - 1) * self.spacing\n                else:\n                    self.h += (len(self.children) - 1) * self.spacing\n            else:\n                self.w = 0\n                self.h = 0\n        return self.w, self.h\n\nwidgets = {}\n\nn = input()\nrp = re.compile(r'(\\w+)\\.(\\w+)\\((.+)\\)')\n\nfor _ in xrange(n):\n  str = raw_input()\n  if str.find(' ') != -1:\n    type, rhs = str.split(' ')\n    if type == 'Widget':\n      name, other = rhs.split('(')\n      w, h = map(int, other[:-1].split(','))\n      widgets[name] = Widget(type, w, h)\n    else:\n      widgets[rhs] = Widget(type)\n      widgets[rhs].children = []\n      widgets[rhs].spacing = 0\n      widgets[rhs].border = 0\n  else:\n    name, op, arg = rp.match(str).groups()\n    if op == \"set_border\":\n      widgets[name].border = int(arg)\n    elif op == \"set_spacing\":\n      widgets[name].spacing = int(arg)\n    else:\n      widgets[name].children.append(widgets[arg])\n\nfor k, v in sorted(widgets.items(), key = lambda x: x[0]):\n    w, h = v.calc_wh()\n    print k, w, h",
    "prob_desc_created_at": "1308236400",
    "tags": [
        "dp",
        "implementation",
        "graphs",
        "expression parsing"
    ],
    "hidden_unit_tests": ""
}
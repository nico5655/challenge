{
    "prob_desc_time_limit": "1 second",
    "prob_desc_sample_outputs": "[\"Yes\\nNo\\nNo\\nYes\"]",
    "src_uid": "a97e70ad20a337d12dcf79089c16c9f0",
    "prob_desc_notes": "NoteIn the first test case, we can simply swap $$$31$$$ and $$$14$$$ ($$$31 + 14 = 45$$$ which is odd) and obtain the non-decreasing array $$$[1,6,14,31]$$$.In the second test case, the only way we could sort the array is by swapping $$$4$$$ and $$$2$$$, but this is impossible, since their sum $$$4 + 2 = 6$$$ is even.In the third test case, there is no way to make the array non-decreasing.In the fourth test case, the array is already non-decreasing.",
    "prob_desc_description": "You are given an array $$$a_1, a_2, \\dots, a_n$$$. You can perform operations on the array. In each operation you can choose an integer $$$i$$$ ($$$1 \\le i &lt; n$$$), and swap elements $$$a_i$$$ and $$$a_{i+1}$$$ of the array, if $$$a_i + a_{i+1}$$$ is odd.Determine whether it can be sorted in non-decreasing order using this operation any number of times.",
    "prob_desc_output_spec": "For each test case, print \"Yes\" or \"No\" depending on whether you can or can not sort the given array. You may print each letter in any case (for example, \"YES\", \"Yes\", \"yes\", \"yEs\" will all be recognized as positive answer).",
    "prob_desc_input_spec": "Each test contains multiple test cases. The first line contains a single integer $$$t$$$ ($$$1 \\le t \\le 10^5$$$) — the number of test cases. Description of the test cases follows. The first line of each test case contains a single integer $$$n$$$ ($$$1 \\le n \\le 10^5$$$) — the length of the array. The second line of each test case contains $$$n$$$ integers $$$a_1,a_2, \\dots, a_n$$$ ($$$1 \\le a_i \\le 10^9$$$) — the elements of the array. It is guaranteed that the sum of $$$n$$$ over all test cases does not exceed $$$2 \\cdot 10^5$$$.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "Python 3",
    "lang_cluster": "Python",
    "difficulty": 1100,
    "file_name": "train_106.jsonl",
    "code_uid": "a78555172afa167b42e6b761027146a4",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"4\\n\\n4\\n\\n1 6 31 14\\n\\n2\\n\\n4 2\\n\\n5\\n\\n2 9 6 7 10\\n\\n3\\n\\n6 6 6\"]",
    "exec_outcome": "PASSED",
    "source_code": "# cook your dish here\r\n# cook your dish here\r\n#!/usr/bin/env python\r\nfrom cmath import inf\r\nimport os\r\nfrom math import ceil, factorial, floor, log, sqrt\r\nimport re\r\nimport sys\r\nfrom collections import Counter, defaultdict\r\nfrom itertools import permutations\r\nfrom io import BytesIO, IOBase\r\n\r\n\r\nclass newNode:\r\n    def __init__(self, data):\r\n        self.data = data\r\n        self.left = self.right = None\r\n\r\ndef highestPowerOf2(n):\r\n    return (n & (~(n - 1)))\r\ndef gcd(a,b):\r\n    if a == 0:\r\n        return b\r\n    return gcd(b % a, a)\r\n \r\n# Function to return LCM of two numbers\r\ndef lcm(a,b):\r\n    return (a / gcd(a,b))* b\r\ndef is_sorted(n, arr):\r\n    for j in range(n-1):\r\n        if arr[j]>arr[j+1]:\r\n            return False\r\n    return True\r\n# Returns XNOR of num1 and num2\r\ndef prime_factor(n):\r\n    ans = []\r\n    if n%2==0:\r\n        ans.append(2)\r\n    while n%2==0:\r\n        n = n//2 \r\n    for j in range(3, round(n**0.5) + 1, 2):\r\n        if n%j==0:\r\n            ans.append(j)\r\n        while n%j==0:\r\n            n = n//j\r\n    if n!=1:\r\n        ans.append(n)\r\n    return ans\r\ndef isPowerofTwo(n):\r\n    if (n == 0):\r\n        return 0\r\n    if ((n & (~(n - 1))) == n):\r\n        return 1\r\n    return 0\r\n\r\ndef sum_root(n):\r\n    a = 1\r\n    b = 1\r\n    c = -2*n\r\n    d = b**2 - 4*a*c\r\n    root = (-b + int(d**0.5))/2\r\n    return round(root)\r\n\r\ndef factors(n):\r\n    i = 1\r\n    cnt = 0\r\n    while i <= sqrt(n):\r\n         \r\n        if (n % i == 0) :\r\n             \r\n            # If divisors are equal, print only one\r\n            if (n / i == i) :\r\n                cnt += 1\r\n            else :\r\n                # Otherwise print both\r\n                cnt += 2 \r\n        i = i + 1\r\n    return cnt\r\n    \r\n\r\ndef prime(n):\r\n    if n%2==0 and n>2:\r\n        return False\r\n\r\n    for j in range(3, int(sqrt(n)) + 1, 2):\r\n        if n%j==0:\r\n            return False \r\n    return True\r\n\r\n\r\ndef is_palindrome(s, n):\r\n    for j in range(n//2):\r\n        if s[j] != s[n-j-1]:\r\n            return False\r\n    return True\r\nprod = 1\r\nmemo = {}\r\ndef solve(x):\r\n    global memo\r\n    if x in memo:\r\n        return memo[x]\r\n    else:\r\n        if x>4:\r\n            memo[x] = (solve(x//2)*solve(ceil(x/2)))%998244353\r\n        else:\r\n            memo[x] = x\r\n        return memo[x]\r\nclass Graph:\r\n     \r\n    def __init__(self, V):\r\n \r\n        # No. of vertices\r\n        self.V = V\r\n \r\n        # Pointer to an array containing\r\n        # adjacency lists\r\n        self.adj = [[] for i in range(self.V)]\r\n \r\n    # Function to return the number of\r\n    # connected components in an undirected graph\r\n    def NumberOfconnectedComponents(self):\r\n         \r\n        # Mark all the vertices as not visited\r\n        visited = [False for i in range(self.V)]\r\n         \r\n        # To store the number of connected\r\n        # components\r\n        count = 0\r\n         \r\n        for v in range(self.V):\r\n            if (visited[v] == False):\r\n                self.DFSUtil(v, visited)\r\n                count += 1\r\n                 \r\n        return count\r\n         \r\n    def DFSUtil(self, v, visited):\r\n \r\n        # Mark the current node as visited\r\n        visited[v] = True\r\n \r\n        # Recur for all the vertices\r\n        # adjacent to this vertex\r\n        for i in self.adj[v]:\r\n            if (not visited[i]):\r\n                self.DFSUtil(i, visited)\r\n                 \r\n    # Add an undirected edge\r\n    def addEdge(self, v, w):         \r\n        self.adj[v].append(w)\r\n        self.adj[w].append(v)\r\ndef main():\r\n    for i in range(int(input())):\r\n        n = int(input())\r\n        arr = [int(x) for x in input().split()]\r\n        odd = []\r\n        even = []\r\n        for j in range(n):\r\n            if arr[j]%2!=0:\r\n                odd.append(arr[j])\r\n            else:\r\n                even.append(arr[j])\r\n        if odd == list(sorted(odd)) and even == list(sorted(even)):\r\n            print(\"YES\")\r\n        else:\r\n            print(\"NO\")                    \r\n\r\n        \r\n    \r\nBUFSIZE = 8192\r\n\r\n \r\nclass FastIO(IOBase):\r\n    newlines = 0\r\n \r\n    def __init__(self, file):\r\n        self._fd = file.fileno()\r\n        self.buffer = BytesIO()\r\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\r\n        self.write = self.buffer.write if self.writable else None\r\n \r\n    def read(self):\r\n        while True:  \r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            if not b:\r\n                break\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines = 0\r\n        return self.buffer.read()\r\n \r\n    def readline(self):\r\n        while self.newlines == 0:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            self.newlines = b.count(b\"\\n\") + (not b)\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines -= 1\r\n        return self.buffer.readline()\r\n \r\n    def flush(self):\r\n        if self.writable:\r\n            os.write(self._fd, self.buffer.getvalue())\r\n            self.buffer.truncate(0), self.buffer.seek(0)\r\n \r\n \r\nclass IOWrapper(IOBase):\r\n    def __init__(self, file):\r\n        self.buffer = FastIO(file)\r\n        self.flush = self.buffer.flush\r\n        self.writable = self.buffer.writable\r\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\r\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\r\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\r\n \r\n \r\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\r\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\r\n \r\n# endregion\r\n \r\nif __name__ == \"__main__\":\r\n    main()",
    "prob_desc_created_at": "1644849300",
    "tags": [
        "data structures",
        "math",
        "sortings"
    ],
    "hidden_unit_tests": ""
}
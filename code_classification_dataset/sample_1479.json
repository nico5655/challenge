{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"-1\\n-1\\n-1\\n-1\\n5\\n-1\\n6\\n3\\n5\", \"12\"]",
    "src_uid": "9d531125a1e02639fecbd2168fe7d7a1",
    "prob_desc_notes": "NoteIn the first example, the real queries (without being encoded) are: 12 2 1 2 2 0 1073741823 1 1 2 5 2 1 1 2 2 2 2 1 2 1 2 3 6 2 1 1 1 1 3 0 2 1 1 2 2 2 2 3 3  The answers for the first two queries are $$$-1$$$ because we don't have any such information on the array initially.  The first update tells us $$$a_1 \\oplus a_2 = 5$$$. Note that we still can't be certain about the values $$$a_1$$$ or $$$a_2$$$ independently (for example, it could be that $$$a_1 = 1, a_2 = 4$$$, and also $$$a_1 = 3, a_2 = 6$$$).  After we receive all three updates, we have enough information to deduce $$$a_1, a_2, a_3$$$ independently. In the second example, notice that after the first two updates we already know that $$$a_5 \\oplus a_6 = 12$$$, so the third update is contradicting, and we ignore it.",
    "prob_desc_description": "There is an array $$$a$$$ of $$$2^{30}$$$ integers, indexed from $$$0$$$ to $$$2^{30}-1$$$. Initially, you know that $$$0 \\leq a_i &lt; 2^{30}$$$ ($$$0 \\leq i &lt; 2^{30}$$$), but you do not know any of the values. Your task is to process queries of two types: 1 l r x: You are informed that the bitwise xor of the subarray $$$[l, r]$$$ (ends inclusive) is equal to $$$x$$$. That is, $$$a_l \\oplus a_{l+1} \\oplus \\ldots \\oplus a_{r-1} \\oplus a_r = x$$$, where $$$\\oplus$$$ is the bitwise xor operator. In some cases, the received update contradicts past updates. In this case, you should ignore the contradicting update (the current update). 2 l r: You are asked to output the bitwise xor of the subarray $$$[l, r]$$$ (ends inclusive). If it is still impossible to know this value, considering all past updates, then output $$$-1$$$.Note that the queries are encoded. That is, you need to write an online solution.",
    "prob_desc_output_spec": "After every query of the second type, output the bitwise xor of the given subarray or $$$-1$$$ if it is still impossible to know.",
    "prob_desc_input_spec": "The first line contains a single integer $$$q$$$ ($$$1 \\leq q \\leq 2 \\cdot 10^5$$$) — the number of queries. Each of the next $$$q$$$ lines describes a query. It contains one integer $$$t$$$ ($$$1 \\leq t \\leq 2$$$) — the type of query. The given queries will be encoded in the following way: let $$$last$$$ be the answer to the last query of the second type that you have answered (initially, $$$last = 0$$$). If the last answer was $$$-1$$$, set $$$last = 1$$$.  If $$$t = 1$$$, three integers follow, $$$l'$$$, $$$r'$$$, and $$$x'$$$ ($$$0 \\leq l', r', x' &lt; 2^{30}$$$), meaning that you got an update. First, do the following: $$$l = l' \\oplus last$$$, $$$r = r' \\oplus last$$$, $$$x = x' \\oplus last$$$ and, if $$$l &gt; r$$$, swap $$$l$$$ and $$$r$$$.This means you got an update that the bitwise xor of the subarray $$$[l, r]$$$ is equal to $$$x$$$ (notice that you need to ignore updates that contradict previous updates). If $$$t = 2$$$, two integers follow, $$$l'$$$ and $$$r'$$$ ($$$0 \\leq l', r' &lt; 2^{30}$$$), meaning that you got a query. First, do the following: $$$l = l' \\oplus last$$$, $$$r = r' \\oplus last$$$ and, if $$$l &gt; r$$$, swap $$$l$$$ and $$$r$$$.For the given query, you need to print the bitwise xor of the subarray $$$[l, r]$$$. If it is impossible to know, print $$$-1$$$. Don't forget to change the value of $$$last$$$. It is guaranteed there will be at least one query of the second type.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 2",
    "lang_cluster": "Python",
    "difficulty": 2400,
    "file_name": "train_009.jsonl",
    "code_uid": "00b7025abbeb83504775e7c30ff915cf",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"12\\n2 1 2\\n2 1 1073741822\\n1 0 3 4\\n2 0 0\\n2 3 3\\n2 0 3\\n1 6 7 3\\n2 4 4\\n1 0 2 1\\n2 0 0\\n2 4 4\\n2 0 0\", \"4\\n1 5 5 9\\n1 6 6 5\\n1 6 5 10\\n2 6 5\"]",
    "exec_outcome": "PASSED",
    "source_code": "import os\nimport sys\nfrom atexit import register\nfrom io import BytesIO\n\nsys.stdin = BytesIO(os.read(0, os.fstat(0).st_size))\nsys.stdout = BytesIO()\nregister(lambda: os.write(1, sys.stdout.getvalue()))\n\ninput = lambda: sys.stdin.readline().rstrip('\\r\\n')\nq=int(input())\nhome=[]\nlast=0\nparents={}\nfor i in xrange(q):\n    a=list(map(int,input().split()))\n    for i in xrange(len(a)-1):\n        a[i+1]=a[i+1]^last\n    start,end=min(a[1],a[2])-1,max(a[1],a[2])\n    x,y=start in parents,end in parents\n    if x:\n        if y:\n            xor=parents[start][1]\n            daddy=parents[start][0]\n            child=start\n            long=[]\n            while True:\n                if child==daddy:\n                    break\n                long.append((child,parents[child][1]))\n                xor=xor^parents[daddy][1]\n                child=daddy\n                daddy=parents[daddy][0]\n            xor3=0\n            for guy in long[::-1]:\n                xor3^=guy[1]\n                parents[guy[0]]=(daddy,xor3)\n            xor1=parents[end][1]\n            daddy1=parents[end][0]\n            child1=end\n            long=[]\n            while True:\n                if child1==daddy1:\n                    break\n                long.append((child1,parents[child1][1]))\n                xor1=xor1^parents[daddy1][1]\n                child1=daddy1\n                daddy1=parents[daddy1][0]\n            xor2=0\n            for guy in long[::-1]:\n                xor2^=guy[1]\n                parents[guy[0]]=(daddy1,xor2)\n            if a[0]==2:\n                if daddy==daddy1:\n                    last=xor^xor1\n                    print(last)\n                else:\n                    print(-1)\n                    last=1\n            else:\n                if daddy!=daddy1:\n                    parents[daddy]=(parents[daddy1][0],xor1^xor^a[3])\n        else:\n            if a[0]==2:\n                print(-1)\n                last=1\n            else:\n                parents[end]=(parents[start][0],a[3]^parents[start][1])\n    else:\n        if y:\n            if a[0]==2:\n                print(-1)\n                last=1\n            else:\n                parents[start]=(parents[end][0],a[3]^parents[end][1])\n        else:\n            if a[0]==2:\n                print(-1)\n                last=1\n            else:\n                home.append(start)\n                parents[end]=(start,a[3])\n                parents[start]=(start,0)",
    "prob_desc_created_at": "1541355000",
    "tags": [
        "data structures",
        "dsu"
    ],
    "hidden_unit_tests": ""
}
{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"? C\\n\\n? CH\\n\\n? CCHO\\n\\n! CCHH\", \"? O\\n\\n? HHH\\n\\n! CHHHH\\n\\n\\n? COO\\n\\n? COOH\\n\\n? HCCOO\\n\\n? HH\\n\\n! HHHCCOOH\"]",
    "src_uid": "ecd8c5d7f869cabe35cc9bbdbfb8e00c",
    "prob_desc_notes": "NoteNote that the example interaction contains extra empty lines so that it's easier to read. The real interaction doesn't contain any empty lines and you shouldn't print any extra empty lines as well.",
    "prob_desc_description": "MisoilePunch♪ - 彩This is an interactive problem!On a normal day at the hidden office in A.R.C. Markland-N, Rin received an artifact, given to her by the exploration captain Sagar.After much analysis, she now realizes that this artifact contains data about a strange flower, which has existed way before the New Age. However, the information about its chemical structure has been encrypted heavily.The chemical structure of this flower can be represented as a string $$$p$$$. From the unencrypted papers included, Rin already knows the length $$$n$$$ of that string, and she can also conclude that the string contains at most three distinct letters: \"C\" (as in Carbon), \"H\" (as in Hydrogen), and \"O\" (as in Oxygen).At each moment, Rin can input a string $$$s$$$ of an arbitrary length into the artifact's terminal, and it will return every starting position of $$$s$$$ as a substring of $$$p$$$.However, the artifact has limited energy and cannot be recharged in any way, since the technology is way too ancient and is incompatible with any current A.R.C.'s devices. To be specific:  The artifact only contains $$$\\frac{7}{5}$$$ units of energy.  For each time Rin inputs a string $$$s$$$ of length $$$t$$$, the artifact consumes $$$\\frac{1}{t^2}$$$ units of energy.  If the amount of energy reaches below zero, the task will be considered failed immediately, as the artifact will go black forever. Since the artifact is so precious yet fragile, Rin is very nervous to attempt to crack the final data. Can you give her a helping hand?",
    "prob_desc_output_spec": null,
    "prob_desc_input_spec": null,
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "Python 3",
    "lang_cluster": "Python",
    "difficulty": 3500,
    "file_name": "train_014.jsonl",
    "code_uid": "1b991933f1d5f39e3f8b8604bdebd60e",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"1\\n4\\n\\n2 1 2\\n\\n1 2\\n\\n0\\n\\n1\", \"2\\n5\\n\\n0\\n\\n2 2 3\\n\\n1\\n8\\n\\n1 5\\n\\n1 5\\n\\n1 3\\n\\n2 1 2\\n\\n1\"]",
    "exec_outcome": "PASSED",
    "source_code": "\nimport sys\nn, L, minID = None, None, None\ns = []\n\ndef fill(id, c):\n    global n, L, s, minID\n    L -= (s[id] == 'L')\n    s = s[0:id] + c + s[ id +1:]\n    minID = min(minID, id)\n\ndef query(cmd, str):\n    global n, L, s, minID\n    print(cmd, ''.join(str))\n    print(cmd, ''.join(str), file=sys.stderr)\n    sys.stdout.flush()\n    if (cmd == '?'):\n        result = list(map(int, input().split()))\n        assert(result[0] != -1)\n        for z in result[1:]:\n            z -= 1\n            for i in range(len(str)):\n                assert(s[z+i] == 'L' or s[z+i] == str[ i ])\n                fill(z+i, str[i])\n    elif (cmd == '!'):\n        correct = int(input())\n        assert(correct == 1)\n\nfor _ in range(int(input())):\n    n = int(input())\n    if n >= 13:\n        ans = [''] * (n + 1)\n        print('? CO')\n        co = list(map(int, input().split()))[1:]\n        print('? CH')\n        ch = list(map(int, input().split()))[1:]\n        print('? CC')\n        cc = list(map(int, input().split()))[1:]\n        for d in co:\n            ans[d] = 'C'\n            ans[d + 1] = 'O'\n        for d in ch:\n            ans[d] = 'C'\n            ans[d + 1] = 'H'\n        for d in cc:\n            ans[d] = 'C'\n            ans[d + 1] = 'C'\n        print('? OO')\n        oo = list(map(int, input().split()))[1:]\n        print('? OH')\n        oh = list(map(int, input().split()))[1:]\n        for d in oo:\n            ans[d] = 'O'\n            ans[d + 1] = 'O'\n        for d in oh:\n            ans[d] = 'O'\n            ans[d + 1] = 'H'\n        for i in range(1, n):\n            if ans[i] == 'O' and ans[i + 1] == '':\n                ans[i + 1] = 'C'\n        for i in range(1, n):\n            if ans[i] == '' and ans[i + 1] == 'O':\n                ans[i] = 'H'\n        for i in range(1, n):\n            if ans[i] == '' and ans[i + 1] == 'H':\n                ans[i] = 'H'\n        for i in range(1, n):\n            if ans[i] == '' and ans[i + 1] == '':\n                ans[i] = 'H'\n        print('? HOC')\n        hoc = list(map(int, input().split()))[1:]\n        for d in hoc:\n            ans[d] = 'H'\n            ans[d + 1] = 'O'\n            ans[d + 2] = 'C'\n        for d in range(2, n):\n            if ans[d] == '':\n                ans[d] = 'H'\n        if ans[1] == '':\n            print('?', 'H' + ''.join(ans[2:-1]))\n            if input()[0] != '0':\n                ans[1] = 'H'\n            else:\n                ans[1] = 'O'\n        if ans[-1] == '':\n            print('?', ''.join(ans[1:-1]) + 'H')\n            if input()[0] != '0':\n                ans[-1] = 'H'\n            else:\n                print('?', ''.join(ans[1:-1]) + 'O')\n                if input()[0] != '0':\n                    ans[-1] = 'O'\n                else:\n                    ans[-1] = 'C'\n        print('!', ''.join(ans[1:]))\n        kek = input()\n    else:\n        L, minID = n, n\n        s = 'L' * n\n\n        query('?', \"CH\")\n        query('?', \"CO\")\n        query('?', \"HC\")\n        query('?', \"HO\")\n        if (L == n):\n            # the string exists in form O...OX...X, with X=C or X=H\n            # or it's completely mono-character\n            query('?', \"CCC\")\n            if (minID < n):\n                for x in range(minID - 1, -1, -1): fill(x, 'O')\n            else:\n                query('?', \"HHH\")\n                if (minID < n):\n                    for x in range(minID - 1, -1, -1): fill(x, 'O')\n                else:\n                    query('?', \"OOO\")\n                    if (minID == n):\n                        # obviously n=4\n                        query('?', \"OOCC\")\n                        if (minID == n):\n                            fill(0, 'O')\n                            fill(1, 'O')\n                            fill(2, 'H')\n                            fill(3, 'H')\n\n                    if (s[n - 1] == 'L'):\n                        t = s[0:n - 1] + 'C'\n                        if (t[n - 2] == 'L'): t = t[0:n - 2] + 'C' + t[n - 1:]\n                        query('?', t)\n                        if (s[n - 1] == 'L'):\n                            fill(n - 1, 'H')\n                            if (s[n - 2] == 'L'): fill(n - 2, 'H')\n        else:\n            maxID = minID\n            while (maxID < n - 1 and s[maxID + 1] != 'L'): maxID += 1\n            for i in range(minID - 1, -1, -1):\n                query('?', s[i + 1:i + 2] + s[minID:maxID + 1])\n                if (minID != i):\n                    for x in range(i + 1): fill(x, 'O')\n                    break\n\n            nextFilled = None\n            i = maxID + 1\n            while i < n:\n                if (s[i] != 'L'):\n                    i += 1\n                    continue\n                nextFilled = i\n                while (nextFilled < n and s[nextFilled] == 'L'): nextFilled += 1\n                query('?', s[0:i] + s[i - 1])\n                if (s[i] == 'L'):\n                    if (s[i - 1] != 'O'):\n                        fill(i, 'O')\n                    else:\n                        if (nextFilled == n):\n                            query('?', s[0:i] + 'C')\n                            if (s[i] == 'L'): fill(i, 'H')\n                            for x in range(i + 1, nextFilled): fill(x, s[i])\n                        else:\n                            for x in range(i, nextFilled): fill(x, s[nextFilled])\n                        i = nextFilled - 1\n                i += 1\n        query('!', s)",
    "prob_desc_created_at": "1579440900",
    "tags": [
        "math",
        "constructive algorithms",
        "greedy",
        "interactive"
    ],
    "hidden_unit_tests": ""
}
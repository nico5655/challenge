{
    "prob_desc_time_limit": "4 seconds",
    "prob_desc_sample_outputs": "[\"2 1 4 3 \\n1 2 \\n3 4 2 1 5 \\n3 2 1\"]",
    "src_uid": "5481863fd03c37cdcb7d6ee40f973cb9",
    "prob_desc_notes": null,
    "prob_desc_description": "Monocarp had a permutation $$$a$$$ of $$$n$$$ integers $$$1$$$, $$$2$$$, ..., $$$n$$$ (a permutation is an array where each element from $$$1$$$ to $$$n$$$ occurs exactly once).Then Monocarp calculated an array of integers $$$b$$$ of size $$$n$$$, where $$$b_i = \\left\\lfloor \\frac{i}{a_i} \\right\\rfloor$$$. For example, if the permutation $$$a$$$ is $$$[2, 1, 4, 3]$$$, then the array $$$b$$$ is equal to $$$\\left[ \\left\\lfloor \\frac{1}{2} \\right\\rfloor, \\left\\lfloor \\frac{2}{1} \\right\\rfloor, \\left\\lfloor \\frac{3}{4} \\right\\rfloor, \\left\\lfloor \\frac{4}{3} \\right\\rfloor \\right] = [0, 2, 0, 1]$$$.Unfortunately, the Monocarp has lost his permutation, so he wants to restore it. Your task is to find a permutation $$$a$$$ that corresponds to the given array $$$b$$$. If there are multiple possible permutations, then print any of them. The tests are constructed in such a way that least one suitable permutation exists.",
    "prob_desc_output_spec": "For each test case, print $$$n$$$ integers — a permutation $$$a$$$ that corresponds to the given array $$$b$$$. If there are multiple possible permutations, then print any of them.",
    "prob_desc_input_spec": "The first line contains a single integer $$$t$$$ ($$$1 \\le t \\le 10^5$$$) — number of test cases. The first line of each test case contains a single integer $$$n$$$ ($$$1 \\le n \\le 5 \\cdot 10^5$$$). The second line contains $$$n$$$ integers $$$b_1, b_2, \\dots, b_n$$$ ($$$0 \\le b_i \\le n$$$). Additional constrains on the input:   the sum of $$$n$$$ over test cases does not exceed $$$5 \\cdot 10^5$$$;  there exists at least one permutation $$$a$$$ that would yield this array $$$b$$$. ",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3-64",
    "lang_cluster": "Python",
    "difficulty": 1900,
    "file_name": "train_098.jsonl",
    "code_uid": "3babb8db54ba1568e0011deb4af2f572",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"4\\n\\n4\\n\\n0 2 0 1\\n\\n2\\n\\n1 1\\n\\n5\\n\\n0 0 1 4 1\\n\\n3\\n\\n0 1 3\"]",
    "exec_outcome": "PASSED",
    "source_code": "import heapq\r\n\r\nimport sys\r\ninput = sys.stdin.readline\r\nrounds=int(input())\r\nfor ii in range(rounds):\r\n  out=0\r\n  length=int(input())\r\n  arr=list(map(int,input().split()))\r\n  small=[]\r\n  for l in range(length):\r\n    if arr[l]==0:\r\n      small.append([l+2,length,l])\r\n    else:\r\n      little=(l+1)//(arr[l]+1)+1\r\n      big=(l+1)//arr[l]\r\n      small.append([little,big,l])\r\n  \r\n  small.sort()\r\n  used=set()\r\n  out=[0]*length\r\n  p=1\r\n  hold=[]\r\n  heapq.heapify(hold)\r\n  ind=0\r\n  while p<length+1:\r\n    for j in range(ind,length):\r\n      if p>=small[j][0] and small[j][2] not in used:\r\n        heapq.heappush(hold,(small[j][1],small[j][2]))\r\n        used.add(small[j][2])\r\n      else:\r\n        ind=j\r\n        break\r\n    cur=heapq.heappop(hold)\r\n    out[cur[1]]=p\r\n    p+=1\r\n\r\n  for o in out:\r\n    print(o,end=' ')\r\n  print('')",
    "prob_desc_created_at": "1657290900",
    "tags": [
        "binary search",
        "data structures",
        "greedy",
        "math",
        "sortings",
        "two pointers"
    ],
    "hidden_unit_tests": ""
}
{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"2 1 3\", \"IMPOSSIBLE\"]",
    "src_uid": "e683d660af1e8a98f20296f289aa8960",
    "prob_desc_notes": "NoteConsider the first sample test. We need to find a tree with 3 nodes that satisfies the following two constraints. The node labeled 2 with pre-order traversal should be in the left subtree of the node labeled 1 with pre-order traversal; the node labeled 3 with pre-order traversal should be in the right subtree of the node labeled 1. There is only one tree with three nodes that satisfies these constraints and its in-order traversal is (2, 1, 3).Pre-order is the \"root – left subtree – right subtree\" order. In-order is the \"left subtree – root – right subtree\" order.For other information regarding in-order and pre-order, see http://en.wikipedia.org/wiki/Tree_traversal.",
    "prob_desc_description": "You need to find a binary tree of size n that satisfies a given set of c constraints. Suppose that the nodes of the unknown binary tree are labeled using a pre-order traversal starting with 1. For the i-th constraint you are given two labels, ai and bi and a direction, left or right. In case of left direction, bi is an element of the subtree rooted at ai's left child. Similarly in the case of right direction bi is an element of the subtree rooted at ai's right child.",
    "prob_desc_output_spec": "Output will be on a single line. Any binary tree that satisfies the constraints will be accepted. The tree's nodes should be printed out as n space separated labels representing an in-order traversal, using the pre-order numbers as labels of vertices. If there are no trees that satisfy the constraints, print \"IMPOSSIBLE\" (without quotes).",
    "prob_desc_input_spec": "The first line of input contains two integers n and c. The next c lines contain 2 integers ai, bi (1 ≤ ai, bi ≤ n) and either \"LEFT\" or \"RIGHT\" denoting whether b is in the subtree rooted at ai's left child or in the subtree rooted at ai's right child. The problem consists of multiple subproblems. The subproblems have different constraints on the input. You will get some score for the correct submission of the subproblem. The description of the subproblems follows.   In subproblem D1 (9 points), the constraints 1 ≤ n ≤ 100, 1 ≤ c ≤ 50 will hold.  In subproblem D2 (8 points), the constraints 1 ≤ n ≤ 1000000, 1 ≤ c ≤ 100000 will hold. ",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "Python 2",
    "lang_cluster": "Python",
    "difficulty": 2400,
    "file_name": "train_018.jsonl",
    "code_uid": "d524a65a6ab4e924fe53c533d908c3d2",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"3 2\\n1 2 LEFT\\n1 3 RIGHT\", \"3 2\\n1 2 RIGHT\\n1 3 LEFT\"]",
    "exec_outcome": "PASSED",
    "source_code": "#!/usr/bin/env python\n#-*- coding:utf-8 -*-\n\nimport sys\nimport math\nimport random\nimport operator\nfrom fractions import Fraction, gcd\nfrom decimal import Decimal, getcontext\nfrom itertools import product, permutations, combinations\nfrom collections import deque, defaultdict, Counter\n\nMOD = 10**9 + 7\nINF = float(\"+inf\")\n\n\ndef die():\n    print \"IMPOSSIBLE\"\n    quit()\n\n\nn, c = map(int, raw_input().split())\n#lefts = defaultdict(set)\n#rights = defaultdict(set)\nmax_left = defaultdict(lambda: 0)\nmax_right = defaultdict(lambda: 0)\nmin_left = defaultdict(lambda: INF)\nmin_right = defaultdict(lambda: INF)\n\nmins = defaultdict(lambda: INF)\nfor i in xrange(c):\n    a, b, dir = raw_input().split()\n    a = int(a)\n    b = int(b)\n    if a >= b:\n        die()\n\n    if dir == \"LEFT\":\n        #lefts[a].add(b)\n        max_left[a] = max(max_left[a], b)\n        min_left[a] = min(min_left[a], b)\n    else:\n        #rights[a].add(b)\n        max_right[a] = max(max_right[a], b)\n        min_right[a] = min(min_right[a], b)\n\nroot = 1\ntree_left = {}\ntree_right = {}\n#print max_left\n#print max_right\n\n\ndef recurse(node, min_to_drop, max_to_drop):\n    global top\n    # print \"rec\", node, \"min\", min_to_drop, \"mx\", max_to_drop, \"|\", top, max_left[node], max_right[node]\n    if min_to_drop <= top:\n        die()\n\n    need_left = bool(max_left[node])\n    if need_left:\n        min_to_left = min(min_to_drop, min_left[node])\n        max_to_left = max_left[node]\n        if min_to_left <= top:\n            die()\n\n        top = tree_left[node] = top + 1\n        if min_to_left == top:\n            min_to_left += 1\n\n        # print \"  \", node, \"left\"\n        recurse(top, min_to_left, max_to_left)\n\n    need_right = bool(max_right[node]) or top < max_to_drop\n    if need_right:\n        min_to_right = min(top + 1, min_right[node])\n        max_to_right = max(max_to_drop, max_right[node])\n        if min_to_right <= top:\n            die()\n\n        top = tree_right[node] = top + 1\n        if min_to_right == top:\n            min_to_right += 1\n\n        # print \"  \", node, \"right\"\n        recurse(top, min_to_right, max_to_right)\n\n\ndef visit(node):\n    left = tree_left.get(node, None)\n    right = tree_right.get(node, None)\n    if left:\n        visit(left)\n    print node,\n    if right:\n        visit(right)\n\ntop = 1\nrecurse(top, 2, n)\nvisit(1)\n\nquit()\n\n\n\nhas_left = defaultdict(lambda: False)\nhas_right = defaultdict(lambda: False)\nparents = defaultdict(set)\nchildren = defaultdict(set)\n\nn, c = map(int, raw_input().split())\nfor i in xrange(c):\n    a, b, dir = raw_input().split()\n    if a >= b:\n        die()\n    if dir == \"LEFT\":\n        maxes[a] = max(maxes[a], b)\n        has_left[a] = True\n    else:\n        mins[a] = min(mins[a], b)\n        has_right[a] = True\n\n    if maxes[a] >= mins[a]:\n        die()\n\n    parents[b] += parents[a]\n    parents[b].add(a)\n\n    children[a].add(b)\n    for par in parents[a]:\n        children[par].add(b)\n\nroot = 1\nleft = {}\nright = {}\n\n\n# def recursive(node, ):\n#     if not children[node]:\n#         return (\n#     if has_left[node]:\n#         left = min(children[node])\n#         children[node].remove(left)\n\n\n",
    "prob_desc_created_at": "1423328400",
    "tags": [
        "dfs and similar"
    ],
    "hidden_unit_tests": ""
}
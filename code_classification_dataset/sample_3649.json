{
    "prob_desc_time_limit": "4 seconds",
    "prob_desc_sample_outputs": "[\"? 4 \\n1 2 3 4\\n? 2\\n1 2\\n? 2\\n1 3\\n? 2\\n1 4\\n? 2\\n2 4\\n? 2\\n3 4\\nY 2\\n1 2\", \"? 4\\n1 4 2 3\\n? 3\\n1 2 4\\nN 3\\n2 1 4\"]",
    "src_uid": "6b4fb840d0aeaf30cfcd05a26979813b",
    "prob_desc_notes": "NoteIn the first case, Alice learns that there are $$$4$$$ edges in the whole graph. Over the course of the next three queries, she learns that vertex $$$1$$$ has two neighbors: $$$3$$$ and $$$4$$$. She then learns that while vertex $$$2$$$ is adjacent to $$$4$$$, the vertex $$$3$$$ isn't adjacent to $$$4$$$. There is only one option for the remaining edge, and that is $$$(2, 3)$$$. This means that the graph is a cycle on four vertices, with $$$(1, 2)$$$ being one partition and $$$(3, 4)$$$ being the second. Here, it would be also valid to output \"3 4\" on the second line.In the second case, we also have a graph on four vertices and four edges. In the second query, Alice learns that there are three edges among vertices $$$(1, 2, 4)$$$. The only way this could possibly happen is that those form a triangle. As the triangle is not bipartite, Alice can report it as a proof. Notice that she does not learn where the fourth edge is, but she is able to answer Bob correctly anyway.",
    "prob_desc_description": "Bob has a simple undirected connected graph (without self-loops and multiple edges). He wants to learn whether his graph is bipartite (that is, you can paint all vertices of the graph into two colors so that there is no edge connecting two vertices of the same color) or not. As he is not very good at programming, he asked Alice for help. He does not want to disclose his graph to Alice, but he agreed that Alice can ask him some questions about the graph.The only question that Alice can ask is the following: she sends $$$s$$$ — a subset of vertices of the original graph. Bob answers with the number of edges that have both endpoints in $$$s$$$. Since he doesn't want Alice to learn too much about the graph, he allows her to ask no more than $$$20000$$$ questions. Furthermore, he suspects that Alice might introduce false messages to their communication channel, so when Alice finally tells him whether the graph is bipartite or not, she also needs to provide a proof — either the partitions themselves or a cycle of odd length.Your task is to help Alice to construct the queries, find whether the graph is bipartite. ",
    "prob_desc_output_spec": null,
    "prob_desc_input_spec": "The first line contains a single integer $$$n$$$ ($$$1 \\leq n \\leq 600$$$) — the number of vertices in Bob's graph.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3",
    "lang_cluster": "Python",
    "difficulty": 2800,
    "file_name": "train_076.jsonl",
    "code_uid": "fb8fe9c2e89ffd482bc001d0e73ceb66",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"4\\n4\\n0\\n1\\n1\\n1\\n0\", \"4\\n4\\n3\"]",
    "exec_outcome": "PASSED",
    "source_code": "from sys import stdout\n\n\ndef Ask(S1, S2, L, R):\n    size = 0 if S2 is None else len(S2)\n\n    if size == 0 and R - L < 2:\n        return 0\n\n    question = []\n\n    for i in range(L, R):\n        question.append(str(S1[i] + 1))\n\n    for i in range(size):\n        question.append(str(S2[i] + 1))\n\n    stdout.write(\"? \" + str(size + R - L) + \"\\n\" + \" \".join(question) + \"\\n\")\n    stdout.flush()\n\n    answer = int(input())\n\n    if answer == -1:\n        exit()\n\n    return answer\n\n\ndef Binary_Search(S, check):\n    L = 0\n    R = len(S)\n\n    while R - L > 1:\n        middle = L + (R - L) // 2\n\n        if check(S, L, middle):\n            R = middle\n\n        else:\n            L = middle\n\n    return S[L]\n\n\ndef Spanning_Build(v, S, father, set, sets):\n    sets[v] = set\n    S.remove(v)\n    D = [v]\n\n    while len(S) > 0 and Ask(S, D, 0, len(S)) != Ask(S, None, 0, len(S)):\n        w = Binary_Search(S, lambda S_i, i, j: Ask(S_i, D, i, j) != Ask(S_i, None, i, j))\n        father[w] = v\n        Spanning_Build(w, S, father, not set, sets)\n\n\ndef Found_Edge(B):\n    L = 0\n    R = len(B)\n\n    while R - L > 2:\n        middle = L + (R - L) // 2\n\n        if Ask(B, None, L, middle):\n            R = middle\n\n        elif Ask(B, None, middle, R):\n                L = middle\n\n        else:\n            B_1 = B[L: middle]\n            B_2 = B[middle: R]\n\n            v = Binary_Search(B_1, lambda B_1i, i, j: Ask(B_1i, B_2, i, j) != 0)\n\n            D = [v]\n\n            w = Binary_Search(B_2, lambda B_2i, i, j: Ask(B_2i, D, i, j) != 0)\n\n            return v, w\n\n    return B[L], B[L + 1]\n\n\ndef Odd_Cycle(v, w, father):\n    mark = [False for _ in range(len(father))]\n\n    x = v\n\n    while x != -1:\n        mark[x] = True\n        x = father[x]\n\n    x = w\n\n    while not mark[x]:\n        x = father[x]\n\n    first_middle = []\n    second_middle = []\n\n    while w != x:\n        first_middle.append(str(w + 1))\n        w = father[w]\n\n    first_middle.append(str(x + 1))\n\n    while v != x:\n        second_middle.append(str(v + 1))\n        v = father[v]\n\n    stdout.write(\"N \" + str(len(first_middle) + len(second_middle)) + \"\\n\" + \" \".join(first_middle)\n                     + \" \" + \" \".join(reversed(second_middle)) + \"\\n\")\n    stdout.flush()\n\n\nn = int(input())\n\nfather = [-1 for _ in range(n)]\nsets = [False for _ in range(n)]\nS = [i for i in range(n)]\n\nSpanning_Build(0, S, father, True, sets)\n\nB = []\nN = []\n\nfor i in range(n):\n    if sets[i]:\n        B.append(i)\n\n    else:\n        N.append(i)\n\nif Ask(B, None, 0, len(B)) != 0:\n    v, w = Found_Edge(B)\n    Odd_Cycle(v, w, father)\n\nelif Ask(N, None, 0, len(N)) != 0:\n    v, w = Found_Edge(N)\n    Odd_Cycle(v, w, father)\n\nelse:\n    B = [str(v + 1) for v in B]\n    stdout.write(\"Y \" + str(len(B)) + \"\\n\" + \" \".join(B) + \"\\n\")\n    stdout.flush()\n",
    "prob_desc_created_at": "1538931900",
    "tags": [
        "graphs",
        "constructive algorithms",
        "interactive",
        "binary search",
        "dfs and similar"
    ],
    "hidden_unit_tests": ""
}
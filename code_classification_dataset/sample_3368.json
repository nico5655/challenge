{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"3 1\", \"11 2 0 0\"]",
    "src_uid": "607dd33e61f57caced7b61ca8001e871",
    "prob_desc_notes": "NoteConsider a string t = t1t2... t|t|, where ti denotes the i-th character of the string, and |t| denotes the length of the string.Then t[i... j] (1 ≤ i ≤ j ≤ |t|) represents the string titi + 1... tj (substring of t from position i to position j inclusive).",
    "prob_desc_description": "You are given three strings (s1, s2, s3). For each integer l (1 ≤ l ≤ min(|s1|, |s2|, |s3|) you need to find how many triples (i1, i2, i3) exist such that three strings sk[ik... ik + l - 1] (k = 1, 2, 3) are pairwise equal. Print all found numbers modulo 1000000007 (109 + 7).See notes if you are not sure about some of the denotions used in the statement.",
    "prob_desc_output_spec": "You need to output min(|s1|, |s2|, |s3|) numbers separated by spaces — answers for the problem modulo 1000000007 (109 + 7).",
    "prob_desc_input_spec": "First three lines contain three non-empty input strings. The sum of lengths of all strings is no more than 3·105. All strings consist only of lowercase English letters.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 2",
    "lang_cluster": "Python",
    "difficulty": 2400,
    "file_name": "train_055.jsonl",
    "code_uid": "13680e9d743be50cd1953498f8dc91c4",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"abc\\nbc\\ncbc\", \"abacaba\\nabac\\nabcd\"]",
    "exec_outcome": "PASSED",
    "source_code": "\n\nMOD = 1000000007\noo = int(2e9)\n\nclass Node:\n    def __init__(self, p, l = oo):\n        self.spos = p\n        self.slink = 0\n        self.length = l\n        self.next_node = [0 for _ in range(28)]\n\n\n#Ukkonen\nclass SuffixTree:\n    def __init__(self, s):\n        self.nodes = [Node(0)]\n        self.s = []\n        self.pos = 0\n        self.node = 0\n        self.last_leaf = 0\n        for c in s:\n            self.extend(ord(c) - 97)\n\n    def get_len(self, p):\n        if p == 0:\n            return 0\n        return min(self.nodes[p].length, len(self.s) - self.nodes[p].spos)\n\n    def add_node(self, p, l = oo):\n        r = len(self.nodes)\n        self.nodes.append(Node(p, l))\n        return r\n\n    def extend(self, c):\n        self.pos += 1\n        self.s.append(c)\n        n = len(self.s)\n        last = 0\n        while self.pos:\n            while self.pos > self.nodes[self.nodes[self.node].next_node[self.s[n - self.pos]]].length:\n                self.node = self.nodes[self.node].next_node[self.s[n - self.pos]]\n                self.pos -= self.nodes[self.node].length\n\n            v = self.nodes[self.node].next_node[self.s[n - self.pos]]\n            t = self.s[self.nodes[v].spos + self.pos - 1]\n            if v == 0:\n                nl = self.add_node(n - self.pos)\n                self.nodes[self.node].next_node[self.s[n - self.pos]] = nl\n                self.nodes[last].slink = self.node\n                last = 0\n            elif t == c:\n                self.nodes[last].slink = self.node\n                return\n            else:\n                u = self.add_node(self.nodes[v].spos, self.pos - 1)\n                nl = self.add_node(n - 1)\n                self.nodes[u].next_node[c] = nl\n                self.nodes[u].next_node[t] = v\n                self.nodes[v].spos += self.pos - 1\n                self.nodes[v].length -= self.pos - 1\n\n                self.nodes[last].slink = u\n                self.nodes[self.node].next_node[self.s[n - self.pos]] = u\n                last = u\n\n            if self.node:\n                self.node = self.nodes[self.node].slink\n            else:\n                self.pos -= 1\n\n            self.nodes[self.last_leaf].slink = nl\n            self.last_leaf = nl\n\n\ndef dfs(u, d):\n    pila = [(0, u, d)]\n    while len(pila):\n        k, u, d = pila.pop()\n        if k == 0:\n            if st.nodes[u].next_node.count(0) == 28:\n                dl = d\n                for i in range(2, -1, -1):\n                    if dl <= l[i] + 1:\n                        suffs[u][i] += 1\n                        break\n                    else:\n                        dl -= l[i] + 1\n                pila.append((1, u, d))\n            else:\n                pila.append((1, u, d))\n                for v in st.nodes[u].next_node:\n                    if v:\n                        pila.append((0, v, d + st.get_len(v)))\n        else:\n            if st.nodes[u].next_node.count(0) != 28:\n                for v in st.nodes[u].next_node:\n                    if v:\n                        for i in range(3):\n                            suffs[u][i] += suffs[v][i]\n\n            nd = d - st.get_len(u) + 1\n            if nd <= ml:\n                val = 1\n                for i in range(3):\n                    val *= suffs[u][i]\n                    val %= MOD\n                resp[nd] += val\n                resp[nd] %= MOD\n\n                if d + 1 <= ml:\n                    resp[d + 1] -= val\n                    resp[d + 1] %= MOD\n\n\ns = []\nl = []\nfor _ in range(3):\n    r = raw_input()\n    s.append(r)\n    l.append(len(r))\n    s.append('{')\ns[-1] = '|'\ns = ''.join(s)\nml = min(l)\n\nst = SuffixTree(s)\nsuffs = [[0] * 3 for _ in range(len(st.nodes))]\nresp = [0] * (ml + 1)\ndfs(0, 0)\n\nfor i in range(len(resp) - 1):\n    resp[i + 1] += resp[i]\n    resp[i + 1] %= MOD\n\nprint(' '.join(map(str, resp[1:])))\n",
    "prob_desc_created_at": "1406480400",
    "tags": [
        "data structures",
        "dsu",
        "string suffix structures",
        "strings"
    ],
    "hidden_unit_tests": ""
}
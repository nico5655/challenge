{
    "prob_desc_time_limit": "6 seconds",
    "prob_desc_sample_outputs": "[\"? 1 5 2\\n\\n? 20 19 2\\n\\n! 9 10 19 7 16 18 11 14 15 6 20 8 17 4 5 3 12 2 13 1\"]",
    "src_uid": "f07c0885a2f9937787971dd1a5a91154",
    "prob_desc_notes": "NoteThe secret permutation is $$$\\{9,10,19,7,16,18,11,14,15,6,20,8,17,4,5,3,12,2,13,1\\}$$$.For the first query, the values of $$$(a,b,c)$$$ is $$$(1,5,2)$$$. Since $$$p[1]=9$$$, $$$p[5]=16$$$ and $$$p[2]=10$$$. The return value is the median of $$$\\{|9-16|,|16-10|,|9-10|\\}$$$ which is $$$6$$$.For the second query, the values of $$$(a,b,c)$$$ is $$$(20,19,2)$$$. Since $$$p[20]=1$$$, $$$p[19]=13$$$ and $$$p[2]=10$$$. The return value is the median of $$$\\{|1-13|,|13-10|,|1-10|\\}$$$ which is $$$9$$$.By some miracle, we have figured out that the secret permutation is $$$\\{9,10,19,7,16,18,11,14,15,6,20,8,17,4,5,3,12,2,13,1\\}$$$. We output it and receive $$$1$$$ from the interactor, meaning that we have guessed the secret permutation correctly.",
    "prob_desc_description": "This is an interactive problem.There is a secret permutation $$$p$$$ ($$$1$$$-indexed) of numbers from $$$1$$$ to $$$n$$$. More formally, for $$$1 \\leq i \\leq n$$$, $$$1 \\leq p[i] \\leq n$$$ and for $$$1 \\leq i &lt; j \\leq n$$$, $$$p[i] \\neq p[j]$$$. It is known that $$$p[1]&lt;p[2]$$$.In $$$1$$$ query, you give $$$3$$$ distinct integers $$$a,b,c$$$ ($$$1 \\leq a,b,c \\leq n$$$), and receive the median of $$$\\{|p[a]-p[b]|,|p[b]-p[c]|,|p[a]-p[c]|\\}$$$.In this case, the median is the $$$2$$$-nd element ($$$1$$$-indexed) of the sequence when sorted in non-decreasing order. The median of $$$\\{4,6,2\\}$$$ is $$$4$$$ and the median of $$$\\{0,123,33\\}$$$ is $$$33$$$.Can you find the secret permutation in not more than $$$2n+420$$$ queries?Note: the grader is not adaptive: the permutation is fixed before any queries are made.",
    "prob_desc_output_spec": null,
    "prob_desc_input_spec": "The first line of input contains a single integer $$$t$$$ $$$(1 \\leq t \\leq 1000)$$$ — the number of testcases. The first line of each testcase consists of a single integer $$$n$$$ $$$(20 \\leq n \\leq 100000)$$$ — the length of the secret permutation. It is guaranteed that the sum of $$$n$$$ over all test cases does not exceed $$$100000$$$.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "Python 3",
    "lang_cluster": "Python",
    "difficulty": 3000,
    "file_name": "train_105.jsonl",
    "code_uid": "2fdd2795ae336663b2cb773c7b6ef89a",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"1\\n20\\n\\n6\\n\\n9\\n\\n1\"]",
    "exec_outcome": "PASSED",
    "source_code": "import sys\nimport itertools\nimport heapq\nfrom collections import defaultdict, Counter\nfrom math import inf\n\n\ndef read():\n    v = int(input())\n    if v == -1:\n        sys.exit()\n    else:\n        assert v > 0\n        return v\n\n\ndef ask(a, b, c):\n    if c == a:\n        return -1\n    elif c == b:\n        return 0\n    print('?', a + 1, b + 1, c + 1)\n    return read()\n\n\ndef say(*args):\n    print('!', *args)\n    assert read() == 1\n\n\ndef find_king_and_prince_starting_from(a, b, *, n):\n    \"\"\"Return pair of indices (king, prince)\n\n    ...such that (p[king], p[prince]) is either (1, 2) or (n, n-1)\n    \"\"\"\n    rs = heapq.nlargest(4, ((ask(a, b, i), i) for i in range(n)))\n    mx, king = rs.pop(0)  # p[king] is either 1 or n\n    if rs[0][0] == mx:\n        rs.pop(0)  # skip other king\n    mx2, x = rs.pop(0)\n    assert mx2 == mx - 1\n    mx3, y = rs.pop(0)\n    if mx3 == mx2:\n        # set {p[x], p[y]} is equal to set {2, n-1}\n        # need to determine which of [x, y] is correct \"prince\"\n        x = min([x, y], key = lambda v: ask(king, v, a) + ask(king, v, b))\n    return king, x\n\n\ndef is_sorted(seq):\n    return tuple(seq) == tuple(sorted(seq))\n\n\ndef find_two_close_values(*, n):\n    \"\"\"Return pair of indices of any two \"close\" values.\n\n    Values p[a] and p[b] are considered \"close\" if either\n    ask(a, b, 1) or ask(a, b, n) is greater than abs(p[a] - p[b]) + 1\n    \"\"\"\n    dist = (n - 5) // 3\n    values = defaultdict(Counter)\n    minmax_value = defaultdict(lambda: (inf, -inf))\n    banned_pairs = set()\n    for (a, b, c) in itertools.combinations(range(13), 3):\n        assert is_sorted((a, b, c))\n        if any(pair in banned_pairs for pair in ((a, b), (b, c), (a, c))):\n            continue  # what you gonna do now, user14767553? ;)\n        r = ask(a, b, c)\n        if r <= dist // 2:\n            # any of (a, b), (b, c), (c, a) goes because their difference is\n            # less than or equal to (n - 5) // 3\n            return (a, b)\n        for pair in itertools.combinations((a, b, c), 2):\n            assert isinstance(pair, tuple)\n            assert is_sorted(pair)\n            values[pair][r] += 1\n            mn, mx = minmax_value.get(pair, (r, r))\n            minmax_value[pair] = (min(mn, r), max(mx, r))\n            if mx > 2*mn + 1:\n                # let (a, b) = pair. Then\n                # abs(p[a] - p[b]) <= 2*mn < mx - 1\n                return pair\n            # if ask(a, b, x) == r for at least 3 different x,\n            # then abs(p[a] - p[b]) == r\n            if values[pair][r] >= 3:\n                if r <= dist:\n                    # bingo!\n                    return pair\n                elif r > 2 * dist:\n                    banned_pairs.add(pair)\n\n    raise AssertionError\n\n\ndef solve():\n    n = read()\n    assert n >= 20\n    a, b = find_two_close_values(n=n)\n    king, prince = find_king_and_prince_starting_from(a, b, n=n)\n    rank = [ask(king, prince, i) for i in range(n)]\n    if king == 0 or (king != 1 and rank[0] < rank[1]):\n        ans = [r + 2 for r in rank]\n        assert ans[king] == 1\n        assert ans[prince] == 2\n    else:\n        ans = [n - 1 - r for r in rank]\n        assert ans[king] == n\n        assert ans[prince] == n - 1\n    say(*ans)\n\n\ndef main():\n    t = int(input())\n    for __ in range(t):\n        solve()\n\n\nif __name__ == '__main__':\n    main()\n",
    "prob_desc_created_at": "1622210700",
    "tags": [
        "constructive algorithms",
        "interactive",
        "probabilities"
    ],
    "hidden_unit_tests": ""
}
{
    "prob_desc_time_limit": "1 second",
    "prob_desc_sample_outputs": "[\"4\", \"-1\"]",
    "src_uid": "6126d9533abd466545d8153233b14192",
    "prob_desc_notes": "NoteIn the second sample test one of the progressions contains only powers of two, the other one contains only powers of three.",
    "prob_desc_description": "Geometric progression with the first element a and common ratio b is a sequence of numbers a, ab, ab2, ab3, ....You are given n integer geometric progressions. Your task is to find the smallest integer x, that is the element of all the given progressions, or else state that such integer does not exist.",
    "prob_desc_output_spec": "If the intersection of all progressions is empty, then print  - 1, otherwise print the remainder of the minimal positive integer number belonging to all progressions modulo 1000000007 (109 + 7).",
    "prob_desc_input_spec": "The first line contains integer (1 ≤ n ≤ 100) — the number of geometric progressions.  Next n lines contain pairs of integers a, b (1 ≤ a, b ≤ 109), that are the first element and the common ratio of the corresponding geometric progression.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "Python 2",
    "lang_cluster": "Python",
    "difficulty": 3200,
    "file_name": "train_034.jsonl",
    "code_uid": "06762491a581df862d3167c84537c143",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"2\\n2 2\\n4 1\", \"2\\n2 2\\n3 3\"]",
    "exec_outcome": "PASSED",
    "source_code": "\ndef primes(n):\n\tsize = n/3 + (n%6==2)\n\tplist = size * [True]\n\tplist[0] = False\n\tfor i in xrange(int(n**0.5)/3+1):\n\t\tif plist[i]:\n\t\t\tk=3*i+1|1\n\t\t\tfor j in xrange((k*k)/3,size,2*k):\n\t\t\t\tplist[j] = False\n\t\t\tfor j in xrange((k*k+4*k-2*k*(i&1))/3,size,2*k):\n\t\t\t\tplist[j] = False\n\tans = [2,3]\n\tfor i in xrange(size):\n\t\tif plist[i]:\n\t\t\tans.append(3*i+1|1)\n\treturn ans\n\ndef solve():\n\tmod = 1000000007\n\tplist = primes(31700)\n\n\tinstring = \"\"\"2\n\t2 2\n\t4 1\"\"\"\n\n\tn = int(raw_input())\n\n\talist = []\n\tblist = []\n\n\tfor i in xrange(n):\n\t\ta,b = [int(x) for x in raw_input().split()]\n\t\talist.append(a)\n\t\tblist.append(b)\n\n\t# break down the primes\n\tamaps = []\n\tbmaps = []\n\n\tfor i in xrange(n):\n\t\ta,b = alist[i], blist[i]\n\t\tamap = dict()\n\t\tbmap = dict()\n\t\tfor p in plist:\n\t\t\tif p*p > a:\n\t\t\t\tif a > 1:\n\t\t\t\t\tamap[a] = 1\n\t\t\t\t\tbmap[a] = 0\n\t\t\t\tbreak\n\t\t\tif a%p == 0:\n\t\t\t\tcount = 1\n\t\t\t\ta /= p\n\t\t\t\twhile a%p == 0:\n\t\t\t\t\tcount += 1\n\t\t\t\t\ta /= p\n\t\t\t\tamap[p] = count\n\t\t\t\tbmap[p] = 0\n\t\tfor p in plist:\n\t\t\tif p*p > b:\n\t\t\t\tif b > 1:\n\t\t\t\t\tif b not in bmap:\n\t\t\t\t\t\tamap[b] = 0\n\t\t\t\t\tbmap[b] = 1\n\t\t\t\tbreak\n\t\t\tif b%p == 0:\n\t\t\t\tcount = 1\n\t\t\t\tb /= p\n\t\t\t\twhile b%p == 0:\n\t\t\t\t\tcount += 1\n\t\t\t\t\tb /= p\n\t\t\t\tif p not in bmap:\n\t\t\t\t\tamap[p] = 0\n\t\t\t\tbmap[p] = count\n\t\tamaps.append(amap)\n\t\tbmaps.append(bmap)\n\n\t#print amaps\n\t#print bmaps\n\t\n\t# check each a, see if any works\n\tfor i in xrange(n):\n\t\ta = alist[i]\n\t\tamap = amaps[i]\n\n\t\tworks = True\n\t\tfor j in xrange(n):\n\t\t\tif alist[j] == a:\n\t\t\t\tcontinue\n\t\t\tconstrained = -1\n\t\t\tamapj = amaps[j]\n\n\t\t\tfor p in amapj:\n\t\t\t\tif p not in amap:\n\t\t\t\t\tworks = False\n\t\t\tif not works:\n\t\t\t\tbreak\n\n\t\t\tbmapj = bmaps[j]\n\n\t\t\tfor (p,c) in amap.iteritems():\n\t\t\t\tneed = c\n\t\t\t\tif p in amapj:\n\t\t\t\t\tneed -= amapj[p]\n\t\t\t\tadd = 0\n\t\t\t\tif p in bmapj:\n\t\t\t\t\tadd = bmapj[p]\n\t\t\t\tif need == 0 and add == 0:\n\t\t\t\t\tcontinue\n\t\t\t\tif need < 0 or (add==0 and need>0) or need%add != 0:\n\t\t\t\t\tworks = False\n\t\t\t\t\tbreak\n\t\t\t\tindex = need / add\n\t\t\t\tif constrained == -1:\n\t\t\t\t\tconstrained = index\n\t\t\t\telif constrained != index:\n\t\t\t\t\tworks = False\n\t\t\t\t\tbreak\n\n\t\tif works:\n\t\t\tprint a\n\t\t\treturn True\n\n\t#print \"Looks like no a works...\"\n\n\t# make sure all seqs use same primes\n\tfor i in xrange(n):\n\t\tfor j in xrange(i+1,n):\n\t\t\tif amaps[i].keys() != amaps[j].keys():\n\t\t\t\treturn False\n\n\t#print \"All them primes check out dude\"\n\n\t# look for a diff in prime alloc in two b's (ratio diff), use to solve equation\n\tpkeys = amaps[0].keys()\n\n\tfor i in xrange(len(pkeys)):\n\t\tp1 = pkeys[i]\n\t\tfor j in xrange(i+1,len(pkeys)):\n\t\t\tp2 = pkeys[j]\n\t\t\tfor k in xrange(n):\n\t\t\t\tfor l in xrange(k+1,n):\n\t\t\t\t\t#diff1 = bmaps[k][p1] - bmaps[l][p1]\n\t\t\t\t\t#diff2 = bmaps[k][p2] - bmaps[l][p2]\n\n\t\t\t\t\ta1p1 = amaps[k][p1]\n\t\t\t\t\tb1p1 = bmaps[k][p1]\n\t\t\t\t\ta1p2 = amaps[k][p2]\n\t\t\t\t\tb1p2 = bmaps[k][p2]\n\t\t\t\t\ta2p1 = amaps[l][p1]\n\t\t\t\t\tb2p1 = bmaps[l][p1]\n\t\t\t\t\ta2p2 = amaps[l][p2]\n\t\t\t\t\tb2p2 = bmaps[l][p2]\n\t\t\t\t\tq = b1p1\n\t\t\t\t\ts = b2p1\n\t\t\t\t\tr = b1p2\n\t\t\t\t\tt = b2p2\n\t\t\t\t\tc1 = a2p1 - a1p1\n\t\t\t\t\tc2 = a2p2 - a1p2\n\n\t\t\t\t\tif q*t == r*s:\n\t\t\t\t\t\tif r*c1 == q*c2:\n\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\telse:\n\t\t\t\t\t\t\treturn False\n\n\t\t\t\t\tx3 = s*r - q*t\n\t\t\t\t\tc3 = q*c2 - r*c1\n\n\t\t\t\t\tif c3 % x3 != 0:\n\t\t\t\t\t\treturn False\n\n\t\t\t\t\tsol_l = c3 / x3\n\n\t\t\t\t\t# check if it works for all sequences \n\t\t\t\t\tpmap = dict(amaps[l])\n\t\t\t\t\tfor key, value in bmaps[l].iteritems():\n\t\t\t\t\t\tpmap[key] += sol_l*value\n\n\t\t\t\t\tfor o in xrange(n):\n\t\t\t\t\t\tamap = amaps[o]\n\t\t\t\t\t\tbmap = bmaps[o]\n\t\t\t\t\t\tindex = -1\n\t\t\t\t\t\tfor key, value in pmap.iteritems():\n\t\t\t\t\t\t\tneed = value - amap[key]\n\t\t\t\t\t\t\tadd = bmap[key]\n\t\t\t\t\t\t\tif need == 0 and add == 0:\n\t\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\t\tif need < 0 or (need > 0 and add == 0):\n\t\t\t\t\t\t\t\treturn False\n\t\t\t\t\t\t\tif need % add != 0:\n\t\t\t\t\t\t\t\treturn False\n\t\t\t\t\t\t\tmustbe = need / add\n\t\t\t\t\t\t\tif index == -1:\n\t\t\t\t\t\t\t\tindex = mustbe\n\t\t\t\t\t\t\telif index != mustbe:\n\t\t\t\t\t\t\t\treturn False\n\n\t\t\t\t\tprint alist[l] * pow(blist[l],sol_l,mod) % mod\n\t\t\t\t\treturn True\n\t\t\t\t\t'''\n\t\t\t\t\tif diff1 != diff2:\n\t\t\t\t\t\tprint \"We got one!\"\n\t\t\t\t\t\t\n\t\t\t\t\t\ta1p1 = amaps[k][p1]\n\t\t\t\t\t\tb1p1 = bmaps[k][p1]\n\t\t\t\t\t\ta1p2 = amaps[k][p2]\n\t\t\t\t\t\tb1p2 = bmaps[k][p2]\n\t\t\t\t\t\ta2p1 = amaps[l][p1]\n\t\t\t\t\t\tb2p1 = bmaps[l][p1]\n\t\t\t\t\t\ta2p2 = amaps[l][p2]\n\t\t\t\t\t\tb2p2 = bmaps[l][p2]\n\t\t\t\t\t\t#print \"%d + %d*i = %d + %d*j\" % (a1p1,b1p1,a2p1,b2p1)\n\t\t\t\t\t\t#print \"%d + %d*i = %d + %d*j\" % (a1p2,b1p2,a2p2,b2p2)\n\t\t\t\t\t\tq = b1p1\n\t\t\t\t\t\ts = b2p1\n\t\t\t\t\t\tr = b1p2\n\t\t\t\t\t\tt = b2p2\n\t\t\t\t\t\tc1 = a2p1 - a1p1\n\t\t\t\t\t\tc2 = a2p2 - a1p2\n\t\t\t\t\t\t\n\t\t\t\t\t\t#print \"%d*i-%d*j = %d\" % (q,s,c1)\n\t\t\t\t\t\t#print \"%d*i-%d*j = %d\" % (r,t,c2)\n\t\t\t\t\t\tif (r*c1)%q != 0 or (r*s)%q != 0:\n\t\t\t\t\t\t\t#print \"Non integer solution to cross\"\n\t\t\t\t\t\t\treturn False\n\t\t\t\t\t\tc3 = c2 - (r*c1)/q\n\t\t\t\t\t\tx3 = (r*s)/q - t\n\t\t\t\t\t\tif c3%x3 != 0:\n\t\t\t\t\t\t\t#print \"Non integer solution to cross\"\n\t\t\t\t\t\t\treturn False\n\t\t\t\t\t\tsol_l = c3 / x3\n\t\t\t\t\t\t#print p1, p2, sol_l, (c1+s)*sol_l/q\n\n\t\t\t\t\t\t# check if it works for all sequences \n\t\t\t\t\t\tpmap = dict(amaps[l])\n\t\t\t\t\t\tfor key, value in bmaps[l].iteritems():\n\t\t\t\t\t\t\tpmap[key] += value\n\n\t\t\t\t\t\tfor o in xrange(n):\n\t\t\t\t\t\t\tamap = amaps[o]\n\t\t\t\t\t\t\tbmap = bmaps[o]\n\t\t\t\t\t\t\tindex = -1\n\t\t\t\t\t\t\tfor key, value in pmap.iteritems():\n\t\t\t\t\t\t\t\tneed = value - amap[key]\n\t\t\t\t\t\t\t\tadd = bmap[key]\n\t\t\t\t\t\t\t\tif need == 0 and add == 0:\n\t\t\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\t\t\tif need < 0 or (need > 0 and add == 0):\n\t\t\t\t\t\t\t\t\treturn False\n\t\t\t\t\t\t\t\tif need % add != 0:\n\t\t\t\t\t\t\t\t\treturn False\n\t\t\t\t\t\t\t\tmustbe = need / add\n\t\t\t\t\t\t\t\tif index == -1:\n\t\t\t\t\t\t\t\t\tindex = mustbe\n\t\t\t\t\t\t\t\telif index != mustbe:\n\t\t\t\t\t\t\t\t\treturn False\n\n\t\t\t\t\t\tprint alist[l] * pow(blist[l],sol_l,mod) % mod\n\t\t\t\t\t\treturn True\n\t\t\t\t\t\t'''\n\n\t# if no diffs, use mod sys solver\n\teea = lambda b,s,w=1,x=0,y=0,z=1:(b,w,x)if s==0 else eea(s,b%s,y,z,w-b/s*y,x-b/s*z)\n\n\tdef solve_mod_sys(eqs):\n\t\tif len(eqs) == 1: return eqs\n\t\ta,m1 = eqs.pop()\n\t\tb,m2 = eqs.pop()\n\t\tlhs,rhs = m1,b-a\n\t\tgcd, m1inv = eea(m1,m2)[:2]\n\t\tif (gcd > 1):\n\t\t\tif rhs%gcd == 0:\n\t\t\t\trhs/=gcd\n\t\t\t\tm1/=gcd\n\t\t\t\tm2/=gcd\n\t\t\t\tm1inv = eea(m1,m2)[1]\n\t\t\telse:\n\t\t\t\treturn False\n\t\trhs = m1inv*rhs%m2\n\t\tc = a + rhs*lhs\n\t\tm3 = m2*lhs\n\t\teqs.append((c,m3))\n\t\treturn solve_mod_sys(eqs)\n\n\tpkey = amaps[0].keys()[0]\n\tequations = []\n\n\tfor i in xrange(n):\n\t\tstart = amaps[i][pkey]\n\t\tstep = bmaps[i][pkey]\n\t\tequations.append((start,step))\n\n\tres = solve_mod_sys(equations)\n\tif res == False:\n\t\treturn False\n\telse:\n\t\tx,m = res[0]\n\n\tx /= bmaps[0][pkey]\n\n\tsolution = alist[0]\n\tfor p in bmaps[0]:\n\t\tsolution *= pow(p,x*bmaps[0][p],mod)\n\tprint solution % mod\n\treturn True\n\n\nif not solve():\n\tprint -1\n",
    "prob_desc_created_at": "1440261000",
    "tags": [
        "math"
    ],
    "hidden_unit_tests": ""
}
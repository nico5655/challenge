{
    "prob_desc_time_limit": "3 seconds",
    "prob_desc_sample_outputs": "[\"1 -1 -2\\n1 2 5\\n0\\n1 -100000 -100000\"]",
    "src_uid": "e86ffda4e59c87acafeb3bf0aa805a52",
    "prob_desc_notes": null,
    "prob_desc_description": "$$$n$$$ robots have escaped from your laboratory! You have to find them as soon as possible, because these robots are experimental, and their behavior is not tested yet, so they may be really dangerous!Fortunately, even though your robots have escaped, you still have some control over them. First of all, you know the location of each robot: the world you live in can be modeled as an infinite coordinate plane, and the $$$i$$$-th robot is currently located at the point having coordinates ($$$x_i$$$, $$$y_i$$$). Furthermore, you may send exactly one command to all of the robots. The command should contain two integer numbers $$$X$$$ and $$$Y$$$, and when each robot receives this command, it starts moving towards the point having coordinates ($$$X$$$, $$$Y$$$). The robot stops its movement in two cases:  either it reaches ($$$X$$$, $$$Y$$$);  or it cannot get any closer to ($$$X$$$, $$$Y$$$). Normally, all robots should be able to get from any point of the coordinate plane to any other point. Each robot usually can perform four actions to move. Let's denote the current coordinates of the robot as ($$$x_c$$$, $$$y_c$$$). Then the movement system allows it to move to any of the four adjacent points:  the first action allows it to move from ($$$x_c$$$, $$$y_c$$$) to ($$$x_c - 1$$$, $$$y_c$$$);  the second action allows it to move from ($$$x_c$$$, $$$y_c$$$) to ($$$x_c$$$, $$$y_c + 1$$$);  the third action allows it to move from ($$$x_c$$$, $$$y_c$$$) to ($$$x_c + 1$$$, $$$y_c$$$);  the fourth action allows it to move from ($$$x_c$$$, $$$y_c$$$) to ($$$x_c$$$, $$$y_c - 1$$$). Unfortunately, it seems that some movement systems of some robots are malfunctioning. For each robot you know which actions it can perform, and which it cannot perform.You want to send a command so all robots gather at the same point. To do so, you have to choose a pair of integer numbers $$$X$$$ and $$$Y$$$ so that each robot can reach the point ($$$X$$$, $$$Y$$$). Is it possible to find such a point?",
    "prob_desc_output_spec": "You should answer each query independently, in the order these queries appear in the input. To answer a query, you should do one of the following:   if it is impossible to find a point that is reachable by all $$$n$$$ robots, print one number $$$0$$$ on a separate line;  if it is possible to find a point that is reachable by all $$$n$$$ robots, print three space-separated integers on the same line: $$$1$$$ $$$X$$$ $$$Y$$$, where $$$X$$$ and $$$Y$$$ are the coordinates of the point reachable by all $$$n$$$ robots. Both $$$X$$$ and $$$Y$$$ should not exceed $$$10^5$$$ by absolute value; it is guaranteed that if there exists at least one point reachable by all robots, then at least one of such points has both coordinates not exceeding $$$10^5$$$ by absolute value.",
    "prob_desc_input_spec": "The first line contains one integer $$$q$$$ ($$$1 \\le q \\le 10^5$$$) — the number of queries. Then $$$q$$$ queries follow. Each query begins with one line containing one integer $$$n$$$ ($$$1 \\le n \\le 10^5$$$) — the number of robots in the query. Then $$$n$$$ lines follow, the $$$i$$$-th of these lines describes the $$$i$$$-th robot in the current query: it contains six integer numbers $$$x_i$$$, $$$y_i$$$, $$$f_{i, 1}$$$, $$$f_{i, 2}$$$, $$$f_{i, 3}$$$ and $$$f_{i, 4}$$$ ($$$-10^5 \\le x_i, y_i \\le 10^5$$$, $$$0 \\le f_{i, j} \\le 1$$$). The first two numbers describe the initial location of the $$$i$$$-th robot, and the following four numbers describe which actions the $$$i$$$-th robot can use to move ($$$f_{i, j} = 1$$$ if the $$$i$$$-th robot can use the $$$j$$$-th action, and $$$f_{i, j} = 0$$$ if it cannot use the $$$j$$$-th action). It is guaranteed that the total number of robots over all queries does not exceed $$$10^5$$$.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "Python 3",
    "lang_cluster": "Python",
    "difficulty": 1500,
    "file_name": "train_024.jsonl",
    "code_uid": "5162d79efdf6ed4ffb01514ed329e91c",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"4\\n2\\n-1 -2 0 0 0 0\\n-1 -2 0 0 0 0\\n3\\n1 5 1 1 1 1\\n2 5 0 1 0 1\\n3 5 1 0 0 0\\n2\\n1337 1337 0 1 1 1\\n1336 1337 1 1 0 1\\n1\\n3 5 1 1 1 1\"]",
    "exec_outcome": "PASSED",
    "source_code": "import sys \n# sys.setrecursionlimit(10**6) \nfrom sys import stdin, stdout\nimport bisect            #c++ upperbound\nimport math\nimport heapq\ndef modinv(n,p):\n    return pow(n,p-2,p)\ndef cin():\n    return map(int,sin().split())\ndef ain():                           #takes array as input\n    return list(map(int,sin().split()))\ndef sin():\n    return input()\ndef inin():\n    return int(input())\nimport math  \ndef Divisors(n) : \n    l = []  \n    for i in range(1, int(math.sqrt(n) + 1)) :\n        if (n % i == 0) : \n            if (n // i == i) : \n                l.append(i) \n            else : \n                l.append(i)\n                l.append(n//i)\n    return l\n\"\"\"*******************************************************\"\"\"\ndef main():\n    t=inin()\n    for _ in range(t):\n        n=inin()\n        x1=100000\n        y1=100000\n        x2=-100000\n        y2=-100000\n        for i in range(n):\n            a,b,c,d,e,f=cin()\n            if(c==0):\n                x2=max(x2,a)\n            if(d==0):\n                y1=min(y1,b)\n            if(e==0):\n                x1=min(x1,a)\n            if(f==0):\n                y2=max(y2,b)\n        # print(x1,x2,y1,y2)\n        if(x1>=x2 and y1>=y2):\n            if(x1>=-100000):\n                x2=x1\n            if(y1>=-100000):\n                y2=y1\n            print(1,x2,y2)\n        else:\n            print(0)\n            \n                \n            \n        \n######## Python 2 and 3 footer by Pajenegod and c1729\n \n# Note because cf runs old PyPy3 version which doesn't have the sped up\n# unicode strings, PyPy3 strings will many times be slower than pypy2.\n# There is a way to get around this by using binary strings in PyPy3\n# but its syntax is different which makes it kind of a mess to use.\n \n# So on cf, use PyPy2 for best string performance.\n \npy2 = round(0.5)\nif py2:\n    from future_builtins import ascii, filter, hex, map, oct, zip\n    range = xrange\n \nimport os, sys\nfrom io import IOBase, BytesIO\n \nBUFSIZE = 8192\nclass FastIO(BytesIO):\n    newlines = 0\n \n    def __init__(self, file):\n        self._file = file\n        self._fd = file.fileno()\n        self.writable = \"x\" in file.mode or \"w\" in file.mode\n        self.write = super(FastIO, self).write if self.writable else None\n \n    def _fill(self):\n        s = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n        self.seek((self.tell(), self.seek(0,2), super(FastIO, self).write(s))[0])\n        return s\n \n    def read(self):\n        while self._fill(): pass\n        return super(FastIO,self).read()\n \n    def readline(self):\n        while self.newlines == 0:\n            s = self._fill(); self.newlines = s.count(b\"\\n\") + (not s)\n        self.newlines -= 1\n        return super(FastIO, self).readline()\n \n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.getvalue())\n            self.truncate(0), self.seek(0)\n \nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        if py2:\n            self.write = self.buffer.write\n            self.read = self.buffer.read\n            self.readline = self.buffer.readline\n        else:\n            self.write = lambda s:self.buffer.write(s.encode('ascii'))\n            self.read = lambda:self.buffer.read().decode('ascii')\n            self.readline = lambda:self.buffer.readline().decode('ascii')\n \n \nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip('\\r\\n')\n \n# Cout implemented in Python\nimport sys\nclass ostream:\n    def __lshift__(self,a):\n        sys.stdout.write(str(a))\n        return self\ncout = ostream()\nendl = '\\n'\n \n# Read all remaining integers in stdin, type is given by optional argument, this is fast\ndef readnumbers(zero = 0):\n    conv = ord if py2 else lambda x:x\n    A = []; numb = zero; sign = 1; i = 0; s = sys.stdin.buffer.read()\n    try:\n        while True:\n            if s[i] >= b'0' [0]:\n                numb = 10 * numb + conv(s[i]) - 48\n            elif s[i] == b'-' [0]: sign = -1\n            elif s[i] != b'\\r' [0]:\n                A.append(sign*numb)\n                numb = zero; sign = 1\n            i += 1\n    except:pass\n    if s and s[-1] >= b'0' [0]:\n        A.append(sign*numb)\n    return A\n \nif __name__== \"__main__\":\n  main()",
    "prob_desc_created_at": "1563978900",
    "tags": [
        "implementation"
    ],
    "hidden_unit_tests": ""
}
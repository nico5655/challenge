{
    "prob_desc_time_limit": "3 seconds",
    "prob_desc_sample_outputs": "[\"3\", \"2\", \"2\"]",
    "src_uid": "3fb43df3a6f763f196aa514f305473e2",
    "prob_desc_notes": "NoteIn the first sample, Limak has 20 balloons initially. There are three teams with more balloons (32, 40 and 45 balloons), so Limak has the fourth place initially. One optimal strategy is: Limak gives 6 balloons away to a team with 32 balloons and weight 37, which is just enough to make them fly. Unfortunately, Limak has only 14 balloons now and he would get the fifth place. Limak gives 6 balloons away to a team with 45 balloons. Now they have 51 balloons and weight 50 so they fly and get disqualified. Limak gives 1 balloon to each of two teams with 16 balloons initially. Limak has 20 - 6 - 6 - 1 - 1 = 6 balloons. There are three other teams left and their numbers of balloons are 40, 14 and 2. Limak gets the third place because there are two teams with more balloons. In the second sample, Limak has the second place and he can't improve it.In the third sample, Limak has just enough balloons to get rid of teams 2, 3 and 5 (the teams with 81 000 000 000, 5 000 000 000 and 46 000 000 000 balloons respectively). With zero balloons left, he will get the second place (ex-aequo with team 6 and team 7).",
    "prob_desc_description": "One tradition of ACM-ICPC contests is that a team gets a balloon for every solved problem. We assume that the submission time doesn't matter and teams are sorted only by the number of balloons they have. It means that one's place is equal to the number of teams with more balloons, increased by 1. For example, if there are seven teams with more balloons, you get the eight place. Ties are allowed.You should know that it's important to eat before a contest. If the number of balloons of a team is greater than the weight of this team, the team starts to float in the air together with their workstation. They eventually touch the ceiling, what is strictly forbidden by the rules. The team is then disqualified and isn't considered in the standings.A contest has just finished. There are n teams, numbered 1 through n. The i-th team has ti balloons and weight wi. It's guaranteed that ti doesn't exceed wi so nobody floats initially.Limak is a member of the first team. He doesn't like cheating and he would never steal balloons from other teams. Instead, he can give his balloons away to other teams, possibly making them float. Limak can give away zero or more balloons of his team. Obviously, he can't give away more balloons than his team initially has.What is the best place Limak can get?",
    "prob_desc_output_spec": "Print one integer denoting the best place Limak can get.",
    "prob_desc_input_spec": "The first line of the standard input contains one integer n (2 ≤ n ≤ 300 000) — the number of teams. The i-th of n following lines contains two integers ti and wi (0 ≤ ti ≤ wi ≤ 1018) — respectively the number of balloons and the weight of the i-th team. Limak is a member of the first team.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 2",
    "lang_cluster": "Python",
    "difficulty": 1800,
    "file_name": "train_056.jsonl",
    "code_uid": "c593d233226203f808fd163a79aa16f7",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"8\\n20 1000\\n32 37\\n40 1000\\n45 50\\n16 16\\n16 16\\n14 1000\\n2 1000\", \"7\\n4 4\\n4 4\\n4 4\\n4 4\\n4 4\\n4 4\\n5 5\", \"7\\n14000000003 1000000000000000000\\n81000000000 88000000000\\n5000000000 7000000000\\n15000000000 39000000000\\n46000000000 51000000000\\n0 1000000000\\n0 0\"]",
    "exec_outcome": "PASSED",
    "source_code": "import heapq\nclass Heap(object):\n    \"\"\" A neat min-heap wrapper which allows storing items by priority\n        and get the lowest item out first (pop()).\n        Also implements the iterator-methods, so can be used in a for\n        loop, which will loop through all items in increasing priority order.\n        Remember that accessing the items like this will iteratively call\n        pop(), and hence empties the heap! \"\"\"\n\n    def __init__(self):\n        \"\"\" create a new min-heap. \"\"\"\n        self._heap = []\n\n    def push(self, priority, item=None):\n        \"\"\" Push an item with priority into the heap.\n            Priority 0 is the highest, which means that such an item will\n            be popped first.\"\"\"\n        if item==None: item=priority\n        #~ assert priority >= 0\n        heapq.heappush(self._heap, (priority, item))\n\n    def pop(self):\n        \"\"\" Returns the item with lowest priority. \"\"\"\n        item = heapq.heappop(self._heap)[1] # (prio, item)[1] == item\n        return item\n    \n    def top(self):\n        return self._heap[0][1]\n    \n    def __len__(self):\n        return len(self._heap)\n\n    def __iter__(self):\n        \"\"\" Get all elements ordered by asc. priority. \"\"\"\n        return self\n    \n    def __getitem__(self, k):\n        return self._heap[k]\n\n    def next(self):\n        \"\"\" Get all elements ordered by their priority (lowest first). \"\"\"\n        try:\n            return self.pop()\n        except IndexError:\n            raise StopIteration\n\ndef readval(typ=int):\n    return typ( raw_input() )\n\ndef readvals(typ=int):\n    return map( typ, raw_input().split() )\n\ndef testcase():\n    n = readval()\n    t0, w0 = readvals()\n    better, worse = Heap(), []\n    for i in xrange(n-1):\n        t,w = readvals()\n        if t>t0: better.push(priority=(w-t+1), item=(t,w))\n        else: worse.append((t,w))\n    worse.sort(key=lambda (t,w): -t)\n    cur_place = len(better)+1\n    best_place = cur_place\n    \n    #~ print '---'*3, cur_place, t0\n    #~ print better._heap\n    #~ print worse._heap\n    \n    idx_worse = 0\n    \n    while len(better)>0 :\n        t,w = better.pop()\n        ballons_togive = w-t+1\n        t0 -= ballons_togive\n        if t0<0: break\n        cur_place -= 1\n        \n        while idx_worse<len(worse) and worse[idx_worse][0]>t0: #len(worse)>0 and worse.top()[0]>t0:\n            t,w = worse[idx_worse]\n            better.push(priority=(w-t+1), item=(t,w))\n            cur_place += 1\n            idx_worse += 1\n        best_place = min(cur_place, best_place)\n        \n        #~ print '---'*3, cur_place, t0\n        #~ print better._heap\n        #~ print worse._heap\n    \n    print best_place\n    \n    \n    #~ def give(k): # highest rank if limak gives k ballons\n        #~ t_limak = limak[0]-k\n        #~ _teams = filter(lambda (t,w): t > t_limak, teams)\n        #~ _teams.sort(key=lambda (t,w): w-t+1)\n        #~ rank = len(_teams)+1\n        #~ for (ti,wi) in _teams:\n            #~ deltai = wi-ti+1\n            #~ if deltai>k: break\n            #~ k -= deltai\n            #~ rank -= 1\n        #~ return rank\n    \n    #~ # linear search: \n    #~ print min( [give(k) for k in xrange(limak[0])] )\n        \n        \n    \n    \n\nif __name__=='__main__':\n    testcase()\n",
    "prob_desc_created_at": "1477148700",
    "tags": [
        "data structures",
        "greedy"
    ],
    "hidden_unit_tests": ""
}
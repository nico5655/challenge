{
    "prob_desc_time_limit": "1 second",
    "prob_desc_sample_outputs": "[\"2\\n3 1 2 1\\n2 1 3\", \"1\\n6 1 1 1 1 1 1\", \"0\"]",
    "src_uid": "07bc926194f45da75e4c534a7fd3656b",
    "prob_desc_notes": "NoteExplanation of the first testcase: Initially the deck is [3 1 2 4].   The first operation splits the deck as [(3) (1 2) (4)] and then transforms it into [4 1 2 3].  The second operation splits the deck as [(4) (1 2 3)] and then transforms it into [1 2 3 4].  Explanation of the second testcase: Initially the deck is [6 5 4 3 2 1].   The first (and only) operation splits the deck as [(6) (5) (4) (3) (2) (1)] and then transforms it into [1 2 3 4 5 6]. ",
    "prob_desc_description": "You are given a deck of $$$n$$$ cards numbered from $$$1$$$ to $$$n$$$ (not necessarily in this order in the deck). You have to sort the deck by repeating the following operation.   Choose $$$2 \\le k \\le n$$$ and split the deck in $$$k$$$ nonempty contiguous parts $$$D_1, D_2,\\dots, D_k$$$ ($$$D_1$$$ contains the first $$$|D_1|$$$ cards of the deck, $$$D_2$$$ contains the following $$$|D_2|$$$ cards and so on). Then reverse the order of the parts, transforming the deck into $$$D_k, D_{k-1}, \\dots, D_2, D_1$$$ (so, the first $$$|D_k|$$$ cards of the new deck are $$$D_k$$$, the following $$$|D_{k-1}|$$$ cards are $$$D_{k-1}$$$ and so on). The internal order of each packet of cards $$$D_i$$$ is unchanged by the operation. You have to obtain a sorted deck (i.e., a deck where the first card is $$$1$$$, the second is $$$2$$$ and so on) performing at most $$$n$$$ operations. It can be proven that it is always possible to sort the deck performing at most $$$n$$$ operations.Examples of operation: The following are three examples of valid operations (on three decks with different sizes).   If the deck is [3 6 2 1 4 5 7] (so $$$3$$$ is the first card and $$$7$$$ is the last card), we may apply the operation with $$$k=4$$$ and $$$D_1=$$$[3 6], $$$D_2=$$$[2 1 4], $$$D_3=$$$[5], $$$D_4=$$$[7]. Doing so, the deck becomes [7 5 2 1 4 3 6].  If the deck is [3 1 2], we may apply the operation with $$$k=3$$$ and $$$D_1=$$$[3], $$$D_2=$$$[1], $$$D_3=$$$[2]. Doing so, the deck becomes [2 1 3].  If the deck is [5 1 2 4 3 6], we may apply the operation with $$$k=2$$$ and $$$D_1=$$$[5 1], $$$D_2=$$$[2 4 3 6]. Doing so, the deck becomes [2 4 3 6 5 1]. ",
    "prob_desc_output_spec": "On the first line, print the number $$$q$$$ of operations you perform (it must hold $$$0\\le q\\le n$$$). Then, print $$$q$$$ lines, each describing one operation. To describe an operation, print on a single line the number $$$k$$$ of parts you are going to split the deck in, followed by the size of the $$$k$$$ parts: $$$|D_1|, |D_2|, \\dots , |D_k|$$$.  It must hold $$$2\\le k\\le n$$$, and $$$|D_i|\\ge 1$$$ for all $$$i=1,\\dots,k$$$, and $$$|D_1|+|D_2|+\\cdots + |D_k| = n$$$. It can be proven that it is always possible to sort the deck performing at most $$$n$$$ operations. If there are several ways to sort the deck you can output any of them.",
    "prob_desc_input_spec": "The first line of the input contains one integer $$$n$$$ ($$$1\\le n\\le 52$$$)  — the number of cards in the deck. The second line contains $$$n$$$ integers $$$c_1, c_2, \\dots, c_n$$$  — the cards in the deck. The first card is $$$c_1$$$, the second is $$$c_2$$$ and so on. It is guaranteed that for all $$$i=1,\\dots,n$$$ there is exactly one $$$j\\in\\{1,\\dots,n\\}$$$ such that $$$c_j = i$$$.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 2",
    "lang_cluster": "Python",
    "difficulty": 2000,
    "file_name": "train_005.jsonl",
    "code_uid": "de7bd33643a7d1b071812e94af3c2121",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"4\\n3 1 2 4\", \"6\\n6 5 4 3 2 1\", \"1\\n1\"]",
    "exec_outcome": "PASSED",
    "source_code": "from collections import Counter, defaultdict, deque\nimport bisect\nfrom sys import stdin, stdout\nfrom itertools import repeat\nimport math\n\n# sys.stdin = open('input')\n\ndef mod(x, y, mod):\n    re = 1\n    now = x\n    while y:\n        if y&1:\n            re *= now\n            re %= mod\n        y >>= 1\n        now = (now*now)%mod\n    return re\n\ndef inp(force_list=False):\n    re = map(int, raw_input().split())\n    if len(re) == 1 and not force_list:\n        return re[0]\n    return re\n\ndef inst():\n    return raw_input().strip()\n\ndef gcd(x, y):\n   while(y):\n       x, y = y, x % y\n   return x\n\nMOD = int(1e9+7)\n\ndef query(ty, num):\n    if ty==0:\n        print 'A %d' % num\n    else:\n        print 'B %d' % num\n    stdout.flush()\n    return inp()\n\ndef my_main():\n    T = 1\n    ans = []\n    for _ in range(T):\n        n = inp()\n        da = inp(True)\n        op = []\n        st = 0\n        l = 1\n        nl = 0\n        mid = n/2+1+n%2\n        nm = 0\n        for i in range(n-n%2):\n            if st==0:\n                idx = da.index(mid)\n                da = da[n-nm:] + da[idx:n-nm] +  da[nl:idx] + da[0:nl]\n                tmpp = filter(lambda x: x!=0, (nl-0, idx-nl, n-nm-idx, n-n+nm))\n                len(tmpp) > 1 and ans.append(tmpp)\n                mid += 1\n                nm += 1\n            else:\n                idx = da.index(l)\n                da = da[n-nl:] + da[idx:n-nl] + da[nm:idx] + da[0:nm]\n                tmpp = filter(lambda x: x!=0, (nm-0, idx-nm, n-nl-idx, n-n+nl))\n                len(tmpp) > 1 and ans.append(tmpp)\n                l += 1\n                nl += 1\n            # print da, tmpp\n            # print l, mid,'kkk',st\n            st ^= 1\n        print len(ans)\n        for iq in ans:\n            iq = filter(lambda x: x!=0, iq)\n            print len(iq), ' '.join(map(str, iq))\n\n\n\n\n\n\n\n\n\n\nmy_main()\n",
    "prob_desc_created_at": "1602341400",
    "tags": [
        "constructive algorithms",
        "implementation"
    ],
    "hidden_unit_tests": ""
}
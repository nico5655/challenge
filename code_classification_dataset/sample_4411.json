{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"YES\\nYES\\nNO\\nYES\\nNO\\nYES\"]",
    "src_uid": "4de6411fbc7a8018844bd8e0e13638f2",
    "prob_desc_notes": "NoteIn the first test case, you control the slime at position $$$4$$$ with health $$$6$$$. One way to escape is to absorb the slimes at positions $$$5$$$, $$$6$$$, and $$$7$$$. Your slime escapes with $$$0$$$ health at position $$$8$$$.In the second test case, you control the slime with $$$232$$$ health at position $$$1$$$. Since your slime is already located next to the escape at position $$$0$$$, you can move to it without absorbing any slime.In the third test case, it can be shown that your slime would always have a negative health before reaching any one of two escapes.In the fourth test case, you control the slime at position $$$4$$$ with health $$$6$$$. The following describes a possible sequence of moves to win:  Absorb the slimes at positions $$$5$$$, $$$6$$$, and $$$7$$$: your health becomes $$$4$$$ after absorbing the slime with health $$$-2$$$; becomes $$$1$$$ after absorbing the slime with health $$$-3$$$; and becomes $$$7$$$ after absorbing the slime with health $$$6$$$.  Absorb the slimes at positions $$$3$$$, and $$$2$$$: your health becomes $$$7-7+10=10$$$.  Absorb the slime at position $$$8$$$: your health becomes $$$10-10=0$$$.  Use the escape at position $$$9$$$. Since your slime has maintained non-negative health at all times, you have won.",
    "prob_desc_description": "You are playing a game called Slime Escape. The game takes place on a number line. Initially, there are $$$n$$$ slimes. For all positive integers $$$i$$$ where $$$1 \\le i \\le n$$$, the $$$i$$$-th slime is located at position $$$i$$$ and has health $$$a_i$$$. You are controlling the slime at position $$$k$$$. There are two escapes located at positions $$$0$$$ and $$$n+1$$$. Your goal is to reach any one of the two escapes by performing any number of game moves.In one game move, you move your slime to the left or right by one position. However, if there is another slime in the new position, you must absorb it. When absorbing a slime, the health of your slime would be increased by the health of the absorbed slime, then the absorbed slime would be removed from the game.Note that some slimes might have negative health, so your health would decrease when absorbing such slimes. You lose the game immediately if your slime has negative health at any moment during the game.Can you reach one of two escapes by performing any number of game moves, without ever losing the game?",
    "prob_desc_output_spec": "For each test case, print \"YES\" (without quotes) if you can escape without losing, and \"NO\" (without quotes) otherwise.",
    "prob_desc_input_spec": "Each test contains multiple test cases. The first line contains a single integer $$$t$$$ ($$$1 \\leq t \\leq 20\\,000$$$) — the number of test cases. Description of the test cases follows. The first line of each test case contains two positive integers $$$n$$$, $$$k$$$ ($$$3 \\leq n \\leq 200\\,000$$$, $$$1 \\leq k \\leq n$$$) — the number of slimes and the position of your slime. The second line of each test case contains $$$n$$$ integers, $$$a_1, a_2, \\ldots, a_n$$$ ($$$-10^9 \\leq a_i \\leq 10^9$$$) — the health of the slimes. It is guaranteed that health of your slime is non-negative ($$$a_k \\geq 0$$$), and all other slimes have non-zero health ($$$a_i \\ne 0$$$ for $$$i \\ne k$$$). It is guaranteed that the sum of $$$n$$$ over all test cases does not exceed $$$200\\,000$$$.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3-64",
    "lang_cluster": "Python",
    "difficulty": 1800,
    "file_name": "train_097.jsonl",
    "code_uid": "b71d0636b144e0a66fc6dafba5167da4",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"6\\n\\n7 4\\n\\n-1 -2 -3 6 -2 -3 -1\\n\\n3 1\\n\\n232 -500 -700\\n\\n7 4\\n\\n-1 -2 -4 6 -2 -4 -1\\n\\n8 4\\n\\n-100 10 -7 6 -2 -3 6 -10\\n\\n8 2\\n\\n-999 0 -2 3 4 5 6 7\\n\\n7 3\\n\\n7 3 3 4 2 1 1\"]",
    "exec_outcome": "PASSED",
    "source_code": "import sys\r\ninput = sys.stdin.readline\r\n\r\ndef solve():\r\n    n, k = list(map(int, input().split()))\r\n    a = list(map(int, input().split()))\r\n    k -= 1\r\n    ls, rs = a[:k][::-1], a[k + 1:]\r\n    # 把连续的合并，变成[最大代价，最终收益]的形式\r\n    ls2, rs2 = [], []\r\n\r\n    # left\r\n    score, minScore = 0, 0\r\n    for aa in ls:\r\n        if score + aa >= 0:\r\n            score += aa\r\n            ls2.append([minScore, score])\r\n            # init\r\n            score, minScore = 0, 0\r\n        else:\r\n            score += aa\r\n            minScore = min(minScore, score)\r\n    if score != 0 or minScore != 0:\r\n        ls2.append([minScore, score])\r\n\r\n    # right\r\n    score, minScore = 0, 0\r\n    for aa in rs:\r\n        if score + aa >= 0:\r\n            score += aa\r\n            rs2.append([minScore, score])\r\n            # init\r\n            score, minScore = 0, 0\r\n        else:\r\n            score += aa\r\n            minScore = min(minScore, score)\r\n    if score != 0 or minScore != 0:\r\n        rs2.append([minScore, score])\r\n\r\n\r\n    # 根据rs2和ls2左右弹跳\r\n    #print(ls2)\r\n    #print(rs2)\r\n    ml, mr = len(ls2), len(rs2)\r\n    i, j = 0, 0\r\n    curr = a[k]\r\n    while i < ml and j < mr:\r\n        if curr + ls2[i][0] >= 0:\r\n            curr += ls2[i][1]\r\n            i += 1\r\n        elif curr + rs2[j][0] >= 0:\r\n            curr += rs2[j][1]\r\n            j += 1\r\n        else:\r\n            break\r\n\r\n    if i == ml or j == mr:\r\n        print('YES')\r\n    else:\r\n        print('NO')\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nif __name__ == '__main__':\r\n    for _ in range(int(input())):\r\n        solve()",
    "prob_desc_created_at": "1663934700",
    "tags": [
        "data structures",
        "dp",
        "greedy",
        "two pointers"
    ],
    "hidden_unit_tests": ""
}
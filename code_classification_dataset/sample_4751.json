{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"1 1 1\", \"3 3\", \"6 12\"]",
    "src_uid": "ea8f191447a4089e211a17bccced97dc",
    "prob_desc_notes": "NoteIn the second example, there are $$$3$$$ sequences he can get after $$$1$$$ swap, because there are $$$3$$$ pairs of cubes he can swap. Also, there are $$$3$$$ sequences he can get after $$$2$$$ swaps:  $$$[1,2,3]$$$,  $$$[3,1,2]$$$,  $$$[2,3,1]$$$. ",
    "prob_desc_description": "This time around, Baby Ehab will play with permutations. He has $$$n$$$ cubes arranged in a row, with numbers from $$$1$$$ to $$$n$$$ written on them. He'll make exactly $$$j$$$ operations. In each operation, he'll pick up $$$2$$$ cubes and switch their positions.He's wondering: how many different sequences of cubes can I have at the end? Since Baby Ehab is a turbulent person, he doesn't know how many operations he'll make, so he wants the answer for every possible $$$j$$$ between $$$1$$$ and $$$k$$$.",
    "prob_desc_output_spec": "Print $$$k$$$ space-separated integers. The $$$i$$$-th of them is the number of possible sequences you can end up with if you do exactly $$$i$$$ operations. Since this number can be very large, print the remainder when it's divided by $$$10^9+7$$$.",
    "prob_desc_input_spec": "The only line contains $$$2$$$ integers $$$n$$$ and $$$k$$$ ($$$2 \\le n \\le 10^9$$$, $$$1 \\le k \\le 200$$$) — the number of cubes Baby Ehab has, and the parameter $$$k$$$ from the statement.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3-64",
    "lang_cluster": "Python",
    "difficulty": 2500,
    "file_name": "train_105.jsonl",
    "code_uid": "78434fdd87735cbc678c84b3033d3040",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"2 3\", \"3 2\", \"4 2\"]",
    "exec_outcome": "PASSED",
    "source_code": "import os,sys\r\nfrom random import randint\r\nfrom io import BytesIO, IOBase\r\n\r\nfrom collections import defaultdict,deque,Counter\r\nfrom bisect import bisect_left,bisect_right\r\nfrom heapq import heappush,heappop\r\nfrom functools import lru_cache\r\nfrom itertools import accumulate\r\nimport math\r\n\r\n# Fast IO Region\r\nBUFSIZE = 8192\r\nclass FastIO(IOBase):\r\n    newlines = 0\r\n    def __init__(self, file):\r\n        self._fd = file.fileno()\r\n        self.buffer = BytesIO()\r\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\r\n        self.write = self.buffer.write if self.writable else None\r\n    def read(self):\r\n        while True:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            if not b:\r\n                break\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines = 0\r\n        return self.buffer.read()\r\n    def readline(self):\r\n        while self.newlines == 0:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            self.newlines = b.count(b\"\\n\") + (not b)\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines -= 1\r\n        return self.buffer.readline()\r\n    def flush(self):\r\n        if self.writable:\r\n            os.write(self._fd, self.buffer.getvalue())\r\n            self.buffer.truncate(0), self.buffer.seek(0)\r\nclass IOWrapper(IOBase):\r\n    def __init__(self, file):\r\n        self.buffer = FastIO(file)\r\n        self.flush = self.buffer.flush\r\n        self.writable = self.buffer.writable\r\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\r\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\r\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\r\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\r\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\r\n\r\n\r\n# for _ in range(int(input())):\r\n#     n = int(input())\r\n#     a = list(map(int, input().split()))\r\n\r\n# for _ in range(int(input())):\r\n#     n, k = list(map(int, input().split()))\r\n#     a = list(map(int, input().split()))\r\n#     i = 0\r\n#     while i < n - 1 and k > 0:\r\n#         if a[i] > 0:\r\n#             a[i] -= 1\r\n#             a[-1] += 1\r\n#             k -= 1\r\n#         else:\r\n#             i += 1\r\n#     print(*a)\r\n\r\n# for _ in range(int(input())):\r\n#     def solve():\r\n#         n = int(input())\r\n#         a = list(map(int, input().split()))\r\n#         tot = 0\r\n#         for i in range(n):\r\n#             tot ^= a[i]\r\n#         if tot == 0:\r\n#             print('YES')\r\n#             return\r\n#         res = 0\r\n#         for i in range(n):\r\n#             res ^= a[i]\r\n#             if res == tot:\r\n#                 l = i\r\n#                 break\r\n#         res = 0\r\n#         for i in range(n)[::-1]:\r\n#             res ^= a[i]\r\n#             if res == tot:\r\n#                 r = i\r\n#                 break\r\n#         if l < r:\r\n#             print('YES')\r\n#         else:\r\n#             print('NO')\r\n#     solve()\r\n\r\n# def solve():\r\n#     n = int(input())\r\n#     a = list(map(int, input().split()))\r\n#     if sum(a) % 2:\r\n#         print(0)\r\n#         return\r\n#     b = sorted(a)\r\n#     s = set([0])\r\n#     for i in range(n):\r\n#         news = set()\r\n#         for j in s:\r\n#             news.add(j)\r\n#             news.add(j + a[i])\r\n#         s = news\r\n#     if sum(a) // 2 not in s:\r\n#         print(0)\r\n#         return\r\n#     for _ in range(40):\r\n#         for i in range(n):\r\n#             if a[i] % 2 == 1:\r\n#                 print(1)\r\n#                 print(i + 1)\r\n#                 return\r\n#             a[i] //= 2\r\n# solve()\r\n\r\nmod = 10 ** 9 + 7\r\nN = 410\r\nc = [[0] * N for _ in range(N)]\r\nfor i in range(N):\r\n    c[i][0] = c[i][i] = 1\r\nfor i in range(1, N):\r\n    for j in range(1, i):\r\n        c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % mod\r\n\r\nn, k = list(map(int, input().split()))\r\nf = [[0] * (k + 1) for _ in range(2 * k + 1)]\r\nfor i in range(1, 2 * k + 1):\r\n    f[i][0] = 1\r\n    for j in range(1, k + 1):\r\n        f[i][j] = (f[i - 1][j] + (i - 1) * f[i - 1][j - 1]) % mod\r\n\r\ng = [[0] * (k + 1) for _ in range(2 * k + 1)]\r\nfor j in range(k + 1):\r\n    for i in range(min(n, 2 * j) + 1):\r\n        for l in range(i + 1):\r\n            if l % 2 == 0:\r\n                g[i][j] += c[i][l] * f[i - l][j]\r\n            else:\r\n                g[i][j] -= c[i][l] * f[i - l][j]\r\n            g[i][j] %= mod\r\n\r\nans = [0] * (k + 1)\r\nans[0] = 1\r\nfor i in range(1, k + 1):\r\n    w = 1\r\n    for j in range(min(n, 2 * i) + 1):\r\n        ans[i] += w * g[j][i] % mod\r\n        ans[i] %= mod\r\n        w *= (n - j) * pow(j + 1, mod - 2, mod) % mod\r\n        w %= mod\r\nfor i in range(2, k + 1):\r\n    ans[i] = (ans[i] + ans[i - 2]) % mod\r\nprint(*ans[1:])\r\n\r\n\r\n\r\n\r\n",
    "prob_desc_created_at": "1619012100",
    "tags": [
        "combinatorics",
        "dp",
        "math"
    ],
    "hidden_unit_tests": ""
}
{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"2 2 3\\n\\n2 20 30\\n\\n3 5 7 9\"]",
    "src_uid": "fff0deb3f5f2df8935684abfe07c31bf",
    "prob_desc_notes": "NoteIn the first example the number $$$5$$$ is hidden.",
    "prob_desc_description": "This problem is interactive.You should guess hidden number $$$x$$$ which is between $$$1$$$ and $$$M = 10004205361450474$$$, inclusive.You could use up to $$$5$$$ queries.In each query, you can output an increasing sequence of $$$k \\leq x$$$ integers, each between $$$1$$$ and $$$M$$$, inclusive, and you will obtain one of the following as an answer:  either the hidden number belongs to your query sequence, in this case you immediately win;  or you will be given where the hidden number is located with respect to your query sequence, that is, either it is less than all numbers from the sequence, greater than all numbers from the sequence, or you will be given such an $$$i$$$ that the hidden number $$$x$$$ is between the $$$i$$$-th and the $$$(i+1)$$$-st numbers of your sequence. See the interaction section for clarity.Be aware that the interactor is adaptive, i.e. the hidden number can depend on queries the solution makes. However, it is guaranteed that for any solution the interactor works non-distinguishable from the situation when the hidden number is fixed beforehand.Hacks are allowed only with fixed hidden number. A hack is represented by a single integer between $$$1$$$ and $$$M$$$. In all pretests the hidden number is fixed as well.",
    "prob_desc_output_spec": null,
    "prob_desc_input_spec": null,
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "Python 3",
    "lang_cluster": "Python",
    "difficulty": 3000,
    "file_name": "train_002.jsonl",
    "code_uid": "9289ff0759d3d25353f8ddb841fc10e1",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"2\\n\\n0\\n\\n-1\"]",
    "exec_outcome": "PASSED",
    "source_code": "from math import *\nfrom sys import stdout\nimport os\n\n\ndef get_5th():\n    return 1\n\ndef full_5th(k):\n    return min(10000, k)\n\ndef get_4th():\n    now = 1\n    now = now + get_5th()\n    now = now + full_5th(now + 1)\n    return now\n\ndef full_4th(k):\n    if k>=10000:\n        return 10000*(10000+1) + 10000\n    now_seg = full_5th(k)\n    ret = k\n    seg_point = k -1\n    for i in range(k+1):\n        ret = ret + now_seg\n        seg_point = seg_point + now_seg + 1\n        now_seg = full_5th(seg_point + 1)\n    return ret\n\ndef get_3rd():\n    now = 1\n    now = now + get_4th()\n    now = now + full_4th(now + 1)\n    return now\n       \ndef full_3rd(k):\n    if k>=10000:\n        return full_4th(k)*(10000 + 1) + 10000\n    now_seg = full_4th(k)\n    ret = k\n    seg_point = k -1\n    for i in range(k+1):\n        ret = ret + now_seg\n        seg_point = seg_point + now_seg + 1\n        now_seg = full_4th(seg_point + 1)\n    return ret\n\ndef get_2nd():\n    now = 1\n    now = now + get_3rd()\n    now = now + full_3rd(now + 1)\n    return now\n\ndef full_2nd(k):\n    if k>=10000:\n        return full_3rd(k)*(10000 + 1) + 10000\n    now_seg = full_3rd(k)\n    ret = k\n    seg_point = k -1\n    for i in range(k+1):\n        ret = ret + now_seg\n        seg_point = seg_point +now_seg + 1\n        now_seg = full_3rd(seg_point + 1)\n    return ret\n\n\ndef get_1st():\n    now = 1\n    now = now + get_2nd()\n    now = now + full_2nd(now + 1)\n    return now\n\ndef get_list(l, full, one):\n    if l == 1:\n        return [1 + one()]\n    point_num = min(l, 10000)\n    ret = []\n    now_seg = full(l)\n    seg_point = l - 1\n    for i in range(point_num):\n       seg_point = seg_point + now_seg + 1\n       ret.append(seg_point)\n       now_seg = full(seg_point + 1)\n    return ret\n\n\n\ndef output(lis):\n    n = len(lis)\n    out = \"%d \"%(n)\n    for idx, x in enumerate(lis):\n        out = out + \"%d \"%x\n\n    test = None\n    if test == None:\n        print(\"%s\\n\"%out)\n        stdout.flush()\n        pt = int(input())\n    else :\n        pt = n\n        for idx, x in enumerate(lis):\n            if test == x:\n                pt = -1\n                break\n            if test < x:\n                pt = idx\n                break\n        if pt == -1:\n            l,r = -1,-1\n        elif pt == n:\n            l,r = lis[n-1], -1\n        elif pt == 0:\n            l,r = -1, lis[0]\n        else :\n            l,r = lis[pt-1],lis[pt]\n        print(pt,l,r)\n    if pt != -1:\n        return 1 if pt == 0 else lis[pt-1] + 1\n    return pt\n\ndef check(l, now):\n    temp = output(now)\n    if temp == -1:\n        os._exit(0)\n    ret =  max(l, temp)\n    return ret\n\nif __name__ == '__main__':\n\n    l,r = 1, 10004205361450474\n\n    #first query\n    now = get_list(l,full_2nd, get_2nd) \n    l = check(l, now)\n    #second query\n    now = get_list(l, full_3rd, get_3rd)\n    l = check(l, now)\n    \n    #3rd query\n    now = get_list(l, full_4th, get_4th)\n    l = check(l, now)\n\n    #4th query\n    now = get_list(l, full_5th, get_5th)\n    l = check(l, now)\n\n    #5th query\n    output([x+l for x in range(min(l, 10000))])\n    \n        \n    \n\n\n\n\n",
    "prob_desc_created_at": "1535387700",
    "tags": [
        "dp",
        "interactive"
    ],
    "hidden_unit_tests": ""
}
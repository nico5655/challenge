{
    "prob_desc_time_limit": "1 second",
    "prob_desc_sample_outputs": "[\"3\\n1\\n4\\n4\\n5\"]",
    "src_uid": "f4479bff71a45efdaa42729de64eb10f",
    "prob_desc_notes": "NoteIn the first test case, it is optimal to change the value of $$$a_2$$$ to $$$-2$$$ in one operation.The resulting array $$$a$$$ will be $$$[2,-2,1,-1,0]$$$, with a score of $$$3$$$:  $$$a_1+a_2=2-2=0$$$;  $$$a_1+a_2+a_3+a_4=2-2+1-1=0$$$;  $$$a_1+a_2+a_3+a_4+a_5=2-2+1-1+0=0$$$. In the second test case, it is optimal to change the value of $$$a_3$$$ to $$$-2\\,000\\,000\\,000$$$, giving us an array with a score of $$$1$$$.In the third test case, it is not necessary to perform any operations.",
    "prob_desc_description": "The score of an array $$$v_1,v_2,\\ldots,v_n$$$ is defined as the number of indices $$$i$$$ ($$$1 \\le i \\le n$$$) such that $$$v_1+v_2+\\ldots+v_i = 0$$$.You are given an array $$$a_1,a_2,\\ldots,a_n$$$ of length $$$n$$$. You can perform the following operation multiple times:  select an index $$$i$$$ ($$$1 \\le i \\le n$$$) such that $$$a_i=0$$$;  then replace $$$a_i$$$ by an arbitrary integer.  What is the maximum possible score of $$$a$$$ that can be obtained by performing a sequence of such operations?",
    "prob_desc_output_spec": "For each test case, print the maximum possible score of the array $$$a$$$ after performing a sequence of operations.",
    "prob_desc_input_spec": "Each test contains multiple test cases. The first line contains a single integer $$$t$$$ ($$$1 \\le t \\le 10^4$$$) — the number of test cases. The first line of each test case contains one integer $$$n$$$ ($$$1 \\le n \\le 2 \\cdot 10^5$$$) — the length of the array $$$a$$$. The second line of each test case contains $$$n$$$ integers $$$a_1,a_2,\\ldots,a_n$$$ ($$$-10^9 \\le a_i \\le 10^9$$$) — array $$$a$$$. It is guaranteed that the sum of $$$n$$$ over all test cases does not exceed $$$2 \\cdot 10^5$$$.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3-64",
    "lang_cluster": "Python",
    "difficulty": 1600,
    "file_name": "train_083.jsonl",
    "code_uid": "815f33eeab14557e982d2fcb959f35a1",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"5\\n\\n5\\n\\n2 0 1 -1 0\\n\\n3\\n\\n1000000000 1000000000 0\\n\\n4\\n\\n0 0 0 0\\n\\n8\\n\\n3 0 2 -10 10 -30 30 0\\n\\n9\\n\\n1 0 0 1 -1 0 1 0 -1\"]",
    "exec_outcome": "PASSED",
    "source_code": "import random, sys, os, math, threading, gc\r\nfrom collections import Counter, defaultdict, deque\r\nfrom functools import lru_cache, reduce, cmp_to_key\r\nfrom itertools import accumulate, combinations, permutations, product\r\nfrom heapq import nsmallest, nlargest, heapify, heappop, heappush\r\nfrom io import BytesIO, IOBase\r\nfrom copy import deepcopy\r\nfrom bisect import bisect_left, bisect_right, insort, insort_left, insort_right\r\nfrom math import factorial, ceil, floor, gcd\r\nfrom operator import mul, xor\r\nfrom types import GeneratorType\r\n# sys.setrecursionlimit(2*10**5)\r\nBUFSIZE = 8192\r\nMOD = 10**9 + 7\r\nMODD = 998244353\r\nINF = float('inf')\r\nD4 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\r\nD8 = [(1, 0), (1, 1), (0, 1), (-1, 1), (-1, 0), (-1, -1), (0, -1), (1, -1)]\r\n\r\ndef solve():\r\n    n = II()\r\n    arr = LII()\r\n    ans = 0\r\n    s = sum(arr)\r\n    d = defaultdict(int)\r\n    for i in arr[::-1]:\r\n        d[s] += 1\r\n        if i == 0:\r\n            ans += max(d.values())\r\n            d.clear()\r\n        else:\r\n            s -= i\r\n    ans += d[0]\r\n    print(ans)\r\n\r\n    \r\n    return\r\n\r\ndef main():\r\n    t = 1\r\n    t = II()\r\n    for _ in range(t):\r\n        solve()\r\n\r\ndef bootstrap(f, stack=[]):\r\n    def wrappedfunc(*args, **kwargs):\r\n        if stack:\r\n            return f(*args, **kwargs)\r\n        else:\r\n            to = f(*args, **kwargs)\r\n            while True:\r\n                if type(to) is GeneratorType:\r\n                    stack.append(to)\r\n                    to = next(to)\r\n                else:\r\n                    stack.pop()\r\n                    if not stack:\r\n                        break\r\n                    to = stack[-1].send(to)\r\n            return to\r\n    return wrappedfunc\r\n\r\ndef bitcnt(n):\r\n    c = (n & 0x5555555555555555) + ((n >> 1) & 0x5555555555555555)\r\n    c = (c & 0x3333333333333333) + ((c >> 2) & 0x3333333333333333)\r\n    c = (c & 0x0F0F0F0F0F0F0F0F) + ((c >> 4) & 0x0F0F0F0F0F0F0F0F)\r\n    c = (c & 0x00FF00FF00FF00FF) + ((c >> 8) & 0x00FF00FF00FF00FF)\r\n    c = (c & 0x0000FFFF0000FFFF) + ((c >> 16) & 0x0000FFFF0000FFFF)\r\n    c = (c & 0x00000000FFFFFFFF) + ((c >> 32) & 0x00000000FFFFFFFF)\r\n    return c\r\n\r\ndef lcm(x, y):\r\n    return x * y // gcd(x, y)\r\n\r\ndef lowbit(x):\r\n    return x & -x\r\n\r\n@bootstrap\r\ndef exgcd(a: int, b: int):\r\n    if b == 0:\r\n        d, x, y = a, 1, 0\r\n    else:\r\n        (d, p, q) = yield exgcd(b, a % b)\r\n        x = q\r\n        y = p - q * (a // b)\r\n \r\n    yield d, x, y\r\n\r\ndef perm(n, r):\r\n    return factorial(n) // factorial(n - r) if n >= r else 0\r\n \r\ndef comb(n, r):\r\n    return factorial(n) // (factorial(r) * factorial(n - r)) if n >= r else 0\r\n\r\ndef probabilityMod(x, y, mod):\r\n    return x * pow(y, mod-2, mod) % mod\r\n\r\nclass UnionFind:\r\n    def __init__(self, n):\r\n        self.parent = list(range(n))\r\n        self.size = [1] * n\r\n        self.part = n\r\n\r\n    @bootstrap\r\n    def find(self, i):\r\n        if self.parent[i] != i:\r\n            self.parent[i] = yield self.find(self.parent[i])\r\n        yield self.parent[i]\r\n\r\n    def union(self, i, j):\r\n        x, y = self.find(i), self.find(j)\r\n        if x != y:\r\n            self.size[y] += self.size[x]\r\n            self.parent[x] = self.parent[y]\r\n            self.part -= 1\r\n\r\nclass SortedList:\r\n    def __init__(self, iterable=[], _load=200):\r\n        \"\"\"Initialize sorted list instance.\"\"\"\r\n        values = sorted(iterable)\r\n        self._len = _len = len(values)\r\n        self._load = _load\r\n        self._lists = _lists = [values[i:i + _load] for i in range(0, _len, _load)]\r\n        self._list_lens = [len(_list) for _list in _lists]\r\n        self._mins = [_list[0] for _list in _lists]\r\n        self._fen_tree = []\r\n        self._rebuild = True\r\n \r\n    def _fen_build(self):\r\n        \"\"\"Build a fenwick tree instance.\"\"\"\r\n        self._fen_tree[:] = self._list_lens\r\n        _fen_tree = self._fen_tree\r\n        for i in range(len(_fen_tree)):\r\n            if i | i + 1 < len(_fen_tree):\r\n                _fen_tree[i | i + 1] += _fen_tree[i]\r\n        self._rebuild = False\r\n \r\n    def _fen_update(self, index, value):\r\n        \"\"\"Update `fen_tree[index] += value`.\"\"\"\r\n        if not self._rebuild:\r\n            _fen_tree = self._fen_tree\r\n            while index < len(_fen_tree):\r\n                _fen_tree[index] += value\r\n                index |= index + 1\r\n \r\n    def _fen_query(self, end):\r\n        \"\"\"Return `sum(_fen_tree[:end])`.\"\"\"\r\n        if self._rebuild:\r\n            self._fen_build()\r\n \r\n        _fen_tree = self._fen_tree\r\n        x = 0\r\n        while end:\r\n            x += _fen_tree[end - 1]\r\n            end &= end - 1\r\n        return x\r\n \r\n    def _fen_findkth(self, k):\r\n        \"\"\"Return a pair of (the largest `idx` such that `sum(_fen_tree[:idx]) <= k`, `k - sum(_fen_tree[:idx])`).\"\"\"\r\n        _list_lens = self._list_lens\r\n        if k < _list_lens[0]:\r\n            return 0, k\r\n        if k >= self._len - _list_lens[-1]:\r\n            return len(_list_lens) - 1, k + _list_lens[-1] - self._len\r\n        if self._rebuild:\r\n            self._fen_build()\r\n \r\n        _fen_tree = self._fen_tree\r\n        idx = -1\r\n        for d in reversed(range(len(_fen_tree).bit_length())):\r\n            right_idx = idx + (1 << d)\r\n            if right_idx < len(_fen_tree) and k >= _fen_tree[right_idx]:\r\n                idx = right_idx\r\n                k -= _fen_tree[idx]\r\n        return idx + 1, k\r\n \r\n    def _delete(self, pos, idx):\r\n        \"\"\"Delete value at the given `(pos, idx)`.\"\"\"\r\n        _lists = self._lists\r\n        _mins = self._mins\r\n        _list_lens = self._list_lens\r\n \r\n        self._len -= 1\r\n        self._fen_update(pos, -1)\r\n        del _lists[pos][idx]\r\n        _list_lens[pos] -= 1\r\n \r\n        if _list_lens[pos]:\r\n            _mins[pos] = _lists[pos][0]\r\n        else:\r\n            del _lists[pos]\r\n            del _list_lens[pos]\r\n            del _mins[pos]\r\n            self._rebuild = True\r\n \r\n    def _loc_left(self, value):\r\n        \"\"\"Return an index pair that corresponds to the first position of `value` in the sorted list.\"\"\"\r\n        if not self._len:\r\n            return 0, 0\r\n \r\n        _lists = self._lists\r\n        _mins = self._mins\r\n \r\n        lo, pos = -1, len(_lists) - 1\r\n        while lo + 1 < pos:\r\n            mi = (lo + pos) >> 1\r\n            if value <= _mins[mi]:\r\n                pos = mi\r\n            else:\r\n                lo = mi\r\n \r\n        if pos and value <= _lists[pos - 1][-1]:\r\n            pos -= 1\r\n \r\n        _list = _lists[pos]\r\n        lo, idx = -1, len(_list)\r\n        while lo + 1 < idx:\r\n            mi = (lo + idx) >> 1\r\n            if value <= _list[mi]:\r\n                idx = mi\r\n            else:\r\n                lo = mi\r\n \r\n        return pos, idx\r\n \r\n    def _loc_right(self, value):\r\n        \"\"\"Return an index pair that corresponds to the last position of `value` in the sorted list.\"\"\"\r\n        if not self._len:\r\n            return 0, 0\r\n \r\n        _lists = self._lists\r\n        _mins = self._mins\r\n \r\n        pos, hi = 0, len(_lists)\r\n        while pos + 1 < hi:\r\n            mi = (pos + hi) >> 1\r\n            if value < _mins[mi]:\r\n                hi = mi\r\n            else:\r\n                pos = mi\r\n \r\n        _list = _lists[pos]\r\n        lo, idx = -1, len(_list)\r\n        while lo + 1 < idx:\r\n            mi = (lo + idx) >> 1\r\n            if value < _list[mi]:\r\n                idx = mi\r\n            else:\r\n                lo = mi\r\n \r\n        return pos, idx\r\n \r\n    def add(self, value):\r\n        \"\"\"Add `value` to sorted list.\"\"\"\r\n        _load = self._load\r\n        _lists = self._lists\r\n        _mins = self._mins\r\n        _list_lens = self._list_lens\r\n \r\n        self._len += 1\r\n        if _lists:\r\n            pos, idx = self._loc_right(value)\r\n            self._fen_update(pos, 1)\r\n            _list = _lists[pos]\r\n            _list.insert(idx, value)\r\n            _list_lens[pos] += 1\r\n            _mins[pos] = _list[0]\r\n            if _load + _load < len(_list):\r\n                _lists.insert(pos + 1, _list[_load:])\r\n                _list_lens.insert(pos + 1, len(_list) - _load)\r\n                _mins.insert(pos + 1, _list[_load])\r\n                _list_lens[pos] = _load\r\n                del _list[_load:]\r\n                self._rebuild = True\r\n        else:\r\n            _lists.append([value])\r\n            _mins.append(value)\r\n            _list_lens.append(1)\r\n            self._rebuild = True\r\n \r\n    def discard(self, value):\r\n        \"\"\"Remove `value` from sorted list if it is a member.\"\"\"\r\n        _lists = self._lists\r\n        if _lists:\r\n            pos, idx = self._loc_right(value)\r\n            if idx and _lists[pos][idx - 1] == value:\r\n                self._delete(pos, idx - 1)\r\n \r\n    def remove(self, value):\r\n        \"\"\"Remove `value` from sorted list; `value` must be a member.\"\"\"\r\n        _len = self._len\r\n        self.discard(value)\r\n        if _len == self._len:\r\n            raise ValueError('{0!r} not in list'.format(value))\r\n \r\n    def pop(self, index=-1):\r\n        \"\"\"Remove and return value at `index` in sorted list.\"\"\"\r\n        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)\r\n        value = self._lists[pos][idx]\r\n        self._delete(pos, idx)\r\n        return value\r\n \r\n    def bisect_left(self, value):\r\n        \"\"\"Return the first index to insert `value` in the sorted list.\"\"\"\r\n        pos, idx = self._loc_left(value)\r\n        return self._fen_query(pos) + idx\r\n \r\n    def bisect_right(self, value):\r\n        \"\"\"Return the last index to insert `value` in the sorted list.\"\"\"\r\n        pos, idx = self._loc_right(value)\r\n        return self._fen_query(pos) + idx\r\n \r\n    def count(self, value):\r\n        \"\"\"Return number of occurrences of `value` in the sorted list.\"\"\"\r\n        return self.bisect_right(value) - self.bisect_left(value)\r\n \r\n    def __len__(self):\r\n        \"\"\"Return the size of the sorted list.\"\"\"\r\n        return self._len\r\n \r\n    def __getitem__(self, index):\r\n        \"\"\"Lookup value at `index` in sorted list.\"\"\"\r\n        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)\r\n        return self._lists[pos][idx]\r\n \r\n    def __delitem__(self, index):\r\n        \"\"\"Remove value at `index` from sorted list.\"\"\"\r\n        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)\r\n        self._delete(pos, idx)\r\n \r\n    def __contains__(self, value):\r\n        \"\"\"Return true if `value` is an element of the sorted list.\"\"\"\r\n        _lists = self._lists\r\n        if _lists:\r\n            pos, idx = self._loc_left(value)\r\n            return idx < len(_lists[pos]) and _lists[pos][idx] == value\r\n        return False\r\n \r\n    def __iter__(self):\r\n        \"\"\"Return an iterator over the sorted list.\"\"\"\r\n        return (value for _list in self._lists for value in _list)\r\n \r\n    def __reversed__(self):\r\n        \"\"\"Return a reverse iterator over the sorted list.\"\"\"\r\n        return (value for _list in reversed(self._lists) for value in reversed(_list))\r\n \r\n    def __repr__(self):\r\n        \"\"\"Return string representation of sorted list.\"\"\"\r\n        return 'SortedList({0})'.format(list(self))\r\n\r\nclass FastIO(IOBase):\r\n    newlines = 0\r\n\r\n    def __init__(self, file):\r\n        self._fd = file.fileno()\r\n        self.buffer = BytesIO()\r\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\r\n        self.write = self.buffer.write if self.writable else None\r\n\r\n    def read(self):\r\n        while True:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            if not b:\r\n                break\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines = 0\r\n        return self.buffer.read()\r\n\r\n    def readline(self):\r\n        while self.newlines == 0:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            self.newlines = b.count(b\"\\n\") + (not b)\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines -= 1\r\n        return self.buffer.readline()\r\n\r\n    def flush(self):\r\n        if self.writable:\r\n            os.write(self._fd, self.buffer.getvalue())\r\n            self.buffer.truncate(0), self.buffer.seek(0)\r\n\r\nclass IOWrapper(IOBase):\r\n    def __init__(self, file):\r\n        self.buffer = FastIO(file)\r\n        self.flush = self.buffer.flush\r\n        self.writable = self.buffer.writable\r\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\r\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\r\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\r\n\r\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\r\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\r\n\r\ndef I():\r\n    return input()\r\n\r\ndef II():\r\n    return int(input())\r\n\r\ndef MI():\r\n    return map(int, input().split())\r\n\r\ndef LI():\r\n    return list(input().split())\r\n\r\ndef LII():\r\n    return list(map(int, input().split()))\r\n\r\ndef GMI():\r\n    return map(lambda x: int(x) - 1, input().split())\r\n\r\ndef LGMI():\r\n    return list(map(lambda x: int(x) - 1, input().split()))\r\n\r\nif __name__ == \"__main__\":\r\n    main()",
    "prob_desc_created_at": "1668263700",
    "tags": [
        "brute force",
        "data structures",
        "dp",
        "greedy",
        "implementation"
    ],
    "hidden_unit_tests": ""
}
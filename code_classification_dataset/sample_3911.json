{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"4 13\"]",
    "src_uid": "28b031722c279783ec44c755ef933836",
    "prob_desc_notes": "NoteIn the first test the initial coordinates of people are $$$9$$$, $$$6$$$, $$$6$$$, $$$9$$$, $$$9$$$ and their speeds are $$$1$$$, $$$2$$$, $$$1$$$, $$$1$$$, $$$1$$$. So, it's easy to see, that at the moment $$$4$$$ one coordinate was modified from $$$13$$$ to $$$12$$$.This is the first test in the hack format:5 79 6 6 9 91 2 1 1 12 3 4 1 00 2 3 1 44 3 0 1 21 3 4 0 21 4 0 2 32 4 1 3 02 4 1 3 04 0 12",
    "prob_desc_description": "Cirno gives AquaMoon a problem. There are $$$m$$$ people numbered from $$$0$$$ to $$$m - 1$$$. They are standing on a coordinate axis in points with positive integer coordinates. They are facing right (i.e. in the direction of the coordinate increase). At this moment everyone will start running with the constant speed in the direction of coordinate increasing. The initial coordinate of the $$$i$$$-th person on the line is $$$x_i$$$, and the speed of the $$$i$$$-th person is $$$v_i$$$. So the coordinate of the $$$i$$$-th person at the moment $$$t$$$ will be $$$x_i + t \\cdot v_i$$$.Cirno captured the coordinates of $$$m$$$ people in $$$k$$$ consecutive integer moments from $$$0$$$ to $$$k - 1$$$. In every moment, the coordinates of $$$m$$$ people were recorded in arbitrary order.To make the problem more funny, Cirno modified one coordinate at the moment $$$y$$$ ($$$0 &lt; y &lt; k-1$$$) to a different integer.AquaMoon wants to find the moment $$$y$$$ and the original coordinate $$$p$$$ before the modification. Actually, she is not a programmer at all. So she wasn't able to solve it. Can you help her?",
    "prob_desc_output_spec": "Print a single line with two integers $$$y$$$, $$$p$$$ — the moment that contains the modified coordinate and the original coordinate.",
    "prob_desc_input_spec": "This problem is made as interactive. It means, that your solution will read the input, given by the interactor. But the interactor will give you the full input at the beginning and after that, you should print the answer. So you should solve the problem, like as you solve the usual, non-interactive problem because you won't have any interaction process. The only thing you should not forget is to flush the output buffer, after printing the answer. Otherwise, you can get an \"Idleness limit exceeded\" verdict. Refer to the interactive problems guide for the detailed information about flushing the output buffer. The first line contains two integers $$$m$$$ and $$$k$$$ ($$$5 \\leq m \\leq 1000$$$, $$$7 \\leq k \\leq 1000$$$) — the number of people and the number of recorded moments.  The next $$$k$$$ lines contain captured positions. $$$i$$$-th of these lines contains $$$m$$$ integers between $$$1$$$ and $$$10^6$$$ (inclusive), representing positions captured by Cirno at the moment $$$i-1$$$. The input is guaranteed to be valid (i.e. only one integer was modified to a different value according to the problem statement). Also, it is guaranteed, that $$$1 \\le v_i \\le 1000$$$ for all $$$1 \\leq i \\leq m$$$. Hack format: The first line should contain two integers $$$m$$$ and $$$k$$$ ($$$5 \\leq m \\leq 1000$$$, $$$7 \\leq k \\leq 1000$$$) — the number of people and the number of moments.  In the second line, there should be $$$m$$$ integers $$$x_0, x_1, \\dots,x_{m - 1}$$$ ($$$1 \\le x_i \\le 10^6$$$), where $$$x_i$$$ is the initial coordinate of the $$$i$$$-th person. In the third line, there should be $$$m$$$ integers $$$v_0, v_1, \\dots,v_{m - 1}$$$ ($$$1 \\le v_i \\le 1000$$$), where $$$v_i$$$ is the speed of the $$$i$$$-th person. It should be true that $$$x_i + (k-1) v_i \\leq 10^6$$$ for each $$$0 \\leq i &lt; m$$$. In the next $$$k$$$ lines, each line should contain $$$m$$$ integers. $$$i$$$-th line should contain $$$m$$$ distinct integers $$$p_0, p_1, \\ldots, p_{m-1}$$$ ($$$0 \\leq p_j &lt; m$$$). The meaning of these numbers: $$$j$$$-th integer in the input in the $$$i$$$-th moment is the coordinate of the $$$p_{j}$$$-th person. In the last line, there should be three integers $$$y$$$, $$$i$$$, $$$c$$$. Cirno modified the coordinate of the $$$i$$$-th person at the moment $$$y$$$ to $$$c$$$ ($$$1 \\leq y \\leq k-2$$$, $$$0 \\leq i \\leq m - 1$$$, $$$1 \\leq c \\leq 10^6$$$, $$$c \\neq x_i + y \\cdot v_i$$$).",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3-64",
    "lang_cluster": "Python",
    "difficulty": 3000,
    "file_name": "train_086.jsonl",
    "code_uid": "c7cd001fc5adce73aef24db2fea3faa4",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"5 7\\n6 9 9 6 9\\n10 7 10 8 10\\n11 11 11 10 8\\n12 12 12 12 9\\n14 13 12 10 13\\n11 14 16 14 14\\n12 15 18 15 15\"]",
    "exec_outcome": "PASSED",
    "source_code": "import os,sys\r\nfrom random import randint\r\nfrom io import BytesIO, IOBase\r\n\r\nfrom collections import defaultdict,deque,Counter\r\nfrom bisect import bisect_left,bisect_right\r\nfrom heapq import heappush,heappop\r\nfrom functools import lru_cache\r\nfrom itertools import accumulate\r\nimport math\r\n\r\n# Fast IO Region\r\nBUFSIZE = 8192\r\nclass FastIO(IOBase):\r\n    newlines = 0\r\n    def __init__(self, file):\r\n        self._fd = file.fileno()\r\n        self.buffer = BytesIO()\r\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\r\n        self.write = self.buffer.write if self.writable else None\r\n    def read(self):\r\n        while True:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            if not b:\r\n                break\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines = 0\r\n        return self.buffer.read()\r\n    def readline(self):\r\n        while self.newlines == 0:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            self.newlines = b.count(b\"\\n\") + (not b)\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines -= 1\r\n        return self.buffer.readline()\r\n    def flush(self):\r\n        if self.writable:\r\n            os.write(self._fd, self.buffer.getvalue())\r\n            self.buffer.truncate(0), self.buffer.seek(0)\r\nclass IOWrapper(IOBase):\r\n    def __init__(self, file):\r\n        self.buffer = FastIO(file)\r\n        self.flush = self.buffer.flush\r\n        self.writable = self.buffer.writable\r\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\r\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\r\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\r\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\r\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\r\n\r\n# for _ in range(int(input())):\r\n#     n = int(input())\r\n#     a = list(map(int, input().split()))\r\n\r\n# for _ in range(int(input())):\r\n#     n = int(input())\r\n#     a = list(map(int, input().split()))\r\n#     b = list(map(int, input().split()))\r\n#     if sum(a) != sum(b):\r\n#         print(-1)\r\n#     else:\r\n#         pos, neg = [], []\r\n#         for i in range(n):\r\n#             if a[i] > b[i]:\r\n#                 pos.append([a[i] - b[i], i])\r\n#             elif a[i] < b[i]:\r\n#                 neg.append([b[i] - a[i], i])\r\n#         ans = []\r\n#         while pos:\r\n#             ans.append((pos[-1][1], neg[-1][1]))\r\n#             pos[-1][0] -= 1\r\n#             neg[-1][0] -= 1\r\n#             if pos[-1][0] == 0:\r\n#                 pos.pop()\r\n#             if neg[-1][0] == 0:\r\n#                 neg.pop()\r\n#         print(len(ans))\r\n#         for i, j in ans:\r\n#             print(i + 1, j + 1)\r\n\r\n# for _ in range(int(input())):\r\n#     n, m = list(map(int, input().split()))\r\n#     cnt = [[0] * m for _ in range(26)]\r\n#     for _ in range(n):\r\n#         s = input()\r\n#         for i in range(m):\r\n#             cnt[ord(s[i]) - ord('a')][i] += 1\r\n#     for _ in range(n - 1):\r\n#         s = input()\r\n#         for i in range(m):\r\n#             cnt[ord(s[i]) - ord('a')][i] -= 1\r\n#     ans = []\r\n#     for j in range(m):\r\n#         for i in range(26):\r\n#             if cnt[i][j]:\r\n#                 ans.append(chr(97 + i))\r\n#                 break\r\n#     print(''.join(ans))\r\n\r\n# for _ in range(int(input())):\r\n#     def solve():\r\n#         n = int(input())\r\n#         a = list(map(int, input().split()))\r\n#         b = sorted(a)\r\n#         odd = defaultdict(list)\r\n#         even = defaultdict(list)\r\n#         for i in range(n):\r\n#             if i % 2:\r\n#                 odd[b[i]].append(i)\r\n#             else:\r\n#                 even[b[i]].append(i)\r\n#         for i in range(n):\r\n#             if i % 2:\r\n#                 if not odd[a[i]]:\r\n#                     print('NO')\r\n#                     return\r\n#                 odd[a[i]].pop()\r\n#             else:\r\n#                 if not even[a[i]]:\r\n#                     print('NO')\r\n#                     return\r\n#                 even[a[i]].pop()\r\n#         print('YES')\r\n#     solve()\r\n\r\n# mod = 998244353\r\n# N = 100010\r\n# fac = [1] * N\r\n# for i in range(2, N):\r\n#     fac[i] = fac[i - 1] * i % mod\r\n# invfac = [1] * N\r\n# invfac[N - 1] = pow(fac[N - 1], mod - 2, mod)\r\n# for i in range(N - 1)[::-1]:\r\n#     invfac[i] = invfac[i + 1] * (i + 1) % mod\r\n# def c(i, j):\r\n#     return fac[i] * invfac[j] * invfac[i - j] % mod\r\n\r\n# for _ in range(int(input())):\r\n#     n = int(input())\r\n#     s = input()\r\n#     cnt11 = cnt0 = 0\r\n#     cur = 0\r\n#     for i in range(n):\r\n#         if s[i] == '1':\r\n#             cur += 1\r\n#         else:\r\n#             cnt0 += 1\r\n#             cnt11 += cur // 2\r\n#             cur = 0\r\n#     cnt11 += cur // 2\r\n#     print(c(cnt0 + cnt11, cnt0))\r\n\r\nm, k = list(map(int, input().split()))\r\na_1d = [list(map(int, input().split())) for _ in range(k)]\r\nsum_1d = [sum(a_1d[i]) for i in range(k)]\r\ndif_1d = [sum_1d[i + 1] - sum_1d[i] for i in range(k - 1)]\r\n\r\nfor i in range(k - 2):\r\n    if dif_1d[i] == dif_1d[i + 1]:\r\n        real_dif_1d = dif_1d[i]\r\n        break\r\nfor i in range(k - 1):\r\n    if dif_1d[i] != real_dif_1d:\r\n        add_1d = real_dif_1d - dif_1d[i]\r\n        pos = i + 1\r\n        break\r\n\r\nsum_2d = []\r\nfor i in range(k):\r\n    t = 0\r\n    for j in range(m):\r\n        t += a_1d[i][j] * a_1d[i][j]\r\n    sum_2d.append(t)\r\ndif_2d = [sum_2d[i + 1] - sum_2d[i] for i in range(k - 1)]\r\ndifdif_2d = [dif_2d[i + 1] - dif_2d[i] for i in range(k - 2)]\r\n\r\nreal_dif_2d = difdif_2d[0]\r\nfor i in range(k - 3):\r\n    if difdif_2d[i] == difdif_2d[i + 1]:\r\n        real_dif_2d = difdif_2d[i]\r\n        break\r\n\r\nif pos > 1:\r\n    real_2d = sum_2d[pos - 1] + sum_2d[pos - 1] - sum_2d[pos - 2] + real_dif_2d\r\nelse:\r\n    real_2d = sum_2d[pos + 1] - ((sum_2d[pos + 2] - sum_2d[pos + 1]) - real_dif_2d)\r\n\r\nadd2d = real_2d - sum_2d[pos]\r\nori = (add_1d + add2d // add_1d) // 2\r\nprint(pos, ori)\r\n\r\n\r\n# ori - last = add\r\n# ori^2-last^2=add2\r\n# ori+last=add2//add\r\n# ori = (add+add2//add) // 2\r\n\r\n\r\n# x1   ... xk\r\n# x1+v1 ... xk+vk\r\n# x1+2v1 ... xk+2vk\r\n\r\n# sum0\r\n# sum0+dif = fake + x\r\n# sum0+dif*2\r\n\r\n# 66999 21111\r\n# 87101010\r\n\r\n# a, b, c, d, e = 6, 6, 9, 9, 9\r\n# pre = a*a+b*b+c*c+d*d+e*e\r\n# for _ in range(6):\r\n#     a += 2\r\n#     b += 1\r\n#     c += 1\r\n#     d += 1\r\n#     e += 1\r\n#     print(a*a+b*b+c*c+d*d+e*e, a*a+b*b+c*c+d*d+e*e - pre)\r\n#     pre = a*a+b*b+c*c+d*d+e*e\r\n\r\n# ori**2 -last**2 - \r\n\r\n\r\n    \r\n    \r\n    ",
    "prob_desc_created_at": "1626012300",
    "tags": [
        "interactive",
        "math"
    ],
    "hidden_unit_tests": ""
}
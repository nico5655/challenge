{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"3\", \"1\", \"1\"]",
    "src_uid": "1254d7ee968ed89a229e02ccefaf5994",
    "prob_desc_notes": "NoteFor example $$$1$$$, by disturbing both blocks of sand on the first row from the top at the first and sixth columns from the left, and the block of sand on the second row from the top and the fourth column from the left, it is possible to have all the required amounts of sand fall in each column. It can be proved that this is not possible with fewer than $$$3$$$ operations, and as such the answer is $$$3$$$. Here is the puzzle from the first example.   For example $$$2$$$, by disturbing the cell on the top row and rightmost column, one can cause all of the blocks of sand in the board to fall into the counters at the bottom. Thus, the answer is $$$1$$$. Here is the puzzle from the second example.   For example $$$3$$$, by disturbing the cell on the top row and rightmost column, it is possible to have all the required amounts of sand fall in each column. It can be proved that this is not possible with fewer than $$$1$$$ operation, and as such the answer is $$$1$$$. Here is the puzzle from the third example.   ",
    "prob_desc_description": "This is the hard version of the problem. The difference between the versions is the constraints on $$$a_i$$$. You can make hacks only if all versions of the problem are solved.Little Dormi has recently received a puzzle from his friend and needs your help to solve it. The puzzle consists of an upright board with $$$n$$$ rows and $$$m$$$ columns of cells, some empty and some filled with blocks of sand, and $$$m$$$ non-negative integers $$$a_1,a_2,\\ldots,a_m$$$ ($$$0 \\leq a_i \\leq n$$$). In this version of the problem, $$$a_i$$$ will always be not greater than the number of blocks of sand in column $$$i$$$.When a cell filled with a block of sand is disturbed, the block of sand will fall from its cell to the sand counter at the bottom of the column (each column has a sand counter). While a block of sand is falling, other blocks of sand that are adjacent at any point to the falling block of sand will also be disturbed and start to fall. Specifically, a block of sand disturbed at a cell $$$(i,j)$$$ will pass through all cells below and including the cell $$$(i,j)$$$ within the column, disturbing all adjacent cells along the way. Here, the cells adjacent to a cell $$$(i,j)$$$ are defined as $$$(i-1,j)$$$, $$$(i,j-1)$$$, $$$(i+1,j)$$$, and $$$(i,j+1)$$$ (if they are within the grid). Note that the newly falling blocks can disturb other blocks.In one operation you are able to disturb any piece of sand. The puzzle is solved when there are at least $$$a_i$$$ blocks of sand counted in the $$$i$$$-th sand counter for each column from $$$1$$$ to $$$m$$$.You are now tasked with finding the minimum amount of operations in order to solve the puzzle. Note that Little Dormi will never give you a puzzle that is impossible to solve.",
    "prob_desc_output_spec": "Print one non-negative integer, the minimum amount of operations needed to solve the puzzle.",
    "prob_desc_input_spec": "The first line consists of two space-separated positive integers $$$n$$$ and $$$m$$$ ($$$1 \\leq n \\cdot m \\leq 400\\,000$$$). Each of the next $$$n$$$ lines contains $$$m$$$ characters, describing each row of the board. If a character on a line is '.', the corresponding cell is empty. If it is '#', the cell contains a block of sand. The final line contains $$$m$$$ non-negative integers $$$a_1,a_2,\\ldots,a_m$$$ ($$$0 \\leq a_i \\leq n$$$) â€” the minimum amount of blocks of sand that needs to fall below the board in each column. In this version of the problem, $$$a_i$$$ will always be not greater than the number of blocks of sand in column $$$i$$$.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "Python 3",
    "lang_cluster": "Python",
    "difficulty": 3000,
    "file_name": "train_091.jsonl",
    "code_uid": "564b5149bfdefab0343980c38cb23bd6",
    "prob_desc_memory_limit": "512 megabytes",
    "prob_desc_sample_inputs": "[\"5 7\\n#....#.\\n.#.#...\\n#....#.\\n#....##\\n#.#....\\n4 1 1 1 0 3 1\", \"3 3\\n#.#\\n#..\\n##.\\n3 1 1\", \"7 5\\n.#..#\\n#....\\n..##.\\n..##.\\n..###\\n..#..\\n#.##.\\n0 0 2 4 2\"]",
    "exec_outcome": "PASSED",
    "source_code": "import itertools\nimport math\nfrom math import inf\n\n\ndef readline():\n    return map(int, input().split())\n\n\ndef blocks(bits):\n    start = None\n    for (i, bit) in enumerate(itertools.chain(bits, [False])):\n        if bit and start is None:\n            start = i\n        if not bit and start is not None:\n            yield (start, i)\n            start = None\n\n\ndef test_blocks():\n    assert list(blocks([0, 0, 0])) == []\n    assert list(blocks([0, 1, 1])) == [(1, 3)]\n    assert list(blocks([1, 1])) == [(0, 2)]\n    assert list(blocks([0, 1, 1, 0, 0, 1, 1, 0])) == [(1, 3), (5, 7)]\n\n\n\ndef cut(iterable):\n    for (a, b, __) in iterable:\n        yield (a, b)\n\n\ndef magic_blocks(blocks, prev_blocks, annotate_w=False):\n    if annotate_w:\n        blocks = ((a, b, b-a) for (a, b) in blocks)\n    glue = itertools.chain(prev_blocks, [(inf, inf)])\n    gb, ge = -inf, -inf\n    ma, mb, weight = None, None, 0\n    for (a, b, w) in itertools.chain(blocks, [(inf, inf, inf)]):\n        if ma is None:\n            ma, mb, weight = a, b, w\n            continue\n        while ge <= a and ge < inf:\n            gb, ge = next(glue)\n        if gb < mb:\n            mb = b\n            weight += w\n        else:\n            # assert math.isfinite(weight)\n            yield ma, mb, weight\n            ma, mb, weight = a, b, w\n\n\ndef test_magic_blocks():\n    blocks = ((0, 2), (4, 7), (10, 15))\n    def tcut(mb):\n        return tuple(cut(mb))\n    assert tcut(magic_blocks(blocks, [])) == blocks\n    assert tcut(magic_blocks(blocks, [(2, 4)])) == blocks\n    assert tcut(magic_blocks(blocks, [(1, 4)])) == blocks\n    assert tcut(magic_blocks(blocks, [(1, 5)])) == ((0, 7), (10, 15))\n    assert tcut(magic_blocks(blocks, [(1, 10)])) == ((0, 7), (10, 15))\n    assert tcut(magic_blocks(blocks, [(1, 11)])) == ((0, 15),)\n    assert tcut(magic_blocks(blocks, [(1, 2), (3, 4), (7, 10)])) == blocks\n    assert tcut(magic_blocks(blocks, [(1, 2), (3, 4), (6, 100)])) == ((0, 2), (4, 15))\n    assert tcut(magic_blocks(blocks, [(7, 100), (101, 104)])) == blocks\n    assert tcut(magic_blocks((), [(7, 100), (101, 104)])) == ()\n\n\nunset = object()\n\n\ndef debug(*args):\n    import sys\n    print(*args, file=sys.stderr)\n\n\ndef solve_1(seq, a):\n    ans = 0\n    t = False\n    for (is_sand, ai) in zip(seq, a):\n        if not is_sand:\n            t = False\n        if ai:\n            assert is_sand\n            if not t:\n                ans += 1\n                t = True\n    print(ans)\n\n\ndef main():\n    n, m = readline()\n    s = [\n        [ch == '#' for ch in input()]\n        for __ in range(n)\n    ]\n    # assert all(len(row) == m for row in s)\n    a = list(readline())\n    ans = 0\n\n    if n == 1:\n        solve_1(s[0], a)\n        return\n\n    m_blocks = [()]\n    for i in range(m):\n        sb = (blocks(row[i] for row in reversed(s)))\n        m_blocks.append(tuple(magic_blocks(sb, cut(m_blocks[-1]), annotate_w=True)))\n    m_blocks.pop(0)\n    m_blocks.append(())\n    for i in range(m, 0, -1):\n        m_blocks[i-1] = tuple(magic_blocks(m_blocks[i-1], cut(m_blocks[i])))\n\n    c = None\n    f = -1\n    for i in range(m):\n        sand = a[i]\n        next_c = unset\n        next_f = -1\n        top = -1\n        for (from_, to, weight) in m_blocks[i]:\n            top = to - 1\n            if from_ <= f:\n                next_f = top\n            sand -= weight\n            if sand > 0:\n                continue\n            if c is not None and c > top:\n                continue\n            if next_c is unset:\n                next_c = from_\n        assert sand <= 0\n\n        if next_c is not unset and (c is not None or a[i] and next_c > f):\n            if c is None:\n                ans += 1\n            c = next_c\n            f = top\n        else:\n            c = None\n            f = next_f\n        # debug('cf', c, f)\n\n    print(ans)\n\n\nif __name__ == '__main__':\n    main()\n",
    "prob_desc_created_at": "1623598500",
    "tags": [
        "dfs and similar",
        "dp",
        "graphs",
        "greedy"
    ],
    "hidden_unit_tests": ""
}
{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"2\\nAG\\nAM\", \"8\\nAT\\nCH\\nCY\\nDG\\nDO\\nER\\nIN\\nOW\", \"4\\nAD\\nAE\\nBB\\nCC\"]",
    "src_uid": "739f51381ed125770e61194b9bc8adb0",
    "prob_desc_notes": "NoteIn the first sample, the solution uses two sheets: the first sheet has A on one side and G on the other side; the second sheet has A on one side and M on the other side.The name AA can be spelled using the A side of both sheets. The name GA can be spelled using the G side of the first sheet and the A side of the second sheet. Finally, the name MA can be spelled using the M side of the second sheet and the A side of the first sheet.",
    "prob_desc_description": "Vittorio has three favorite toys: a teddy bear, an owl, and a raccoon. Each of them has a name. Vittorio takes several sheets of paper and writes a letter on each side of every sheet so that it is possible to spell any of the three names by arranging some of the sheets in a row (sheets can be reordered and flipped as needed). The three names do not have to be spelled at the same time, it is sufficient that it is possible to spell each of them using all the available sheets (and the same sheet can be used to spell different names).Find the minimum number of sheets required. In addition, produce a list of sheets with minimum cardinality which can be used to spell the three names (if there are multiple answers, print any).",
    "prob_desc_output_spec": "The first line of the output contains a single integer $$$m$$$ — the minimum number of sheets required. Then $$$m$$$ lines follow: the $$$j$$$-th of these lines contains a string of two uppercase letters of the English alphabet — the letters appearing on the two sides of the $$$j$$$-th sheet. Note that you can print the sheets and the two letters of each sheet in any order.",
    "prob_desc_input_spec": "The first line contains a string $$$t$$$ consisting of uppercase letters of the English alphabet ($$$1\\le |t| \\le 1000$$$) — the name of the teddy bear. The second line contains a string $$$o$$$ consisting of uppercase letters of the English alphabet ($$$1\\le |o| \\le 1000$$$) — the name of the owl. The third line contains a string $$$r$$$ consisting of uppercase letters of the English alphabet ($$$1\\le |r| \\le 1000$$$) — the name of the raccoon. The values $$$|t|$$$, $$$|o|$$$, $$$|r|$$$ denote the length of the three names $$$t$$$, $$$o$$$, $$$r$$$.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3-64",
    "lang_cluster": "Python",
    "difficulty": -1,
    "file_name": "train_085.jsonl",
    "code_uid": "3cf7a776238434cd1ea41d3cfc1ad9f6",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"AA\\nGA\\nMA\", \"TEDDY\\nHEDWIG\\nRACCOON\", \"BDC\\nCAA\\nCE\"]",
    "exec_outcome": "PASSED",
    "source_code": "class SegmentTree:\r\n    def __init__(self, init_val, segfunc, ide_ele):\r\n        n = len(init_val)\r\n        self.segfunc = segfunc\r\n        self.ide_ele = ide_ele\r\n        self.num = 1 << (n - 1).bit_length()\r\n        self.tree = [ide_ele] * 2 * self.num\r\n        self.size = n\r\n        for i in range(n):\r\n            self.tree[self.num + i] = init_val[i]\r\n        for i in range(self.num - 1, 0, -1):\r\n            self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])\r\n\r\n    def update(self, k, x):\r\n        k += self.num\r\n        self.tree[k] = self.segfunc(self.tree[k],x)\r\n        while k > 1:\r\n            k >>= 1\r\n            self.tree[k] = self.segfunc(self.tree[2*k], self.tree[2*k+1])\r\n\r\n    def query(self, l, r):\r\n        if r==self.size:\r\n            r = self.num\r\n\r\n        res = self.ide_ele\r\n\r\n        l += self.num\r\n        r += self.num\r\n        right = []\r\n        while l < r:\r\n            if l & 1:\r\n                res = self.segfunc(res, self.tree[l])\r\n                l += 1\r\n            if r & 1:\r\n                right.append(self.tree[r-1])\r\n            l >>= 1\r\n            r >>= 1\r\n\r\n        for e in right[::-1]:\r\n            res = self.segfunc(res,e)\r\n        return res\r\n\r\nimport sys,random,bisect\r\nfrom collections import deque,defaultdict\r\nfrom heapq import heapify,heappop,heappush\r\nfrom itertools import permutations\r\nfrom math import log,gcd\r\n\r\ninput = lambda :sys.stdin.readline().rstrip()\r\nmi = lambda :map(int,input().split())\r\nli = lambda :list(mi())\r\n\r\nfor _ in range(1):\r\n    #S = [random.choice(\"ABC\") for i in range(10)]\r\n    #T = [random.choice(\"ABC\") for i in range(10)]\r\n    #U = [random.choice(\"ABC\") for i in range(10)]\r\n    #S = \"\".join(S)\r\n    #T = \"\".join(T)\r\n    #U = \"\".join(U)\r\n    S = input()\r\n    T = input()\r\n    U = input()\r\n\r\n    max_match = 0\r\n    for q in range(26):\r\n        ch = chr(q+ord(\"A\"))\r\n        X = [i for i in range(len(S)) if S[i]==ch]\r\n        Y = [i for i in range(len(T)) if T[i]==ch]\r\n        Z = [i for i in range(len(U)) if U[i]==ch]\r\n        x,y,z = len(X),len(Y),len(Z)\r\n        \"\"\"\r\n        0 <= k <= min(x,y)\r\n        maximize k+min(z,x+y-2*k)\r\n        \"\"\"\r\n\r\n        check = -1\r\n        k = -1\r\n        for tt in range(min(x,y)+1):\r\n            tmp = tt + min(x+y-2*tt,z)\r\n            if tmp > check:\r\n                k = tt\r\n                check = tmp\r\n        max_match += check\r\n    \r\n    check = -1\r\n    EM = -1\r\n    for t in range(max_match+1):\r\n        tmp = min(t,len(S))+min(t,len(T))+min(t,len(U))-2*t\r\n        if tmp > check:\r\n            check = tmp\r\n            EM = t\r\n\r\n    ST = []\r\n    TU = []\r\n    US = []\r\n\r\n    res = []\r\n    use_S = [False] * len(S)\r\n    use_T = [False] * len(T)\r\n    use_U = [False] * len(U)\r\n\r\n    for q in range(26):\r\n        ch = chr(q+ord(\"A\"))\r\n        X = [i for i in range(len(S)) if S[i]==ch]\r\n        Y = [i for i in range(len(T)) if T[i]==ch]\r\n        Z = [i for i in range(len(U)) if U[i]==ch]\r\n        x,y,z = len(X),len(Y),len(Z)\r\n        \"\"\"\r\n        0 <= k <= min(x,y)\r\n        maximize k+min(z,x+y-2*k)\r\n        \"\"\"\r\n\r\n        check = -1\r\n        k = -1\r\n        for tt in range(min(x,y)+1):\r\n            tmp = tt + min(x+y-2*tt,z)\r\n            if tmp > check:\r\n                k = tt\r\n                check = tmp\r\n\r\n        def calc(tt):\r\n            if tt < 0 or tt > min(x,y):\r\n                return -1\r\n            return tt + min(x+y-2*tt,z)\r\n        assert calc(k-1) <= calc(k)\r\n        assert calc(k) >= calc(k+1)\r\n        for _ in range(k):\r\n            a,b = X.pop(),Y.pop()\r\n            if EM:\r\n                EM -= 1\r\n                ST.append(ch)\r\n                use_S[a] = True\r\n                use_T[b] = True\r\n        while Z and X and EM:\r\n            a,c = X.pop(),Z.pop()\r\n            US.append(ch)\r\n            use_S[a] = use_U[c] = True\r\n            EM -= 1\r\n        while Z and Y and EM:\r\n            b,c = Y.pop(),Z.pop()\r\n            TU.append(ch)\r\n            use_T[b] = use_U[c] = True\r\n            EM -= 1\r\n    \r\n\r\n    ans = []\r\n    X = [S[i] for i in range(len(S)) if not use_S[i]]\r\n    Y = [T[i] for i in range(len(T)) if not use_T[i]]\r\n    Z = [U[i] for i in range(len(U)) if not use_U[i]]\r\n    while X and TU:\r\n        ans.append(X.pop()+TU.pop())\r\n    while Y and US:\r\n        ans.append(Y.pop()+US.pop())\r\n    while Z and ST:\r\n        ans.append(Z.pop()+ST.pop())\r\n    #print(ST,TU,US,X,Y,Z)\r\n\r\n    for ch in ST:\r\n        X.append(ch)\r\n        Y.append(ch)\r\n    for ch in TU:\r\n        Y.append(ch)\r\n        Z.append(ch)\r\n    for ch in US:\r\n        Z.append(ch)\r\n        X.append(ch)\r\n        \r\n\r\n    if len(X) > len(Y):\r\n        X,Y = Y,X\r\n    if len(Y) > len(Z):\r\n        Y,Z = Z,Y\r\n\r\n    ALL = [X,Y,Z]\r\n\r\n    while True:\r\n        p = [0,1,2]\r\n        p.sort(key=lambda i:len(ALL[i]))\r\n        if not ALL[p[1]]:\r\n            break\r\n        a = ALL[p[2]].pop()\r\n        b = ALL[p[1]].pop()\r\n        ans.append(a+b)\r\n\r\n    for a in ALL[p[2]]:\r\n        ans.append(a+\"A\")\r\n\r\n    print(len(ans))\r\n    print(*ans,sep=\"\\n\")\r\n\r\n    def check(S,res):\r\n        n = len(res)\r\n        for i in range(2**n):\r\n            cnt = [0] * 26\r\n            for j in range(n):\r\n                p = res[j]\r\n                if i>>j & 1:\r\n                    cnt[ord(p[0])-ord(\"A\")] += 1\r\n                else:\r\n                    cnt[ord(p[1])-ord(\"A\")] += 1\r\n            for j in range(26):\r\n                ch = chr(ord(\"A\")+j)\r\n                if cnt[j] < S.count(ch):\r\n                    break\r\n            else:\r\n                return True\r\n        return False\r\n\r\n    def checker(S,T,U,res):\r\n        for p in [S,T,U]:\r\n            if not check(p,res):\r\n                return False\r\n        return True\r\n\r\n    \r\n\r\n    #assert checker(S,T,U,ans)",
    "prob_desc_created_at": "1650798300",
    "tags": [
        "greedy",
        "strings"
    ],
    "hidden_unit_tests": ""
}
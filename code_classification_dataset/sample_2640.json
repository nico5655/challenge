{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"-1\", \"1.414214\", \"2.125000\"]",
    "src_uid": "8b1129d61855e558e4153e9c07427ffd",
    "prob_desc_notes": null,
    "prob_desc_description": "Luyi has n circles on the plane. The i-th circle is centered at (xi, yi). At the time zero circles start to grow simultaneously. In other words, the radius of each circle at time t (t &gt; 0) is equal to t. The circles are drawn as black discs on an infinite white plane. So at each moment the plane consists of several black and white regions. Note that the circles may overlap while growing.  We define a hole as a closed, connected white region. For instance, the figure contains two holes shown by red border. During growing some holes may be created and it is easy to see that each created hole will disappear eventually. Luyi asks you to find moment of time such that the last hole disappears. In other words, you should find the first moment such that no hole can be seen after that.",
    "prob_desc_output_spec": "Print the moment where the last hole disappears. If there exists no moment in which we can find holes print -1. The answer will be considered correct if the absolute or relative error does not exceed 10 - 4.",
    "prob_desc_input_spec": "The first line of the input contains integer n (1 ≤ n ≤ 100). Each of the next n lines contains two integers xi and yi ( - 104 ≤ xi, yi ≤ 104), indicating the location of i-th circle. It's guaranteed that no two circles are centered at the same point.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "Python 2",
    "lang_cluster": "Python",
    "difficulty": 2600,
    "file_name": "train_027.jsonl",
    "code_uid": "be30d120637e9f63f40521bacc1b45de",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"3\\n0 0\\n1 1\\n2 2\", \"4\\n0 0\\n0 2\\n2 2\\n2 0\", \"4\\n0 1\\n0 -1\\n-2 0\\n4 0\"]",
    "exec_outcome": "PASSED",
    "source_code": "from collections import namedtuple\nimport math\n\nDRAW = False\n\n#############################################################################\n#\n# Voronoi diagram calculator/ Delaunay triangulator\n# Translated to Python by Bill Simons\n# September, 2005\n#\n# Calculate Delaunay triangulation or the Voronoi polygons for a set of \n# 2D input points.\n#\n# Derived from code bearing the following notice:\n#\n#  The author of this software is Steven Fortune.  Copyright (c) 1994 by AT&T\n#  Bell Laboratories.\n#  Permission to use, copy, modify, and distribute this software for any\n#  purpose without fee is hereby granted, provided that this entire notice\n#  is included in all copies of any software which is or includes a copy\n#  or modification of this software and in all copies of the supporting\n#  documentation for such software.\n#  THIS SOFTWARE IS BEING PROVIDED \"AS IS\", WITHOUT ANY EXPRESS OR IMPLIED\n#  WARRANTY.  IN PARTICULAR, NEITHER THE AUTHORS NOR AT&T MAKE ANY\n#  REPRESENTATION OR WARRANTY OF ANY KIND CONCERNING THE MERCHANTABILITY\n#  OF THIS SOFTWARE OR ITS FITNESS FOR ANY PARTICULAR PURPOSE.\n#\n# Comments were incorporated from Shane O'Sullivan's translation of the \n# original code into C++ (http://mapviewer.skynet.ie/voronoi.html)\n#\n# Steve Fortune's homepage: http://netlib.bell-labs.com/cm/cs/who/sjf/index.html\n#\n#############################################################################\n\ndef usage():\n    print \"\"\"\nvoronoi - compute Voronoi diagram or Delaunay triangulation\n\nvoronoi [-t -p -d]  [filename]\n\nVoronoi reads from filename (or standard input if no filename given) for a set \nof points in the plane and writes either the Voronoi diagram or the Delaunay \ntriangulation to the standard output.  Each input line should consist of two \nreal numbers, separated by white space.\n\nIf option -t is present, the Delaunay triangulation is produced. \nEach output line is a triple i j k, which are the indices of the three points\nin a Delaunay triangle. Points are numbered starting at 0.\n\nIf option -t is not present, the Voronoi diagram is produced.  \nThere are four output record types.\n\ns a b      indicates that an input point at coordinates a b was seen.\nl a b c    indicates a line with equation ax + by = c.\nv a b      indicates a vertex at a b.\ne l v1 v2  indicates a Voronoi segment which is a subsegment of line number l\n           with endpoints numbered v1 and v2.  If v1 or v2 is -1, the line \n           extends to infinity.\n\nOther options include:\n\nd    Print debugging info\n\np    Produce output suitable for input to plot (1), rather than the forms \n     described above.\n\nOn unsorted data uniformly distributed in the unit square, voronoi uses about \n20n+140 bytes of storage.\n\nAUTHOR\nSteve J. Fortune (1987) A Sweepline Algorithm for Voronoi Diagrams,\nAlgorithmica 2, 153-174.\n\"\"\"\n\n#############################################################################\n#\n# For programmatic use two functions are available:\n#\n#   computeVoronoiDiagram(points)\n#\n#        Takes a list of point objects (which must have x and y fields).\n#        Returns a 3-tuple of:\n#\n#           (1) a list of 2-tuples, which are the x,y coordinates of the \n#               Voronoi diagram vertices\n#           (2) a list of 3-tuples (a,b,c) which are the equations of the\n#               lines in the Voronoi diagram: a*x + b*y = c\n#           (3) a list of 3-tuples, (l, v1, v2) representing edges of the \n#               Voronoi diagram.  l is the index of the line, v1 and v2 are\n#               the indices of the vetices at the end of the edge.  If \n#               v1 or v2 is -1, the line extends to infinity.\n#\n#   computeDelaunayTriangulation(points):\n#\n#        Takes a list of point objects (which must have x and y fields).\n#        Returns a list of 3-tuples: the indices of the points that form a\n#        Delaunay triangle.\n#\n#############################################################################\nimport math\nimport sys\nimport getopt\nTOLERANCE = 1e-9\nBIG_FLOAT = 1e38\n\n#------------------------------------------------------------------\nclass Context(object):\n    def __init__(self):\n        self.doPrint = 0\n        self.debug   = 0\n        self.plot    = 0\n        self.triangulate = False\n        self.vertices  = []    # list of vertex 2-tuples: (x,y)\n        self.lines     = []    # equation of line 3-tuple (a b c), for the equation of the line a*x+b*y = c  \n        self.edges     = []    # edge 3-tuple: (line index, vertex 1 index, vertex 2 index)   if either vertex index is -1, the edge extends to infiinity\n        self.triangles = []    # 3-tuple of vertex indices\n\n    def circle(self,x,y,rad):\n        pass\n\n    def clip_line(self,edge):\n        pass\n\n    def line(self,x0,y0,x1,y1):\n        pass\n\n    def outSite(self,s):\n        if(self.debug):\n            print \"site (%d) at %f %f\" % (s.sitenum, s.x, s.y)\n        elif(self.triangulate):\n            pass\n        elif(self.plot):\n            self.circle (s.x, s.y, cradius)\n        elif(self.doPrint):\n            print \"s %f %f\" % (s.x, s.y)\n\n    def outVertex(self,s):\n        self.vertices.append((s.x,s.y))\n        if(self.debug):\n            print  \"vertex(%d) at %f %f\" % (s.sitenum, s.x, s.y)\n        elif(self.triangulate):\n            pass\n        elif(self.doPrint and not self.plot):\n            print \"v %f %f\" % (s.x,s.y)\n\n    def outTriple(self,s1,s2,s3):\n        self.triangles.append((s1.sitenum, s2.sitenum, s3.sitenum))\n        if(self.debug):\n            print \"circle through left=%d right=%d bottom=%d\" % (s1.sitenum, s2.sitenum, s3.sitenum)\n        elif(self.triangulate and self.doPrint and not self.plot):\n            print \"%d %d %d\" % (s1.sitenum, s2.sitenum, s3.sitenum)\n\n    def outBisector(self,edge):\n        self.lines.append((edge.a, edge.b, edge.c))\n        if(self.debug):\n            print \"line(%d) %gx+%gy=%g, bisecting %d %d\" % (edge.edgenum, edge.a, edge.b, edge.c, edge.reg[0].sitenum, edge.reg[1].sitenum)\n        elif(self.triangulate):\n            if(self.plot):\n                self.line(edge.reg[0].x, edge.reg[0].y, edge.reg[1].x, edge.reg[1].y)\n        elif(self.doPrint and not self.plot):\n            print \"l %f %f %f\" % (edge.a, edge.b, edge.c)\n\n    def outEdge(self,edge):\n        sitenumL = -1\n        if edge.ep[Edge.LE] is not None:\n            sitenumL = edge.ep[Edge.LE].sitenum\n        sitenumR = -1\n        if edge.ep[Edge.RE] is not None:\n            sitenumR = edge.ep[Edge.RE].sitenum\n        self.edges.append((edge.edgenum,sitenumL,sitenumR))\n        if(not self.triangulate):\n            if self.plot:\n                self.clip_line(edge)\n            elif(self.doPrint): \n                print \"e %d\" % edge.edgenum,\n                print \" %d \" % sitenumL,\n                print \"%d\" % sitenumR\n\n#------------------------------------------------------------------\ndef voronoi(siteList,context):\n    edgeList  = EdgeList(siteList.xmin,siteList.xmax,len(siteList))\n    priorityQ = PriorityQueue(siteList.ymin,siteList.ymax,len(siteList))\n    siteIter = siteList.iterator()\n    \n    bottomsite = siteIter.next()\n    context.outSite(bottomsite)\n    newsite = siteIter.next()\n    minpt = Site(-BIG_FLOAT,-BIG_FLOAT)\n    while True:\n        if not priorityQ.isEmpty():\n            minpt = priorityQ.getMinPt()\n\n        if (newsite and (priorityQ.isEmpty() or cmp(newsite,minpt) < 0)):\n            # newsite is smallest -  this is a site event\n            context.outSite(newsite)\n            \n            # get first Halfedge to the LEFT and RIGHT of the new site \n            lbnd = edgeList.leftbnd(newsite) \n            rbnd = lbnd.right                    \n            \n            # if this halfedge has no edge, bot = bottom site (whatever that is)\n            # create a new edge that bisects\n            bot  = lbnd.rightreg(bottomsite)     \n            edge = Edge.bisect(bot,newsite)      \n            context.outBisector(edge)\n            \n            # create a new Halfedge, setting its pm field to 0 and insert \n            # this new bisector edge between the left and right vectors in\n            # a linked list\n            bisector = Halfedge(edge,Edge.LE)    \n            edgeList.insert(lbnd,bisector)       \n\n            # if the new bisector intersects with the left edge, remove \n            # the left edge's vertex, and put in the new one\n            p = lbnd.intersect(bisector)\n            if p is not None:\n                priorityQ.delete(lbnd)\n                priorityQ.insert(lbnd,p,newsite.distance(p))\n\n            # create a new Halfedge, setting its pm field to 1\n            # insert the new Halfedge to the right of the original bisector\n            lbnd = bisector\n            bisector = Halfedge(edge,Edge.RE)     \n            edgeList.insert(lbnd,bisector)        \n\n            # if this new bisector intersects with the right Halfedge\n            p = bisector.intersect(rbnd)\n            if p is not None:\n                # push the Halfedge into the ordered linked list of vertices\n                priorityQ.insert(bisector,p,newsite.distance(p))\n            \n            newsite = siteIter.next()\n\n        elif not priorityQ.isEmpty():\n            # intersection is smallest - this is a vector (circle) event \n\n            # pop the Halfedge with the lowest vector off the ordered list of \n            # vectors.  Get the Halfedge to the left and right of the above HE\n            # and also the Halfedge to the right of the right HE\n            lbnd  = priorityQ.popMinHalfedge()      \n            llbnd = lbnd.left               \n            rbnd  = lbnd.right              \n            rrbnd = rbnd.right              \n            \n            # get the Site to the left of the left HE and to the right of\n            # the right HE which it bisects\n            bot = lbnd.leftreg(bottomsite)  \n            top = rbnd.rightreg(bottomsite) \n            \n            # output the triple of sites, stating that a circle goes through them\n            mid = lbnd.rightreg(bottomsite)\n            context.outTriple(bot,top,mid)          \n\n            # get the vertex that caused this event and set the vertex number\n            # couldn't do this earlier since we didn't know when it would be processed\n            v = lbnd.vertex                 \n            siteList.setSiteNumber(v)\n            context.outVertex(v)\n            \n            # set the endpoint of the left and right Halfedge to be this vector\n            if lbnd.edge.setEndpoint(lbnd.pm,v):\n                context.outEdge(lbnd.edge)\n            \n            if rbnd.edge.setEndpoint(rbnd.pm,v):\n                context.outEdge(rbnd.edge)\n\n            \n            # delete the lowest HE, remove all vertex events to do with the \n            # right HE and delete the right HE\n            edgeList.delete(lbnd)           \n            priorityQ.delete(rbnd)\n            edgeList.delete(rbnd)\n            \n            \n            # if the site to the left of the event is higher than the Site\n            # to the right of it, then swap them and set 'pm' to RIGHT\n            pm = Edge.LE\n            if bot.y > top.y:\n                bot,top = top,bot\n                pm = Edge.RE\n\n            # Create an Edge (or line) that is between the two Sites.  This \n            # creates the formula of the line, and assigns a line number to it\n            edge = Edge.bisect(bot, top)     \n            context.outBisector(edge)\n\n            # create a HE from the edge \n            bisector = Halfedge(edge, pm)    \n            \n            # insert the new bisector to the right of the left HE\n            # set one endpoint to the new edge to be the vector point 'v'\n            # If the site to the left of this bisector is higher than the right\n            # Site, then this endpoint is put in position 0; otherwise in pos 1\n            edgeList.insert(llbnd, bisector) \n            if edge.setEndpoint(Edge.RE - pm, v):\n                context.outEdge(edge)\n            \n            # if left HE and the new bisector don't intersect, then delete \n            # the left HE, and reinsert it \n            p = llbnd.intersect(bisector)\n            if p is not None:\n                priorityQ.delete(llbnd);\n                priorityQ.insert(llbnd, p, bot.distance(p))\n\n            # if right HE and the new bisector don't intersect, then reinsert it \n            p = bisector.intersect(rrbnd)\n            if p is not None:\n                priorityQ.insert(bisector, p, bot.distance(p))\n        else:\n            break\n\n    he = edgeList.leftend.right\n    while he is not edgeList.rightend:\n        context.outEdge(he.edge)\n        he = he.right\n\n#------------------------------------------------------------------\ndef isEqual(a,b,relativeError=TOLERANCE):\n    # is nearly equal to within the allowed relative error\n    norm = max(abs(a),abs(b))\n    return (norm < relativeError) or (abs(a - b) < (relativeError * norm))\n\n#------------------------------------------------------------------\nclass Site(object):\n    def __init__(self,x=0.0,y=0.0,sitenum=0):\n        self.x = x\n        self.y = y\n        self.sitenum = sitenum\n\n    def dump(self):\n        print \"Site #%d (%g, %g)\" % (self.sitenum,self.x,self.y)\n\n    def __cmp__(self,other):\n        if self.y < other.y:\n            return -1\n        elif self.y > other.y:\n            return 1\n        elif self.x < other.x:\n            return -1\n        elif self.x > other.x:\n            return 1\n        else:\n            return 0\n\n    def distance(self,other):\n        dx = self.x - other.x\n        dy = self.y - other.y\n        return math.sqrt(dx*dx + dy*dy)\n\n#------------------------------------------------------------------\nclass Edge(object):\n    LE = 0\n    RE = 1\n    EDGE_NUM = 0\n    DELETED = {}   # marker value\n\n    def __init__(self):\n        self.a = 0.0\n        self.b = 0.0\n        self.c = 0.0\n        self.ep  = [None,None]\n        self.reg = [None,None]\n        self.edgenum = 0\n\n    def dump(self):\n        print \"(#%d a=%g, b=%g, c=%g)\" % (self.edgenum,self.a,self.b,self.c)\n        print \"ep\",self.ep\n        print \"reg\",self.reg\n\n    def setEndpoint(self, lrFlag, site):\n        self.ep[lrFlag] = site\n        if self.ep[Edge.RE - lrFlag] is None:\n            return False\n        return True\n\n    @staticmethod\n    def bisect(s1,s2):\n        newedge = Edge()\n        newedge.reg[0] = s1 # store the sites that this edge is bisecting\n        newedge.reg[1] = s2\n\n        # to begin with, there are no endpoints on the bisector - it goes to infinity\n        # ep[0] and ep[1] are None\n\n        # get the difference in x dist between the sites\n        dx = float(s2.x - s1.x)\n        dy = float(s2.y - s1.y)\n        adx = abs(dx)  # make sure that the difference in positive\n        ady = abs(dy)\n        \n        # get the slope of the line\n        newedge.c = float(s1.x * dx + s1.y * dy + (dx*dx + dy*dy)*0.5)  \n        if adx > ady :\n            # set formula of line, with x fixed to 1\n            newedge.a = 1.0\n            newedge.b = dy/dx\n            newedge.c /= dx\n        else:\n            # set formula of line, with y fixed to 1\n            newedge.b = 1.0\n            newedge.a = dx/dy\n            newedge.c /= dy\n\n        newedge.edgenum = Edge.EDGE_NUM\n        Edge.EDGE_NUM += 1\n        return newedge\n\n\n#------------------------------------------------------------------\nclass Halfedge(object):\n    def __init__(self,edge=None,pm=Edge.LE):\n        self.left  = None   # left Halfedge in the edge list\n        self.right = None   # right Halfedge in the edge list\n        self.qnext = None   # priority queue linked list pointer\n        self.edge  = edge   # edge list Edge\n        self.pm     = pm\n        self.vertex = None  # Site()\n        self.ystar  = BIG_FLOAT\n\n    def dump(self):\n        print \"Halfedge--------------------------\"\n        print \"left: \",    self.left  \n        print \"right: \",   self.right \n        print \"edge: \",    self.edge  \n        print \"pm: \",      self.pm    \n        print \"vertex: \",\n        if self.vertex: self.vertex.dump()\n        else: print \"None\"\n        print \"ystar: \",   self.ystar \n\n\n    def __cmp__(self,other):\n        if self.ystar > other.ystar:\n            return 1\n        elif self.ystar < other.ystar:\n            return -1\n        elif self.vertex.x > other.vertex.x:\n            return 1\n        elif self.vertex.x < other.vertex.x:\n            return -1\n        else:\n            return 0\n\n    def leftreg(self,default):\n        if not self.edge: \n            return default\n        elif self.pm == Edge.LE:\n            return self.edge.reg[Edge.LE]\n        else:\n            return self.edge.reg[Edge.RE]\n\n    def rightreg(self,default):\n        if not self.edge: \n            return default\n        elif self.pm == Edge.LE:\n            return self.edge.reg[Edge.RE]\n        else:\n            return self.edge.reg[Edge.LE]\n\n\n    # returns True if p is to right of halfedge self\n    def isPointRightOf(self,pt):\n        e = self.edge\n        topsite = e.reg[1]\n        right_of_site = pt.x > topsite.x\n        \n        if(right_of_site and self.pm == Edge.LE): \n            return True\n        \n        if(not right_of_site and self.pm == Edge.RE):\n            return False\n        \n        if(e.a == 1.0):\n            dyp = pt.y - topsite.y\n            dxp = pt.x - topsite.x\n            fast = 0;\n            if ((not right_of_site and e.b < 0.0) or (right_of_site and e.b >= 0.0)):\n                above = dyp >= e.b * dxp\n                fast = above\n            else:\n                above = pt.x + pt.y * e.b > e.c\n                if(e.b < 0.0):\n                    above = not above\n                if (not above):\n                    fast = 1\n            if (not fast):\n                dxs = topsite.x - (e.reg[0]).x\n                above = e.b * (dxp*dxp - dyp*dyp) < dxs*dyp*(1.0+2.0*dxp/dxs + e.b*e.b)\n                if(e.b < 0.0):\n                    above = not above\n        else:  # e.b == 1.0 \n            yl = e.c - e.a * pt.x\n            t1 = pt.y - yl\n            t2 = pt.x - topsite.x\n            t3 = yl - topsite.y\n            above = t1*t1 > t2*t2 + t3*t3\n        \n        if(self.pm==Edge.LE):\n            return above\n        else:\n            return not above\n\n    #--------------------------\n    # create a new site where the Halfedges el1 and el2 intersect\n    def intersect(self,other):\n        e1 = self.edge\n        e2 = other.edge\n        if (e1 is None) or (e2 is None):\n            return None\n\n        # if the two edges bisect the same parent return None\n        if e1.reg[1] is e2.reg[1]:\n            return None\n\n        d = e1.a * e2.b - e1.b * e2.a\n        if isEqual(d,0.0):\n            return None\n\n        xint = (e1.c*e2.b - e2.c*e1.b) / d\n        yint = (e2.c*e1.a - e1.c*e2.a) / d\n        if(cmp(e1.reg[1],e2.reg[1]) < 0):\n            he = self\n            e = e1\n        else:\n            he = other\n            e = e2\n\n        rightOfSite = xint >= e.reg[1].x\n        if((rightOfSite     and he.pm == Edge.LE) or\n           (not rightOfSite and he.pm == Edge.RE)):\n            return None\n\n        # create a new site at the point of intersection - this is a new \n        # vector event waiting to happen\n        return Site(xint,yint)\n\n        \n\n#------------------------------------------------------------------\nclass EdgeList(object):\n    def __init__(self,xmin,xmax,nsites):\n        if xmin > xmax: xmin,xmax = xmax,xmin\n        self.hashsize = int(2*math.sqrt(nsites+4))\n        \n        self.xmin   = xmin\n        self.deltax = float(xmax - xmin)\n        self.hash   = [None]*self.hashsize\n        \n        self.leftend  = Halfedge()\n        self.rightend = Halfedge()\n        self.leftend.right = self.rightend\n        self.rightend.left = self.leftend\n        self.hash[0]  = self.leftend\n        self.hash[-1] = self.rightend\n\n    def insert(self,left,he):\n        he.left  = left\n        he.right = left.right\n        left.right.left = he\n        left.right = he\n\n    def delete(self,he):\n        he.left.right = he.right\n        he.right.left = he.left\n        he.edge = Edge.DELETED\n\n    # Get entry from hash table, pruning any deleted nodes \n    def gethash(self,b):\n        if(b < 0 or b >= self.hashsize):\n            return None\n        he = self.hash[b]\n        if he is None or he.edge is not Edge.DELETED:\n            return he\n\n        #  Hash table points to deleted half edge.  Patch as necessary.\n        self.hash[b] = None\n        return None\n\n    def leftbnd(self,pt):\n        # Use hash table to get close to desired halfedge \n        bucket = int(((pt.x - self.xmin)/self.deltax * self.hashsize))\n        \n        if(bucket < 0): \n            bucket =0;\n        \n        if(bucket >=self.hashsize): \n            bucket = self.hashsize-1\n\n        he = self.gethash(bucket)\n        if(he is None):\n            i = 1\n            while True:\n                he = self.gethash(bucket-i)\n                if (he is not None): break;\n                he = self.gethash(bucket+i)\n                if (he is not None): break;\n                i += 1\n    \n        # Now search linear list of halfedges for the corect one\n        if (he is self.leftend) or (he is not self.rightend and he.isPointRightOf(pt)):\n            he = he.right\n            while he is not self.rightend and he.isPointRightOf(pt):\n                he = he.right\n            he = he.left;\n        else:\n            he = he.left\n            while (he is not self.leftend and not he.isPointRightOf(pt)):\n                he = he.left\n\n        # Update hash table and reference counts\n        if(bucket > 0 and bucket < self.hashsize-1):\n            self.hash[bucket] = he\n        return he\n\n\n#------------------------------------------------------------------\nclass PriorityQueue(object):\n    def __init__(self,ymin,ymax,nsites):\n        self.ymin = ymin\n        self.deltay = ymax - ymin\n        self.hashsize = int(4 * math.sqrt(nsites))\n        self.count = 0\n        self.minidx = 0\n        self.hash = []\n        for i in range(self.hashsize):\n            self.hash.append(Halfedge())\n\n    def __len__(self):\n        return self.count\n\n    def isEmpty(self):\n        return self.count == 0\n\n    def insert(self,he,site,offset):\n        he.vertex = site\n        he.ystar  = site.y + offset\n        last = self.hash[self.getBucket(he)]\n        next = last.qnext\n        while((next is not None) and cmp(he,next) > 0):\n            last = next\n            next = last.qnext\n        he.qnext = last.qnext\n        last.qnext = he\n        self.count += 1\n\n    def delete(self,he):\n        if (he.vertex is not None):\n            last = self.hash[self.getBucket(he)]\n            while last.qnext is not he:\n                last = last.qnext\n            last.qnext = he.qnext\n            self.count -= 1\n            he.vertex = None\n\n    def getBucket(self,he):\n        bucket = int(((he.ystar - self.ymin) / self.deltay) * self.hashsize)\n        if bucket < 0: bucket = 0\n        if bucket >= self.hashsize: bucket = self.hashsize-1\n        if bucket < self.minidx:  self.minidx = bucket\n        return bucket\n\n    def getMinPt(self):\n        while(self.hash[self.minidx].qnext is None):\n            self.minidx += 1\n        he = self.hash[self.minidx].qnext\n        x = he.vertex.x\n        y = he.ystar\n        return Site(x,y)\n\n    def popMinHalfedge(self):\n        curr = self.hash[self.minidx].qnext\n        self.hash[self.minidx].qnext = curr.qnext\n        self.count -= 1\n        return curr\n\n\n#------------------------------------------------------------------\nclass SiteList(object):\n    def __init__(self,pointList):\n        self.__sites = []\n        self.__sitenum = 0\n\n        self.__xmin = pointList[0].x\n        self.__ymin = pointList[0].y\n        self.__xmax = pointList[0].x\n        self.__ymax = pointList[0].y\n        for i,pt in enumerate(pointList):\n            self.__sites.append(Site(pt.x,pt.y,i))\n            if pt.x < self.__xmin: self.__xmin = pt.x\n            if pt.y < self.__ymin: self.__ymin = pt.y\n            if pt.x > self.__xmax: self.__xmax = pt.x\n            if pt.y > self.__ymax: self.__ymax = pt.y\n        self.__sites.sort()\n\n    def setSiteNumber(self,site):\n        site.sitenum = self.__sitenum\n        self.__sitenum += 1\n\n    class Iterator(object):\n        def __init__(this,lst):  this.generator = (s for s in lst)\n        def __iter__(this):      return this\n        def next(this): \n            try:\n                return this.generator.next()\n            except StopIteration:\n                return None\n\n    def iterator(self):\n        return SiteList.Iterator(self.__sites)\n\n    def __iter__(self):\n        return SiteList.Iterator(self.__sites)\n\n    def __len__(self):\n        return len(self.__sites)\n\n    def _getxmin(self): return self.__xmin\n    def _getymin(self): return self.__ymin\n    def _getxmax(self): return self.__xmax\n    def _getymax(self): return self.__ymax\n    xmin = property(_getxmin)\n    ymin = property(_getymin)\n    xmax = property(_getxmax)\n    ymax = property(_getymax)\n\n\n#------------------------------------------------------------------\ndef computeVoronoiDiagram(points):\n    \"\"\" Takes a list of point objects (which must have x and y fields).\n        Returns a 3-tuple of:\n\n           (1) a list of 2-tuples, which are the x,y coordinates of the \n               Voronoi diagram vertices\n           (2) a list of 3-tuples (a,b,c) which are the equations of the\n               lines in the Voronoi diagram: a*x + b*y = c\n           (3) a list of 3-tuples, (l, v1, v2) representing edges of the \n               Voronoi diagram.  l is the index of the line, v1 and v2 are\n               the indices of the vetices at the end of the edge.  If \n               v1 or v2 is -1, the line extends to infinity.\n    \"\"\"\n    siteList = SiteList(points)\n    context  = Context()\n    voronoi(siteList,context)\n    return (context.vertices,context.lines,context.edges)\n\n#------------------------------------------------------------------\ndef computeDelaunayTriangulation(points):\n    \"\"\" Takes a list of point objects (which must have x and y fields).\n        Returns a list of 3-tuples: the indices of the points that form a\n        Delaunay triangle.\n    \"\"\"\n    siteList = SiteList(points)\n    context  = Context()\n    context.triangulate = true\n    voronoi(siteList,context)\n    return context.triangles\n\ndef dist(p, v):\n    return (p.x - v[0]) * (p.x - v[0]) + (p.y - v[1]) * (p.y - v[1])\n\ndef distp(p1, p2):\n    return dist(p1, (p2.x, p2.y))\n\ndef modulo2pi(angle):\n    return angle - 2 * math.pi * math.floor((angle + math.pi) / (2 * math.pi))\n\n#-----------------------------------------------------------------------------\nif __name__ == '__main__':\n    Point = namedtuple('Point', ['x', 'y'])\n    N = int(raw_input())\n    l = []\n    for _ in range(N):\n        x, y = map(int, raw_input().split())\n        l.append(Point(x, y))\n    vor, _, _ = computeVoronoiDiagram(l)\n    if not vor:\n        print -1\n    else:\n        is_obtuse = True\n        rv = sorted([min([(math.sqrt(dist(p, v)), v) for p in l]) for v in vor])\n        rmin = 0\n        r_collision = 0\n        # print(rv)\n        save = []\n        while is_obtuse and rv:\n            # print('POP')\n            rmin, interesting_vor = rv.pop()\n            interesting_points = sorted([p for p in l if abs(math.sqrt(dist(p, interesting_vor)) - rmin) < 1e-4], key=lambda p: math.atan2(p.y - interesting_vor[1], p.x - interesting_vor[0]))\n            n = len(interesting_points)\n            # print(interesting_points)\n            save.append((interesting_vor, interesting_points))\n            r_collision = max([math.sqrt(distp(interesting_points[i], interesting_points[(i + 1) % n])) for i in range(n)]) / 2\n            angles = map(lambda p: math.atan2(p.y - interesting_vor[1], p.x - interesting_vor[0]), interesting_points)\n            # print([angle / math.pi for angle in angles])\n            is_obtuse = any([angles[i + 1] - angles[i] >= math.pi for i in range(n - 1)] + [angles[0] + 2 * math.pi - angles[-1] >= math.pi])\n        # print(r_collision, rmin, is_obtuse)\n        if DRAW:\n            with open('draw.tex', 'w') as f:\n                for p in l:\n                    f.write('\\\\filldraw[black] (%d,%d) circle (%e);\\n' % (p.x, p.y, rmin))\n                for p in l:\n                    f.write('\\\\filldraw[white] (%d,%d) circle (2pt);\\n' % (p.x, p.y))\n                for iv, ip in save[2:3]:\n                    f.write('\\\\filldraw[black] (%d,%d) circle (20pt);\\n' % (iv[0], iv[1]))\n                    f.write('\\\\draw[cyan]' + ' -- '.join('(%d,%d)' % (p.x, p.y) for p in ip) + ' -- cycle;\\n')\n                f.write('\\\\filldraw[yellow] (%d,%d) circle (2pt);\\n' % (interesting_vor[0], interesting_vor[1]))\n                for p in interesting_points:\n                    f.write('\\\\filldraw[red] (%d,%d) circle (2pt);\\n' % (p.x, p.y))\n        if is_obtuse or rmin <= r_collision:\n            print -1\n        else:\n            print rmin\n",
    "prob_desc_created_at": "1361374200",
    "tags": [],
    "hidden_unit_tests": ""
}
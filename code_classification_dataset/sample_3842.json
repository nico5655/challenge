{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"8\\n6\\n25\"]",
    "src_uid": "639eeeabcb005152035a1fcf09ed3b44",
    "prob_desc_notes": null,
    "prob_desc_description": "You are given a string $$$s$$$ consisting of the characters 0, 1, and ?.Let's call a string unstable if it consists of the characters 0 and 1 and any two adjacent characters are different (i. e. it has the form 010101... or 101010...).Let's call a string beautiful if it consists of the characters 0, 1, and ?, and you can replace the characters ? to 0 or 1 (for each character, the choice is independent), so that the string becomes unstable.For example, the strings 0??10, 0, and ??? are beautiful, and the strings 00 and ?1??1 are not.Calculate the number of beautiful contiguous substrings of the string $$$s$$$.",
    "prob_desc_output_spec": "For each test case, output a single integer — the number of beautiful substrings of the string $$$s$$$.",
    "prob_desc_input_spec": "The first line contains a single integer $$$t$$$ ($$$1 \\le t \\le 10^4$$$) — number of test cases. The first and only line of each test case contains the string $$$s$$$ ($$$1 \\le |s| \\le 2 \\cdot 10^5$$$) consisting of characters 0, 1, and ?. It is guaranteed that the sum of the string lengths over all test cases does not exceed $$$2 \\cdot 10^5$$$.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "Python 3",
    "lang_cluster": "Python",
    "difficulty": 1400,
    "file_name": "train_085.jsonl",
    "code_uid": "55574ab9369e8555c146282807e5d35b",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"3\\n0?10\\n???\\n?10??1100\"]",
    "exec_outcome": "PASSED",
    "source_code": "'''\nAuthor: your name\nDate: 2021-12-10 14:18:39\nLastEditTime: 2021-12-27 21:12:35\nLastEditors: Please set LastEditors\nDescription: In User Settings Edit\nFilePath: /code_everyWeek/week3.py\n'''\n\ndef unstable_string(input_str):\n    if len(input_str) == 1:\n        return 1\n    i = 0\n    j = 1\n    res = 0\n    lastj = 0\n    last_value = \"0/1\"\n    while i < len(input_str) and j < len(input_str):\n        ifok, last_value = judge_ok(input_str[j-1 : j+1], last_value)\n        if ifok:\n            j = j + 1\n        else:\n            res += (j - i) * (j - i + 1) // 2\n            if lastj > i:\n                res -= (lastj - i) * (lastj - i + 1) // 2\n            lastj = j\n            i = j\n            while i >= 0 and input_str[i-1] == '?':\n                i -= 1\n                last_value = \"0/1\"\n            j = i + 1\n            \n    res += (j - i) * (j - i + 1) // 2\n    if lastj > i:\n        res -= (lastj - i) * (lastj - i +1) // 2\n    return res\n\n    \ndef judge_ok(substr, last_value):\n    if substr == \"10\" or substr == \"01\" or (substr == \"??\" and last_value == \"0/1\"):\n        return True, last_value\n    if (substr == \"?1\" and last_value != \"1\") or (substr == \"?0\" and last_value != \"0\"):\n        return True, last_value\n    \n    if substr == \"??\" and last_value == \"0\":\n        return True, \"1\"\n    if substr == \"??\" and last_value == \"1\":\n        return True, \"0\"\n\n    if substr == \"1?\":\n        return True, \"0\"\n    if substr == \"0?\":\n        return True, \"1\"\n    return False, last_value\n\n\ndef unstable_string_dp(input_str):\n    \"\"\"\n        动态规划做法\n    \"\"\"\n    ans = 0\n    n = len(input_str)\n    dp = [[0, 0] for i in range(n)]\n    if input_str[0] == '0':\n        dp[0][0] = 1\n        dp[0][1] = 0\n    elif input_str[0] == '1':\n        dp[0][0] = 0\n        dp[0][1] = 1\n    else:\n        dp[0][0] = 1\n        dp[0][1] = 1\n    \n    ans += max(dp[0][1], dp[0][0])\n    \n    for i in range(1, n):\n        if input_str[i] == '0':\n            dp[i][1] = 0\n            dp[i][0] = dp[i - 1][1] + 1\n        elif input_str[i] == '1':\n            dp[i][0] = 0\n            dp[i][1] = dp[i - 1][0] + 1\n        else:\n            dp[i][0] = dp[i - 1][1] + 1\n            dp[i][1] = dp[i - 1][0] + 1\n        \n        ans += max(dp[i][1], dp[i][0])\n    \n    return ans\n\n\n\nif __name__ == \"__main__\":\n    num_test = int(input())\n    for i in range(num_test):\n        input_str = input()\n        res = unstable_string_dp(input_str)\n        print(res)\n\n\n",
    "prob_desc_created_at": "1622817300",
    "tags": [
        "binary search",
        "dp",
        "greedy",
        "implementation",
        "strings",
        "two pointers"
    ],
    "hidden_unit_tests": ""
}
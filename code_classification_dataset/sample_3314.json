{
    "prob_desc_time_limit": "5 seconds",
    "prob_desc_sample_outputs": "[\"9\\n13\\n15\", \"187\\n87\\n139\\n128\\n141\"]",
    "src_uid": "a5cc9b7ef5222280b20ee7e096a93394",
    "prob_desc_notes": null,
    "prob_desc_description": "Let's denote as L(x, p) an infinite sequence of integers y such that gcd(p, y) = 1 and y &gt; x (where gcd is the greatest common divisor of two integer numbers), sorted in ascending order. The elements of L(x, p) are 1-indexed; for example, 9, 13 and 15 are the first, the second and the third elements of L(7, 22), respectively.You have to process t queries. Each query is denoted by three integers x, p and k, and the answer to this query is k-th element of L(x, p).",
    "prob_desc_output_spec": "Print t integers, where i-th integer is the answer to i-th query.",
    "prob_desc_input_spec": "The first line contains one integer t (1 ≤ t ≤ 30000) — the number of queries to process. Then t lines follow. i-th line contains three integers x, p and k for i-th query (1 ≤ x, p, k ≤ 106).",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 2",
    "lang_cluster": "Python",
    "difficulty": 2200,
    "file_name": "train_052.jsonl",
    "code_uid": "0c227549e71e5cb8345e02847af64896",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"3\\n7 22 1\\n7 22 2\\n7 22 3\", \"5\\n42 42 42\\n43 43 43\\n44 44 44\\n45 45 45\\n46 46 46\"]",
    "exec_outcome": "PASSED",
    "source_code": "from __future__ import division, print_function\ndef main():\n    big = 10 ** 6\n    prime_factors = [[] for _ in range(big + 1)]\n    primes=[1 for i in range(big+1)]\n    def generate_primes(n):\n        \n        for p in range(2,n+1):\n            if primes[p]:\n                prime_factors[p].append(p)\n                for i in range(2 * p,n+1,p):\n                    primes[i] = 0\n                    prime_factors[i].append(p)\n    generate_primes(big)\n    result = []\n    for _ in range(int(input())):\n        x, p, k = map(int, input().split())\n        arr = prime_factors[p]\n        to_add = []\n        to_subtract = []\n        for i in range(1, 1 << len(arr)):\n            mul = 1\n            count = 0\n            for j in range(len(arr)):\n                if (1 << j) & i:\n                    count += 1\n                    mul *= arr[j]\n                \n            if count%2:\n                to_add.append(mul)\n            else:\n                to_subtract.append(mul)\n        count_before = 0\n        for num in to_add:\n            count_before += x//num\n            \n        for num in to_subtract:\n            count_before -= x//num\n        \n        k += (x - count_before)\n        \n        low = 0\n        high = 10**9\n        answer = high\n        while low <= high:\n            mid = (high + low)//2\n            temp_count = 0\n            for num in to_add:\n                temp_count += mid // num\n            for num in to_subtract:\n                temp_count -= mid // num\n            temp_count = mid - temp_count\n            if temp_count >= k:\n                answer = min(answer, mid)\n                high = mid - 1\n            else:\n                low = mid + 1\n        result.append(answer)\n    \n    print(*result, sep = \"\\n\")\n\n######## Python 2 and 3 footer by Pajenegod and c1729\n\n# Note because cf runs old PyPy3 version which doesn't have the sped up\n# unicode strings, PyPy3 strings will many times be slower than pypy2.\n# There is a way to get around this by using binary strings in PyPy3\n# but its syntax is different which makes it kind of a mess to use.\n\n# So on cf, use PyPy2 for best string performance.\n\npy2 = round(0.5)\nif py2:\n    from future_builtins import ascii, filter, hex, map, oct, zip\n    range = xrange\n\nimport os, sys\nfrom io import IOBase, BytesIO\n\nBUFSIZE = 8192\nclass FastIO(BytesIO):\n    newlines = 0\n\n    def __init__(self, file):\n        self._file = file\n        self._fd = file.fileno()\n        self.writable = \"x\" in file.mode or \"w\" in file.mode\n        self.write = super(FastIO, self).write if self.writable else None\n\n    def _fill(self):\n        s = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n        self.seek((self.tell(), self.seek(0,2), super(FastIO, self).write(s))[0])\n        return s\n\n    def read(self):\n        while self._fill(): pass\n        return super(FastIO,self).read()\n\n    def readline(self):\n        while self.newlines == 0:\n            s = self._fill(); self.newlines = s.count(b\"\\n\") + (not s)\n        self.newlines -= 1\n        return super(FastIO, self).readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.getvalue())\n            self.truncate(0), self.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        if py2:\n            self.write = self.buffer.write\n            self.read = self.buffer.read\n            self.readline = self.buffer.readline\n        else:\n            self.write = lambda s:self.buffer.write(s.encode('ascii'))\n            self.read = lambda:self.buffer.read().decode('ascii')\n            self.readline = lambda:self.buffer.readline().decode('ascii')\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip('\\r\\n')\n\n# Cout implemented in Python\nimport sys\nclass ostream:\n    def __lshift__(self,a):\n        sys.stdout.write(str(a))\n        return self\ncout = ostream()\nendl = '\\n'\n\n# Read all remaining integers in stdin, type is given by optional argument, this is fast\ndef readnumbers(zero = 0):\n    conv = ord if py2 else lambda x:x\n    A = []; numb = zero; sign = 1; i = 0; s = sys.stdin.buffer.read()\n    try:\n        while True:\n            if s[i] >= b'0' [0]:\n                numb = 10 * numb + conv(s[i]) - 48\n            elif s[i] == b'-' [0]: sign = -1\n            elif s[i] != b'\\r' [0]:\n                A.append(sign*numb)\n                numb = zero; sign = 1\n            i += 1\n    except:pass\n    if s and s[-1] >= b'0' [0]:\n        A.append(sign*numb)\n    return A\n\nif __name__== \"__main__\":\n  main()",
    "prob_desc_created_at": "1517582100",
    "tags": [
        "combinatorics",
        "number theory",
        "bitmasks",
        "math",
        "binary search",
        "brute force"
    ],
    "hidden_unit_tests": ""
}
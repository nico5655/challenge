{
    "prob_desc_time_limit": "1 second",
    "prob_desc_sample_outputs": "[\"2\\n1 1 1 2\\n1 2 2 2\", \"2\\n2 2 2 1\\n1 1 1 2\", \"4\\n2 1 1 1\\n2 2 2 1\\n1 1 1 2\\n1 2 2 2\", \"9\\n2 2 1 2\\n1 2 1 1\\n2 3 2 2\\n3 3 2 3\\n2 2 1 2\\n1 1 2 1\\n2 1 3 1\\n3 1 3 2\\n1 2 2 2\"]",
    "src_uid": "717f27957cc208a68a25a79befac6fc7",
    "prob_desc_notes": "NoteIn the fourth example the printed sequence of movements (shown on the picture below) is valid, but not shortest. There is a solution in $$$3$$$ operations.  ",
    "prob_desc_description": "Vasya passes all exams! Despite expectations, Vasya is not tired, moreover, he is ready for new challenges. However, he does not want to work too hard on difficult problems.Vasya remembered that he has a not-so-hard puzzle: $$$m$$$ colored cubes are placed on a chessboard of size $$$n \\times n$$$. The fact is that $$$m \\leq n$$$ and all cubes have distinct colors. Each cube occupies exactly one cell. Also, there is a designated cell for each cube on the board, the puzzle is to place each cube on its place. The cubes are fragile, so in one operation you only can move one cube onto one of four neighboring by side cells, if only it is empty. Vasya wants to be careful, so each operation takes exactly one second. Vasya used to train hard for VK Cup Final, so he can focus his attention on the puzzle for at most $$$3$$$ hours, that is $$$10800$$$ seconds. Help Vasya find such a sequence of operations that all cubes will be moved onto their designated places, and Vasya won't lose his attention.",
    "prob_desc_output_spec": "In the first line print a single integer $$$k$$$ ($$$0 \\le k \\leq 10800$$$) â€” the number of operations Vasya should make. In each of the next $$$k$$$ lines you should describe one operation: print four integers $$$x_1$$$, $$$y_1$$$, $$$x_2$$$, $$$y_2$$$, where $$$x_1, y_1$$$ is the position of the cube Vasya should move, and $$$x_2, y_2$$$ is the new position of the cube. The cells $$$x_1, y_1$$$ and $$$x_2, y_2$$$ should have a common side, the cell $$$x_2, y_2$$$ should be empty before the operation. We can show that there always exists at least one solution. If there are multiple solutions, print any of them.",
    "prob_desc_input_spec": "The first line contains two integers $$$n$$$ and $$$m$$$ ($$$1 \\leq m \\leq n \\leq 50$$$). Each of the next $$$m$$$ lines contains two integers $$$x_i$$$, $$$y_i$$$ ($$$1 \\leq x_i, y_i \\leq n$$$), the initial positions of the cubes. The next $$$m$$$ lines describe the designated places for the cubes in the same format and order.  It is guaranteed that all initial positions are distinct and all designated places are distinct, however, it is possible that some initial positions coincide with some final positions.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "Python 2",
    "lang_cluster": "Python",
    "difficulty": 2700,
    "file_name": "train_012.jsonl",
    "code_uid": "2b6b68a5a7c2b320db75f9aabb1638d3",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"2 1\\n1 1\\n2 2\", \"2 2\\n1 1\\n2 2\\n1 2\\n2 1\", \"2 2\\n2 1\\n2 2\\n2 2\\n2 1\", \"4 3\\n2 2\\n2 3\\n3 3\\n3 2\\n2 2\\n2 3\"]",
    "exec_outcome": "PASSED",
    "source_code": "def fix(grid,x,y, rev, moves):\n    want = grid[x][y][1]\n    while x < want:\n        if grid[x+1][y]:\n            fix(grid,x+1,y,rev, moves)\n        st = (x,y,x+1,y)\n        if rev:\n            st = (st[2],st[3],st[0],st[1])\n        moves.append(' '.join(map(str,st)))\n        grid[x+1][y], grid[x][y] = grid[x][y], grid[x+1][y]\n        x+=1\n    while x > want:\n        if grid[x-1][y]:\n            fix(grid,x-1,y,rev, moves)\n        st = (x,y,x-1,y)\n        if rev:\n            st = (st[2],st[3],st[0],st[1])\n        moves.append(' '.join(map(str,st)))\n        grid[x-1][y], grid[x][y] = grid[x][y], grid[x-1][y]\n        x-=1\n\ndef solve(cubes, rev):\n    global n,m\n    cubes=[[cubes[i][0],cubes[i][1],i+1] for i in xrange(m)]\n    cubes.sort()\n    moves = []\n    grid=[[0 for i in xrange(n+1)]for j in xrange(n+1)]\n    for i,(x,y,z) in enumerate(cubes):\n        grid[x][y] = (z,i+1)\n    for i in xrange(n+1):\n        for j in xrange(n+1):\n            if grid[i][j]:\n                fix(grid,i,j,rev, moves)\n    cubes = []\n    for i in xrange(n+1):\n        for j in xrange(n+1):\n            if grid[i][j]:\n                cubes.append([i,j,grid[i][j][0]])\n    \n    for i in xrange(m):\n        want = cubes[i][-1]\n        while cubes[i][1] < want:\n            st = (cubes[i][0], cubes[i][1], cubes[i][0], cubes[i][1] + 1)\n            if rev:\n                st = (st[2],st[3],st[0],st[1])\n            moves.append(' '.join(map(str,st)))\n            cubes[i][1] += 1\n        while cubes[i][1] > want:\n            st = (cubes[i][0], cubes[i][1], cubes[i][0], cubes[i][1] - 1)\n            if rev:\n                st = (st[2],st[3],st[0],st[1])\n            moves.append(' '.join(map(str,st)))\n            cubes[i][1] -= 1\n    for i in xrange(m):\n        want = cubes[i][-1]\n        while cubes[i][0] < want:\n            st = (cubes[i][0], cubes[i][1], cubes[i][0] + 1, cubes[i][1])\n            if rev:\n                st = (st[2],st[3],st[0],st[1])\n            moves.append(' '.join(map(str,st)))\n            cubes[i][0] += 1\n        while cubes[i][0] > want:\n            st = (cubes[i][0], cubes[i][1], cubes[i][0] - 1, cubes[i][1])\n            if rev:\n                st = (st[2],st[3],st[0],st[1])\n            moves.append(' '.join(map(str,st)))\n            cubes[i][0] -= 1\n    return moves\n\nn,m = map(int, raw_input().split())\nfirst = [map(int,raw_input().split()) for i in xrange(m)]\nsecond = [map(int,raw_input().split()) for i in xrange(m)]\nmoves = solve(first, 0) + list(reversed(solve(second, 1)))\nprint len(moves)\nprint '\\n'.join(moves)\n",
    "prob_desc_created_at": "1534685700",
    "tags": [
        "constructive algorithms",
        "implementation",
        "matrices"
    ],
    "hidden_unit_tests": ""
}
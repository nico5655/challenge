{
    "prob_desc_time_limit": "3 seconds",
    "prob_desc_sample_outputs": "[\"9\\n11\\n9\\n24\\n11\"]",
    "src_uid": "046d0c0c73aad1a5dc295af1a43e0fc6",
    "prob_desc_notes": "NoteFor the first query, the minimum weighted distance is between points $$$1$$$ and $$$3$$$, which is equal to $$$|x_1 - x_3| \\cdot (w_1 + w_3) = |-2 - 1| \\cdot (2 + 1) = 9$$$.For the second query, the minimum weighted distance is between points $$$2$$$ and $$$3$$$, which is equal to $$$|x_2 - x_3| \\cdot (w_2 + w_3) = |0 - 1| \\cdot (10 + 1) = 11$$$.For the fourth query, the minimum weighted distance is between points $$$3$$$ and $$$4$$$, which is equal to $$$|x_3 - x_4| \\cdot (w_3 + w_4) = |1 - 9| \\cdot (1 + 2) = 24$$$.",
    "prob_desc_description": "There are $$$n$$$ weighted points on the $$$OX$$$-axis. The coordinate and the weight of the $$$i$$$-th point is $$$x_i$$$ and $$$w_i$$$, respectively. All points have distinct coordinates and positive weights. Also, $$$x_i &lt; x_{i + 1}$$$ holds for any $$$1 \\leq i &lt; n$$$. The weighted distance between $$$i$$$-th point and $$$j$$$-th point is defined as $$$|x_i - x_j| \\cdot (w_i + w_j)$$$, where $$$|val|$$$ denotes the absolute value of $$$val$$$.You should answer $$$q$$$ queries, where the $$$i$$$-th query asks the following: Find the minimum weighted distance among all pairs of distinct points among the points in subarray $$$[l_i,r_i]$$$.",
    "prob_desc_output_spec": "For each query output one integer, the minimum weighted distance among all pair of distinct points in the given subarray.",
    "prob_desc_input_spec": "The first line contains 2 integers $$$n$$$ and $$$q$$$ $$$(2 \\leq n \\leq 3 \\cdot 10^5; 1 \\leq q \\leq 3 \\cdot 10^5)$$$ — the number of points and the number of queries. Then, $$$n$$$ lines follows, the $$$i$$$-th of them contains two integers $$$x_i$$$ and $$$w_i$$$ $$$(-10^9 \\leq x_i \\leq 10^9; 1 \\leq w_i \\leq 10^9)$$$ — the coordinate and the weight of the $$$i$$$-th point. It is guaranteed that the points are given in the increasing order of $$$x$$$. Then, $$$q$$$ lines follows, the $$$i$$$-th of them contains two integers $$$l_i$$$ and $$$r_i$$$ $$$(1 \\leq l_i &lt; r_i \\leq n)$$$ — the given subarray of the $$$i$$$-th query.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3",
    "lang_cluster": "Python",
    "difficulty": 2800,
    "file_name": "train_108.jsonl",
    "code_uid": "f339af14a07a24319672137d1263060e",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"5 5\\n-2 2\\n0 10\\n1 1\\n9 2\\n12 7\\n1 3\\n2 3\\n1 5\\n3 5\\n2 4\"]",
    "exec_outcome": "PASSED",
    "source_code": "''' F. Closest Pair\nhttps://codeforces.com/contest/1635/problem/F\n'''\n\nimport io, os, sys\ninput = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline  # decode().strip() if str\noutput = sys.stdout.write\n\nDEBUG = os.environ.get('debug') not in [None, '0']\n\nif DEBUG:\n    from inspect import currentframe, getframeinfo\n    from re import search\n\ndef debug(*args):\n    if not DEBUG: return\n    frame = currentframe().f_back\n    s = getframeinfo(frame).code_context[0]\n    r = search(r\"\\((.*)\\)\", s).group(1)\n    vnames = r.split(', ')\n    var_and_vals = [f'{var}={val}' for var, val in zip(vnames, args)]\n    prefix = f'{currentframe().f_back.f_lineno:02d}: '\n    print(f'{prefix}{\", \".join(var_and_vals)}')\n\n\nINF = float('inf')\n\n# -----------------------------------------\n\nclass FenwickTreeMin:\n    def __init__(self, data):\n        '''transform list into BIT'''\n        self.bit = data\n        for i in range(len(data)):\n            j = i | (i + 1)\n            if j < len(data):\n                data[j] = min(data[j], data[i])\n\n    def query(self, end):\n        '''calc min(bit[:end])'''\n        x = INF\n        while end:\n            x = min(x, self.bit[end - 1])\n            end &= end - 1  # 110 -> 100\n        return x\n\n    def update(self, idx, x):\n        '''updates bit[idx] += x'''\n        while idx < len(self.bit):\n            self.bit[idx] = min(self.bit[idx], x)\n            idx |= idx + 1   # 101 -> 110\n\n\n# let L[i] = max j < i s.t. wj <= wi, R[i] = min j > i s.t. wj <= wi\n# then closest pair for i..N-1 must be one of 2N intervals (L[i], i), (R[i], i)\n# given q = (l, r), find min-dist interval fully covered by (l, r)\n\ndef solve(N, Q, points, queries):\n    # find all cand intervals (L[i], i), (R[i], i)\n    # ends[l] = right ends of all cand intervals starting at l\n    ends = [[] for _ in range(N)]\n\n    stack = []\n    for i, (_, w) in enumerate(points):\n        while stack and points[stack[-1]][1] > w: stack.pop()\n        if stack: ends[stack[-1]].append(i)\n        stack.append(i)\n    \n    stack = []\n    for i in range(N-1, -1, -1):\n        _, w = points[i]\n        while stack and points[stack[-1]][1] > w: stack.pop()\n        if stack: ends[i].append(stack[-1])\n        stack.append(i)\n    \n    # query_ends[l] = [](r, i) for all queries starting at l\n    query_ends = [[] for _ in range(N)]\n    for i, (l, r) in enumerate(queries):\n        query_ends[l-1].append((r-1, i))\n    \n    # move l right to left\n    # add dist(l, ends[l]) and process query (l, query_ends[l])\n    # all intervals added so far will have left end >= l\n    # so fenwick.query(r) returns min dist inside (l, r)\n    fenwick = FenwickTreeMin([INF] * N)\n    res = [INF] * Q\n    for l in range(N-1, -1, -1):\n        for r in ends[l]:\n            fenwick.update(r, (points[r][0] - points[l][0]) * (points[r][1] + points[l][1]))\n        for r, i in query_ends[l]:\n            res[i] = fenwick.query(r + 1)\n\n    return res\n\n\ndef main():\n    N, Q = list(map(int, input().split()))\n    points = [list(map(int, input().split())) for _ in range(N)]\n    queries = [list(map(int, input().split())) for _ in range(Q)]\n    out = solve(N, Q, points, queries)\n    print('\\n'.join(map(str, out)))\n\n\nif __name__ == '__main__':\n    main()\n\n",
    "prob_desc_created_at": "1645367700",
    "tags": [
        "data structures",
        "greedy"
    ],
    "hidden_unit_tests": ""
}
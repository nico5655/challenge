{
    "prob_desc_time_limit": "5 seconds",
    "prob_desc_sample_outputs": "[\"2 1 8 7\"]",
    "src_uid": "e01cf98c203b8845312ce30af70d3f2e",
    "prob_desc_notes": "NoteLet d(x, y) be the shortest distance between cities x and y. Then in the example d(2, 1) = 3, d(1, 8) = 7, d(8, 7) = 3. The total distance equals 13. ",
    "prob_desc_description": "A famous sculptor Cicasso goes to a world tour!Well, it is not actually a world-wide. But not everyone should have the opportunity to see works of sculptor, shouldn't he? Otherwise there will be no any exclusivity. So Cicasso will entirely hold the world tour in his native country — Berland.Cicasso is very devoted to his work and he wants to be distracted as little as possible. Therefore he will visit only four cities. These cities will be different, so no one could think that he has \"favourites\". Of course, to save money, he will chose the shortest paths between these cities. But as you have probably guessed, Cicasso is a weird person. Although he doesn't like to organize exhibitions, he likes to travel around the country and enjoy its scenery. So he wants the total distance which he will travel to be as large as possible. However, the sculptor is bad in planning, so he asks you for help. There are n cities and m one-way roads in Berland. You have to choose four different cities, which Cicasso will visit and also determine the order in which he will visit them. So that the total distance he will travel, if he visits cities in your order, starting from the first city in your list, and ending in the last, choosing each time the shortest route between a pair of cities — will be the largest. Note that intermediate routes may pass through the cities, which are assigned to the tour, as well as pass twice through the same city. For example, the tour can look like that: . Four cities in the order of visiting marked as overlines: [1, 5, 2, 4].Note that Berland is a high-tech country. So using nanotechnologies all roads were altered so that they have the same length. For the same reason moving using regular cars is not very popular in the country, and it can happen that there are such pairs of cities, one of which generally can not be reached by car from the other one. However, Cicasso is very conservative and cannot travel without the car. Choose cities so that the sculptor can make the tour using only the automobile. It is guaranteed that it is always possible to do. ",
    "prob_desc_output_spec": "Print four integers — numbers of cities which Cicasso will visit according to optimal choice of the route. Numbers of cities should be printed in the order that Cicasso will visit them. If there are multiple solutions, print any of them.",
    "prob_desc_input_spec": "In the first line there is a pair of integers n and m (4 ≤ n ≤ 3000, 3 ≤ m ≤ 5000) — a number of cities and one-way roads in Berland. Each of the next m lines contains a pair of integers ui, vi (1 ≤ ui, vi ≤ n) — a one-way road from the city ui to the city vi. Note that ui and vi are not required to be distinct. Moreover, it can be several one-way roads between the same pair of cities. ",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 2",
    "lang_cluster": "Python",
    "difficulty": 2000,
    "file_name": "train_049.jsonl",
    "code_uid": "c92be19baf6f31ad8ad811e1c0efc3ec",
    "prob_desc_memory_limit": "512 megabytes",
    "prob_desc_sample_inputs": "[\"8 9\\n1 2\\n2 3\\n3 4\\n4 1\\n4 5\\n5 6\\n6 7\\n7 8\\n8 5\"]",
    "exec_outcome": "PASSED",
    "source_code": "#!/usr/bin/env python\nfrom __future__ import division, print_function\n\nimport os\nimport sys\nfrom io import BytesIO, IOBase\nfrom heapq import heappop, heappush\n\nif sys.version_info[0] < 3:\n    from __builtin__ import xrange as range\n    from future_builtins import ascii, filter, hex, map, oct, zip\n\n\nINF = float('inf')\n\n\n\ndef bfs(graph, start=0):\n    used = [False] * len(graph)\n    used[start] = True\n    dist = [0] * len(graph)\n    q = [start]\n    for v in q:\n        for w in graph[v]:\n            if not used[w]:\n                dist[w] = dist[v] + 1\n                used[w] = True\n                q.append(w)\n    return dist, q[-3:]\n\n\ndef main():\n    n, m = map(int, input().split())\n\n    rev_graph = [set() for _ in range(n)]\n    graph = [set() for _ in range(n)]\n    for _ in range(m):\n        u, v = map(int, input().split())\n        if u == v:\n            continue\n        graph[u - 1].add(v - 1)\n        rev_graph[v - 1].add(u - 1)\n\n\n    adj = [[0] * n for _ in range(n)]\n    best_to = [[0] * 3 for _ in range(n)]\n    best_from = [[0] * 3 for _ in range(n)]\n\n    for i in range(n):\n        adj[i], best_from[i] = bfs(graph, i)\n        _, best_to[i] = bfs(rev_graph, i)\n\n\n    best_score = 0\n    sol = (-1, -1, -1, -1)\n\n    for c2 in range(n):\n        for c3 in range(n):\n            if not adj[c2][c3] or c2 == c3:\n                continue\n\n            for c1 in best_to[c2]:\n                if c1 in [c2, c3]:\n                    continue\n\n                for c4 in best_from[c3]:\n                    if c4 in [c1, c2, c3]:\n                        continue\n\n                    score = adj[c1][c2] + adj[c2][c3] + adj[c3][c4]\n\n                    if score > best_score:\n                        best_score = score\n                        sol = (c1 + 1, c2 + 1, c3 + 1, c4 + 1)\n\n    print(*sol)\n\n\n# region fastio\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\ndef print(*args, **kwargs):\n    \"\"\"Prints the values to a stream, or to sys.stdout by default.\"\"\"\n    sep, file = kwargs.pop(\"sep\", \" \"), kwargs.pop(\"file\", sys.stdout)\n    at_start = True\n    for x in args:\n        if not at_start:\n            file.write(sep)\n        file.write(str(x))\n        at_start = False\n    file.write(kwargs.pop(\"end\", \"\\n\"))\n    if kwargs.pop(\"flush\", False):\n        file.flush()\n\n\nif sys.version_info[0] < 3:\n    sys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)\nelse:\n    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\n\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n# endregion\n\nif __name__ == \"__main__\":\n    main()\n",
    "prob_desc_created_at": "1461947700",
    "tags": [
        "shortest paths",
        "graphs"
    ],
    "hidden_unit_tests": ""
}
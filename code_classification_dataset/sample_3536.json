{
    "prob_desc_time_limit": "4.5 seconds",
    "prob_desc_sample_outputs": "[\"4 3 6 7\"]",
    "src_uid": "667d00cac98b3bd07fc7c78be5373fb5",
    "prob_desc_notes": null,
    "prob_desc_description": "Recently an official statement of the world Olympic Committee said that the Olympic Winter Games 2030 will be held in Tomsk. The city officials decided to prepare for the Olympics thoroughly and to build all the necessary Olympic facilities as early as possible. First, a biathlon track will be built.To construct a biathlon track a plot of land was allocated, which is a rectangle divided into n × m identical squares. Each of the squares has two coordinates: the number of the row (from 1 to n), where it is located, the number of the column (from 1 to m), where it is located. Also each of the squares is characterized by its height. During the sports the biathletes will have to move from one square to another. If a biathlete moves from a higher square to a lower one, he makes a descent. If a biathlete moves from a lower square to a higher one, he makes an ascent. If a biathlete moves between two squares with the same height, then he moves on flat ground.The biathlon track should be a border of some rectangular area of the allocated land on which biathletes will move in the clockwise direction. It is known that on one move on flat ground an average biathlete spends tp seconds, an ascent takes tu seconds, a descent takes td seconds. The Tomsk Administration wants to choose the route so that the average biathlete passes it in as close to t seconds as possible. In other words, the difference between time ts of passing the selected track and t should be minimum.For a better understanding you can look at the first sample of the input data. In this sample n = 6, m = 7, and the administration wants the track covering time to be as close to t = 48 seconds as possible, also, tp = 3, tu = 6 and td = 2. If we consider the rectangle shown on the image by arrows, the average biathlete can move along the boundary in a clockwise direction in exactly 48 seconds. The upper left corner of this track is located in the square with the row number 4, column number 3 and the lower right corner is at square with row number 6, column number 7.  Among other things the administration wants all sides of the rectangle which boundaries will be the biathlon track to consist of no less than three squares and to be completely contained within the selected land.You are given the description of the given plot of land and all necessary time values. You are to write the program to find the most suitable rectangle for a biathlon track. If there are several such rectangles, you are allowed to print any of them.",
    "prob_desc_output_spec": "In a single line of the output print four positive integers — the number of the row and the number of the column of the upper left corner and the number of the row and the number of the column of the lower right corner of the rectangle that is chosen for the track.",
    "prob_desc_input_spec": "The first line of the input contains three integers n, m and t (3 ≤ n, m ≤ 300, 1 ≤ t ≤ 109) — the sizes of the land plot and the desired distance covering time. The second line also contains three integers tp, tu and td (1 ≤ tp, tu, td ≤ 100) — the time the average biathlete needs to cover a flat piece of the track, an ascent and a descent respectively. Then n lines follow, each line contains m integers that set the heights of each square of the given plot of land. Each of the height values is a positive integer, not exceeding 106.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 2",
    "lang_cluster": "Python",
    "difficulty": 2300,
    "file_name": "train_066.jsonl",
    "code_uid": "b1c86f718877370e23952762bf2e49d3",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"6 7 48\\n3 6 2\\n5 4 8 3 3 7 9\\n4 1 6 8 7 1 1\\n1 6 4 6 4 8 6\\n7 2 6 1 6 9 4\\n1 9 8 6 3 9 2\\n4 5 6 8 4 3 7\"]",
    "exec_outcome": "PASSED",
    "source_code": "import sys\nrange = xrange\ninput = raw_input\n \ninp = map(int, sys.stdin.read().split())\nii = 0\n \nn = inp[ii]\nii += 1\nm = inp[ii]\nii += 1\nt = inp[ii]\nii += 1\n \ntp,tu,td = inp[ii:ii+3]\nii += 3\nT = [tp, tu, td]\n \nA = []\nfor _ in range(n):\n    A.append(inp[ii:ii+m])\n    ii += m\n \nD = [[0]*m for _ in range(n - 1)]\nU = [[0]*m for _ in range(n - 1)]\nfor y in range(n - 1):\n    Dy = D[y]\n    Uy = U[y]\n    Ay = A[y]\n    Ayp1 = A[y + 1]\n    for x in range(m):\n        Dy[x] = T[(Ay[x] <= Ayp1[x]) - (Ay[x] >= Ayp1[x])]\n        Uy[x] = T[(Ay[x] >= Ayp1[x]) - (Ay[x] <= Ayp1[x])]\n \nL = [[0]*(m - 1) for _ in range(n)]\nR = [[0]*(m - 1) for _ in range(n)]\nfor y in range(n):\n    Ly = L[y]\n    Ry = R[y]\n    Ay = A[y]\n    for x in range(m - 1):\n        Ry[x] = T[(Ay[x] <= Ay[x + 1]) - (Ay[x] >= Ay[x + 1])]\n        Ly[x] = T[(Ay[x] >= Ay[x + 1]) - (Ay[x] <= Ay[x + 1])]\n \nDcum = [[0]*m for _ in range(n)]\nUcum = [[0]*m for _ in range(n)]\nLcum = [[0]*m for _ in range(n)]\nRcum = [[0]*m for _ in range(n)]\n \nfor y in range(n):\n    Lcumy = Lcum[y]\n    Ly = L[y]\n    Rcumy = Rcum[y]\n    Ry = R[y]\n    for x in reversed(range(m - 1)):\n        Lcumy[x] = Lcumy[x + 1] + Ly[x]\n        Rcumy[x] = Rcumy[x + 1] + Ry[x]\n \n \nfor y in reversed(range(n - 1)):\n    Ucumy = Ucum[y]\n    Ucumyp1 = Ucum[y + 1]\n    Uy = U[y]\n    \n    Dcumy = Dcum[y]\n    Dcumyp1 = Dcum[y + 1]\n    Dy = D[y]\n \n \n    for x in range(m):\n        Ucumy[x] = Ucumyp1[x] + Uy[x]\n        Dcumy[x] = Dcumyp1[x] + Dy[x]\n \nbesta = 2 * 10**9\nbestay1 = -1\nbestay2 = -1\nbestax1 = -1\nbestax2 = -1\n \nfor y1 in range(n):\n    y1besta = besta\n \n    Rcumy1 = Rcum[y1]\n    Ucumy1 = Ucum[y1]\n    Dcumy1 = Dcum[y1]\n \n    help1y1 = [Rcumy1[x] + Ucumy1[x] - t for x in range(m)]\n    help2y1 = [Rcumy1[x] - Dcumy1[x] for x in range(m)]\n \n    for y2 in range(y1 + 2, n):\n        y2besta = besta\n        \n        Lcumy2 = Lcum[y2]\n        Ucumy2 = Ucum[y2]\n        Dcumy2 = Dcum[y2]\n        \n        precalc1 = [help1y1[x] + Lcumy2[x] - Ucumy2[x] for x in range(m)]\n        precalc2 = [help2y1[x] + Lcumy2[x] + Dcumy2[x] for x in range(m)]\n\n        tmp = []\n        \n        for x1 in range(m - 2):\n            t2 = precalc1[x1]\n            a = -1\n            b = len(tmp)\n            while 1 + a - b:\n                c = a + b >> 1\n                if tmp[c] < t2:\n                    a = c\n                else:\n                    b = c\n            tmp.insert(b, t2)\n            \n            t3 = precalc2[x1 + 2]\n            a = -1\n            b = len(tmp)\n            while 1 + a - b:\n                c = a + b >> 1\n                if tmp[c] < t3:\n                    a = c\n                else:\n                    b = c\n            \n            if b < len(tmp) and tmp[b] - t3 < besta:\n                besta = tmp[b] - t3\n            if b - 1 >= 0 and t3 - tmp[b - 1] < besta:\n                besta = t3 - tmp[b - 1]\n        \n        if y2besta != besta:\n            bestay2 = y2\n    if y1besta != besta:\n        bestay1 = y1\n\nRcumy1 = Rcum[bestay1]\nUcumy1 = Ucum[bestay1]\nDcumy1 = Dcum[bestay1]\nLcumy2 = Lcum[bestay2]\nUcumy2 = Ucum[bestay2]\nDcumy2 = Dcum[bestay2]\n \nfor bestax1 in range(m):\n    for bestax2 in range(bestax1 + 2, m):\n        val = Rcumy1[bestax1] - Rcumy1[bestax2] + Lcumy2[bestax1] - Lcumy2[bestax2] + Ucumy1[bestax1] - Ucumy2[bestax1] + Dcumy1[bestax2] - Dcumy2[bestax2]\n        if abs(val - t) == besta:break\n    else:\n        continue\n    break\n \nprint bestay1 + 1, bestax1 + 1, bestay2 + 1, bestax2 + 1\n",
    "prob_desc_created_at": "1398409200",
    "tags": [
        "dp",
        "constructive algorithms",
        "data structures",
        "binary search",
        "brute force"
    ],
    "hidden_unit_tests": ""
}
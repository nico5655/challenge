{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"1 2\\n1 3\\n3 5\\n3 4\\n2 7\\n7 6\\n5 1\\n1 3\\n3 2\\n2 4\"]",
    "src_uid": "dd3ba43eb0261ccdb7269a2696a042da",
    "prob_desc_notes": "NoteThe output of the first sample case corresponds to the following tree:    For the first restriction, the simple path between $$$1$$$ and $$$3$$$ is $$$1, 3$$$, which doesn't contain $$$2$$$. The simple path between $$$3$$$ and $$$5$$$ is $$$3, 5$$$, which doesn't contain $$$4$$$. The simple path between $$$5$$$ and $$$7$$$ is $$$5, 3, 1, 2, 7$$$, which doesn't contain $$$6$$$. The simple path between $$$6$$$ and $$$4$$$ is $$$6, 7, 2, 1, 3, 4$$$, which doesn't contain $$$5$$$. Thus, this tree meets all of the restrictions.The output of the second sample case corresponds to the following tree:   ",
    "prob_desc_description": "Lord Omkar would like to have a tree with $$$n$$$ nodes ($$$3 \\le n \\le 10^5$$$) and has asked his disciples to construct the tree. However, Lord Omkar has created $$$m$$$ ($$$\\mathbf{1 \\le m &lt; n}$$$) restrictions to ensure that the tree will be as heavenly as possible. A tree with $$$n$$$ nodes is an connected undirected graph with $$$n$$$ nodes and $$$n-1$$$ edges. Note that for any two nodes, there is exactly one simple path between them, where a simple path is a path between two nodes that does not contain any node more than once.Here is an example of a tree:   A restriction consists of $$$3$$$ pairwise distinct integers, $$$a$$$, $$$b$$$, and $$$c$$$ ($$$1 \\le a,b,c \\le n$$$). It signifies that node $$$b$$$ cannot lie on the simple path between node $$$a$$$ and node $$$c$$$. Can you help Lord Omkar and become his most trusted disciple? You will need to find heavenly trees for multiple sets of restrictions. It can be shown that a heavenly tree will always exist for any set of restrictions under the given constraints.",
    "prob_desc_output_spec": "For each test case, output $$$n-1$$$ lines representing the $$$n-1$$$ edges in the tree. On each line, output two integers $$$u$$$ and $$$v$$$ ($$$1 \\le u, v \\le n$$$, $$$u \\neq v$$$) signifying that there is an edge between nodes $$$u$$$ and $$$v$$$. Given edges have to form a tree that satisfies Omkar's restrictions.",
    "prob_desc_input_spec": "Each test contains multiple test cases. The first line contains the number of test cases $$$t$$$ ($$$1 \\leq t \\leq 10^4$$$). Description of the test cases follows. The first line of each test case contains two integers, $$$n$$$ and $$$m$$$ ($$$3 \\leq n \\leq 10^5$$$, $$$\\mathbf{1 \\leq m &lt; n}$$$), representing the size of the tree and the number of restrictions. The $$$i$$$-th of the next $$$m$$$ lines contains three integers $$$a_i$$$, $$$b_i$$$, $$$c_i$$$ ($$$1 \\le a_i, b_i, c_i \\le n$$$, $$$a$$$, $$$b$$$, $$$c$$$ are distinct), signifying that node $$$b_i$$$ cannot lie on the simple path between nodes $$$a_i$$$ and $$$c_i$$$.  It is guaranteed that the sum of $$$n$$$ across all test cases will not exceed $$$10^5$$$.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "Python 3",
    "lang_cluster": "Python",
    "difficulty": 1200,
    "file_name": "train_087.jsonl",
    "code_uid": "0cf5c96733100e8b5a852413d5fc16ca",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"2\\n7 4\\n1 2 3\\n3 4 5\\n5 6 7\\n6 5 4\\n5 3\\n1 2 3\\n2 3 4\\n3 4 5\"]",
    "exec_outcome": "PASSED",
    "source_code": "import os\nimport sys\nimport math\nfrom io import BytesIO, IOBase\nfrom collections import deque,defaultdict,OrderedDict,Counter\nfrom heapq import heappush,heappop,heapify\nfrom bisect import bisect_right,insort,bisect_left\nfrom functools import lru_cache\nfrom itertools import permutations\n\nsys.setrecursionlimit(10**6)\n\ndef STRIN():return input()\ndef INTIN():return int(input())\ndef LINT():return list(map(int,input().split()))\ndef LSTR():return list(map(str,input().split()))\ndef MINT():return map(int,input().split())\ndef MSTR():return map(str,input().split())\n\ndef divisors(n) :\n     \n    c=0\n    i=1\n    while i <= int(math.sqrt(n)):\n         \n        if (n % i == 0) :\n            if (n // i == i):\n                c+=1\n            else :\n                c+=2\n                 \n        i = i + 1\n\n    return c \n\ndef isValid(x,y,n,m,graph,vis):\n    if x<0 or x>=n or y<0 or y>=m or graph[x][y]=='#' or vis[x][y]:\n\n        return False\n\n    return True\n\n\ndef dfs(u,graph,vis,parent,p,vertex):\n    \n    vis[u]=1\n   \n    parent[u]=p\n    for v in graph[u]:\n       \n        if vis[v]:\n            if p!=v:\n                vertex[0]=v \n                vertex[1]=u\n                return True\n \n        if not vis[v]:\n            \n            if dfs(v,graph,vis,parent,u,vertex):                               \n                return True\n    \n    return False\n \n\ndef bfs(u,graph,vis,teams):\n    pass\n\n    \ndef palin(s):\n    s=str(s)\n\n    i=0\n    j=len(s)-1\n\n    while i<=j:\n        if s[i]!=s[j]:\n            return False\n\n        i+=1\n        j-=1\n\n\n    return True\n\n\n\n\ndef solve():\n\n    n,m=MINT()\n    ans=[]\n    st=set()\n    nodes=[]\n\n    for i in range(m):\n        a,b,c=MINT()\n        nodes.append((a,b,c))\n        st.add(b)\n           \n            \n    for i in range(1,n+1):\n        if i not in st:\n            node=i  \n\n\n            break\n\n            \n           \n    for i in range(1,n+1):\n        if i!=node:\n            ans.append([node,i])\n    \n\n    for i in range(len(ans)):\n        print(*ans[i],end=\"\\n\")\n\n\n\n       \n\n\ndef main():\n    for _ in range(INTIN()):\n        solve()\n    \n    \n        \n\n\n\n\n\n# region fastio\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n# endregion\n\nif __name__ == \"__main__\":\n    main()\n\n",
    "prob_desc_created_at": "1634468700",
    "tags": [
        "constructive algorithms",
        "trees"
    ],
    "hidden_unit_tests": ""
}
{
    "prob_desc_time_limit": "1.5 seconds",
    "prob_desc_sample_outputs": "[\"0 3 2 2\", \"0\", \"1073741823 0\"]",
    "src_uid": "891a7bd69187975f61b8c6ef6b6acac3",
    "prob_desc_notes": "NoteIn the first sample, these are all the arrays satisfying the statements:   $$$[0, 3, 2, 2]$$$,  $$$[2, 1, 0, 0]$$$,  $$$[2, 1, 0, 2]$$$,  $$$[2, 1, 2, 0]$$$,  $$$[2, 1, 2, 2]$$$,  $$$[2, 3, 0, 0]$$$,  $$$[2, 3, 0, 2]$$$,  $$$[2, 3, 2, 0]$$$,  $$$[2, 3, 2, 2]$$$. ",
    "prob_desc_description": "The Narrator has an integer array $$$a$$$ of length $$$n$$$, but he will only tell you the size $$$n$$$ and $$$q$$$ statements, each of them being three integers $$$i, j, x$$$, which means that $$$a_i \\mid a_j = x$$$, where $$$|$$$ denotes the bitwise OR operation.Find the lexicographically smallest array $$$a$$$ that satisfies all the statements.An array $$$a$$$ is lexicographically smaller than an array $$$b$$$ of the same length if and only if the following holds:   in the first position where $$$a$$$ and $$$b$$$ differ, the array $$$a$$$ has a smaller element than the corresponding element in $$$b$$$. ",
    "prob_desc_output_spec": "On a single line print $$$n$$$ integers $$$a_1, a_2, \\ldots, a_n$$$ ($$$0 \\le a_i &lt; 2^{30}$$$) — array $$$a$$$.",
    "prob_desc_input_spec": "In the first line you are given with two integers $$$n$$$ and $$$q$$$ ($$$1 \\le n \\le 10^5$$$, $$$0 \\le q \\le 2 \\cdot 10^5$$$). In the next $$$q$$$ lines you are given with three integers $$$i$$$, $$$j$$$, and $$$x$$$ ($$$1 \\le i, j \\le n$$$, $$$0 \\le x &lt; 2^{30}$$$) — the statements. It is guaranteed that all $$$q$$$ statements hold for at least one array.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3-64",
    "lang_cluster": "Python",
    "difficulty": 1900,
    "file_name": "train_082.jsonl",
    "code_uid": "19d850f43229ef9c5b587111f73d4efd",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"4 3\\n1 2 3\\n1 3 2\\n4 1 2\", \"1 0\", \"2 1\\n1 1 1073741823\"]",
    "exec_outcome": "PASSED",
    "source_code": "#  if you win, you live. you cannot win unless you fighst.\r\nfrom sys import stdin,setrecursionlimit\r\nimport os\r\nimport sys\r\nfrom io import BytesIO, IOBase\r\n\r\n_str = str\r\nstr = lambda x=b\"\": x if type(x) is bytes else _str(x).encode()\r\n\r\nBUFSIZE = 8192\r\n\r\n\r\nclass FastIO(IOBase):\r\n    newlines = 0\r\n\r\n    def __init__(self, file):\r\n        self._file = file\r\n        self._fd = file.fileno()\r\n        self.buffer = BytesIO()\r\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\r\n        self.write = self.buffer.write if self.writable else None\r\n\r\n    def read(self):\r\n        while True:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            if not b:\r\n                break\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines = 0\r\n        return self.buffer.read()\r\n\r\n    def readline(self):\r\n        while self.newlines == 0:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            self.newlines = b.count(b\"\\n\") + (not b)\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines -= 1\r\n        return self.buffer.readline()\r\n\r\n    def flush(self):\r\n        if self.writable:\r\n            os.write(self._fd, self.buffer.getvalue())\r\n            self.buffer.truncate(0), self.buffer.seek(0)\r\n\r\n\r\nclass IOWrapper(IOBase):\r\n    def __init__(self, file):\r\n        self.buffer = FastIO(file)\r\n        self.flush = self.buffer.flush\r\n        self.writable = self.buffer.writable\r\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\r\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\r\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\r\n\r\n\r\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\r\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\r\nimport heapq\r\nrd=lambda: map(lambda s: int(s), input().strip().split())\r\nrdone=lambda: map(lambda s: int(s)-1, input().strip().split())\r\nri=lambda: int(input())\r\nrs=lambda :input().strip()\r\nfrom collections import defaultdict as unsafedict,deque,Counter as unsafecounter\r\nfrom bisect import bisect_left as bl, bisect_right as br\r\nfrom random import randint\r\nfrom math import gcd, floor,log2,factorial,radians,sin,cos\r\nrandom = randint(1, 10 ** 9)\r\nmod=998244353\r\ndef ceil(a,b):\r\n    return (a+b-1)//b\r\nclass mydict:\r\n    def __init__(self,func):\r\n        self.random = randint(0,1<<32)\r\n        self.default=func\r\n        self.dict={}\r\n    def __getitem__(self,key):\r\n        mykey=self.random^key\r\n        if mykey not in self.dict:\r\n            self.dict[mykey]=self.default()\r\n        return self.dict[mykey]\r\n    def get(self,key,default):\r\n        mykey=self.random^key\r\n        if mykey not in self.dict:\r\n            return default\r\n        return self.dict[mykey]\r\n    def __setitem__(self,key,item):\r\n        mykey=self.random^key\r\n        self.dict[mykey]=item\r\n    def getkeys(self):\r\n        return [self.random^i for i in self.dict]\r\n    def __str__(self):\r\n        return f'{[(self.random^i,self.dict[i]) for i in self.dict]}'\r\n\r\n'''\r\n6576394 4462850\r\n268435455 4460800\r\n'''\r\nn,m=rd()\r\ncan1=[[True]*30 for i in range(n+1)]\r\ncan0=[[True]*30 for i in range(n+1)]\r\nstore=[[] for i in range(n+1)]\r\nst=[[0]*30 for i in range(n+1)]\r\nfor _ in range(m):\r\n    i,j,x=rd()\r\n    if j<i:\r\n        i,j=j,i\r\n    if i==j:\r\n        for bit in range(30):\r\n            if x&(1<<bit):\r\n                can0[i][bit]=False\r\n            else:\r\n                can1[i][bit]=False\r\n        continue\r\n    store[i].append((j,x))\r\n    for bit in range(30):\r\n        if x&(1<<bit) :\r\n            st[i][bit]=1\r\n            st[j][bit]=1\r\n        else:\r\n            can1[i][bit]=False\r\n            can1[j][bit]=False\r\nfor i in range(1,n+1):\r\n    for bit in range(30):\r\n        if can0[i][bit]==False:\r\n            continue\r\n        fl=False\r\n        need=False\r\n        for id,val in store[i]:\r\n            if val&(1<<bit):\r\n                need=True\r\n            if val&(1<<bit) and can1[id][bit]==False:\r\n                fl=True\r\n                break\r\n        if fl and need:\r\n            can0[i][bit]=False\r\n        elif need:\r\n            for id,val in store[i]:\r\n                if val&(1<<bit) :\r\n                    can0[id][bit]=False\r\nans=[]\r\nfor i in range(1,n+1):\r\n    pp=0\r\n    for bit in range(30):\r\n        if  can0[i][bit]==False:\r\n            pp|=(1<<bit)\r\n    ans.append(pp)\r\nprint(*ans)\r\n",
    "prob_desc_created_at": "1661006100",
    "tags": [
        "2-sat",
        "bitmasks",
        "graphs",
        "greedy"
    ],
    "hidden_unit_tests": ""
}
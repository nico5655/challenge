{
    "prob_desc_time_limit": "5 seconds",
    "prob_desc_sample_outputs": "[\"6\", \"10\", \"7\", \"2\"]",
    "src_uid": "2508a347f02aa0f49e0d154c54879b13",
    "prob_desc_notes": "NoteIn the first test, you can get the array $$$a = [11, 10, 9, 8, 7, 6, 5, 4, 3]$$$ by performing $$$6$$$ operations:   Set $$$a_3$$$ to $$$9$$$: the array becomes $$$[3, 2, 9, 8, 6, 9, 5, 4, 1]$$$;  Set $$$a_2$$$ to $$$10$$$: the array becomes $$$[3, 10, 9, 8, 6, 9, 5, 4, 1]$$$;  Set $$$a_6$$$ to $$$6$$$: the array becomes $$$[3, 10, 9, 8, 6, 6, 5, 4, 1]$$$;  Set $$$a_9$$$ to $$$3$$$: the array becomes $$$[3, 10, 9, 8, 6, 6, 5, 4, 3]$$$;  Set $$$a_5$$$ to $$$7$$$: the array becomes $$$[3, 10, 9, 8, 7, 6, 5, 4, 3]$$$;  Set $$$a_1$$$ to $$$11$$$: the array becomes $$$[11, 10, 9, 8, 7, 6, 5, 4, 3]$$$. $$$a$$$ is an arithmetic progression: in fact, $$$a_{i+1}-a_i=a_i-a_{i-1}=-1$$$ for any $$$2 \\leq i \\leq n-1$$$.There is no sequence of less than $$$6$$$ operations that makes $$$a$$$ an arithmetic progression.In the second test, you can get the array $$$a = [-1, 2, 5, 8, 11, 14, 17, 20, 23, 26, 29, 32, 35, 38]$$$ by performing $$$10$$$ operations.In the third test, you can get the array $$$a = [100000, 80000, 60000, 40000, 20000, 0, -20000, -40000, -60000, -80000]$$$ by performing $$$7$$$ operations.",
    "prob_desc_description": "You are given an array of integers $$$a_1, a_2, \\ldots, a_n$$$.You can do the following operation any number of times (possibly zero):   Choose any index $$$i$$$ and set $$$a_i$$$ to any integer (positive, negative or $$$0$$$). What is the minimum number of operations needed to turn $$$a$$$ into an arithmetic progression? The array $$$a$$$ is an arithmetic progression if $$$a_{i+1}-a_i=a_i-a_{i-1}$$$ for any $$$2 \\leq i \\leq n-1$$$.",
    "prob_desc_output_spec": "Print a single integer: the minimum number of operations needed to turn $$$a$$$ into an arithmetic progression.",
    "prob_desc_input_spec": "The first line contains a single integer $$$n$$$ ($$$1 \\le n \\le 10^5$$$). The second line contains $$$n$$$ integers $$$a_1, a_2, \\ldots, a_n$$$ ($$$1 \\leq a_i \\leq 10^5$$$).",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3-64",
    "lang_cluster": "Python",
    "difficulty": 2300,
    "file_name": "train_105.jsonl",
    "code_uid": "ecd05e438142a11b624af407f3794efa",
    "prob_desc_memory_limit": "1024 megabytes",
    "prob_desc_sample_inputs": "[\"9\\n3 2 7 8 6 9 5 4 1\", \"14\\n19 2 15 8 9 14 17 13 4 14 4 11 15 7\", \"10\\n100000 1 60000 2 20000 4 8 16 32 64\", \"4\\n10000 20000 10000 1\"]",
    "exec_outcome": "PASSED",
    "source_code": "import sys\r\ninput=sys.stdin.readline\r\n\r\nfrom collections import defaultdict,deque\r\nfrom heapq import heappush,heappop\r\nfrom functools import lru_cache\r\nimport time\r\nfrom math import gcd\r\n\r\ndef lcm(x, y):\r\n    return int(x * y / gcd(x, y))\r\n\r\nclass SortedList:\r\n    def __init__(self, iterable=[], _load=200):\r\n        \"\"\"Initialize sorted list instance.\"\"\"\r\n        values = sorted(iterable)\r\n        self._len = _len = len(values)\r\n        self._load = _load\r\n        self._lists = _lists = [values[i:i + _load] for i in range(0, _len, _load)]\r\n        self._list_lens = [len(_list) for _list in _lists]\r\n        self._mins = [_list[0] for _list in _lists]\r\n        self._fen_tree = []\r\n        self._rebuild = True\r\n \r\n    def _fen_build(self):\r\n        \"\"\"Build a fenwick tree instance.\"\"\"\r\n        self._fen_tree[:] = self._list_lens\r\n        _fen_tree = self._fen_tree\r\n        for i in range(len(_fen_tree)):\r\n            if i | i + 1 < len(_fen_tree):\r\n                _fen_tree[i | i + 1] += _fen_tree[i]\r\n        self._rebuild = False\r\n \r\n    def _fen_update(self, index, value):\r\n        \"\"\"Update `fen_tree[index] += value`.\"\"\"\r\n        if not self._rebuild:\r\n            _fen_tree = self._fen_tree\r\n            while index < len(_fen_tree):\r\n                _fen_tree[index] += value\r\n                index |= index + 1\r\n \r\n    def _fen_query(self, end):\r\n        \"\"\"Return `sum(_fen_tree[:end])`.\"\"\"\r\n        if self._rebuild:\r\n            self._fen_build()\r\n \r\n        _fen_tree = self._fen_tree\r\n        x = 0\r\n        while end:\r\n            x += _fen_tree[end - 1]\r\n            end &= end - 1\r\n        return x\r\n \r\n    def _fen_findkth(self, k):\r\n        \"\"\"Return a pair of (the largest `idx` such that `sum(_fen_tree[:idx]) <= k`, `k - sum(_fen_tree[:idx])`).\"\"\"\r\n        _list_lens = self._list_lens\r\n        if k < _list_lens[0]:\r\n            return 0, k\r\n        if k >= self._len - _list_lens[-1]:\r\n            return len(_list_lens) - 1, k + _list_lens[-1] - self._len\r\n        if self._rebuild:\r\n            self._fen_build()\r\n \r\n        _fen_tree = self._fen_tree\r\n        idx = -1\r\n        for d in reversed(range(len(_fen_tree).bit_length())):\r\n            right_idx = idx + (1 << d)\r\n            if right_idx < len(_fen_tree) and k >= _fen_tree[right_idx]:\r\n                idx = right_idx\r\n                k -= _fen_tree[idx]\r\n        return idx + 1, k\r\n \r\n    def _delete(self, pos, idx):\r\n        \"\"\"Delete value at the given `(pos, idx)`.\"\"\"\r\n        _lists = self._lists\r\n        _mins = self._mins\r\n        _list_lens = self._list_lens\r\n \r\n        self._len -= 1\r\n        self._fen_update(pos, -1)\r\n        del _lists[pos][idx]\r\n        _list_lens[pos] -= 1\r\n \r\n        if _list_lens[pos]:\r\n            _mins[pos] = _lists[pos][0]\r\n        else:\r\n            del _lists[pos]\r\n            del _list_lens[pos]\r\n            del _mins[pos]\r\n            self._rebuild = True\r\n \r\n    def _loc_left(self, value):\r\n        \"\"\"Return an index pair that corresponds to the first position of `value` in the sorted list.\"\"\"\r\n        if not self._len:\r\n            return 0, 0\r\n \r\n        _lists = self._lists\r\n        _mins = self._mins\r\n \r\n        lo, pos = -1, len(_lists) - 1\r\n        while lo + 1 < pos:\r\n            mi = (lo + pos) >> 1\r\n            if value <= _mins[mi]:\r\n                pos = mi\r\n            else:\r\n                lo = mi\r\n \r\n        if pos and value <= _lists[pos - 1][-1]:\r\n            pos -= 1\r\n \r\n        _list = _lists[pos]\r\n        lo, idx = -1, len(_list)\r\n        while lo + 1 < idx:\r\n            mi = (lo + idx) >> 1\r\n            if value <= _list[mi]:\r\n                idx = mi\r\n            else:\r\n                lo = mi\r\n \r\n        return pos, idx\r\n \r\n    def _loc_right(self, value):\r\n        \"\"\"Return an index pair that corresponds to the last position of `value` in the sorted list.\"\"\"\r\n        if not self._len:\r\n            return 0, 0\r\n \r\n        _lists = self._lists\r\n        _mins = self._mins\r\n \r\n        pos, hi = 0, len(_lists)\r\n        while pos + 1 < hi:\r\n            mi = (pos + hi) >> 1\r\n            if value < _mins[mi]:\r\n                hi = mi\r\n            else:\r\n                pos = mi\r\n \r\n        _list = _lists[pos]\r\n        lo, idx = -1, len(_list)\r\n        while lo + 1 < idx:\r\n            mi = (lo + idx) >> 1\r\n            if value < _list[mi]:\r\n                idx = mi\r\n            else:\r\n                lo = mi\r\n \r\n        return pos, idx\r\n \r\n    def add(self, value):\r\n        \"\"\"Add `value` to sorted list.\"\"\"\r\n        _load = self._load\r\n        _lists = self._lists\r\n        _mins = self._mins\r\n        _list_lens = self._list_lens\r\n \r\n        self._len += 1\r\n        if _lists:\r\n            pos, idx = self._loc_right(value)\r\n            self._fen_update(pos, 1)\r\n            _list = _lists[pos]\r\n            _list.insert(idx, value)\r\n            _list_lens[pos] += 1\r\n            _mins[pos] = _list[0]\r\n            if _load + _load < len(_list):\r\n                _lists.insert(pos + 1, _list[_load:])\r\n                _list_lens.insert(pos + 1, len(_list) - _load)\r\n                _mins.insert(pos + 1, _list[_load])\r\n                _list_lens[pos] = _load\r\n                del _list[_load:]\r\n                self._rebuild = True\r\n        else:\r\n            _lists.append([value])\r\n            _mins.append(value)\r\n            _list_lens.append(1)\r\n            self._rebuild = True\r\n \r\n    def discard(self, value):\r\n        \"\"\"Remove `value` from sorted list if it is a member.\"\"\"\r\n        _lists = self._lists\r\n        if _lists:\r\n            pos, idx = self._loc_right(value)\r\n            if idx and _lists[pos][idx - 1] == value:\r\n                self._delete(pos, idx - 1)\r\n \r\n    def remove(self, value):\r\n        \"\"\"Remove `value` from sorted list; `value` must be a member.\"\"\"\r\n        _len = self._len\r\n        self.discard(value)\r\n        if _len == self._len:\r\n            raise ValueError('{0!r} not in list'.format(value))\r\n \r\n    def pop(self, index=-1):\r\n        \"\"\"Remove and return value at `index` in sorted list.\"\"\"\r\n        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)\r\n        value = self._lists[pos][idx]\r\n        self._delete(pos, idx)\r\n        return value\r\n \r\n    def bisect_left(self, value):\r\n        \"\"\"Return the first index to insert `value` in the sorted list.\"\"\"\r\n        pos, idx = self._loc_left(value)\r\n        return self._fen_query(pos) + idx\r\n \r\n    def bisect_right(self, value):\r\n        \"\"\"Return the last index to insert `value` in the sorted list.\"\"\"\r\n        pos, idx = self._loc_right(value)\r\n        return self._fen_query(pos) + idx\r\n \r\n    def count(self, value):\r\n        \"\"\"Return number of occurrences of `value` in the sorted list.\"\"\"\r\n        return self.bisect_right(value) - self.bisect_left(value)\r\n \r\n    def __len__(self):\r\n        \"\"\"Return the size of the sorted list.\"\"\"\r\n        return self._len\r\n \r\n    def __getitem__(self, index):\r\n        \"\"\"Lookup value at `index` in sorted list.\"\"\"\r\n        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)\r\n        return self._lists[pos][idx]\r\n \r\n    def __delitem__(self, index):\r\n        \"\"\"Remove value at `index` from sorted list.\"\"\"\r\n        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)\r\n        self._delete(pos, idx)\r\n \r\n    def __contains__(self, value):\r\n        \"\"\"Return true if `value` is an element of the sorted list.\"\"\"\r\n        _lists = self._lists\r\n        if _lists:\r\n            pos, idx = self._loc_left(value)\r\n            return idx < len(_lists[pos]) and _lists[pos][idx] == value\r\n        return False\r\n \r\n    def __iter__(self):\r\n        \"\"\"Return an iterator over the sorted list.\"\"\"\r\n        return (value for _list in self._lists for value in _list)\r\n \r\n    def __reversed__(self):\r\n        \"\"\"Return a reverse iterator over the sorted list.\"\"\"\r\n        return (value for _list in reversed(self._lists) for value in reversed(_list))\r\n \r\n    def __repr__(self):\r\n        \"\"\"Return string representation of sorted list.\"\"\"\r\n        return 'SortedList({0})'.format(list(self))\r\n\r\n# for _ in range(int(input())):\r\n#     n = int(input())\r\n#     nums = list(map(int,input().split(' ')))\r\n#     nums.sort()\r\n#     print(nums[-1]+nums[-2])\r\n\r\n# for _ in range(int(input())):\r\n#     s = input()\r\n#     n = len(s)\r\n#     nums = list(s)\r\n#     d = defaultdict(list)\r\n#     for i,j in enumerate(nums):\r\n#         d[j].append(i)\r\n#     ans = 10**9\r\n#     for i in range(97,123):\r\n#         if len(d[chr(i)]) >= 1:\r\n#             ans = min(ans,d[chr(i)][-1])\r\n#     print(s[ans:])\r\n\r\n# for _ in range(int(input())):\r\n#     n = int(input())\r\n#     nums = list(map(int,input().split(' ')))\r\n#     nums.sort()\r\n#     total = sum(nums)\r\n#     q = SortedList()\r\n#     q.add(total)\r\n#     while q and nums and q[-1] >= nums[-1]:\r\n#         while q and nums and q[-1] == nums[-1]:\r\n#             q.pop()\r\n#             nums.pop()\r\n#         if q:\r\n#             t = q.pop()\r\n#             a,b = t//2,t-t//2\r\n#             q.add(a)\r\n#             q.add(b)\r\n#     if not nums:\r\n#         print('YES')\r\n#     else:\r\n#         print('NO')\r\n\r\n# for _ in range(int(input())):\r\n#     n = int(input())\r\n#     deg = [0]*(n+1)\r\n#     d = defaultdict(list)\r\n#     for _ in range(n-1):\r\n#         i,j,x,y = list(map(int,input().split(' ')))\r\n#         d[i].append((j,x,y))\r\n#         d[j].append((i,y,x))\r\n#         deg[i] += 1\r\n#         deg[j] += 1\r\n#     # print(deg)\r\n#     degg = SortedList([(deg[i],i) for i in range(1,n+1)])\r\n#     vis = set()\r\n#     ans = [1]*(n+1)\r\n#     q = deque()\r\n#     for i,j in degg:\r\n#         if i == 1:\r\n#             q.append(j)\r\n#     # while degg and n >= 1:\r\n#         # i = degg[0][1]\r\n#     while q:\r\n#         i = q.popleft()\r\n#         vis.add(i)\r\n#         for idx in d[i]:\r\n#             if idx[0] not in vis:\r\n#                 j,x,y = idx\r\n        \r\n#         r = gcd(x,y)\r\n#         x,y = x//r,y//r\r\n#         a,b = ans[i],ans[j]\r\n#         c = lcm(a,b)\r\n#         x1,y1 = c*x,c*y\r\n#         xm,ym = x1//a,y1//b\r\n#         r1 = gcd(xm,ym)\r\n#         # r1 = gcd(x1,y1)\r\n#         x1,y1 = x1//r1,y1//r1\r\n#         x2,y2 = x1//a,y1//b\r\n#         print(i,j,x,y,a,b,x2,y2)\r\n#         print('vis',vis)\r\n#         print(d[i],d[j])\r\n#         for k in d[i]:\r\n#             # print(k)\r\n#             if k[0] in vis:\r\n#                 ans[k[0]] *= x2\r\n#         for k in d[j]:\r\n#             # print(k)\r\n#             if k[0] in vis and k[0] != i:\r\n#                 ans[k[0]] *= y2\r\n#         ans[i] *= x2\r\n#         ans[j] *= y2\r\n#         print('ans',ans)\r\n#         n -= 1\r\n#         deg[i] -= 1\r\n#         # degg.pop(0)\r\n#         # degg.remove((deg[j],j))\r\n#         deg[j] -= 1\r\n#         if deg[j] == 1:\r\n#             q.append(j)\r\n#         # if deg[j] > 0:\r\n#         #     degg.add((deg[j],j))\r\n#     print(ans)\r\n\r\nn = int(input())\r\na = list(map(int,input().split(' ')))\r\nans = 0\r\nK = 317**3\r\ndic = [0]*K*2\r\nfor d in range(-317,317):\r\n    for i in range(n):\r\n        ai = a[i]-i*d+K\r\n        dic[ai] += 1\r\n        ans = max(ans,dic[ai])\r\n    for i in range(n):\r\n        ai = a[i]-i*d+K\r\n        dic[ai] = 0\r\n\r\n\r\nfor i in range(n):\r\n    for j in range(i+1,min(n,i+317)):\r\n        da = a[j] - a[i]\r\n        dx = j - i\r\n        if da % dx != 0:\r\n            continue\r\n        d = da//dx\r\n        dic[d] += 1\r\n        ans = max(ans,dic[d]+1)\r\n    for j in range(i+1,min(n,i+317)):\r\n        da = a[j] - a[i]\r\n        dx = j - i\r\n        d = da//dx\r\n        dic[d] = 0\r\nprint(n-ans)\r\n\r\n        \r\n        \r\n\r\n\r\n\r\n\r\n        ",
    "prob_desc_created_at": "1647764100",
    "tags": [
        "brute force",
        "data structures",
        "graphs",
        "math"
    ],
    "hidden_unit_tests": ""
}
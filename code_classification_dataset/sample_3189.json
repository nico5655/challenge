{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"-1\\n330\\n-1\\n40\"]",
    "src_uid": "c01a5ed6a598a1c443611a8f1b1a3db7",
    "prob_desc_notes": "NoteAll the subsets of multiset $$$\\{20, 300, 10001\\}$$$ are balanced, thus the answer is -1.The possible unbalanced subsets in the third query are $$$\\{20, 310\\}$$$ and $$$\\{20, 310, 10001\\}$$$. The lowest sum one is $$$\\{20, 310\\}$$$. Note that you are asked to choose a subset, not a subsegment, thus the chosen elements might not be adjancent in the array.The fourth query includes only the empty subset and subset $$$\\{20\\}$$$. Both of them are balanced.The last query includes the empty subset and the subsets $$$\\{20\\}$$$, $$$\\{20\\}$$$ and $$$\\{20, 20\\}$$$. Only $$$\\{20, 20\\}$$$ is unbalanced, its sum is $$$40$$$. Note that you are asked to choose a multiset, thus it might include equal elements.",
    "prob_desc_description": "Let's define a balanced multiset the following way. Write down the sum of all elements of the multiset in its decimal representation. For each position of that number check if the multiset includes at least one element such that the digit of the element and the digit of the sum at that position are the same. If that holds for every position, then the multiset is balanced. Otherwise it's unbalanced.For example, multiset $$$\\{20, 300, 10001\\}$$$ is balanced and multiset $$$\\{20, 310, 10001\\}$$$ is unbalanced:   The red digits mark the elements and the positions for which these elements have the same digit as the sum. The sum of the first multiset is $$$10321$$$, every position has the digit required. The sum of the second multiset is $$$10331$$$ and the second-to-last digit doesn't appear in any number, thus making the multiset unbalanced.You are given an array $$$a_1, a_2, \\dots, a_n$$$, consisting of $$$n$$$ integers.You are asked to perform some queries on it. The queries can be of two types:  $$$1~i~x$$$ — replace $$$a_i$$$ with the value $$$x$$$;  $$$2~l~r$$$ — find the unbalanced subset of the multiset of the numbers $$$a_l, a_{l + 1}, \\dots, a_r$$$ with the minimum sum, or report that no unbalanced subset exists. Note that the empty multiset is balanced.For each query of the second type print the lowest sum of the unbalanced subset. Print -1 if no unbalanced subset exists.",
    "prob_desc_output_spec": "For each query of the second type print the lowest sum of the unbalanced subset. Print -1 if no unbalanced subset exists.",
    "prob_desc_input_spec": "The first line contains two integers $$$n$$$ and $$$m$$$ ($$$1 \\le n, m \\le 2 \\cdot 10^5$$$) — the number of elements in the array and the number of queries, respectively. The second line contains $$$n$$$ integers $$$a_1, a_2, \\dots, a_n$$$ ($$$1 \\le a_i &lt; 10^9$$$). Each of the following $$$m$$$ lines contains a query of one of two types:   $$$1~i~x$$$ ($$$1 \\le i \\le n$$$, $$$1 \\le x &lt; 10^9$$$) — replace $$$a_i$$$ with the value $$$x$$$;  $$$2~l~r$$$ ($$$1 \\le l \\le r \\le n$$$) — find the unbalanced subset of the multiset of the numbers $$$a_l, a_{l + 1}, \\dots, a_r$$$ with the lowest sum, or report that no unbalanced subset exists.  It is guaranteed that there is at least one query of the second type.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 2",
    "lang_cluster": "Python",
    "difficulty": 2300,
    "file_name": "train_045.jsonl",
    "code_uid": "293f8cd68d6c41736e45fbbad469cf4d",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"4 5\\n300 10001 20 20\\n2 1 3\\n1 1 310\\n2 1 3\\n2 3 3\\n2 3 4\"]",
    "exec_outcome": "PASSED",
    "source_code": "class segtree:\n    def __init__(s, data):\n        s.n = len(data)\n        s.m = 1\n        while s.m < s.n: s.m *= 2\n \n        s.data = [0]*(2*s.m)\n        s.data[s.m : s.m + s.n] = data\n        for i in reversed(range(1, s.m)):\n            s.data[i] = min(s.data[2*i], s.data[2*i + 1])\n \n    def set(s,i,val):\n        i += s.m\n        while i:\n            s.data[i] = val\n            val = min(val, s.data[i ^ 1])\n            i >>= 1\n \n    def min(s,index):\n        ans = min(index, key = s.data.__getitem__)\n        goal = s.data[ans]\n        while ans < s.m:\n            ans <<= 1\n            if s.data[ans] != goal:\n                ans += 1\n        return ans - s.m, goal\n \ndef main():\n    big = 10**9 + 1\n    \n    inp = readnumbers()\n    ii = 0\n \n    n = inp[ii]\n    ii += 1\n    m = inp[ii]\n    ii += 1\n \n    M = 1\n    while M < n:\n        M *= 2\n \n    A = inp[ii:ii+n]\n    ii += n\n    \n    B = list(A)\n    segs = []\n    for _ in range(9):\n        tmp = []\n        for i in range(n):\n            B[i], diff = divmod(B[i], 10)\n            tmp.append(A[i] if diff else big)\n        segs.append(segtree(tmp))\n    \n \n    for _ in range(m):\n        c = inp[ii]\n        ii += 1\n        if c == 1:\n            i = inp[ii] - 1\n            ii += 1\n            x = inp[ii]\n            ii += 1\n \n            A[i] = xx = x\n            for seg in segs:\n                xx, diff = divmod(xx, 10)\n                seg.set(i, x if diff else big)\n \n        else:\n            l = inp[ii] - 1\n            ii += 1\n            r = inp[ii]\n            ii += 1\n            \n            if r - l <= 1:\n                cout << -1 << '\\n'\n                continue\n \n            L = l + M\n            R = r + M\n            index = []\n            while L < R:\n                if L & 1:\n                    index.append(L)\n                    L += 1\n                if R & 1:\n                    index.append(R - 1)\n                L >>= 1\n                R >>= 1\n \n \n            minval = 2 * big\n            for seg in segs:\n                idx,val = seg.min(index)\n                if 2 * val < minval:\n                    seg.set(idx, big)\n                    idx2,val2 = seg.min(index)\n                    seg.set(idx, val)\n \n                    if val2 != big:\n                        minval = min(minval, val + val2)\n \n            cout << (minval if minval - 2 * big else -1) << '\\n'\n \n \n \n \n######## Python 2 and 3 footer by Pajenegod and c1729\n \n# Note because cf runs old PyPy3 version which doesn't have the sped up\n# unicode strings, PyPy3 strings will many times be slower than pypy2.\n# There is a way to get around this by using binary strings in PyPy3\n# but its syntax is different which makes it kind of a mess to use.\n \n# So on cf, use PyPy2 for best string performance.\n \npy2 = round(0.5)\nif py2:\n    from future_builtins import ascii, filter, hex, map, oct, zip\n    range = xrange\n \nimport os, sys\nfrom io import IOBase, BytesIO\n \nBUFSIZE = 8192\nclass FastIO(BytesIO):\n    newlines = 0\n \n    def __init__(self, file):\n        self._file = file\n        self._fd = file.fileno()\n        self.writable = \"x\" in file.mode or \"w\" in file.mode\n        self.write = super(FastIO, self).write if self.writable else None\n \n    def _fill(self):\n        s = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n        self.seek((self.tell(), self.seek(0,2), super(FastIO, self).write(s))[0])\n        return s\n \n    def read(self):\n        while self._fill(): pass\n        return super(FastIO,self).read()\n \n    def readline(self):\n        while self.newlines == 0:\n            s = self._fill(); self.newlines = s.count(b\"\\n\") + (not s)\n        self.newlines -= 1\n        return super(FastIO, self).readline()\n \n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.getvalue())\n            self.truncate(0), self.seek(0)\n \nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        if py2:\n            self.write = self.buffer.write\n            self.read = self.buffer.read\n            self.readline = self.buffer.readline\n        else:\n            self.write = lambda s:self.buffer.write(s.encode('ascii'))\n            self.read = lambda:self.buffer.read().decode('ascii')\n            self.readline = lambda:self.buffer.readline().decode('ascii')\n \n \nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip('\\r\\n')\n \n# Cout implemented in Python\nimport sys\nclass ostream:\n    def __lshift__(self,a):\n        sys.stdout.write(str(a))\n        return self\ncout = ostream()\nendl = '\\n'\n \n# Read all remaining integers in stdin, type is given by optional argument, this is fast\ndef readnumbers(zero = 0):\n    conv = ord if py2 else lambda x:x\n    A = []; numb = zero; sign = 1; i = 0; s = sys.stdin.buffer.read()\n    try:\n        while True:\n            if s[i] >= b'0' [0]:\n                numb = 10 * numb + conv(s[i]) - 48\n            elif s[i] == b'-' [0]: sign = -1\n            elif s[i] != b'\\r' [0]:\n                A.append(sign*numb)\n                numb = zero; sign = 1\n            i += 1\n    except:pass\n    if s and s[-1] >= b'0' [0]:\n        A.append(sign*numb)\n    return A\n \n \nif __name__== \"__main__\":\n    main()",
    "prob_desc_created_at": "1567694100",
    "tags": [
        "data structures",
        "implementation",
        "greedy",
        "math"
    ],
    "hidden_unit_tests": ""
}
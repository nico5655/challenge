{
    "prob_desc_time_limit": "1 second",
    "prob_desc_sample_outputs": "[\"4\\n4\\n1\\n1\"]",
    "src_uid": "f7f1d57921fe7b7a697967dcfc8f0169",
    "prob_desc_notes": "NoteIn the first test battle points for each ant are v = [4, 0, 2, 0, 2], so ant number 1 is freed. Mole eats the ants 2, 3, 4, 5.In the second test case battle points are v = [0, 2, 0, 2], so no ant is freed and all of them are eaten by Mole.In the third test case battle points are v = [2, 0, 2], so ants number 3 and 5 are freed. Mole eats only the ant 4.In the fourth test case battle points are v = [0, 1], so ant number 5 is freed. Mole eats the ant 4.",
    "prob_desc_description": "Mole is hungry again. He found one ant colony, consisting of n ants, ordered in a row. Each ant i (1 ≤ i ≤ n) has a strength si.In order to make his dinner more interesting, Mole organizes a version of «Hunger Games» for the ants. He chooses two numbers l and r (1 ≤ l ≤ r ≤ n) and each pair of ants with indices between l and r (inclusively) will fight. When two ants i and j fight, ant i gets one battle point only if si divides sj (also, ant j gets one battle point only if sj divides si). After all fights have been finished, Mole makes the ranking. An ant i, with vi battle points obtained, is going to be freed only if vi = r - l, or in other words only if it took a point in every fight it participated. After that, Mole eats the rest of the ants. Note that there can be many ants freed or even none.In order to choose the best sequence, Mole gives you t segments [li, ri] and asks for each of them how many ants is he going to eat if those ants fight.",
    "prob_desc_output_spec": "Print to the standard output t lines. The i-th line contains number of ants that Mole eats from the segment [li, ri].",
    "prob_desc_input_spec": "The first line contains one integer n (1 ≤ n ≤ 105), the size of the ant colony.  The second line contains n integers s1, s2, ..., sn (1 ≤ si ≤ 109), the strengths of the ants.  The third line contains one integer t (1 ≤ t ≤ 105), the number of test cases.  Each of the next t lines contains two integers li and ri (1 ≤ li ≤ ri ≤ n), describing one query.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 2",
    "lang_cluster": "Python",
    "difficulty": 2100,
    "file_name": "train_062.jsonl",
    "code_uid": "da2a4a4e23a6d99ca26015529c1e202b",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"5\\n1 3 2 4 2\\n4\\n1 5\\n2 5\\n3 5\\n4 5\"]",
    "exec_outcome": "PASSED",
    "source_code": "import sys\nrange = xrange\n\n# n log n time and memory precalc,\n# then answers queries in O(1) time\nclass Queries:\n    def __init__(self, A, f = lambda a,b: a + b, max_d = float('inf')):\n        self.f = f\n        self.lists = [A]\n        n = len(A)\n        for d in range(1, min(n.bit_length(), max_d + 1)):\n            tmp = list(A)\n            self.lists.append(tmp)\n            x = (1 << d) + 1\n            jump = x + 1\n            I = (1 << d + 1) - 1\n            while x < n:\n                tmp[x]     = f(tmp[x - 1], tmp[x])\n                tmp[x ^ I] = f(tmp[x ^ I], tmp[x - 1 ^ I])\n                x += 1 if ~x & I else jump\n            if x == n:\n                while x & I:\n                    tmp[x ^ I] = f(tmp[x ^ I], tmp[x - 1 ^ I])\n                    x += 1\n\n    def __call__(self, a, b):\n        tmp = self.lists[(a ^ b - 1).bit_length() - 1]\n        return self.f(tmp[a], tmp[b - 1]) if a - b + 1 else self.lists[0][a]\n\n# n log log n time and memory precalc\n# then answers queries in O(1) time\nclass Queries2:\n    def __init__(self, A, f = lambda a,b: a + b):\n        self.f = f\n        self.c = Queries(A, f, 3).__call__\n        \n        n = len(A)\n        self.p = prefix = list(A)\n        self.s = suffix = list(A)\n        i = 17\n        while i < n:\n            prefix[i] = f(prefix[i - 1], prefix[i])\n            i += 1 + (~i & 15 == 0)\n        i = n - 2 if n - 2 & 15 != 15 else n - 3\n        while i >= 0:\n            suffix[i] = f(suffix[i], suffix[i + 1])\n            i -= 1 + (i & 15 == 0)\n        self.k = Queries(suffix[:-16: 16], f).__call__\n\n    def __call__(self, a, b):\n        if a ^ b - 1 < 16: \n            return self.c(a, b)\n        return self.f(self.f(self.s[a], self.k((a >> 4) + 1, b - 1 >> 4)) if (a >> 4) + 1 < b - 1 >> 4 else self.s[a], self.p[b - 1])\n\ndef gcd(a,b):\n    while a:\n        a,b = b % a, a\n    return b\n\ndef merge((val1, count1), (val2, count2)):\n    g = gcd(val1, val2)\n    if g == val1 == val2:\n        return g, count1 + count2\n    elif g == val1:\n        return g, count1\n    elif g == val2:\n        return g, count2\n    else:\n        return g, 0\n\ninp = [int(x) for x in sys.stdin.read().split()]; ii = 0\n\nn = inp[ii]; ii += 1\nS = inp[ii: ii + n]; ii += n\n\nRQ = Queries2([(s,1) for s in S], merge)\n\nt = inp[ii]; ii += 1\nout = []\nfor _ in range(t):\n    l = inp[ii] - 1; ii += 1\n    r = inp[ii]; ii += 1\n\n    out.append(r - l - RQ(l,r)[1])\nprint '\\n'.join(str(x) for x in out)\n",
    "prob_desc_created_at": "1412609400",
    "tags": [
        "data structures",
        "number theory",
        "math"
    ],
    "hidden_unit_tests": ""
}
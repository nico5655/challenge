{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"4\\n2\\n31\\n7\"]",
    "src_uid": "5b40c60ba54c7bb9a649b15588ef6510",
    "prob_desc_notes": "NoteIn the first example, the valid subsequences are $$$[0]$$$, $$$[1]$$$, $$$[0,1]$$$ and $$$[0,2]$$$.In the second example, the valid subsequences are $$$[0]$$$ and $$$[1]$$$.In the third example, any non-empty subsequence is valid. ",
    "prob_desc_description": "Let's call a sequence of integers $$$x_1, x_2, \\dots, x_k$$$ MEX-correct if for all $$$i$$$ ($$$1 \\le i \\le k$$$) $$$|x_i - \\operatorname{MEX}(x_1, x_2, \\dots, x_i)| \\le 1$$$ holds. Where $$$\\operatorname{MEX}(x_1, \\dots, x_k)$$$ is the minimum non-negative integer that doesn't belong to the set $$$x_1, \\dots, x_k$$$. For example, $$$\\operatorname{MEX}(1, 0, 1, 3) = 2$$$ and $$$\\operatorname{MEX}(2, 1, 5) = 0$$$.You are given an array $$$a$$$ consisting of $$$n$$$ non-negative integers. Calculate the number of non-empty MEX-correct subsequences of a given array. The number of subsequences can be very large, so print it modulo $$$998244353$$$. Note: a subsequence of an array $$$a$$$ is a sequence $$$[a_{i_1}, a_{i_2}, \\dots, a_{i_m}]$$$ meeting the constraints $$$1 \\le i_1 &lt; i_2 &lt; \\dots &lt; i_m \\le n$$$. If two different ways to choose the sequence of indices $$$[i_1, i_2, \\dots, i_m]$$$ yield the same subsequence, the resulting subsequence should be counted twice (i. e. two subsequences are different if their sequences of indices $$$[i_1, i_2, \\dots, i_m]$$$ are not the same).",
    "prob_desc_output_spec": "For each test case, print a single integer — the number of non-empty MEX-correct subsequences of a given array, taken modulo $$$998244353$$$.",
    "prob_desc_input_spec": "The first line contains a single integer $$$t$$$ ($$$1 \\le t \\le 10^5$$$) — the number of test cases. The first line of each test case contains a single integer $$$n$$$ ($$$1 \\le n \\le 5 \\cdot 10^5$$$). The second line contains $$$n$$$ integers $$$a_1, a_2, \\dots, a_n$$$ ($$$0 \\le a_i \\le n$$$). The sum of $$$n$$$ over all test cases doesn't exceed $$$5 \\cdot 10^5$$$.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3-64",
    "lang_cluster": "Python",
    "difficulty": 1900,
    "file_name": "train_090.jsonl",
    "code_uid": "0d4b2c83f1d4316b89955f4a20c758ca",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"4\\n3\\n0 2 1\\n2\\n1 0\\n5\\n0 0 0 0 0\\n4\\n0 1 2 3\"]",
    "exec_outcome": "PASSED",
    "source_code": "import sys\r\nimport os\r\nfrom io import BytesIO, IOBase\r\n\r\n# region fastio\r\n# BUFSIZE = 8192\r\n#   \r\n# class FastIO(IOBase):\r\n#     newlines = 0\r\n#   \r\n#     def __init__(self, file):\r\n#         self._fd = file.fileno()\r\n#         self.buffer = BytesIO()\r\n#         self.writable = \"x\" in file.mode or \"r\" not in file.mode\r\n#         self.write = self.buffer.write if self.writable else None\r\n#   \r\n#     def read(self):\r\n#         while True:\r\n#             b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n#             if not b:\r\n#                 break\r\n#             ptr = self.buffer.tell()\r\n#             self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n#         self.newlines = 0\r\n#         return self.buffer.read()\r\n#   \r\n#     def readline(self):\r\n#         while self.newlines == 0:\r\n#             b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n#             self.newlines = b.count(b\"\\n\") + (not b)\r\n#             ptr = self.buffer.tell()\r\n#             self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n#         self.newlines -= 1\r\n#         return self.buffer.readline()\r\n#   \r\n#     def flush(self):\r\n#         if self.writable:\r\n#             os.write(self._fd, self.buffer.getvalue())\r\n#             self.buffer.truncate(0), self.buffer.seek(0)\r\n#   \r\n# class IOWrapper(IOBase):\r\n#     def __init__(self, file):\r\n#         self.buffer = FastIO(file)\r\n#         self.flush = self.buffer.flush\r\n#         self.writable = self.buffer.writable\r\n#         self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\r\n#         self.read = lambda: self.buffer.read().decode(\"ascii\")\r\n#         self.readline = lambda: self.buffer.readline().decode(\"ascii\")\r\n#  \r\n# if sys.version_info[0] < 3:\r\n#     sys.stdin = BytesIO(os.read(0, os.fstat(0).st_size))\r\n# else:\r\n#     sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\r\n\r\nf = sys.stdin\r\nif os.environ.get('USER') == \"loic\":\r\n    f = open(\"data.in\")\r\n    \r\nline = lambda: f.readline().split()\r\nui = lambda: int(line()[0])\r\nti = lambda: map(int,line())\r\nli = lambda: list(ti())\r\n\r\n#######################################################################\r\n\r\ndef solve():\r\n    \r\n    ones = 0\r\n    sz = N + 2\r\n    dp = [0] * sz\r\n    pref = [0] * sz\r\n    \r\n    for val in A:\r\n        if val == 1:\r\n            ones = (ones * 2 + 1) % M\r\n        \r\n        mex = val\r\n        \r\n        if mex >= 1:\r\n            dp[mex] = (dp[mex] * 2) % M\r\n            dp[mex] = (dp[mex] + pref[mex-1]) % M\r\n            pref[mex] = (pref[mex] * 2) % M\r\n            pref[mex] = (pref[mex] + pref[mex-1]) % M\r\n        else:\r\n            dp[0] = (dp[0] * 2 + 1) % M\r\n            pref[0] = (pref[0] * 2 + 1) % M\r\n         \r\n        if val >= 2:\r\n            mex = val - 2\r\n            dp[mex] = (dp[mex] * 2) % M\r\n    \r\n    \r\n    res = ones\r\n    for i in range(sz):\r\n        res = (res + dp[i]) % M\r\n        \r\n    res %= M\r\n    \r\n    return str(res)\r\n\r\nZ = 5 * 10**5\r\nM = 998244353\r\n# POW = power_two(Z)\r\nfor test in range(1,ui()+1):\r\n    N = ui()\r\n    A = li()\r\n    \r\n    print(solve())\r\n    \r\nf.close()",
    "prob_desc_created_at": "1638369300",
    "tags": [
        "dp",
        "math"
    ],
    "hidden_unit_tests": ""
}
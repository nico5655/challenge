{
    "prob_desc_time_limit": "4 seconds",
    "prob_desc_sample_outputs": "[\"1\\n2\\n1\\n6\\n-1\"]",
    "src_uid": "797533fd0d87c7f6de60aafac9a915cd",
    "prob_desc_notes": "NoteTest case $$$1$$$: one optimal partition is $$$[1, 2]$$$, $$$[-3]$$$. $$$1+2&gt;0$$$ so the value of $$$[1, 2]$$$ is $$$2$$$. $$$-3&lt;0$$$, so the value of $$$[-3]$$$ is $$$-1$$$. $$$2+(-1)=1$$$.Test case $$$2$$$: the optimal partition is $$$[0, -2, 3]$$$, $$$[-4]$$$, and the sum of values is $$$3+(-1)=2$$$.",
    "prob_desc_description": "You are given an array $$$a$$$ consisting of $$$n$$$ integers. You should divide $$$a$$$ into continuous non-empty subarrays (there are $$$2^{n-1}$$$ ways to do that).Let $$$s=a_l+a_{l+1}+\\ldots+a_r$$$. The value of a subarray $$$a_l, a_{l+1}, \\ldots, a_r$$$ is:   $$$(r-l+1)$$$ if $$$s&gt;0$$$, $$$0$$$ if $$$s=0$$$, $$$-(r-l+1)$$$ if $$$s&lt;0$$$.  What is the maximum sum of values you can get with a partition?",
    "prob_desc_output_spec": "For each test case print a single integer — the maximum sum of values you can get with an optimal parition.",
    "prob_desc_input_spec": "The input consists of multiple test cases. The first line contains a single integer $$$t$$$ ($$$1 \\le t \\le 5 \\cdot 10^5$$$) — the number of test cases. The description of the test cases follows. The first line of each test case contains a single integer $$$n$$$ ($$$1 \\le n \\le 5 \\cdot 10^5$$$). The second line of each test case contains $$$n$$$ integers $$$a_1$$$, $$$a_2$$$, ..., $$$a_n$$$ ($$$-10^9 \\le a_i \\le 10^9$$$). It is guaranteed that the sum of $$$n$$$ over all test cases does not exceed $$$5 \\cdot 10^5$$$.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3-64",
    "lang_cluster": "Python",
    "difficulty": 2100,
    "file_name": "train_084.jsonl",
    "code_uid": "1d8a5ec45cbb88252a5cbedda574d1bf",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"5\\n\\n3\\n\\n1 2 -3\\n\\n4\\n\\n0 -2 3 -4\\n\\n5\\n\\n-1 -2 3 -1 -1\\n\\n6\\n\\n-1 2 -3 4 -5 6\\n\\n7\\n\\n1 -1 -1 1 -1 -1 1\"]",
    "exec_outcome": "PASSED",
    "source_code": "\r\ndef getCoordinateCompressMap(arr): # returns {number : compressed number}\r\n    nums = sorted(set(arr))\r\n    mapp = {x : i for i, x in enumerate(nums)}\r\n    return mapp\r\n\r\nclass SegmentTree():\r\n    def __init__(self,arr,combinerFunction,isCommutative=True): # isCommutative means f(a,b)==f(b,a)\r\n        self.n=len(arr)\r\n        def cmb(a,b):\r\n            if a==None: return b\r\n            if b==None: return a\r\n            return combinerFunction(a,b)\r\n        self.cmb=cmb\r\n        self.sz=self.n if isCommutative else pow(2,((self.n-1).bit_length())) # non-commutative needs power of 2 size\r\n        self.t=[None]*(2*self.sz) # use None as initial value\r\n        for i in range(self.n): self.t[i+self.sz]=arr[i]\r\n        for i in range(self.sz-1,0,-1): self.pull(i)\r\n    def pull(self,p):\r\n        self.t[p]=self.cmb(self.t[2*p],self.t[2*p+1])\r\n    def update(self,idx,val): # set val at idx\r\n        idx+=self.sz\r\n        self.t[idx]=val\r\n        idx//=2\r\n        while idx>0:\r\n            self.pull(idx)\r\n            idx//=2\r\n    def query(self,l,r): # aggregated value in [l,r] inclusive\r\n        l+=self.sz; r+=self.sz+1\r\n        a=b=None\r\n        while l<r:\r\n            if l%2==1: a=self.cmb(a,self.t[l]); l+=1\r\n            if r%2==1: r-=1; b=self.cmb(self.t[r],b)\r\n            l//=2; r//=2\r\n        return self.cmb(a,b)\r\ndef getMaxSegTree(arr):\r\n    return SegmentTree(arr,lambda a,b:max(a,b),True)\r\ndef getMinSegTree(arr):\r\n    return SegmentTree(arr,lambda a,b:min(a,b),True)\r\ndef getSumSegTree(arr):\r\n    return SegmentTree(arr,lambda a,b:a+b,True)\r\n\r\n\r\ndef main():\r\n    \r\n    t = int(input())\r\n    allans = []\r\n    for _ in range(t):\r\n        n = int(input())\r\n        a = readIntArr()\r\n        \r\n        prefix_sums = a.copy()\r\n        for i in range(1, n):\r\n            prefix_sums[i] += prefix_sums[i - 1]\r\n        mapp = getCoordinateCompressMap(prefix_sums + [0])\r\n        prefix_sums_compressed = [mapp[x] for x in prefix_sums]\r\n        # pad everything by 1\r\n        for i in range(n):\r\n            prefix_sums_compressed[i] += 1\r\n        maxN = max(prefix_sums_compressed)\r\n        maxN += 5\r\n        \r\n        st1 = getMaxSegTree([-int(2e9)] * maxN) # for s > 0. stores v + i\r\n        st2 = getMaxSegTree([-int(2e9)] * maxN) # for s < 0. stores v - i\r\n        equal_checker = [-int(2e9)] * maxN # for s == 0. stores v\r\n        \r\n        # initialize for i = -1 and sum = 0\r\n        zero_compressed = mapp[0] + 1 # padded by 1\r\n        st1.update(zero_compressed, 1)\r\n        st2.update(zero_compressed, -1)\r\n        equal_checker[zero_compressed] = 0\r\n        \r\n        dp = [-int(2e9)] * n\r\n        \r\n        for r, x in enumerate(a):\r\n            p = prefix_sums_compressed[r]\r\n            v1 = st1.query(0, p - 1) + r\r\n            v2 = st2.query(p + 1, maxN - 1) - r\r\n            v3 = equal_checker[p]\r\n            v = max(v1, v2, v3)\r\n            dp[r] = v\r\n            \r\n            if st1.query(p, p) < v - r:\r\n                st1.update(p, v - r)\r\n            if st2.query(p, p) < v + r:\r\n                st2.update(p, v + r)\r\n            equal_checker[p] = max(equal_checker[p], v)\r\n        \r\n        ans = dp[n - 1]\r\n        allans.append(ans)\r\n    multiLineArrayPrint(allans)\r\n    \r\n    return\r\n \r\nimport sys\r\ninput=sys.stdin.buffer.readline #FOR READING PURE INTEGER INPUTS (space separation ok)\r\n# input=lambda: sys.stdin.readline().rstrip(\"\\r\\n\") #FOR READING STRING/TEXT INPUTS.\r\n \r\ndef oneLineArrayPrint(arr):\r\n    print(' '.join([str(x) for x in arr]))\r\ndef multiLineArrayPrint(arr):\r\n    print('\\n'.join([str(x) for x in arr]))\r\ndef multiLineArrayOfArraysPrint(arr):\r\n    print('\\n'.join([' '.join([str(x) for x in y]) for y in arr]))\r\n \r\ndef readIntArr():\r\n    return [int(x) for x in input().split()]\r\n# def readFloatArr():\r\n#     return [float(x) for x in input().split()]\r\n \r\ndef makeArr(defaultValFactory,dimensionArr): # eg. makeArr(lambda:0,[n,m])\r\n    dv=defaultValFactory;da=dimensionArr\r\n    if len(da)==1:return [dv() for _ in range(da[0])]\r\n    else:return [makeArr(dv,da[1:]) for _ in range(da[0])]\r\n \r\ndef queryInteractive(a, b, c):\r\n    print('? {} {} {}'.format(a, b, c))\r\n    sys.stdout.flush()\r\n    return int(input())\r\n \r\ndef answerInteractive(x1, x2):\r\n    print('! {} {}'.format(x1, x2))\r\n    sys.stdout.flush()\r\n \r\ninf=float('inf')\r\n# MOD=10**9+7\r\n# MOD=998244353\r\n \r\nfrom math import gcd,floor,ceil\r\nimport math\r\n# from math import floor,ceil # for Python2\r\n \r\nfor _abc in range(1):\r\n    main()",
    "prob_desc_created_at": "1650378900",
    "tags": [
        "data structures",
        "dp"
    ],
    "hidden_unit_tests": ""
}
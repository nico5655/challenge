{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"1\\n0\\n4\\n2\\n1\\n3\"]",
    "src_uid": "e9065e8bd9afb7d797527bc3a50f2150",
    "prob_desc_notes": "NoteIn the first test case, Bob can't win on subsegments of length $$$1$$$, as there is no pair of adjacent piles in an array of length $$$1$$$.In the second test case, every subsegment is not winning.In the fourth test case, the subsegment $$$[1, 4]$$$ is winning, because Bob can make moves with pairs of adjacent piles: $$$(2, 3)$$$, $$$(1, 2)$$$, $$$(3, 4)$$$. Another winning subsegment is $$$[2, 3]$$$.",
    "prob_desc_description": "Bob decided to take a break from calculus homework and designed a game for himself. The game is played on a sequence of piles of stones, which can be described with a sequence of integers $$$s_1, \\ldots, s_k$$$, where $$$s_i$$$ is the number of stones in the $$$i$$$-th pile. On each turn, Bob picks a pair of non-empty adjacent piles $$$i$$$ and $$$i+1$$$ and takes one stone from each. If a pile becomes empty, its adjacent piles do not become adjacent. The game ends when Bob can't make turns anymore. Bob considers himself a winner if at the end all piles are empty.We consider a sequence of piles winning if Bob can start with it and win with some sequence of moves.You are given a sequence $$$a_1, \\ldots, a_n$$$, count the number of subsegments of $$$a$$$ that describe a winning sequence of piles. In other words find the number of segments $$$[l, r]$$$ ($$$1 \\leq l \\leq r \\leq n$$$), such that the sequence $$$a_l, a_{l+1}, \\ldots, a_r$$$ is winning.",
    "prob_desc_output_spec": "Print a single integer for each test case — the answer to the problem.",
    "prob_desc_input_spec": "Each test consists of multiple test cases. The first line contains a single integer $$$t$$$ ($$$1 \\leq t \\leq 3 \\cdot 10^5$$$) — the number of test cases. Description of the test cases follows. The first line of each test case contains a single integer $$$n$$$ ($$$1 \\leq n \\leq 3 \\cdot 10^5$$$). The second line of each test case contains $$$n$$$ integers $$$a_1, a_2, \\ldots, a_n$$$ ($$$0 \\leq a_i \\leq 10^9$$$). It is guaranteed that the sum of $$$n$$$ over all test cases does not exceed $$$3 \\cdot 10^5$$$.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3-64",
    "lang_cluster": "Python",
    "difficulty": 2300,
    "file_name": "train_091.jsonl",
    "code_uid": "70ab0197ded3ece87b6151529d2d643d",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"6\\n2\\n2 2\\n3\\n1 2 3\\n4\\n1 1 1 1\\n4\\n1 2 2 1\\n4\\n1 2 1 2\\n8\\n1 2 1 2 1 2 1 2\"]",
    "exec_outcome": "PASSED",
    "source_code": "''' E. Game with Stones\nhttps://codeforces.com/contest/1589/problem/E\n'''\n\nimport io, os, sys\nfrom math import e\ninput = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline  # decode().strip() if str\noutput = sys.stdout.write\n\n\nfrom types import GeneratorType\ndef bootstrap(f, stack=[]):\n    def wrappedfunc(*args, **kwargs):\n        if stack:\n            return f(*args, **kwargs)\n        else:\n            to = f(*args, **kwargs)\n            while True:\n                if type(to) is GeneratorType:\n                    stack.append(to)\n                    to = next(to)\n                else:\n                    stack.pop()\n                    if not stack:\n                        break\n                    to = stack[-1].send(to)\n            return to\n    return wrappedfunc\n\n\nimport random\nrandom.seed(123)\n\nclass Node:\n    def __init__(self, val, priority):\n        self.val = val\n        self.priority = priority\n        self.count = 1\n        self.left = None\n        self.right = None\n    \n    def __repr__(self):\n        return f'Node(val={self.val}, count={self.count})'\n\n\nclass Treap:\n    '''Multiset treap, all nodes hold unique values'''\n    def __init__(self):\n        self.root = None\n        self.size = 0\n    \n    def _rand(self):\n        return random.randint(1,2**32)\n    \n    def find(self, val):\n        '''find node holding val'''\n        node = self.root\n        while node:\n            if node.val == val: break\n            node = node.left if node.val > val else node.right\n        return node\n\n    @bootstrap\n    def split(self, root, val):\n        '''split subtree rooted here into 2 treaps: one < val, one >= val'''\n        if not root: yield (None, None)\n        if root.val < val:\n            x, y = yield self.split(root.right, val)\n            root.right = x\n            yield (root, y)\n        else:\n            x, y = yield self.split(root.left, val)\n            root.left = y\n            yield (x, root)\n\n    @bootstrap\n    def merge(self, x, y):\n        '''merge 2 treaps into new treap, assuming x vals <= y vals'''\n        if not x or not y: yield x or y\n        if x.priority > y.priority:  # make x root\n            x.right = yield self.merge(x.right, y)\n            yield x\n        else:\n            y.left = yield self.merge(x, y.left)\n            yield y\n \n    def insert(self, val):\n        '''split current tree, then merge 2 trees with new node'''\n        node = self.find(val)\n        if node is not None:\n            node.count += 1\n        else:\n            y = Node(val, self._rand())\n            x, z = self.split(self.root, val)\n            self.root = self.merge(self.merge(x, y), z)\n        self.size += 1\n    \n    def delete(self, val, del_all=False):\n        '''delete node with val, assuming int val'''\n        node = self.find(val)\n        if not node: return\n        if not del_all and node.count > 1:\n            node.count -= 1\n            self.size -= 1\n        else:  # remove entire node\n            x, y = self.split(self.root, val)\n            y, z = self.split(y, val+1)\n            self.root = self.merge(x, z)\n            self.size -= node.count\n    \n    def get_min(self):\n        '''get min value'''\n        node = self.root\n        while node.left:\n            node = node.left\n        return node.val\n \n    def get_max(self):\n        '''get max value'''\n        node = self.root\n        while node.right:\n            node = node.right\n        return node.val\n    \n    def get_count(self, val):\n        '''get num nodes with val'''\n        node = self.find(val)\n        return 0 if not node else node.count\n\n\n# let S(l, r) = a[r] - a[r-1] + a[r-2] - ... + (-1)^(r-l) * a[l]\n# then a[l..r] is winning if S(l, m) >= 0 and S(l, r) == 0 for m=l..r\n \n# iterate i=1..N and track set of valid prefixes / potential segment starts\n# * add S(1, i) to prefix set\n# * remove all prefixes S(1, l) s.t. S(l, r) < 0; note S(l, r) = S(r, 1) - (-1)^(r-l) * S(l-1, 1)\n# -> if S(1, l) remains, then S(i, l) >= 0 for i=l+1..r\n# * num winning segments ending at r is num l s.t. S(l, r) == 0\n \ndef solve_treap(N, nums):\n    # set of valid prefixes with even/odd length\n    pref = [Treap(), Treap()]\n    pref[0].insert(0)\n \n    # running prefix\n    res = p = 0\n    for i, num in enumerate(nums):\n        p = num - p\n        sign, rsign = (i+1) % 2, i % 2\n \n        # remove invalid prefixes\n        while pref[sign].size > 0:\n            mx = pref[sign].get_max()\n            if p - mx >= 0: break\n            pref[sign].delete(mx, del_all=True)\n        while pref[rsign].size > 0:\n            mn = pref[rsign].get_min()\n            if p + mn >= 0: break\n            pref[rsign].delete(mn, del_all=True)\n \n        # num winning segs ending at i\n        res += pref[sign].get_count(p)\n        res += pref[rsign].get_count(-p)\n \n        # add current sum\n        pref[sign].insert(p)\n \n    return res\n\n\nfrom collections import deque\n\ndef solve_deque(N, nums):\n    dq1, dq2 = deque([[0, 1]]), deque()  # (pref, count)\n    res = p = 0\n    for num in nums:\n        p = num - p\n\n        # remove invalid prefixes\n        while dq1 and p - dq1[-1][0] < 0:\n            dq1.pop()\n        while dq2 and p + dq2[0][0] < 0:\n            dq2.popleft()\n\n        # num winning segs ending at i\n        if dq1 and p - dq1[-1][0] == 0:\n            res += dq1[-1][1]\n        if dq2 and p + dq2[0][0] == 0:\n            res += dq2[0][1]\n\n        # add current sum\n        # note p >= all remaining vals in dq1\n        # so dq1 and dq2 are both increasing deque\n        if dq1 and dq1[-1][0] == p:\n            dq1[-1][1] += 1\n        else:\n            dq1.append([p, 1])\n\n        dq1, dq2 = dq2, dq1\n\n    return res\n\n\nsolve = solve_deque\n\ndef main():\n    T = int(input())\n    for _ in range(T):\n        N = int(input())\n        nums = list(map(int, input().split()))\n        out = solve(N, nums)\n        output(f'{out}\\n')\n\nif __name__ == '__main__':\n    main()\n\n",
    "prob_desc_created_at": "1636869900",
    "tags": [
        "binary search",
        "data structures",
        "games",
        "greedy"
    ],
    "hidden_unit_tests": ""
}
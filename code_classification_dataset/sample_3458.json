{
    "prob_desc_time_limit": "1 second",
    "prob_desc_sample_outputs": "[\"YES\\nNO\\nNO\\nYES\"]",
    "src_uid": "b116ab1cae8d64608641b339b8654e21",
    "prob_desc_notes": "NoteThe first test case is pictured above.In the second test case, the tree is a path. We can show that the snake cannot reverse itself.In the third test case, we can show that the snake cannot reverse itself.In the fourth test case, an example solution is:$$$(15,12)\\to (16,11)\\to (15,13)\\to (10,14)\\to (8,13)\\to (4,11)\\to (1,10)$$$$$$\\to (2,8)\\to (3,4)\\to (2,5)\\to (1,6)\\to (4,7)\\to (8,6)\\to (10,5)$$$$$$\\to (11,4)\\to (13,8)\\to (14,10)\\to (13,15)\\to (11,16)\\to (12,15)$$$.",
    "prob_desc_description": "There is an undirected tree of $$$n$$$ vertices, connected by $$$n-1$$$ bidirectional edges. There is also a snake stuck inside of this tree. Its head is at vertex $$$a$$$ and its tail is at vertex $$$b$$$. The snake's body occupies all vertices on the unique simple path between $$$a$$$ and $$$b$$$.The snake wants to know if it can reverse itself  — that is, to move its head to where its tail started, and its tail to where its head started. Unfortunately, the snake's movements are restricted to the tree's structure.In an operation, the snake can move its head to an adjacent vertex not currently occupied by the snake. When it does this, the tail moves one vertex closer to the head, so that the length of the snake remains unchanged. Similarly, the snake can also move its tail to an adjacent vertex not currently occupied by the snake. When it does this, the head moves one unit closer to the tail.  Let's denote a snake position by $$$(h,t)$$$, where $$$h$$$ is the index of the vertex with the snake's head, $$$t$$$ is the index of the vertex with the snake's tail. This snake can reverse itself with the movements $$$(4,7)\\to (5,1)\\to (4,2)\\to (1, 3)\\to (7,2)\\to (8,1)\\to (7,4)$$$. Determine if it is possible to reverse the snake with some sequence of operations.",
    "prob_desc_output_spec": "For each test case, output \"YES\" if it is possible for the snake to reverse itself, or \"NO\" otherwise.",
    "prob_desc_input_spec": "The first line contains a single integer $$$t$$$ ($$$1\\le t\\le 100$$$)  — the number of test cases. The next lines contain descriptions of test cases. The first line of each test case contains three integers $$$n,a,b$$$ ($$$2\\le n\\le 10^5,1\\le a,b\\le n,a\\ne b$$$). Each of the next $$$n-1$$$ lines contains two integers $$$u_i,v_i$$$ ($$$1\\le u_i,v_i\\le n,u_i\\ne v_i$$$), indicating an edge between vertices $$$u_i$$$ and $$$v_i$$$. It is guaranteed that the given edges form a tree. It is guaranteed that the sum of $$$n$$$ across all test cases does not exceed $$$10^5$$$.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3",
    "lang_cluster": "Python",
    "difficulty": 3000,
    "file_name": "train_060.jsonl",
    "code_uid": "ed674f9696a8d18b4dde49ca909a2d3c",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"4\\n8 4 7\\n1 2\\n2 3\\n1 4\\n4 5\\n4 6\\n1 7\\n7 8\\n4 3 2\\n4 3\\n1 2\\n2 3\\n9 3 5\\n1 2\\n2 3\\n3 4\\n1 5\\n5 6\\n6 7\\n1 8\\n8 9\\n16 15 12\\n1 2\\n2 3\\n1 4\\n4 5\\n5 6\\n6 7\\n4 8\\n8 9\\n8 10\\n10 11\\n11 12\\n11 13\\n13 14\\n10 15\\n15 16\"]",
    "exec_outcome": "PASSED",
    "source_code": "from sys import stdin\nimport itertools\ninput = stdin.readline\ndef getint(): return int(input())\ndef getints(): return list(map(int, input().split()))\ndef getint1(): return list(map(lambda x: int(x) - 1, input().split()))\ndef getstr(): return input()[:-1]\n\n\ndef solve():\n    n, a, b = getint1()\n    n += 1\n    adj = [[] for _ in range(n)]\n    for _ in range(n - 1):\n        u, v = getint1()\n        adj[u].append(v)\n        adj[v].append(u)\n    # dfs 1\n    max_child = [[-1] * 3 for _ in range(n)]\n    stack = [(a, -1, 1)]  # (node, parent)\n    while stack:\n        u, p, flag = stack.pop()\n        if p != -1 and len(adj[u]) < 2:\n            max_child[u][0] = 1\n            continue\n        if flag == 1:\n            stack.append((u, p, 0))\n            for v in adj[u]:\n                if v == p:\n                    continue\n                stack.append((v, u, 1))\n        else:\n            for v in adj[u]:\n                if v == p:\n                    continue\n                len_v = max_child[v][0] + 1\n                if len_v > max_child[u][0]:\n                    max_child[u][2] = max_child[u][1]\n                    max_child[u][1] = max_child[u][0]\n                    max_child[u][0] = len_v\n                elif len_v > max_child[u][1]:\n                    max_child[u][2] = max_child[u][1]\n                    max_child[u][1] = len_v\n                elif len_v > max_child[u][2]:\n                    max_child[u][2] = len_v\n    # end of dfs 1\n    # dfs 2\n    body = []\n    ret = [False] * n\n    max_parent = [-1] * n\n    stack.clear()\n    stack = [(a, -1, 0)]  # (node, parent, max len from parent)\n    while stack:\n        u, p, mxp = stack.pop()\n        if mxp >= 0:\n            stack.append((u, p, -1))\n            if p != -1 and len(adj[u]) < 2:\n                continue\n            max_parent[u] = mxp + 1\n            chlen = [max_parent[u], -3]\n            for v in adj[u]:\n                if v == p:\n                    continue\n                len_v = max_child[v][0] + 1\n                if len_v > chlen[0]:\n                    chlen[1] = chlen[0]\n                    chlen[0] = len_v\n                elif len_v > chlen[1]:\n                    chlen[1] = len_v\n            for v in adj[u]:\n                if v == p:\n                    continue\n                stack.append(\n                    (v, u, chlen[int(max_child[v][0] + 1 == chlen[0])]))\n        else:\n            is_body = (u == b)\n            if not is_body:\n                for v in adj[u]:\n                    if v != p and ret[v]:\n                        is_body = True\n                        break\n            if is_body:\n                body.append(u)\n            ret[u] = is_body\n    del ret\n    # end of dfs2\n    ok = False\n    body_len = len(body)\n    can_turn = [False] * n\n    for i in range(n):\n        if 3 <= sum(1 for l in max_child[i] + [max_parent[i]] if l >= body_len):\n            can_turn[i] = True\n            ok = True\n    if not ok:\n        print(\"NO\")\n        return\n    treelen = [1] * body_len\n    # print(body)\n    for i in range(body_len):\n        cur = body[i]\n        pre = -1 if i == 0 else body[i - 1]\n        nxt = -1 if i + 1 == body_len else body[i + 1]\n        for v in adj[cur]:\n            if v == pre or v == nxt:\n                continue\n            treelen[i] = max(treelen[i], max_child[v][0] + 1)\n            if can_turn[v]:\n                can_turn[cur] = True\n                continue\n            # dfs 3\n            stack = [(v, cur)]\n            while stack and not can_turn[cur]:\n                u, p = stack.pop()\n                for w in adj[u]:\n                    if w == p:\n                        continue\n                    if can_turn[w]:\n                        can_turn[cur] = True\n                        break\n                    stack.append((w, u))\n            stack.clear()\n            # end of dfs 3\n        # print(i, cur, can_turn[cur])\n    # use two pointer to find if we can enter the turing point\n    # print(body_len, treelen)\n    l = 0\n    r = body_len - 1\n    lmax = treelen[r] - 1\n    rmin = body_len - treelen[l]\n    ok = (can_turn[body[l]] or can_turn[body[r]])\n    while not ok and (l < lmax or rmin < r):\n        if l < lmax:\n            l += 1\n            rmin = min(rmin, l + (body_len - treelen[l]))\n        if rmin < r:\n            r -= 1\n            lmax = max(lmax, r - (body_len - treelen[r]))\n        if can_turn[body[l]] or can_turn[body[r]]:\n            ok = True\n    ##\n    print(\"YES\" if ok else \"NO\")\n    return\n    # end of solve\n\n\nif __name__ == \"__main__\":\n    # solve()\n    # for t in range(getint()):\n    #     print('Case #', t + 1, ': ', sep='')\n    #     solve()\n    for _ in range(getint()):\n        solve()\n",
    "prob_desc_created_at": "1595342100",
    "tags": [
        "dp",
        "greedy",
        "two pointers",
        "dfs and similar",
        "trees"
    ],
    "hidden_unit_tests": ""
}
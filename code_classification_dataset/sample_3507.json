{
    "prob_desc_time_limit": "3 seconds",
    "prob_desc_sample_outputs": "[\"Suspicious\", \"OK\", \"OK\", \"Suspicious\"]",
    "src_uid": "c23d3ec2b9fb4b4d169bc8053bfd000e",
    "prob_desc_notes": null,
    "prob_desc_description": "Most C/C++ programmers know about excellent opportunities that preprocessor #define directives give; but many know as well about the problems that can arise because of their careless use.In this problem we consider the following model of #define constructions (also called macros). Each macro has its name and value. The generic syntax for declaring a macro is the following:#define macro_name macro_valueAfter the macro has been declared, \"macro_name\" is replaced with \"macro_value\" each time it is met in the program (only the whole tokens can be replaced; i.e. \"macro_name\" is replaced only when it is surrounded by spaces or other non-alphabetic symbol). A \"macro_value\" within our model can only be an arithmetic expression consisting of variables, four arithmetic operations, brackets, and also the names of previously declared macros (in this case replacement is performed sequentially). The process of replacing macros with their values is called substitution.One of the main problems arising while using macros — the situation when as a result of substitution we get an arithmetic expression with the changed order of calculation because of different priorities of the operations.Let's consider the following example. Say, we declared such a #define construction:#define sum x + yand further in the program the expression \"2 * sum\" is calculated. After macro substitution is performed we get \"2 * x + y\", instead of intuitively expected \"2 * (x + y)\".Let's call the situation \"suspicious\", if after the macro substitution the order of calculation changes, falling outside the bounds of some macro. Thus, your task is to find out by the given set of #define definitions and the given expression if this expression is suspicious or not.Let's speak more formally. We should perform an ordinary macros substitution in the given expression. Moreover, we should perform a \"safe\" macros substitution in the expression, putting in brackets each macro value; after this, guided by arithmetic rules of brackets expansion, we can omit some of the brackets. If there exist a way to get an expression, absolutely coinciding with the expression that is the result of an ordinary substitution (character-by-character, but ignoring spaces), then this expression and the macros system are called correct, otherwise — suspicious.Note that we consider the \"/\" operation as the usual mathematical division, not the integer division like in C/C++. That's why, for example, in the expression \"a*(b/c)\" we can omit brackets to get the expression \"a*b/c\".",
    "prob_desc_output_spec": "Output \"OK\", if the expression is correct according to the above given criterion, otherwise output \"Suspicious\".",
    "prob_desc_input_spec": "The first line contains the only number n (0 ≤ n ≤ 100) — the amount of #define constructions in the given program. Then there follow n lines, each of them contains just one #define construction. Each construction has the following syntax: #define name expression where   name — the macro name,  expression — the expression with which the given macro will be replaced. An expression is a non-empty string, containing digits,names of variables, names of previously declared macros, round brackets and operational signs +-*/. It is guaranteed that the expression (before and after macros substitution) is a correct arithmetic expression, having no unary operations. The expression contains only non-negative integers, not exceeding 109.  All the names (#define constructions' names and names of their arguments) are strings of case-sensitive Latin characters. It is guaranteed that the name of any variable is different from any #define construction. Then, the last line contains an expression that you are to check. This expression is non-empty and satisfies the same limitations as the expressions in #define constructions. The input lines may contain any number of spaces anywhere, providing these spaces do not break the word \"define\" or the names of constructions and variables. In particular, there can be any number of spaces before and after the \"#\" symbol. The length of any line from the input file does not exceed 100 characters.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "Python 3",
    "lang_cluster": "Python",
    "difficulty": 2600,
    "file_name": "train_064.jsonl",
    "code_uid": "b82ec5a3b922878a9ce23beb80ef4046",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"1\\n#define sum x + y\\n1 * sum\", \"1\\n#define sum  (x + y)\\nsum - sum\", \"4\\n#define sum  x + y\\n#define mul  a * b\\n#define div  a / b\\n#define expr sum + mul * div * mul\\nexpr\", \"3\\n#define SumSafe   (a+b)\\n#define DivUnsafe  a/b\\n#define DenominatorUnsafe  a*b\\n((SumSafe) + DivUnsafe/DivUnsafe + x/DenominatorUnsafe)\"]",
    "exec_outcome": "PASSED",
    "source_code": "#!/usr/bin/env python\n\n\"\"\"\nCodeForces: 7E. Defining Macros\n\nThe key for the solution is the naked operators that are not surrounded by\nthe parentheses in the macro definition.\n\nSuspicious patterns of the operators in the appearance order are:\n\n    o{-}   n{+-}\n    o{*}   n{+-}\n    o{/}   n{+-*/}\n    n{+-}  o{*}\n    n{+-}  o{/}\n\nwhere:\n    \"o{}\": an operator before or after the macro might construct\n        a suspicious expression with the operators in \"n{}\"\n    \"n{}\": a subset of the naked operators in the macro definition\n        that might construct a suspicious expression with the operator \"o\"\n\nIf the pair of operators in the \"o{}\" and \"n{}\" are matched\nin the expression, the entire expression would be suspicious.\n\"\"\"\n\n# Represent the operator as the bit mask:\n# Pseudo operator whose priority is lower than \"+\",\n# Add (+), Subtract (-), Multiply (*) and Division (/)\nP, A, S, M, D = 1, 2, 4, 8, 16\nADD = A | S\nANY = A | S | M | D\n# Map of the operators (+-*/) to the bit mask\nOP_BIT = {\"+\": A, \"-\": S, \"*\": M, \"/\": D, \")\": 0}\n# unsafe naked operators against the operator before and after the macro\nUNSAFE_BEFORE = {P: 0, A: 0, S: ADD, M: ADD, D: ANY}\nUNSAFE_AFTER = {P: 0, A: 0, S: 0, M: ADD, D: ADD}\n\n# Macro definitions:\n# a map from the macro name to the set of its naked operators\n# Note: the set is represented as a bit pattern\nmacro = dict()\n\n\n# Parse expression with checking suspicious expression\ndef expr(chars,\n         # following arguments are the short cut\n         pseudo=P,\n         expand=macro.get,\n         op_bit=OP_BIT,\n         unsafe_before=UNSAFE_BEFORE,\n         unsafe_after=UNSAFE_AFTER):\n    # stack of the operator before the left parenthesis \"(\"\n    paren = []\n    push = paren.append\n    pop = paren.pop\n    # list of characters that would be a macro name or a number\n    name = []\n    keep = name.append\n    forget = name.clear\n\n    # last_op: last operator before the macro name or the number\n    # retval: set of the naked operators of this expression\n    # naked: set of the naked operators of the macro expanded\n    last_op = retval = naked = pseudo\n\n    # expand the macro and check the preceding operator\n    def safe():\n        nonlocal naked\n        naked = expand(\"\".join(name), pseudo)\n        forget()\n        # early exit for a suspicious expression and a value\n        if naked <= pseudo:\n            return naked\n        # safety check against the operator before the macro\n        return not (unsafe_before[last_op] & naked)\n\n    # parse the expression\n    for c in chars:\n        if c == \"(\":\n            push(last_op)\n            last_op = pseudo\n        elif c not in op_bit:\n            keep(c)\n        elif not safe():\n            return 0\n        elif c == \")\":\n            last_op = pop()\n        else:\n            # safety check against the operator after the macro\n            last_op = op_bit[c]\n            if unsafe_after[last_op] & naked:\n                return 0\n            # record operators not surrounded by the parentheses\n            if not paren:\n                retval |= last_op\n\n    if name and not safe():\n        return 0\n    return retval\n\n\ndef main():\n    global macro\n\n    def chars(b, t):\n        for k in range(b, len(t)):\n            yield from t[k]\n\n    for _ in range(int(input())):\n        token = input().split()\n        s = token[0] == \"#\"\n        macro[token[1 + s]] = expr(chars(2 + s, token))\n\n    print(\"OK\" if expr((c for c in input() if c != \" \")) else \"Suspicious\")\n\n\n\nif __name__ == '__main__':\n    main()\n",
    "prob_desc_created_at": "1270136700",
    "tags": [
        "dp",
        "implementation",
        "expression parsing"
    ],
    "hidden_unit_tests": ""
}
{
    "prob_desc_time_limit": "1 second",
    "prob_desc_sample_outputs": "[\"? 0 1\\n\\n? 2 -1\\n\\n? 1 1\\n\\n! 1 5\"]",
    "src_uid": "801fc5bf710ed545f105ab48638e36d2",
    "prob_desc_notes": "NoteFor the first test, the configuration is the same as shown on the picture from the statement. After the first rotation (which is rotating ring $$$0$$$ clockwise by $$$1$$$ section), we obtain the following configuration:   After the second rotation (which is rotating ring $$$2$$$ counter-clockwise by $$$1$$$ section), we obtain the following configuration:   After the third rotation (which is rotating ring $$$1$$$ clockwise by $$$1$$$ section), we obtain the following configuration:   If we rotate ring $$$0$$$ clockwise once, we can see that the sections ring $$$0$$$ covers will be the same as the sections that ring $$$1$$$ covers, hence $$$p_1=1$$$.If we rotate ring $$$0$$$ clockwise five times, the sections ring $$$0$$$ covers will be the same as the sections that ring $$$2$$$ covers, hence $$$p_2=5$$$.Note that if we will make a different set of rotations, we can end up with different values of $$$p_1$$$ and $$$p_2$$$ at the end.",
    "prob_desc_description": "This is an interactive problem.To prevent the mischievous rabbits from freely roaming around the zoo, Zookeeper has set up a special lock for the rabbit enclosure. This lock is called the Rotary Laser Lock.  The lock consists of $$$n$$$ concentric rings numbered from $$$0$$$ to $$$n-1$$$. The innermost ring is ring $$$0$$$ and the outermost ring is ring $$$n-1$$$. All rings are split equally into $$$nm$$$ sections each. Each of those rings contains a single metal arc that covers exactly $$$m$$$ contiguous sections. At the center of the ring is a core and surrounding the entire lock are $$$nm$$$ receivers aligned to the $$$nm$$$ sections. The core has $$$nm$$$ lasers that shine outward from the center, one for each section. The lasers can be blocked by any of the arcs. A display on the outside of the lock shows how many lasers hit the outer receivers.   In the example above, there are $$$n=3$$$ rings, each covering $$$m=4$$$ sections. The arcs are colored in green (ring $$$0$$$), purple (ring $$$1$$$), and blue (ring $$$2$$$) while the lasers beams are shown in red. There are $$$nm=12$$$ sections and $$$3$$$ of the lasers are not blocked by any arc, thus the display will show $$$3$$$ in this case. Wabbit is trying to open the lock to free the rabbits, but the lock is completely opaque, and he cannot see where any of the arcs are. Given the relative positions of the arcs, Wabbit can open the lock on his own.  To be precise, Wabbit needs $$$n-1$$$ integers $$$p_1,p_2,\\ldots,p_{n-1}$$$ satisfying $$$0 \\leq p_i &lt; nm$$$ such that for each $$$i$$$ $$$(1 \\leq i &lt; n)$$$, Wabbit can rotate ring $$$0$$$ clockwise exactly $$$p_i$$$ times such that the sections that ring $$$0$$$ covers perfectly aligns with the sections that ring $$$i$$$ covers. In the example above, the relative positions are $$$p_1 = 1$$$ and $$$p_2 = 7$$$. To operate the lock, he can pick any of the $$$n$$$ rings and rotate them by $$$1$$$ section either clockwise or anti-clockwise. You will see the number on the display after every rotation.Because his paws are small, Wabbit has asked you to help him to find the relative positions of the arcs after all of your rotations are completed. You may perform up to $$$15000$$$ rotations before Wabbit gets impatient.",
    "prob_desc_output_spec": null,
    "prob_desc_input_spec": "The first line consists of 2 integers $$$n$$$ and $$$m$$$ $$$(2 \\leq n \\leq 100, 2 \\leq m \\leq 20)$$$, indicating the number of rings and the number of sections each ring covers.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3",
    "lang_cluster": "Python",
    "difficulty": 3500,
    "file_name": "train_057.jsonl",
    "code_uid": "ddde0fd13c5fcbb0d872dde1d816c04a",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"3 4\\n\\n4\\n\\n4\\n\\n3\"]",
    "exec_outcome": "PASSED",
    "source_code": "import sys;Z=sys.stdin.readline\ndef P(d=1,x=0):\n    print('?',x,2*d-1);sys.stdout.flush()\n    return int(Z())\ndef poke(n):\n    global K,S,C,L\n    h=len(S);l=0;D=[0]*h\n    while h-l>1:\n        m=(l+h)//2;d=1-D[l]\n        for i in range(m-l):\n            v=P(d,S[l+i]);D[l+i]=d\n        if v<P()+n:\n            if d:l=m\n            else:h=m\n        else:\n            if d:h=m\n            else:l=m\n        P(0)\n    for i in range(len(S)):\n        if D[i]:P(0,S[i])\n    for i in range(M):v=P(0,S[l])\n    K[S[l]]=C;L=C;S=S[:l]+S[l+1:]\n    return v\nN,M=map(int,Z().split())\nif N==2:\n    while P()>0:pass\n    print('!',M);quit()\nK=[-1]*N;S=[*range(1,N)]\npv=P();v=P();w=0\nwhile 1-w or pv<=v:pv,v,w=v,P(),max(w,v>=pv)\npv,v=v,P(0)\ngood=[]\nfor i in S:\n    pv,v=v,P(1,i)\n    if v<pv:\n        pv,v=v,P()\n        if v>=pv:good.append(i);P(0,i);K[i]=0\n        pv,v=v,P(0)\nfor i in good:S.remove(i)\nL=C=0\nfor i in range(len(S)):\n    n=0\n    while (C-L)%(N*M)<M:\n        pv,v,C=v,P(),C+1\n        if pv==v:n=1;break\n    else:\n        pv=v\n        while pv==v:pv,v,C=v,P(),C+1\n    P(0);C-=1;v=poke(n)\nprint('!',' '.join(map(str,[(K[i]-C)%(M*N)for i in range(1,N)])))",
    "prob_desc_created_at": "1602939900",
    "tags": [
        "binary search",
        "interactive"
    ],
    "hidden_unit_tests": ""
}
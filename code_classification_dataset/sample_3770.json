{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"18\\n14\\n-1\\n-1\\n0\\n11\\n25599\\n184470016815529983\"]",
    "src_uid": "10ec2bd27cbb7aaf7b52c281591cc043",
    "prob_desc_notes": "NoteIn the first test case, $$$x=18$$$ is one of the possible solutions, since $$$39|18=55$$$ and $$$12|18=30$$$, both of which are multiples of $$$d=5$$$.In the second test case, $$$x=14$$$ is one of the possible solutions, since $$$8|14=6|14=14$$$, which is a multiple of $$$d=14$$$.In the third and fourth test cases, we can show that there are no solutions.",
    "prob_desc_description": "You are given three integers $$$a$$$, $$$b$$$, and $$$d$$$. Your task is to find any integer $$$x$$$ which satisfies all of the following conditions, or determine that no such integers exist:  $$$0 \\le x \\lt 2^{60}$$$;  $$$a|x$$$ is divisible by $$$d$$$;  $$$b|x$$$ is divisible by $$$d$$$. Here, $$$|$$$ denotes the bitwise OR operation.",
    "prob_desc_output_spec": "For each test case print one integer. If there exists an integer $$$x$$$ which satisfies all of the conditions from the statement, print $$$x$$$. Otherwise, print $$$-1$$$. If there are multiple solutions, you may print any of them. ",
    "prob_desc_input_spec": "Each test contains multiple test cases. The first line of input contains one integer $$$t$$$ ($$$1 \\le t \\le 10^4$$$) — the number of test cases.  Each test case consists of one line, containing three integers $$$a$$$, $$$b$$$, and $$$d$$$ ($$$1 \\le a,b,d \\lt 2^{30}$$$).",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3-64",
    "lang_cluster": "Python",
    "difficulty": 2100,
    "file_name": "train_083.jsonl",
    "code_uid": "08746a4516507a05dc1af0d5088faf90",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"8\\n\\n12 39 5\\n\\n6 8 14\\n\\n100 200 200\\n\\n3 4 6\\n\\n2 2 2\\n\\n18 27 3\\n\\n420 666 69\\n\\n987654321 123456789 999999999\"]",
    "exec_outcome": "PASSED",
    "source_code": "\r\n\"\"\"**************************************************************\\\r\n                   BISMILLAHIR RAHMANIR RAHIM\r\n****************************************************************\r\n               AUTHOR NAME: MD. TAHURUZZOHA TUHIN\r\n\\**************************************************************\"\"\"\r\n\r\n\r\n#!/usr/bin/env python\r\n\r\nimport os\r\nimport sys\r\nfrom collections import Counter, defaultdict, deque\r\nfrom heapq import heapify, heappop, heappush\r\n# from math import *\r\nfrom io import BytesIO, IOBase\r\n\r\nif sys.version_info[0] < 3:\r\n    from __builtin__ import xrange as range\r\n    from future_builtins import ascii, filter, hex, map, oct, zip\r\n\r\n\r\n# Start FASTIO\r\nBUFSIZE = 8192\r\n\r\n\r\nclass FastIO(IOBase):\r\n    newlines = 0\r\n\r\n    def __init__(self, file):\r\n        self._file = file\r\n        self._fd = file.fileno()\r\n        self.buffer = BytesIO()\r\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\r\n        self.write = self.buffer.write if self.writable else None\r\n\r\n    def read(self):\r\n        while True:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            if not b:\r\n                break\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines = 0\r\n        return self.buffer.read()\r\n\r\n    def readline(self):\r\n        while self.newlines == 0:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            self.newlines = b.count(b\"\\n\") + (not b)\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines -= 1\r\n        return self.buffer.readline()\r\n\r\n    def flush(self):\r\n        if self.writable:\r\n            os.write(self._fd, self.buffer.getvalue())\r\n            self.buffer.truncate(0), self.buffer.seek(0)\r\n\r\n\r\nclass IOWrapper(IOBase):\r\n    def __init__(self, file):\r\n        self.buffer = FastIO(file)\r\n        self.flush = self.buffer.flush\r\n        self.writable = self.buffer.writable\r\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\r\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\r\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\r\n\r\n\r\ndef print(*args, **kwargs):\r\n    sep, file = kwargs.pop(\"sep\", \" \"), kwargs.pop(\"file\", sys.stdout)\r\n    at_start = True\r\n    for x in args:\r\n        if not at_start:\r\n            file.write(sep)\r\n        file.write(str(x))\r\n        at_start = False\r\n    file.write(kwargs.pop(\"end\", \"\\n\"))\r\n    if kwargs.pop(\"flush\", False):\r\n        file.flush()\r\n\r\n\r\nif sys.version_info[0] < 3:\r\n    sys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)\r\nelse:\r\n    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\r\n\r\n\r\n# def input(): return sys.stdin.readline().rstrip(\"\\r\\n\")\r\n\r\n\r\ndef prod(a, mod=10 ** 9 + 7):\r\n    ans = 1\r\n    for each in a:\r\n        ans = (ans * each) % mod\r\n    return ans\r\n\r\n\r\ndef gcd(x, y):\r\n    while y:\r\n        x, y = y, x % y\r\n    return x\r\n\r\n\r\ndef lcm(a, b): return a * b // gcd(a, b)\r\n\r\n\r\ndef binary(x, length=16):\r\n    y = bin(x)[2:]\r\n    return y if len(y) >= length else \"0\" * (length - len(y)) + y\r\n\r\n\r\ndef check_freq(x):\r\n    freq = {}\r\n    for c in set(x):\r\n        freq[c] = x.count(c)\r\n    return freq\r\n\r\n\r\ndef numToDigit(x):\r\n    box = []\r\n    while(x):\r\n        tmp = x % 10\r\n        x = x//10\r\n        box.append(tmp)\r\n    box.reverse()\r\n    return box\r\n\r\n\r\ndef ii(): return int(input())\r\ndef si(): return input()\r\ndef mi(): return map(int, input().strip().split(\" \"))\r\ndef li(): return list(mi())\r\n\r\nMAXX = 100000000\r\n\r\n'''**************Solution is Here***********'''\r\n\r\ndef main():\r\n\r\n    T=int(input())\r\n    for i in range(T):\r\n        a,b,d=map(int,input().split())\r\n        num=1\r\n        while d%2==0:\r\n            d//=2\r\n            num*=2\r\n        bitOr=a|b\r\n        if bitOr%num!=0:\r\n            \r\n            print(-1)\r\n            continue\r\n        \r\n        shift=(1<<30)%d\r\n        count=(-bitOr*pow(shift,-1,d))%d\r\n        res=(count<<30)+bitOr\r\n        print(res)\r\n            \r\n# End FASTIO\r\nif __name__ == \"__main__\":\r\n    main()\r\n\r\n",
    "prob_desc_created_at": "1668263700",
    "tags": [
        "bitmasks",
        "chinese remainder theorem",
        "combinatorics",
        "constructive algorithms",
        "math",
        "number theory"
    ],
    "hidden_unit_tests": ""
}
{
    "prob_desc_time_limit": "1 second",
    "prob_desc_sample_outputs": "[\"4\", \"-1\"]",
    "src_uid": "ac879e7c63151c50281cebaf09e790df",
    "prob_desc_notes": "NoteFor the first example, a sequence of operations that can be done is as follows:   Pak Chanek does an operation to stove $$$3$$$, $$$A = [2, -2, 1, 4, 2, -2, 9]$$$.  Pak Chanek does an operation to stove $$$2$$$, $$$A = [0, 2, -1, 4, 2, -2, 9]$$$.  Pak Chanek does an operation to stove $$$3$$$, $$$A = [0, 1, 1, 3, 2, -2, 9]$$$.  Pak Chanek does an operation to stove $$$6$$$, $$$A = [0, 1, 1, 3, 0, 2, 7]$$$. There is no other sequence of operations such that the number of operations needed is fewer than $$$4$$$.",
    "prob_desc_description": "Pak Chanek is participating in a lemper cooking competition. In the competition, Pak Chanek has to cook lempers with $$$N$$$ stoves that are arranged sequentially from stove $$$1$$$ to stove $$$N$$$. Initially, stove $$$i$$$ has a temperature of $$$A_i$$$ degrees. A stove can have a negative temperature.Pak Chanek realises that, in order for his lempers to be cooked, he needs to keep the temperature of each stove at a non-negative value. To make it happen, Pak Chanek can do zero or more operations. In one operation, Pak Chanek chooses one stove $$$i$$$ with $$$2 \\leq i \\leq N-1$$$, then:  changes the temperature of stove $$$i-1$$$ into $$$A_{i-1} := A_{i-1} + A_{i}$$$,  changes the temperature of stove $$$i+1$$$ into $$$A_{i+1} := A_{i+1} + A_{i}$$$, and  changes the temperature of stove $$$i$$$ into $$$A_i := -A_i$$$. Pak Chanek wants to know the minimum number of operations he needs to do such that the temperatures of all stoves are at non-negative values. Help Pak Chanek by telling him the minimum number of operations needed or by reporting if it is not possible to do.",
    "prob_desc_output_spec": "Output an integer representing the minimum number of operations needed to make the temperatures of all stoves at non-negative values or output $$$-1$$$ if it is not possible.",
    "prob_desc_input_spec": "The first line contains a single integer $$$N$$$ ($$$1 \\le N \\le 10^5$$$) — the number of stoves. The second line contains $$$N$$$ integers $$$A_1, A_2, \\ldots, A_N$$$ ($$$-10^9 \\leq A_i \\leq 10^9$$$) — the initial temperatures of the stoves.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3-64",
    "lang_cluster": "Python",
    "difficulty": 2400,
    "file_name": "train_093.jsonl",
    "code_uid": "68c01c3fb1a0385a80060253852948fe",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"7\\n2 -1 -1 5 2 -2 9\", \"5\\n-1 -2 -3 -4 -5\"]",
    "exec_outcome": "PASSED",
    "source_code": "''' L. Lemper Cooking Competition\nhttps://codeforces.com/contest/1725/problem/L\n'''\n\nimport io, os, sys\ninput = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline  # decode().strip() if str\noutput = sys.stdout.write\n\ndef debug(*args):   \n    if os.environ.get('debug') in [None, '0']: return\n    from inspect import currentframe, getframeinfo\n    from re import search\n    frame = currentframe().f_back\n    s = getframeinfo(frame).code_context[0]\n    r = search(r\"\\((.*)\\)\", s).group(1)\n    vnames = r.split(', ')\n    var_and_vals = [f'{var}={val}' for var, val in zip(vnames, args)]\n    prefix = f'{currentframe().f_back.f_lineno:02d}: '\n    print(f'{prefix}{\", \".join(var_and_vals)}')\n\nfrom types import GeneratorType\ndef bootstrap(f, stack=[]):\n    def wrappedfunc(*args, **kwargs):\n        if stack: return f(*args, **kwargs)\n        to = f(*args, **kwargs)\n        while True:\n            if type(to) is GeneratorType:\n                stack.append(to)\n                to = next(to)\n            else:\n                stack.pop()\n                if not stack: break\n                to = stack[-1].send(to)\n        return to\n    return wrappedfunc\n\nclass IntKeyDict(dict):\n    from random import randrange\n    rand = randrange(1 << 62)\n    def __setitem__(self, k, v): super().__setitem__(k^self.rand, v)\n    def __getitem__(self, k): return super().__getitem__(k^self.rand)\n    def __contains__(self, k): return super().__contains__(k^self.rand)\n    def __repr__(self): return str({k: v for k, v in self.items()})\n    def get(self, k, default=None): return super().get(k^self.rand, default)\n    def keys(self): return [k^self.rand for k in super().keys()]\n    def items(self): return [(k^self.rand, v) for k, v in super().items()]\n\nINF = float('inf')\n\n# -----------------------------------------\n\nclass SortedList:\n    def __init__(self, iterable=[], _load=200):\n        '''Initialize sorted list instance.'''\n        values = sorted(iterable)\n        self._len = _len = len(values)\n        self._load = _load\n        self._lists = _lists = [values[i:i + _load] for i in range(0, _len, _load)]\n        self._list_lens = [len(_list) for _list in _lists]\n        self._mins = [_list[0] for _list in _lists]\n        self._fen_tree = []\n        self._rebuild = True\n\n    def add(self, value):\n        '''Add `value` to sorted list.'''\n        _load = self._load\n        _lists = self._lists\n        _mins = self._mins\n        _list_lens = self._list_lens\n\n        self._len += 1\n        if _lists:\n            pos, idx = self._loc_right(value)\n            self._fen_update(pos, 1)\n            _list = _lists[pos]\n            _list.insert(idx, value)\n            _list_lens[pos] += 1\n            _mins[pos] = _list[0]\n            if _load + _load < len(_list):\n                _lists.insert(pos + 1, _list[_load:])\n                _list_lens.insert(pos + 1, len(_list) - _load)\n                _mins.insert(pos + 1, _list[_load])\n                _list_lens[pos] = _load\n                del _list[_load:]\n                self._rebuild = True\n        else:\n            _lists.append([value])\n            _mins.append(value)\n            _list_lens.append(1)\n            self._rebuild = True\n\n    def discard(self, value):\n        '''Remove `value` from sorted list if it is a member.'''\n        _lists = self._lists\n        if _lists:\n            pos, idx = self._loc_right(value)\n            if idx and _lists[pos][idx - 1] == value:\n                self._delete(pos, idx - 1)\n\n    def remove(self, value):\n        '''Remove `value` from sorted list; `value` must be a member.'''\n        _len = self._len\n        self.discard(value)\n        if _len == self._len: raise ValueError('{0!r} not in list'.format(value))\n\n    def pop(self, index=-1):\n        '''Remove and return value at `index` in sorted list.'''\n        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)\n        value = self._lists[pos][idx]\n        self._delete(pos, idx)\n        return value\n\n    def bisect_left(self, value):\n        '''Return the first index to insert `value` in the sorted list.'''\n        pos, idx = self._loc_left(value)\n        return self._fen_query(pos) + idx\n\n    def bisect_right(self, value):\n        '''Return the last index to insert `value` in the sorted list.'''\n        pos, idx = self._loc_right(value)\n        return self._fen_query(pos) + idx\n\n    def count(self, value):\n        '''Return number of occurrences of `value` in the sorted list.'''\n        return self.bisect_right(value) - self.bisect_left(value)\n\n    def _fen_build(self):\n        '''Build a fenwick tree instance.'''\n        self._fen_tree[:] = self._list_lens\n        _fen_tree = self._fen_tree\n        for i in range(len(_fen_tree)):\n            if i | i + 1 < len(_fen_tree):\n                _fen_tree[i | i + 1] += _fen_tree[i]\n        self._rebuild = False\n\n    def _fen_update(self, index, value):\n        '''Update `fen_tree[index] += value`.'''\n        if not self._rebuild:\n            _fen_tree = self._fen_tree\n            while index < len(_fen_tree):\n                _fen_tree[index] += value\n                index |= index + 1\n\n    def _fen_query(self, end):\n        '''Return `sum(_fen_tree[:end])`.'''\n        if self._rebuild: self._fen_build()\n        _fen_tree = self._fen_tree\n        x = 0\n        while end:\n            x += _fen_tree[end - 1]\n            end &= end - 1\n        return x\n\n    def _fen_findkth(self, k):\n        '''Return a pair of (the largest `idx` such that `sum(_fen_tree[:idx]) <= k`, `k - sum(_fen_tree[:idx])`).'''\n        _list_lens = self._list_lens\n        if k < _list_lens[0]: return 0, k\n        if k >= self._len - _list_lens[-1]: return len(_list_lens) - 1, k + _list_lens[-1] - self._len\n        if self._rebuild: self._fen_build()\n\n        _fen_tree = self._fen_tree\n        idx = -1\n        for d in reversed(range(len(_fen_tree).bit_length())):\n            right_idx = idx + (1 << d)\n            if right_idx < len(_fen_tree) and k >= _fen_tree[right_idx]:\n                idx = right_idx\n                k -= _fen_tree[idx]\n        return idx + 1, k\n\n    def _delete(self, pos, idx):\n        '''Delete value at the given `(pos, idx)`.'''\n        _lists = self._lists\n        _mins = self._mins\n        _list_lens = self._list_lens\n\n        self._len -= 1\n        self._fen_update(pos, -1)\n        del _lists[pos][idx]\n        _list_lens[pos] -= 1\n\n        if _list_lens[pos]:\n            _mins[pos] = _lists[pos][0]\n        else:\n            del _lists[pos]\n            del _list_lens[pos]\n            del _mins[pos]\n            self._rebuild = True\n\n    def _loc_left(self, value):\n        '''Return an index pair that corresponds to the first position of `value` in the sorted list.'''\n        if not self._len: return 0, 0\n        _lists = self._lists\n        _mins = self._mins\n\n        lo, pos = -1, len(_lists) - 1\n        while lo + 1 < pos:\n            mi = (lo + pos) >> 1\n            if value <= _mins[mi]: pos = mi\n            else: lo = mi\n\n        if pos and value <= _lists[pos - 1][-1]: pos -= 1\n\n        _list = _lists[pos]\n        lo, idx = -1, len(_list)\n        while lo + 1 < idx:\n            mi = (lo + idx) >> 1\n            if value <= _list[mi]: idx = mi\n            else: lo = mi\n\n        return pos, idx\n\n    def _loc_right(self, value):\n        '''Return an index pair that corresponds to the last position of `value` in the sorted list.'''\n        if not self._len: return 0, 0\n        _lists = self._lists\n        _mins = self._mins\n\n        pos, hi = 0, len(_lists)\n        while pos + 1 < hi:\n            mi = (pos + hi) >> 1\n            if value < _mins[mi]: hi = mi\n            else: pos = mi\n\n        _list = _lists[pos]\n        lo, idx = -1, len(_list)\n        while lo + 1 < idx:\n            mi = (lo + idx) >> 1\n            if value < _list[mi]: idx = mi\n            else: lo = mi\n\n        return pos, idx\n\n    def __len__(self):\n        '''Return the size of the sorted list.'''\n        return self._len\n\n    def __getitem__(self, index):\n        '''Lookup value at `index` in sorted list.'''\n        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)\n        return self._lists[pos][idx]\n\n    def __delitem__(self, index):\n        '''Remove value at `index` from sorted list.'''\n        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)\n        self._delete(pos, idx)\n\n    def __contains__(self, value):\n        '''Return true if `value` is an element of the sorted list.'''\n        _lists = self._lists\n        if _lists:\n            pos, idx = self._loc_left(value)\n            return idx < len(_lists[pos]) and _lists[pos][idx] == value\n        return False\n\n    def __iter__(self):\n        '''Return an iterator over the sorted list.'''\n        return (value for _list in self._lists for value in _list)\n\n    def __reversed__(self):\n        '''Return a reverse iterator over the sorted list.'''\n        return (value for _list in reversed(self._lists) for value in reversed(_list))\n\n    def __repr__(self):\n        '''Return string representation of sorted list.'''\n        return 'SortedList({0})'.format(list(self))\n \n    def val(self, it):  # added\n        '''Return the value of the `it` in the sorted list.'''\n        pos, idx = it\n        return self._lists[pos][idx]\n \n    def begin(self):  # added\n        '''Return the begin of the it in the sorted list.'''\n        return (0, 0)\n \n    def end(self):  # added\n        '''Return the end of the it in the sorted list.'''\n        return (len(self._lists)-1, len(self._lists[-1])) if self._lists else (0, 0)\n \n    def prev(self, it):  # added\n        '''Return the previous `it` in the sorted list.'''\n        if it == self.begin(): raise ValueError('{0!r} already list begin'.format(it))\n        pos, idx = it\n        return (pos, idx-1) if idx else (pos-1, len(self._lists[pos-1])-1)\n \n    def next(self, it):  # added\n        '''Return the next `it` in the sorted list.'''\n        if it == self.end(): raise ValueError('{0!r} already list end'.format(it))\n        pos, idx = it\n        return (pos, idx+1) if pos+1 == len(self._lists) or idx+1 != len(self._lists[pos]) else (pos+1, 0)\n\n\nfrom itertools import accumulate\n\n# op equivalent to swapping 2 adj eles on prefix sum arr\n# min swaps to make non-decreasing\ndef main():\n    N = int(input())\n    A = list(map(int, input().split()))\n    \n    A = list(accumulate(A))\n    if min(A) < 0 or A[-1] != max(A): return -1\n\n    res = 0\n    sl = SortedList()\n    for a in A:\n        res += len(sl) - sl.bisect_right(a)\n        sl.add(a)\n\n    return res\n\n\nif __name__ == '__main__':\n    res = main()\n    print(res)\n",
    "prob_desc_created_at": "1662298500",
    "tags": [
        "data structures"
    ],
    "hidden_unit_tests": ""
}
{
    "prob_desc_time_limit": "1 second",
    "prob_desc_sample_outputs": "[\"4\\n1 1 3 3\\n3 3 4 4\\n4 3 4 4\\n4 2 4 3\\n1\\n1 2 2 3\\n-1\\n0\"]",
    "src_uid": "403805b6986a1dc8560052cf33a7cf18",
    "prob_desc_notes": "NoteThe description of the first test case is below.  In the third test case, it is impossible to paint the desired picture.In the fourth test case, the initial table is already the desired picture.",
    "prob_desc_description": "Madoka as a child was an extremely capricious girl, and one of her favorite pranks was drawing on her wall. According to Madoka's memories, the wall was a table of $$$n$$$ rows and $$$m$$$ columns, consisting only of zeroes and ones. The coordinate of the cell in the $$$i$$$-th row and the $$$j$$$-th column ($$$1 \\le i \\le n$$$, $$$1 \\le j \\le m$$$) is $$$(i, j)$$$.One day she saw a picture \"Mahou Shoujo Madoka Magica\" and decided to draw it on her wall. Initially, the Madoka's table is a table of size $$$n \\times m$$$ filled with zeroes. Then she applies the following operation any number of times:Madoka selects any rectangular subtable of the table and paints it in a chess coloring (the upper left corner of the subtable always has the color $$$0$$$). Note that some cells may be colored several times. In this case, the final color of the cell is equal to the color obtained during the last repainting.  White color means $$$0$$$, black means $$$1$$$. So, for example, the table in the first picture is painted in a chess coloring, and the others are not. For better understanding of the statement, we recommend you to read the explanation of the first test.Help Madoka and find some sequence of no more than $$$n \\cdot m$$$ operations that allows you to obtain the picture she wants, or determine that this is impossible.",
    "prob_desc_output_spec": "If it is impossible to obtain the given picture, print $$$-1$$$. Otherwise, print in the first line a single integer $$$q$$$ ($$$0 \\leq q \\leq n \\cdot m$$$) — the number of operations you need to obtain the picture. Note that you do not need to minimize the number of operations. Then for each operation (in the order of execution) print a single line containing four numbers — the coordinates of the upper-left corner and the lower-right corner of the rectangle.",
    "prob_desc_input_spec": "Each test contains multiple test cases. The first line contains a single integer $$$t$$$ ($$$1 \\le t \\le 10$$$) — the number of test cases. Description of the test cases follows. The first line of each test case contains two integers $$$n$$$ and $$$m$$$ ($$$1 \\leq n, m \\leq 100$$$) — the size of the table. Each of the following $$$n$$$ lines contains a string of length $$$m$$$ consisting only of $$$1$$$ and $$$0$$$ — description of the picture that Madoka wants to obtain.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3-64",
    "lang_cluster": "Python",
    "difficulty": 1300,
    "file_name": "train_096.jsonl",
    "code_uid": "f456515c8b5f67922869038a1c221200",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"4\\n4 5\\n01000\\n10100\\n01010\\n00110\\n2 3\\n001\\n010\\n3 3\\n110\\n101\\n000\\n1 1\\n0\"]",
    "exec_outcome": "PASSED",
    "source_code": "import sys\r\nimport math\r\nfrom collections import defaultdict, Counter, deque\r\nfrom bisect import *\r\nfrom string import ascii_lowercase\r\nfrom heapq import *\r\n\r\n\r\ndef readInts():\r\n    x = list(map(int, (sys.stdin.readline().rstrip().split())))\r\n    return x[0] if len(x) == 1 else x\r\n\r\n\r\ndef readList(type=int):\r\n    x = sys.stdin.readline()\r\n    x = list(map(type, x.rstrip('\\n\\r').split()))\r\n    return x\r\n\r\n\r\ndef readStr():\r\n    x = sys.stdin.readline().rstrip('\\r\\n')\r\n    return x\r\n\r\n\r\nwrite = sys.stdout.write\r\nread = sys.stdin.readline\r\n\r\n\r\ndef dist(x1, x2, y1, y2):\r\n    return math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2)\r\n\r\n\r\ndef mergeSort(arr, check = lambda a, b: a < b, reverse = False):\r\n    if len(arr) > 1:\r\n  \r\n        # Finding the mid of the array\r\n        mid = len(arr)//2\r\n  \r\n        # Dividing the array elements\r\n        L = arr[:mid]\r\n  \r\n        # into 2 halves\r\n        R = arr[mid:]\r\n  \r\n        # Sorting the first half\r\n        mergeSort(L, check, reverse)\r\n  \r\n        # Sorting the second half\r\n        mergeSort(R, check, reverse)\r\n  \r\n        i = j = k = 0\r\n  \r\n        # Copy data to temp arrays L[] and R[]\r\n        while i < len(L) and j < len(R):\r\n            if check(L[i], R[j]):\r\n                if not reverse:\r\n                    arr[k] = L[i]\r\n                    i += 1\r\n                else:\r\n                    arr[k] = R[j]\r\n                    j += 1\r\n            else:\r\n                if not reverse:\r\n                    arr[k] = R[j]\r\n                    j += 1\r\n                else:\r\n                    arr[k] = L[i]\r\n                    i += 1 \r\n            k += 1\r\n  \r\n        # Checking if any element was left\r\n        while i < len(L):\r\n            arr[k] = L[i]\r\n            i += 1\r\n            k += 1\r\n      \r\n        while j < len(R):\r\n            arr[k] = R[j]\r\n            j += 1\r\n            k += 1\r\n\r\n\r\ndef maxSum(arr):\r\n    \r\n    max_sum = float('-inf')   \r\n    max_cur = 0 \r\n    for num in ar:\r\n        max_cur = max(max_cur + num, num)\r\n        if max_cur > max_sum:\r\n            max_sum = max_cur\r\n    return max_sum\r\n\r\n\r\ndef hcf(a, b):\r\n    if b == 0:\r\n        return a\r\n    else:\r\n        return hcf(b, b%a)\r\n\r\n\r\ndef get_power(n, m):\r\n    i = 1\r\n    p = -1\r\n    while i <= n:\r\n        i = i*m\r\n        p += 1\r\n    return p\r\n\r\n\r\ndef fact(n):\r\n    f = 1\r\n    for i in range(2, n+1):\r\n        f *= i\r\n    return f\r\n\r\n\r\ndef find_closest(num, ar):\r\n    min_d = float('inf')\r\n    for num2 in ar:\r\n        d = abs(num2-num)\r\n        if d < min_d:\r\n            min_d = d\r\n    return min_d \r\n\r\n\r\ndef check_pal(n):\r\n    s = str(n)\r\n    j = len(s)-1\r\n    i = 0\r\n    while j > i:\r\n        if s[i] != s[j]:\r\n            return False\r\n        i += 1\r\n        j -= 1\r\n\r\n    return True\r\n\r\n\r\ndef solve(t):\r\n    n, m = readInts()\r\n    ar = []\r\n    \r\n    for _ in range(n):\r\n        ar.append(list(readStr()))\r\n\r\n    prev = False\r\n    res = []\r\n\r\n    if ar[0][0] == '1':\r\n        print(-1)\r\n        return\r\n\r\n    for i in range(n-1, -1, -1):\r\n        for j in range(m-1, -1, -1):\r\n            if ar[i][j] == '1':\r\n                if i == 0:\r\n                    res.append([i+1, j, i+1, j+1])\r\n                else:\r\n                    res.append([i, j+1, i+1, j+1])\r\n\r\n\r\n    print(len(res))\r\n    for op in res:\r\n        print(*op)\r\n\r\n\r\ndef main():\r\n    t = 1\r\n    #f = open('F:/ts2_input.txt', 'r')\r\n    #sys.stdin = f\r\n    sys.setrecursionlimit(10000)\r\n    t = readInts()\r\n    for i in range(t):\r\n        solve(i+1)\r\n    #f.close()\r\n\r\n\r\nif __name__ == '__main__':\r\n    main()\r\n",
    "prob_desc_created_at": "1647009300",
    "tags": [
        "constructive algorithms",
        "greedy"
    ],
    "hidden_unit_tests": ""
}
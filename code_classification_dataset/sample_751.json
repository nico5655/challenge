{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"pret\\nsps\\ncdfs\\njava\\nmama\\nnorm\", \"-1\"]",
    "src_uid": "f8e64d8b7d10c5ba306480cab2cd3489",
    "prob_desc_notes": null,
    "prob_desc_description": "As we communicate, we learn much new information. However, the process of communication takes too much time. It becomes clear if we look at the words we use in our everyday speech.We can list many simple words consisting of many letters: \"information\", \"technologies\", \"university\", \"construction\", \"conservatoire\", \"refrigerator\", \"stopwatch\", \"windowsill\", \"electricity\", \"government\" and so on. Of course, we can continue listing those words ad infinitum. Fortunately, the solution for that problem has been found. To make our speech clear and brief, we should replace the initial words with those that resemble them but are much shorter. This idea hasn't been brought into life yet, that's why you are chosen to improve the situation. Let's consider the following formal model of transforming words: we shall assume that one can use n words in a chat. For each words we shall introduce a notion of its shorter variant. We shall define shorter variant of an arbitrary word s as such word t, that meets the following conditions:  it occurs in s as a subsequence,  its length ranges from one to four characters. In other words, the word t consists at least of one and at most of four characters that occur in the same order in the word s. Note that those characters do not necessarily follow in s immediately one after another. You are allowed not to shorten the initial word if its length does not exceed four characters.You are given a list of n different words. Your task is to find a set of their shortened variants. The shortened variants of all words from the list should be different.",
    "prob_desc_output_spec": "If the solution exists, print in the output file exactly n lines, where the i-th line represents the shortened variant of the i-th word from the initial set. If there are several variants to solve the problem, print any of them. If there is no solution, print -1.",
    "prob_desc_input_spec": "The first line of the input file contains the only integer n (1 ≤ n ≤ 200). Then n lines contain a set of different non-empty words that consist of lowercase Latin letters. The length of each word does not exceed 10 characters.",
    "prob_desc_output_to": "output.txt",
    "prob_desc_input_from": "input.txt",
    "lang": "Python 3",
    "lang_cluster": "Python",
    "difficulty": 1800,
    "file_name": "train_004.jsonl",
    "code_uid": "846b9d1505fdc7e471a5eb9c5aa888f6",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"6\\nprivet\\nspasibo\\ncodeforces\\njava\\nmarmelad\\nnormalno\", \"5\\naaa\\naa\\na\\naaaa\\naaaaa\"]",
    "exec_outcome": "PASSED",
    "source_code": "x,nil=1000000000000000000000000,''\ndef bfs():\n    Q=[]\n    for k,u in enumerate(U):\n        if pair_u[u]==nil:\n            dist[u]=0\n            Q.append(u)\n        else:dist[u]=x\n    dist[nil]=x\n    while Q:\n        u = Q.pop(0)\n        if dist[u]<dist[nil]:\n            for k,v in enumerate(adj[u]):\n                if dist[pair_v[v]]==x:\n                    dist[pair_v[v]]=dist[u]+1\n                    Q.append(pair_v[v])\n    return dist[nil]!=x\ndef dfs(u):\n    if u!=nil:\n        for j,v in enumerate(adj[u]):\n            if dist[pair_v[v]]==dist[u]+1:\n                if dfs(pair_v[v])==True:\n                    pair_v[v]=u\n                    pair_u[u]=v\n                    return True\n        dist[u]=x\n        return False\n    return True\ndef Hopcroft_Karp(U,V,adj,dist,pair_u,pair_v,nil):\n    for i,u in enumerate(U):\n        pair_u[u]=nil\n    for i,v in enumerate(V):\n        pair_v[v]=nil\n    matching=0\n    while bfs()==True:\n        for i,u in enumerate(U):\n            if pair_u[u]==nil:\n                if dfs(u)==True:matching+=1\n    with open('output.txt','w') as g:\n        if matching<n:g.write('-1')\n        else:\n            for i,u in enumerate(pair_u):\n                if u!='':\n                    g.write(pair_u[u][:-1]+'\\n')\ndef add_new(V,adj,new,a):\n    V.append(new)\n    if adj.get(new)==None:adj[new]=set()\n    adj[a].add(new)\n    adj[new].add(a)\nU,V,dist,adj,pair_u,pair_v=[],[],{},{},{},{}\nwith open('input.txt','r') as f:\n    n=int(f.readline())\n    for b in range(n):\n        s=f.readline()[:-1]\n        U.append(s)\n        adj[s]=set()\n        pair_u[s]=x\n        dist[s]=x\n    pair_u[nil]=x\nfor b,a in enumerate(U):\n    length=len(a)\n    for e in range(length):\n        add_new(V,adj,a[e]+'1',a)\n        for q in range(min(length,e+1),length):\n            add_new(V,adj,a[e]+a[q]+'1',a)\n            for o in range(min(length,q+1),length):\n                add_new(V,adj,a[e]+a[q]+a[o]+'1',a)\n                for c in range(min(length,o+1),length):\n                    add_new(V,adj,a[e]+a[q]+a[o]+a[c]+'1',a)\nadj[nil]=set()\ndist[nil]=x\nfor ind,item in enumerate(V):\n    dist[item]=x\n    pair_v[item]=x\n    adj[item].add(nil)\n    adj[nil].add(item)\nHopcroft_Karp(U,V,adj,dist,pair_u,pair_v,nil)",
    "prob_desc_created_at": "1318919400",
    "tags": [
        "graph matchings"
    ],
    "hidden_unit_tests": ""
}
{
    "prob_desc_time_limit": "1 second",
    "prob_desc_sample_outputs": "[\"1 \\n1 2 3 \\n1 2 4 3 \\n1 2 3 4 5\"]",
    "src_uid": "a57823a7ca0f67a07f94175ab59d33de",
    "prob_desc_notes": "NoteIn the first test case, the permutation has length $$$1$$$, so the only possible segment is $$$[1,1]$$$. The resulting permutation is $$$[1]$$$.In the second test case, we can obtain the identity permutation by reversing the segment $$$[1,2]$$$. The resulting permutation is $$$[1,2,3]$$$.In the third test case, the best possible segment is $$$[2,3]$$$. The resulting permutation is $$$[1,2,4,3]$$$.In the fourth test case, there is no lexicographically smaller permutation, so we can leave it unchanged by choosing the segment $$$[1,1]$$$. The resulting permutation is $$$[1,2,3,4,5]$$$.",
    "prob_desc_description": "You are given a permutation $$$p_1, p_2, \\ldots, p_n$$$ of length $$$n$$$. You have to choose two integers $$$l,r$$$ ($$$1 \\le l \\le r \\le n$$$) and reverse the subsegment $$$[l,r]$$$ of the permutation. The permutation will become $$$p_1,p_2, \\dots, p_{l-1},p_r,p_{r-1}, \\dots, p_l,p_{r+1},p_{r+2}, \\dots ,p_n$$$.Find the lexicographically smallest permutation that can be obtained by performing exactly one reverse operation on the initial permutation.Note that for two distinct permutations of equal length $$$a$$$ and $$$b$$$, $$$a$$$ is lexicographically smaller than $$$b$$$ if at the first position they differ, $$$a$$$ has the smaller element.A permutation is an array consisting of $$$n$$$ distinct integers from $$$1$$$ to $$$n$$$ in arbitrary order. For example, $$$[2,3,1,5,4]$$$ is a permutation, but $$$[1,2,2]$$$ is not a permutation ($$$2$$$ appears twice in the array) and $$$[1,3,4]$$$ is also not a permutation ($$$n=3$$$ but there is $$$4$$$ in the array).",
    "prob_desc_output_spec": "For each test case print the lexicographically smallest permutation you can obtain.",
    "prob_desc_input_spec": "Each test contains multiple test cases. The first line contains a single integer $$$t$$$ ($$$1 \\le t \\le 500$$$) — the number of test cases. Description of the test cases follows. The first line of each test case contains a single integer $$$n$$$ ($$$1 \\le n \\le 500$$$) — the length of the permutation. The second line of each test case contains $$$n$$$ integers $$$p_1, p_2, \\dots, p_n$$$ ($$$1 \\le p_i \\le n$$$) — the elements of the permutation.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3-64",
    "lang_cluster": "Python",
    "difficulty": 800,
    "file_name": "train_106.jsonl",
    "code_uid": "f9e5b7fd2e9dfc5b2ea3a05870dc5985",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"4\\n\\n1\\n\\n1\\n\\n3\\n\\n2 1 3\\n\\n4\\n\\n1 4 2 3\\n\\n5\\n\\n1 2 3 4 5\"]",
    "exec_outcome": "PASSED",
    "source_code": "#lista=list(map(int,input().split()))\r\n#x=lista[0]\r\n#n=lista[0]\r\nimport math\r\n#import sys\r\n#from collections import deque\r\n#from sys import stdin, stdout\r\nfrom decimal import *\r\n \r\n#lista=list(map(int,input().split()))\r\n#x=lista[0]\r\n#n=lista[0]\r\n \r\nrasp_final=\"\"\r\n#my_set=set()\r\n#for x in range(1, 100000):\r\n #my_set.add(2*x*x)\r\n #my_set.add(4*x*x)\r\n \r\n#vector_prime=[-1]*21000\r\n#vector_rasp=[0]*21000\r\n \r\n#vector_prime[1]=1\r\n \r\n#vector_rasp[1]=1\r\n \r\n#contor=2\r\n#primes sieve\r\n#for i in range(2,21000):\r\n #if vector_prime[i]==-1:\r\n  #vector_prime[i]=1\r\n  #vector_rasp[contor]=i\r\n  #contor=contor+1\r\n  #for j in range(i+i,21000,i):\r\n  # vector_prime[j]=0\r\n   #print(i,j)\r\n   \r\n#res = list(map(int, str(num))) \r\n  \r\ndef cmmmdc(x,y):\r\n maximul=max(x,y)\r\n minimul=min(x,y)\r\n while maximul!=minimul and minimul!=0:\r\n  \r\n  dif=maximul-minimul\r\n  raport=dif//minimul\r\n \r\n  \r\n  \r\n  maximul-=minimul*(raport+1)\r\n  \r\n  a=max(minimul,maximul)\r\n  b=min(minimul, maximul)\r\n  \r\n  maximul=a\r\n  minimul=b\r\n  \r\n  \r\n  \r\n \r\n  \r\n  \r\n return (maximul)\r\n \r\n \r\ndict = {}  \r\n#suma=0\r\n#vector=list(map(int,input().split()))\r\n#for i in vector:\r\n #suma=suma+i\r\n#luni = {'January':1, 'February':2, 'March':3, 'April':4, 'May':5, 'June':6, 'July':7, 'August':8, 'September':9, 'October':10, 'November':11, 'December':0}\r\n#luni_reverse = {1:'January', 2:'February', 3:'March', 4:'April', 5:'May', 6:'June', 7:'July', 8:'August', 9:'September', 10:'October', 11:'November', 0:'December'} \r\nalfabet = {'a': 1, 'b': 2,'c': 3,'d': 4,'e': 5,'f': 6,'g': 7,'h': 8,'i': 9,'j': 10,'k': 11,'l': 12,'m': 13,'n': 14,'o': 15,'p': 16,'q': 17,'r': 18,'s': 19,'t': 20,'u': 21,'v': 22,'w': 23,'x': 24,'y': 25,'z': 26}\r\n#alfabet_2={'1':\"a\", '2':\"b\", '3':\"c\", '4':\"d\", '5':\"e\", '6':\"f\", '7':\"g\", '8':\"h\", '9':\"i\", '10':\"j\", '11':\"k\", '12':\"l\", '13':\"m\", '14':\"n\", '15':\"o\", '16':\"p\", '17':\"q\", '18':\"r\", '19':\"s\", '20':\"t\", '21':\"u\", '22':\"v\", '23':\"w\", '24':\"x\", '25':\"y\", '26':\"z\"}\r\n \r\n#k=int(input()) \r\nk=1\r\n \r\ncontor=0 \r\nwhile k>0:\r\n \r\n \r\n #contor+=1\r\n \r\n# waiting=deque()\r\n \r\n #pare=0\r\n for _ in range(int(input())):\r\n    a=int(input())\r\n    l=list(map(int,input().split()))\r\n    for i in range(a):\r\n        if l[i]!=i+1:\r\n           \r\n            j=l.index(i+1)+1\r\n            l[i:j]=l[i:j][::-1]\r\n            \r\n            break\r\n    for i in l:\r\n        print(i,end=\" \")\r\n    print()\r\n \r\n \r\n    \r\n \r\n \r\n k=k-1\r\n \r\n#print(rasp_final)",
    "prob_desc_created_at": "1644849300",
    "tags": [
        "constructive algorithms",
        "greedy",
        "math"
    ],
    "hidden_unit_tests": ""
}
{
    "prob_desc_time_limit": "3 seconds",
    "prob_desc_sample_outputs": "[\"0\\n2\\n2\\n10\"]",
    "src_uid": "11452ff3750578d8b2ac5b76ba2749fd",
    "prob_desc_notes": "NoteIn the first test case, the only possible action is to delete vertex $$$2$$$, after which we save $$$0$$$ vertices in total.In the second test case, if we delete vertex $$$2$$$, we can save vertices $$$3$$$ and $$$4$$$.    ",
    "prob_desc_description": "Byteland is a beautiful land known because of its beautiful trees.Misha has found a binary tree with $$$n$$$ vertices, numbered from $$$1$$$ to $$$n$$$. A binary tree is an acyclic connected bidirectional graph containing $$$n$$$ vertices and $$$n - 1$$$ edges. Each vertex has a degree at most $$$3$$$, whereas the root is the vertex with the number $$$1$$$ and it has a degree at most $$$2$$$.Unfortunately, the root got infected.The following process happens $$$n$$$ times:  Misha either chooses a non-infected (and not deleted) vertex and deletes it with all edges which have an end in this vertex or just does nothing.  Then, the infection spreads to each vertex that is connected by an edge to an already infected vertex (all already infected vertices remain infected). As Misha does not have much time to think, please tell him what is the maximum number of vertices he can save from the infection (note that deleted vertices are not counted as saved).",
    "prob_desc_output_spec": "For each test case, output the maximum number of vertices Misha can save.",
    "prob_desc_input_spec": "There are several test cases in the input data. The first line contains a single integer $$$t$$$ ($$$1\\leq t\\leq 5000$$$) — the number of test cases. This is followed by the test cases description. The first line of each test case contains one integer $$$n$$$ ($$$2\\leq n\\leq 3\\cdot 10^5$$$) — the number of vertices of the tree.  The $$$i$$$-th of the following $$$n-1$$$ lines in the test case contains two positive integers $$$u_i$$$ and $$$v_i$$$ ($$$1 \\leq u_i, v_i \\leq n$$$), meaning that there exists an edge between them in the graph.  It is guaranteed that the graph is a binary tree rooted at $$$1$$$. It is also guaranteed that the sum of $$$n$$$ over all test cases won't exceed $$$3\\cdot 10^5$$$.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3-64",
    "lang_cluster": "Python",
    "difficulty": 1600,
    "file_name": "train_095.jsonl",
    "code_uid": "25e87820dd31860090cc15f04339fe73",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"4\\n\\n2\\n\\n1 2\\n\\n4\\n\\n1 2\\n\\n2 3\\n\\n2 4\\n\\n7\\n\\n1 2\\n\\n1 5\\n\\n2 3\\n\\n2 4\\n\\n5 6\\n\\n5 7\\n\\n15\\n\\n1 2\\n\\n2 3\\n\\n3 4\\n\\n4 5\\n\\n4 6\\n\\n3 7\\n\\n2 8\\n\\n1 9\\n\\n9 10\\n\\n9 11\\n\\n10 12\\n\\n10 13\\n\\n11 14\\n\\n11 15\"]",
    "exec_outcome": "PASSED",
    "source_code": "import sys\r\ninput = lambda: sys.stdin.readline().rstrip()\r\nout = sys.stdout.writelines\r\n\r\nclass RootedTree:\r\n\r\n  def __init__(self, G: list, root: int):\r\n    self._n = len(G)\r\n    self._G = G\r\n    self._root = root\r\n    self._height = -1\r\n    self._toposo = []\r\n    self._dist = []\r\n    self._descendant_num = []\r\n    self._child = []\r\n    self._child_num = []\r\n    self._parents = []\r\n    self._diameter = -1\r\n    self._bipartite_graph = []\r\n\r\n    self._calc_dist_toposo()\r\n    # self._calc_child_parents()\r\n\r\n  def __len__(self) -> int:\r\n    \"Return the number of vertex of self. / O(1)\"\r\n    return self._n\r\n\r\n  def __str__(self) -> str:\r\n    \"Print Rooted Tree. / O(N) or O(1)\"\r\n    self._calc_child_parents()\r\n    ret = [\"<RootedTree> [\"]\r\n    ret.extend(\r\n      [f'  dist:{d} - v:{str(i).zfill(2)} - p:{str(self._parents[i]).zfill(2)} - child:{self._child[i]}'\r\n       for i,d in sorted(enumerate(self._dist), key=lambda x: x[1])]\r\n      )\r\n    ret.append(']')\r\n    return '\\n'.join(ret)\r\n\r\n  def _calc_dist_toposo(self) -> None:\r\n    \"Calc dist and toposo. / O(N)\"\r\n    todo = [self._root]\r\n    self._dist = [-1] * self._n\r\n    self._dist[self._root] = 0\r\n    self._toposo = [self._root]\r\n\r\n    for v in todo:\r\n      d = self._dist[v]\r\n      for x,c in self._G[v]:\r\n        if self._dist[x] != -1:\r\n          continue\r\n        self._dist[x] = d + c\r\n        todo.append(x)\r\n        self._toposo.append(x)\r\n    return\r\n\r\n  def _calc_child_parents(self) -> None:\r\n    \"Calc child and parents. / O(N)\"\r\n    if self._child and self._child_num and self._parents:\r\n      return\r\n    self._child_num = [0] * self._n\r\n    self._child = [[] for _ in range(self._n)]\r\n    self._parents = [-1] * self._n\r\n\r\n    for v in self._toposo[::-1]:\r\n      for x,c in self._G[v]:\r\n        if self._dist[x] < self._dist[v]:\r\n          self._parents[v] = x\r\n          continue\r\n        self._child[v].append(x)\r\n        self._child_num[v] += 1\r\n    return\r\n\r\n  def get_dist(self) -> list:\r\n    \"Return dist. / O(N)\"\r\n    return self._dist\r\n\r\n  def get_toposo(self) -> list:\r\n    \"Return toposo. / O(N)\"\r\n    return self._toposo\r\n\r\n  def get_height(self) -> int:\r\n    \"Return height. / O(N)\"\r\n    if self._height > -1:\r\n      return self._height\r\n    self._height = max(self._dist)\r\n    return self._height\r\n\r\n  def get_descendant_num(self) -> list:\r\n    \"Return descendant_num. / O(N)\"\r\n    if self._descendant_num:\r\n      return self._descendant_num\r\n    self._descendant_num = [1] * self._n\r\n\r\n    for v in self._toposo[::-1]:\r\n      for x,c in self._G[v]:\r\n        if self._dist[x] < self._dist[v]:\r\n          continue\r\n        self._descendant_num[v] += self._descendant_num[x]\r\n\r\n    for i in range(self._n):\r\n      self._descendant_num[i] -= 1\r\n    return self._descendant_num\r\n\r\n  def get_child(self) -> list:\r\n    \"Return child / O(N)\"\r\n    if self._child:\r\n      return self._child\r\n    self._calc_child_parents()\r\n    return self._child\r\n\r\n  def get_child_num(self) -> list:\r\n    \"Return child_num. / O(N)\"\r\n    if self._child_num:\r\n      return self._child_num\r\n    self._calc_child_parents()\r\n    return self._child_num\r\n\r\n  def get_parents(self) -> list:\r\n    \"Return parents. / O(N)\"\r\n    if self._parents:\r\n      return self._parents\r\n    self._calc_child_parents()\r\n    return self._parents\r\n\r\n  def get_diameter(self) -> int:\r\n    \"Return diameter of tree. / O(N)\"\r\n    if self._diameter > -1:\r\n      return self._diameter\r\n    s = self._dist.index(self.get_height())\r\n    todo = [s]\r\n    ndist = [-1] * self._n\r\n    ndist[s] = 0\r\n\r\n    while todo:\r\n      v = todo.pop()\r\n      d = ndist[v]\r\n      for x, c in self._G[v]:\r\n        if ndist[x] != -1:\r\n          continue\r\n        ndist[x] = d + c\r\n        todo.append(x)\r\n    self._diameter = max(ndist)\r\n\r\n    return self._diameter\r\n\r\n  def get_bipartite_graph(self) -> list:\r\n    \"Return [1 if root else 0]. / O(N)\"\r\n    if self._bipartite_graph:\r\n      return self._bipartite_graph\r\n    self._bipartite_graph = [-1] * self._n\r\n    self._bipartite_graph[self._root] = 1\r\n    todo = [self._root]\r\n\r\n    while todo:\r\n      v = todo.popleft()\r\n      nc = 0 if self._bipartite_graph[v] else 1\r\n      for x,_ in self._G[v]:\r\n        if self._bipartite_graph[x] != -1:\r\n          continue\r\n        self._bipartite_graph[x] = nc\r\n        todo.append(x)\r\n\r\n    return self._bipartite_graph\r\n\r\ndef main():\r\n  n = int(input())\r\n  G = [[] for _ in range(n)]\r\n  for _ in range(n-1):\r\n    u, v = map(int, input().split())\r\n    u -= 1\r\n    v -= 1\r\n    G[u].append((v, 1))\r\n    G[v].append((u, 1))\r\n\r\n  tree = RootedTree(G, 0)\r\n  dist = tree.get_dist()\r\n  order = tree.get_toposo()\r\n  child = tree.get_child()\r\n  dsnum = tree.get_descendant_num()\r\n\r\n  dp = [0 for _ in range(n)]\r\n  for v in order[::-1]:\r\n    if len(child[v]) == 0:\r\n      continue\r\n    elif len(child[v]) == 1:\r\n      dp[v] = dsnum[child[v][0]]\r\n    elif len(child[v]) == 2:\r\n      x1, x2 = child[v]\r\n      dp[v] = max(dp[x1]+dsnum[x2], dp[x2]+dsnum[x1])\r\n  return dp[0]\r\n\r\nout('\\n'.join(map(str, [main() for _ in range(int(input()))])))\r\n",
    "prob_desc_created_at": "1654878900",
    "tags": [
        "dfs and similar",
        "dp",
        "trees"
    ],
    "hidden_unit_tests": ""
}
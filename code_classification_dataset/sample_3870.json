{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"16\", \"1\", \"10\", \"1\"]",
    "src_uid": "d666df06a7a7ecbe801c1018b3d482b9",
    "prob_desc_notes": "NoteSome strings you can obtain in the first example:  to obtain 0110110, you can take the substring from the $$$1$$$-st character to the $$$4$$$-th character, which is 1100, and reorder its characters to get 0110;  to obtain 1111000, you can take the substring from the $$$3$$$-rd character to the $$$7$$$-th character, which is 00110, and reorder its characters to get 11000;  to obtain 1100101, you can take the substring from the $$$5$$$-th character to the $$$7$$$-th character, which is 110, and reorder its characters to get 101. In the second example, $$$k = 0$$$ so you can only choose the substrings consisting only of 0 characters. Reordering them doesn't change the string at all, so the only string you can obtain is 10010.",
    "prob_desc_description": "You are given a binary string (i.â€‰e. a string consisting of characters 0 and/or 1) $$$s$$$ of length $$$n$$$. You can perform the following operation with the string $$$s$$$ at most once: choose a substring (a contiguous subsequence) of $$$s$$$ having exactly $$$k$$$ characters 1 in it, and shuffle it (reorder the characters in the substring as you wish).Calculate the number of different strings which can be obtained from $$$s$$$ by performing this operation at most once.",
    "prob_desc_output_spec": "Print one integer â€” the number of different strings which can be obtained from $$$s$$$ by performing the described operation at most once. Since the answer can be large, output it modulo $$$998244353$$$.",
    "prob_desc_input_spec": "The first line contains two integers $$$n$$$ and $$$k$$$ ($$$2 \\le n \\le 5000$$$; $$$0 \\le k \\le n$$$). The second line contains the string $$$s$$$ of length $$$n$$$, consisting of characters 0 and/or 1.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3-64",
    "lang_cluster": "Python",
    "difficulty": 2000,
    "file_name": "train_085.jsonl",
    "code_uid": "9f6e5587e9aec288e916e1128ec1332c",
    "prob_desc_memory_limit": "512 megabytes",
    "prob_desc_sample_inputs": "[\"7 2\\n1100110\", \"5 0\\n10010\", \"8 1\\n10001000\", \"10 8\\n0010011000\"]",
    "exec_outcome": "PASSED",
    "source_code": "import os,sys\r\nfrom io import BytesIO, IOBase\r\n\r\nfrom collections import defaultdict,deque,Counter\r\nfrom bisect import bisect_left,bisect_right\r\nfrom heapq import heappush,heappop\r\nfrom functools import lru_cache\r\nfrom itertools import accumulate\r\nimport math\r\nfrom tkinter import N\r\n\r\n# Fast IO Region\r\nBUFSIZE = 8192\r\nclass FastIO(IOBase):\r\n    newlines = 0\r\n    def __init__(self, file):\r\n        self._fd = file.fileno()\r\n        self.buffer = BytesIO()\r\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\r\n        self.write = self.buffer.write if self.writable else None\r\n    def read(self):\r\n        while True:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            if not b:\r\n                break\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines = 0\r\n        return self.buffer.read()\r\n    def readline(self):\r\n        while self.newlines == 0:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            self.newlines = b.count(b\"\\n\") + (not b)\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines -= 1\r\n        return self.buffer.readline()\r\n    def flush(self):\r\n        if self.writable:\r\n            os.write(self._fd, self.buffer.getvalue())\r\n            self.buffer.truncate(0), self.buffer.seek(0)\r\nclass IOWrapper(IOBase):\r\n    def __init__(self, file):\r\n        self.buffer = FastIO(file)\r\n        self.flush = self.buffer.flush\r\n        self.writable = self.buffer.writable\r\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\r\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\r\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\r\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\r\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\r\n\r\n# for _ in range(int(input())):\r\n#     n = int(input())\r\n#     a = list(map(int, input().split(' ')))\r\n\r\n# for _ in range(int(input())):\r\n#     a, b, c = list(map(int, input().split(' ')))\r\n#     if (a == b and c % 2 == 0) or (b == c and a % 2 == 0) or (a == c and b % 2 == 0):\r\n#         print('YES')\r\n#         continue\r\n#     s = [a, b, c]\r\n#     s.sort()\r\n#     if s[0] + s[1] == s[2]:\r\n#         print('YES')\r\n#         continue\r\n#     print('NO')\r\n\r\n# for _ in range(int(input())):\r\n#     n = int(input())\r\n#     a = list(map(int, input().split(' ')))\r\n#     s = input()\r\n#     cnt = s.count('0')\r\n#     ans = [0] * n\r\n#     hi = []\r\n#     lo = []\r\n#     for i in range(n):\r\n#         if s[i] == '1':\r\n#             if a[i] > cnt:\r\n#                 ans[i] = a[i]\r\n#             else:\r\n#                 hi.append(a[i])\r\n#                 ans[i] = -1\r\n#         else:\r\n#             if a[i] <= cnt:\r\n#                 ans[i] = a[i]\r\n#             else:\r\n#                 lo.append(a[i])\r\n#                 ans[i] = -2\r\n#     for i in range(n):\r\n#         if ans[i] == -1:\r\n#             ans[i] = lo.pop()\r\n#         elif ans[i] == -2:\r\n#             ans[i] = hi.pop()\r\n#     print(*ans)\r\n\r\n# for _ in range(int(input())):\r\n#     n, k = list(map(int, input().split(' ')))\r\n#     a = list(map(int, input().split(' ')))\r\n#     a.sort()\r\n#     pre = list(accumulate(a))\r\n#     ans = float('inf')\r\n#     for i in range(n):\r\n#         res = i\r\n#         tmp = pre[n - 1 - i] - pre[0]\r\n#         res += max(0, a[0] - (k - tmp) // (i + 1))\r\n#         ans = min(ans, res)\r\n#     print(ans)\r\n\r\nmod = 998244353\r\nN = 5010\r\nfac = [1] * N\r\nfor i in range(2, N):\r\n    fac[i] = fac[i - 1] * i % mod\r\ninvfac = [1] * N\r\ninvfac[N - 1] = pow(fac[N - 1], mod - 2, mod)\r\nfor i in range(N - 1)[::-1]:\r\n    invfac[i] = invfac[i + 1] * (i + 1) % mod\r\ndef c(i, j):\r\n    return fac[i] * invfac[j] * invfac[i - j] % mod\r\n\r\ndef solve():\r\n    n, k = list(map(int, input().split(' ')))\r\n    a = list(map(int, input()))\r\n    pre = list(accumulate(a))\r\n    tmp = []\r\n    for i in range(n):\r\n        if i == 0:\r\n            r = bisect_right(pre, k)\r\n            if r - 1 >= 0 and pre[r -   1] == k:\r\n                tmp.append((i, r - 1))\r\n        else:\r\n            if a[i - 1] == 0: continue\r\n            r = bisect_right(pre, k + pre[i - 1])\r\n            if r - 1 >= i and pre[r - 1] == k + pre[i - 1]:\r\n                tmp.append((i, r - 1))\r\n\r\n    if not tmp:\r\n        print(1)\r\n        return\r\n    ans = 1\r\n    m = len(tmp)\r\n    for i in range(m):\r\n        l, r = tmp[i]\r\n        if l == 0:\r\n            cnt1 = pre[r]\r\n        else:\r\n            cnt1 = pre[r] - pre[l - 1]\r\n        ans += c(r - l + 1, cnt1) - 1\r\n        ans %= mod\r\n        if i > 0:\r\n            j = i - 1\r\n            r = tmp[j][1]\r\n            if l <= r:\r\n                if l == 0:\r\n                    cnt1 = pre[r]\r\n                else:\r\n                    cnt1 = pre[r] - pre[l - 1]\r\n                ans -= c(r - l + 1, cnt1) - 1\r\n                ans %= mod\r\n    print(ans % mod)\r\n\r\n    \r\nsolve()\r\n        \r\n",
    "prob_desc_created_at": "1640615700",
    "tags": [
        "combinatorics",
        "math",
        "two pointers"
    ],
    "hidden_unit_tests": ""
}
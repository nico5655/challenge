{
    "prob_desc_time_limit": "5 seconds",
    "prob_desc_sample_outputs": "[\"3\\n\\n4\\n\\n5\\n\\n\\n1\\n\\n4\\n\\n6\"]",
    "src_uid": "7a9b559eb3b601590e22eb128f2bf307",
    "prob_desc_notes": "NoteTest Case 1:In this case, the hidden password is $$$2$$$.The first query is $$$3$$$. It is not equal to the current password. So, $$$0$$$ is returned, and the password is changed to $$$1$$$ since $$$2\\oplus_2 1=3$$$.The second query is $$$4$$$. It is not equal to the current password. So, $$$0$$$ is returned, and the password is changed to $$$5$$$ since $$$1\\oplus_2 5=4$$$.The third query is $$$5$$$. It is equal to the current password. So, $$$1$$$ is returned, and the job is done.Test Case 2:In this case, the hidden password is $$$3$$$.The first query is $$$1$$$. It is not equal to the current password. So, $$$0$$$ is returned, and the password is changed to $$$7$$$ since $$$3\\oplus_3 7=1$$$. $$$[3=(10)_3$$$, $$$7=(21)_3$$$, $$$1=(01)_3$$$ and $$$(10)_3\\oplus_3 (21)_3 = (01)_3]$$$.The second query is $$$4$$$. It is not equal to the current password. So, $$$0$$$ is returned, and the password is changed to $$$6$$$ since $$$7\\oplus_3 6=4$$$. $$$[7=(21)_3$$$, $$$6=(20)_3$$$, $$$4=(11)_3$$$ and $$$(21)_3\\oplus_3 (20)_3 = (11)_3]$$$.The third query is $$$6$$$. It is equal to the current password. So, $$$1$$$ is returned, and the job is done.Note that these initial passwords are taken just for the sake of explanation. In reality, the grader might behave differently because it is adaptive.",
    "prob_desc_description": "This is the hard version of the problem. The only difference is that here $$$2\\leq k\\leq 100$$$. You can make hacks only if both the versions of the problem are solved.This is an interactive problem!Every decimal number has a base $$$k$$$ equivalent. The individual digits of a base $$$k$$$ number are called $$$k$$$-its. Let's define the $$$k$$$-itwise XOR of two $$$k$$$-its $$$a$$$ and $$$b$$$ as $$$(a + b)\\bmod k$$$.The $$$k$$$-itwise XOR of two base $$$k$$$ numbers is equal to the new number formed by taking the $$$k$$$-itwise XOR of their corresponding $$$k$$$-its. The $$$k$$$-itwise XOR of two decimal numbers $$$a$$$ and $$$b$$$ is denoted by $$$a\\oplus_{k} b$$$ and is equal to the decimal representation of the $$$k$$$-itwise XOR of the base $$$k$$$ representations of $$$a$$$ and $$$b$$$. All further numbers used in the statement below are in decimal unless specified.You have hacked the criminal database of Rockport Police Department (RPD), also known as the Rap Sheet. But in order to access it, you require a password. You don't know it, but you are quite sure that it lies between $$$0$$$ and $$$n-1$$$ inclusive. So, you have decided to guess it. Luckily, you can try at most $$$n$$$ times without being blocked by the system. But the system is adaptive. Each time you make an incorrect guess, it changes the password. Specifically, if the password before the guess was $$$x$$$, and you guess a different number $$$y$$$, then the system changes the password to a number $$$z$$$ such that $$$x\\oplus_{k} z=y$$$. Guess the password and break into the system.",
    "prob_desc_output_spec": null,
    "prob_desc_input_spec": "The first line of input contains a single integer $$$t$$$ ($$$1\\leq t\\leq 10\\,000$$$) denoting the number of test cases. $$$t$$$ test cases follow. The first line of each test case contains two integers $$$n$$$ ($$$1\\leq n\\leq 2\\cdot 10^5$$$) and $$$k$$$ $$$(2\\leq k\\leq 100)$$$. It is guaranteed that the sum of $$$n$$$ over all test cases does not exceed $$$2\\cdot 10^5$$$.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 2",
    "lang_cluster": "Python",
    "difficulty": 2200,
    "file_name": "train_091.jsonl",
    "code_uid": "36f6ccc85cec8eb345d82cf04662655e",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"2\\n5 2\\n\\n0\\n\\n0\\n\\n1\\n5 3\\n\\n0\\n\\n0\\n\\n1\"]",
    "exec_outcome": "PASSED",
    "source_code": "from __future__ import division, print_function\r\n\r\nimport os,sys\r\nfrom io import BytesIO, IOBase\r\n\r\nif sys.version_info[0] < 3:\r\n    from __builtin__ import xrange as range\r\n    from future_builtins import ascii, filter, hex, map, oct, zip\r\n\r\nfrom bisect import bisect_left as lower_bound, bisect_right as upper_bound \r\ndef so():  return int(input())\r\ndef st():  return input()\r\ndef mj():  return map(int, input().split())\r\ndef msj(): return map(str,input().strip().split(\" \"))\r\ndef le():  return list(map(int,input().split()))\r\ndef rc():  return map(float,input().split())\r\ndef lebe():return list(map(int, input()))\r\n\r\ndef dmain():\r\n    sys.setrecursionlimit(1000000)\r\n    threading.stack_size(1024000)\r\n    thread = threading.Thread(target=main)\r\n    thread.start()\r\ndef joro(L):\r\n    return(''.join(map(str, L)))\r\n\r\n\r\ndef decimalToBinary(n): return bin(n).replace(\"0b\",\"\")\r\n\r\n\r\ndef isprime(n):\r\n    for i in range(2,int(n**0.5)+1):\r\n        if n%i==0:\r\n            return False\r\n    return True\r\ndef npr(n, r):\r\n    return factorial(n) // factorial(n - r) if n >= r else 0\r\n \r\n \r\ndef ncr(n, r):\r\n    return factorial(n) // (factorial(r) * factorial(n - r)) if n >= r else 0\r\n \r\n \r\ndef lower_bound(li, num):\r\n    answer = -1\r\n    start = 0\r\n    end = len(li) - 1\r\n \r\n    while (start <= end):\r\n        middle = (end + start) // 2\r\n        if li[middle] >= num:\r\n            answer = middle\r\n            end = middle - 1\r\n        else:\r\n            start = middle + 1\r\n    return answer  # min index where x is not less than num\r\n \r\n \r\ndef upper_bound(li, num):\r\n    answer = -1\r\n    start = 0\r\n    end = len(li) - 1\r\n \r\n    while (start <= end):\r\n        middle = (end + start) // 2\r\n \r\n        if li[middle] <= num:\r\n            answer = middle\r\n            start = middle + 1\r\n \r\n        else:\r\n            end = middle - 1\r\n    return answer  # max index where x is not greater than num\r\ndef tir(a,b,c):\r\n    if(0==c):\r\n        return 1\r\n    if(len(a)<=b):\r\n        return 0\r\n    \r\n    if(c!=-1):\r\n        return (tir(a,1+b,c+a[b]) or tir(a,b+1,c-a[b]) or tir(a,1+b,c)) \r\n        \r\n        \r\n    else:\r\n        return (tir(a,1+b,a[b]) or tir(a,b+1,-a[b]) or tir(a,1+b,-1))\r\nhoi=int(2**20)        \r\n \r\ndef abs(x):\r\n    return x if x >= 0 else -x\r\n \r\n \r\ndef binary_search(li, val, lb, ub):\r\n    # print(lb, ub, li)\r\n    ans = -1\r\n    while (lb <= ub):\r\n        mid = (lb + ub) // 2\r\n        # print('mid is',mid, li[mid])\r\n        if li[mid] > val:\r\n            ub = mid - 1\r\n        elif val > li[mid]:\r\n            lb = mid + 1\r\n        else:\r\n            ans = mid  # return index\r\n            break\r\n    return ans\r\n \r\n \r\ndef kadane(x):  # maximum sum contiguous subarray\r\n    sum_so_far = 0\r\n    current_sum = 0\r\n    for i in x:\r\n        current_sum += i\r\n        if current_sum < 0:\r\n            current_sum = 0\r\n        else:\r\n            sum_so_far = max(sum_so_far, current_sum)\r\n    return sum_so_far\r\n \r\n \r\ndef pref(li):\r\n    pref_sum = [0]\r\n    for i in li:\r\n        pref_sum.append(pref_sum[-1] + i)\r\n    return pref_sum\r\n \r\n \r\ndef SieveOfEratosthenes(n):\r\n    prime = [True for i in range(n + 1)]\r\n    p = 2\r\n    li = []\r\n    while (p * p <= n):\r\n        if (prime[p] == True):\r\n            for i in range(p * p, n + 1, p):\r\n                prime[i] = False\r\n        p += 1\r\n \r\n    for p in range(2, len(prime)):\r\n        if prime[p]:\r\n            li.append(p)\r\n    return li\r\n \r\n \r\ndef primefactors(n):\r\n    factors = []\r\n    while (n % 2 == 0):\r\n        factors.append(2)\r\n        n //= 2\r\n    for i in range(3, int(sqrt(n)) + 1, 2):  # only odd factors left\r\n        while n % i == 0:\r\n            factors.append(i)\r\n            n //= i\r\n    if n > 2:  # incase of prime\r\n        factors.append(n)\r\n    return factors\r\n\r\ndef read():\r\n    sys.stdin  = open('input.txt', 'r')  \r\n    sys.stdout = open('output.txt', 'w') \r\ndef tr(n):\r\n    return n*(n+1)//2\r\ndef hu(a,b,opp):\r\n    d=1\r\n    c=0\r\n    while(0<b or 0<a):\r\n        c=c+(((b%opp)+(a%opp))%opp)*d\r\n        a=a//opp\r\n        b=b//opp\r\n        d=opp*d\r\n    return c\r\ndef rw(u,opp):\r\n    c=0\r\n    d=1\r\n    while(0<u):\r\n        c=c+((-u%opp)%opp)*d\r\n        u=u//opp\r\n        d=opp*d\r\n    return c\r\nsoi=int(1e9)\r\nboi=int(1e9-7)\r\ndoi=int(1e9+7)\r\n\r\n\r\ndef main():\r\n    import sys\r\n    import math as my\r\n    input=sys.stdin.readline\r\n    y=\"Yes\"\r\n    n=\"No\"\r\n    for i in range(so()):\r\n        #c=0\r\n        op,opp=mj()\r\n        c=0\r\n        for i in range(op):\r\n            if(not i%2):\r\n                z=i\r\n                \r\n            else:\r\n                \r\n                z=rw(i,opp)\r\n            uo=hu(z,c,opp)\r\n            print(uo)\r\n            sys.stdout.flush()\r\n            oppp=so()\r\n            if(1==oppp):\r\n                break\r\n            if(-1==oppp):\r\n                return\r\n            c=hu(rw(c,opp),uo,opp)\r\n    \r\n\r\n    \r\n            \r\n            \r\n            \r\n                \r\n            \r\n        \r\n    \r\n    \r\n    \r\n        \r\n    \r\n    \r\n    \r\n    \r\n    \r\n        \r\n        \r\n                        \r\n            \r\n    \r\n        \r\n    \r\n            \r\n    \r\n            \r\n        \r\n    \r\n\r\n            \r\n        \r\n    \r\n    \r\n    \r\n\r\n    \r\n    \r\n    \r\n    \r\n        \r\n\r\n        \r\n    \r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n\r\n    \r\n\r\n    \r\n        \r\n        \r\n            \r\n    \r\n    \r\n                \r\n            \r\n                \r\n                \r\n                \r\n                \r\n            \r\n    \r\n            \r\n            \r\n    \r\n    \r\n    \r\n    \r\n        \r\n            \r\n    \r\n           \r\n            \r\n            \r\n        \r\n    \r\n        \r\n    \r\n    \r\n        \r\n        \r\n        \r\n\r\n            \r\n                    \r\n                \r\n                    \r\n                    \r\n                    \r\n                    \r\n                    \r\n                    \r\n        \r\n                \r\n        \r\n        \r\n       \r\n    \r\n           \r\n          \r\n          \r\n                \r\n            \r\n        \r\n                \r\n    \r\n        \r\n        \r\n        \r\n       \r\n            \r\n                \r\n        \r\n\r\n\r\n\r\n\r\n# region fastio\r\n# template taken from https://github.com/cheran-senthil/PyRival/blob/master/templates/template.py\r\n\r\nBUFSIZE = 8192\r\n\r\n\r\nclass FastIO(IOBase):\r\n    newlines = 0\r\n\r\n    def __init__(self, file):\r\n        self._fd = file.fileno()\r\n        self.buffer = BytesIO()\r\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\r\n        self.write = self.buffer.write if self.writable else None\r\n\r\n    def read(self):\r\n        while True:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            if not b:\r\n                break\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines = 0\r\n        return self.buffer.read()\r\n\r\n    def readline(self):\r\n        while self.newlines == 0:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            self.newlines = b.count(b\"\\n\") + (not b)\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines -= 1\r\n        return self.buffer.readline()\r\n\r\n    def flush(self):\r\n        if self.writable:\r\n            os.write(self._fd, self.buffer.getvalue())\r\n            self.buffer.truncate(0), self.buffer.seek(0)\r\n\r\n\r\nclass IOWrapper(IOBase):\r\n    def __init__(self, file):\r\n        self.buffer = FastIO(file)\r\n        self.flush = self.buffer.flush\r\n        self.writable = self.buffer.writable\r\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\r\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\r\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\r\n\r\n\r\ndef print(*args, **kwargs):\r\n    \"\"\"Prints the values to a stream, or to sys.stdout by default.\"\"\"\r\n    sep, file = kwargs.pop(\"sep\", \" \"), kwargs.pop(\"file\", sys.stdout)\r\n    at_start = True\r\n    for x in args:\r\n        if not at_start:\r\n            file.write(sep)\r\n        file.write(str(x))\r\n        at_start = False\r\n    file.write(kwargs.pop(\"end\", \"\\n\"))\r\n    if kwargs.pop(\"flush\", False):\r\n        file.flush()\r\n\r\n\r\nif sys.version_info[0] < 3:\r\n    sys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)\r\nelse:\r\n    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\r\n\r\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\r\n\r\n# endregion\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    #read()\r\n    main()\r\n    #dmain()\r\n\r\n# Comment Read()",
    "prob_desc_created_at": "1625668500",
    "tags": [
        "brute force",
        "constructive algorithms",
        "interactive",
        "math"
    ],
    "hidden_unit_tests": ""
}
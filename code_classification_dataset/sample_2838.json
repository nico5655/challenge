{
    "prob_desc_time_limit": "1 second",
    "prob_desc_sample_outputs": "[\"2\", \"3\"]",
    "src_uid": "54f8b8e6711ff5c69e0bc38a6e2f4999",
    "prob_desc_notes": "NoteFormally the 12-hour time format is described at:   http://en.wikipedia.org/wiki/12-hour_clock.  The problem authors recommend you to look through these descriptions before you start with the problem.",
    "prob_desc_description": "The main server of Gomble company received a log of one top-secret process, the name of which can't be revealed. The log was written in the following format: «[date:time]: message», where for each «[date:time]» value existed not more than 10 lines. All the files were encoded in a very complicated manner, and only one programmer — Alex — managed to decode them. The code was so complicated that Alex needed four weeks to decode it. Right after the decoding process was finished, all the files were deleted. But after the files deletion, Alex noticed that he saved the recordings in format «[time]: message». So, information about the dates was lost. However, as the lines were added into the log in chronological order, it's not difficult to say if the recordings could appear during one day or not. It is possible also to find the minimum amount of days during which the log was written.So, to make up for his mistake Alex has to find the minimum amount of days covered by the log. Note that Alex doesn't have to find the minimum amount of days between the beginning and the end of the logging, he has to find the minimum amount of dates in which records could be done. (See Sample test 2 for further clarifications).We should remind you that the process made not more than 10 recordings in a minute. Consider that a midnight belongs to coming day.",
    "prob_desc_output_spec": "Output one number — the minimum amount of days covered by the log.",
    "prob_desc_input_spec": "The first input line contains number n (1 ≤ n ≤ 100). The following n lines contain recordings in format «[time]: message», where time is given in format «hh:mm x.m.». For hh two-digit numbers from 01 to 12 are used, for mm two-digit numbers from 00 to 59 are used, and x is either character «a» or character «p». A message is a non-empty sequence of Latin letters and/or spaces, it doesn't start or end with a space. The length of each message doesn't exceed 20.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3",
    "lang_cluster": "Python",
    "difficulty": 1900,
    "file_name": "train_033.jsonl",
    "code_uid": "ab9f4fe8c95f2ba9f1e8e20c4f9816f4",
    "prob_desc_memory_limit": "64 megabytes",
    "prob_desc_sample_inputs": "[\"5\\n[05:00 a.m.]: Server is started\\n[05:00 a.m.]: Rescan initialized\\n[01:13 p.m.]: Request processed\\n[01:10 p.m.]: Request processed\\n[11:40 p.m.]: Rescan completed\", \"3\\n[09:00 a.m.]: User logged in\\n[08:00 a.m.]: User logged in\\n[07:00 a.m.]: User logged in\"]",
    "exec_outcome": "PASSED",
    "source_code": "#------------------------template--------------------------#\nimport os\nimport sys\nfrom math import *\nfrom collections import *\n# from fractions import *\n# from heapq import*\nfrom bisect import *\nfrom io import BytesIO, IOBase\ndef vsInput():\n    sys.stdin = open('input.txt', 'r')\n    sys.stdout = open('output.txt', 'w')\nBUFSIZE = 8192\nclass FastIO(IOBase):\n    newlines = 0\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\nALPHA='abcdefghijklmnopqrstuvwxyz'\nM=10**9+7\nEPS=1e-6\ndef Ceil(a,b): return a//b+int(a%b>0)\ndef value():return tuple(map(int,input().split()))\ndef array():return [int(i) for i in input().split()]\ndef Int():return int(input())\ndef Str():return input()\ndef arrayS():return [i for i in input().split()]\n\n\n#-------------------------code---------------------------#\n# vsInput()\n\ndef To24Format(s):\n    time,pm=s.split()\n    h,sec=[int(i) for i in time.split(':')]\n    h%=12\n\n    if(pm=='p.m.'):\n        h+=12\n\n    return (h,sec)\n\n\nn=Int()\na=[]\n\nfor i in range(n):\n    s=input()\n    s=s[1:11]\n    a.append(To24Format(s))\n\n\nlast=(inf,inf)\nday=0\nc=0\n# print(a)\n\nfor i in a:\n\n    if(i<last):\n        day+=1\n        c=1\n    elif(i==last): c+=1\n    else: c=1\n\n    if(c>10):\n        c=1\n        day+=1\n    \n    last=i\n\n\nprint(day)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n    \n    \n\n\n\n    \n        \n\n   \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    ",
    "prob_desc_created_at": "1275570000",
    "tags": [
        "implementation",
        "strings"
    ],
    "hidden_unit_tests": ""
}
{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"10 12 14 16 18\\n0 4 4 5\\n4 6 6 7 7 7 7 8 8 8 8\"]",
    "src_uid": "a5927e1883fbd5e5098a8454f6f6631f",
    "prob_desc_notes": "NoteIn the first testcase, it doesn't matter which elements you add $$$x$$$ to. The subarray with the maximum sum will always be the entire array. If you increase $$$k$$$ elements by $$$x$$$, $$$k \\cdot x$$$ will be added to the sum.In the second testcase:   For $$$k = 0$$$, the empty subarray is the best option.  For $$$k = 1$$$, it's optimal to increase the element at position $$$3$$$. The best sum becomes $$$-1 + 5 = 4$$$ for a subarray $$$[3, 3]$$$.  For $$$k = 2$$$, it's optimal to increase the element at position $$$3$$$ and any other element. The best sum is still $$$4$$$ for a subarray $$$[3, 3]$$$.  For $$$k = 3$$$, you have to increase all elements. The best sum becomes $$$(-2 + 5) + (-7 + 5) + (-1 + 5) = 5$$$ for a subarray $$$[1, 3]$$$. ",
    "prob_desc_description": "You are given an array $$$a_1, a_2, \\dots, a_n$$$, consisting of $$$n$$$ integers. You are also given an integer value $$$x$$$.Let $$$f(k)$$$ be the maximum sum of a contiguous subarray of $$$a$$$ after applying the following operation: add $$$x$$$ to the elements on exactly $$$k$$$ distinct positions. An empty subarray should also be considered, it has sum $$$0$$$.Note that the subarray doesn't have to include all of the increased elements.Calculate the maximum value of $$$f(k)$$$ for all $$$k$$$ from $$$0$$$ to $$$n$$$ independently.",
    "prob_desc_output_spec": "For each testcase, print $$$n + 1$$$ integers — the maximum value of $$$f(k)$$$ for all $$$k$$$ from $$$0$$$ to $$$n$$$ independently.",
    "prob_desc_input_spec": "The first line contains a single integer $$$t$$$ ($$$1 \\le t \\le 5000$$$) — the number of testcases. The first line of the testcase contains two integers $$$n$$$ and $$$x$$$ ($$$1 \\le n \\le 5000$$$; $$$0 \\le x \\le 10^5$$$) — the number of elements in the array and the value to add. The second line contains $$$n$$$ integers $$$a_1, a_2, \\dots, a_n$$$ ($$$-10^5 \\le a_i \\le 10^5$$$). The sum of $$$n$$$ over all testcases doesn't exceed $$$5000$$$.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3-64",
    "lang_cluster": "Python",
    "difficulty": 1400,
    "file_name": "train_108.jsonl",
    "code_uid": "0141adabf971edd67695433fc7ebf401",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"3\\n\\n4 2\\n\\n4 1 3 2\\n\\n3 5\\n\\n-2 -7 -1\\n\\n10 2\\n\\n-6 -1 -2 4 -6 -1 -4 4 -5 -4\"]",
    "exec_outcome": "PASSED",
    "source_code": "from heapq import heapify, heappush, heappop\nfrom collections import Counter, defaultdict, deque\nfrom queue import PriorityQueue\nfrom itertools import combinations, product, permutations\nfrom bisect import bisect_left, bisect_right\nfrom functools import lru_cache\nfrom sys import stdin, stdout # for input /output\nimport copy\nimport math\n\nimport sys\nsys.setrecursionlimit(100000)\n####################\n# stdin = open(\"testcase.txt\")\n# def input():\n\t# \treturn stdin.readline().strip()\n\n#####################################################################\n\nclass FastIO:\n\n\t@classmethod\n\tdef input(cls):\n\t\tfrom sys import stdin\n\t\tx = stdin.buffer.readline().decode().strip()\n\t\treturn x\n\n\t@classmethod\n\tdef integer_list(cls):\n\t\treturn list(map(int, cls.input().split()))\n\n\t@classmethod\n\tdef print(cls, s = \"\", end = \"\\n\"):\n\t\tfrom sys import stdout\n\t\tstdout.write(str(s) + end)\n\n\t@classmethod\n\tdef flush(cls):\n\t\tfrom sys import stdout\n\t\tstdout.flush()\n\n\n####################################################################\n\nclass SegmentTree:\n\tdef __init__(self, data, default=0, func=lambda a, b: a + b):\n\t\t\"\"\"initialize the segment tree with data\"\"\"\n\t\t\"\"\" initial default value for each node \"\"\"\n\t\t\"\"\" func which you want to apply to range \"\"\"\n\t\tself._default = default\n\t\tself._func = func\n\t\tself._len = len(data)\n\t\tself._size = _size = 1 << (self._len - 1).bit_length()\n \n\t\tself.data = [default] * (2 * _size)\n\t\tself.data[_size:_size + self._len] = data\n\t\tfor i in reversed(range(_size)):\n\t\t\tself.data[i] = func(self.data[2*i], self.data[2*i + 1])\n \n\tdef __delitem__(self, idx):\n\t\t\"\"\" delete item set item value to its default \"\"\"\n\t\tself[idx] = self._default\n \n\tdef __getitem__(self, idx):\n\t\t\"\"\" geting item by inx \"\"\"\n\t\treturn self.data[idx + self._size]\n \n\tdef __setitem__(self, idx, value):\n\t\t\"\"\" changing seting value to given index\"\"\"\n\t\t\"\"\" apply function to range \"\"\"\n\t\tidx += self._size\n\t\tself.data[idx] = value\n\t\tidx >>= 1\n\t\twhile idx:\n\t\t\tself.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])\n\t\t\tidx >>= 1\n \n\tdef __len__(self):\n\t\treturn self._len\n \n\tdef query(self, start, stop):\n\t\t\"\"\"func of data[start, stop)\"\"\"\n\t\tstart += self._size\n\t\tstop += self._size\n \n\t\tres_left = res_right = self._default\n\t\twhile start < stop:\n\t\t\tif start & 1:\n\t\t\t\tres_left = self._func(res_left, self.data[start])\n\t\t\t\tstart += 1\n\t\t\tif stop & 1:\n\t\t\t\tstop -= 1\n\t\t\t\tres_right = self._func(self.data[stop], res_right)\n\t\t\tstart >>= 1\n\t\t\tstop >>= 1\n \n\t\treturn self._func(res_left, res_right)\n \n\tdef __repr__(self):\n\t\treturn \"SegmentTree({0})\".format(self.data)\n\n#####################################################################\nclass BinaryIndexTree(object):\n\t\"\"\" use one indexing \"\"\"\n\tdef __init__(self, nums):\n\t\tn = len(nums)\n\t\tself._len = len(nums)\n\t\tself.nums = [0 for _ in range(n+1)]\n\t\tself.N = [0 for _ in range(n+1)]\n\t\tfor i, v in enumerate(nums):\n\t\t\tself.__setitem__(i+1, v)\n\n\tdef _lowbit(self, a):\n\t\treturn a & -a\n\n\tdef  __setitem__(self, i, val):\n\t\tdiff = val - self.nums[i]\n\t\tself.nums[i] = val\n\t\twhile i < len(self.N):\n\t\t\tself.N[i] += diff\n\t\t\ti += self._lowbit(i)\n\n\tdef __getitem__(self, i):\n\t\t# return sum up 0 to i\n\t\tret = 0\n\t\twhile i > 0:\n\t\t\tret += self.N[i]\n\t\t\ti -= self._lowbit(i)\n\n\t\treturn ret\n\n\n#######################################################################\n\ndef integer_list():\n\treturn list(map(int, input().split()))\n\ndef pprint(matrix):\n\tfor i in range(len(matrix)):\n\t\tprint(*matrix[i])\n\n\n#####################################################\n#test case section \n\"\"\"  \n0 < k < n\nadd x to k disti ele\n x> = 0 \n\nadd x --> 0\nadd x --> 1\n\n\"\"\"       \n#############################################################\n# for manipulating 0 for runing to your system 1 for online \n\ndef solve(lst, k, n):\n\n\n\tres = 0\n\tfor i in range(k):\n\t\tres += lst[i]\n\n\n\tcurr_sum = res \n\tfor i in range(k, n):\n\t\tcurr_sum += lst[i] - lst[i-k]\n\t\tres = max(res, curr_sum)\n\treturn res\n\t\n\nMOD = 10**9+7\n\nONLINE_JUDGE = 1\n\n\ndef main():\n\tt = int(input())\n\t# t = 1\n\tfor _ in range(t):\n\t\tn, x = integer_list()\n\t\tlst = integer_list()\n\t\t\n\t\ttrack = [0]\n\t\tmax_sum = 0\n\t\tmax_k = 0\n\t\tfor k in range(1,n+1):\n\t\t\tx1 = solve(lst, k, n)\n\t\t\ttrack.append(x1)\n\t\n\n\t\ttrack[0] = max(lst)\n\t\tans = [0]*(n+1)\n\t\tfor k in range(n+1):\n\t\t\ttemp = 0\n\t\t\tfor i in range(n+1):\n\t\t\t\ttemp = max(temp, track[i] + min(k, i)*x)\n\t\t\tans[k] = temp\n\t\t\n\t\t\n\t\t\n\t\t# print(track, max_sum)\n\t\tprint(*ans)\n\t\n\t\t\n\n\n###############################################\n\nif ONLINE_JUDGE:\n\tinput = lambda : stdin.buffer.readline().decode().strip()\nelse:\n\tstdin = open(\"testcase.txt\")\n\tinput = lambda : stdin.readline().strip()\n\t\n\nmain()\t\t\n\t\n\n\n\n",
    "prob_desc_created_at": "1645540500",
    "tags": [
        "brute force",
        "dp",
        "greedy",
        "implementation"
    ],
    "hidden_unit_tests": ""
}
{
    "prob_desc_time_limit": "3 seconds",
    "prob_desc_sample_outputs": "[\"-1\\n-1\\n3\\n3\\n5\"]",
    "src_uid": "8063c96cf62727f1b98e476e43679da2",
    "prob_desc_notes": "Note$$$6$$$ is a $$$3$$$-good number since it can be expressed as a sum of $$$3$$$ numbers which give different remainders when divided by $$$3$$$: $$$6 = 1 + 2 + 3$$$.$$$15$$$ is also a $$$3$$$-good number since $$$15 = 1 + 5 + 9$$$ and $$$1, 5, 9$$$ give different remainders when divided by $$$3$$$.$$$20$$$ is a $$$5$$$-good number since $$$20 = 2 + 3 + 4 + 5 + 6$$$ and $$$2,3,4,5,6$$$ give different remainders when divided by $$$5$$$.",
    "prob_desc_description": "We say that a positive integer $$$n$$$ is $$$k$$$-good for some positive integer $$$k$$$ if $$$n$$$ can be expressed as a sum of $$$k$$$ positive integers which give $$$k$$$ distinct remainders when divided by $$$k$$$.Given a positive integer $$$n$$$, find some $$$k \\geq 2$$$ so that $$$n$$$ is $$$k$$$-good or tell that such a $$$k$$$ does not exist.",
    "prob_desc_output_spec": "For each test case, print a line with a value of $$$k$$$ such that $$$n$$$ is $$$k$$$-good ($$$k \\geq 2$$$), or $$$-1$$$ if $$$n$$$ is not $$$k$$$-good for any $$$k$$$. If there are multiple valid values of $$$k$$$, you can print any of them.",
    "prob_desc_input_spec": "The input consists of multiple test cases. The first line contains a single integer $$$t$$$ ($$$1 \\leq t \\leq 10^5$$$) â€” the number of test cases. Each test case consists of one line with an integer $$$n$$$ ($$$2 \\leq n \\leq 10^{18}$$$).",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3",
    "lang_cluster": "Python",
    "difficulty": 1900,
    "file_name": "train_091.jsonl",
    "code_uid": "c4bcb2446abe50aaf51b5186a7d352ec",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"5\\n2\\n4\\n6\\n15\\n20\"]",
    "exec_outcome": "PASSED",
    "source_code": "import array\r\nimport bisect\r\nimport heapq\r\nimport json\r\nimport math\r\nimport collections\r\nimport sys\r\nimport copy\r\nfrom functools import reduce\r\nimport decimal\r\nfrom io import BytesIO, IOBase\r\nimport os\r\nimport itertools\r\nimport functools\r\nfrom types import GeneratorType\r\nimport fractions\r\nfrom typing import Tuple, List, Union\r\n\r\n# sys.setrecursionlimit(10 ** 9)\r\ndecimal.getcontext().rounding = decimal.ROUND_HALF_UP\r\n\r\ngraphDict = collections.defaultdict\r\n\r\nqueue = collections.deque\r\n\r\n\r\n################## pypy deep recursion handling ##############\r\n# Author = @pajenegod\r\ndef bootstrap(f, stack=[]):\r\n    def wrappedfunc(*args, **kwargs):\r\n        to = f(*args, **kwargs)\r\n        if stack:\r\n            return to\r\n        else:\r\n            while True:\r\n                if type(to) is GeneratorType:\r\n                    stack.append(to)\r\n                    to = next(to)\r\n                else:\r\n                    stack.pop()\r\n                    if not stack:\r\n                        return to\r\n                    to = stack[-1].send(to)\r\n\r\n    return wrappedfunc\r\n\r\n\r\n################## Graphs ###################\r\nclass Graphs:\r\n    def __init__(self):\r\n        self.graph = graphDict(list)\r\n\r\n    def add_edge(self, u, v, w, z):\r\n        self.graph[u].append([v, w, z])\r\n        self.graph[v].append([u, z, w])\r\n\r\n    def dfs_utility(self, nodes, visited_nodes, colors, parity, level):\r\n        global count\r\n        if nodes == 1:\r\n            colors[nodes] = -1\r\n        else:\r\n            if len(self.graph[nodes]) == 1 and parity % 2 == 0:\r\n                if q == 1:\r\n                    colors[nodes] = 1\r\n                else:\r\n                    colors[nodes] = -1\r\n                    count += 1\r\n            else:\r\n                if parity % 2 == 0:\r\n                    colors[nodes] = -1\r\n                else:\r\n                    colors[nodes] = 1\r\n        visited_nodes.add(nodes)\r\n        for neighbour in self.graph[nodes]:\r\n            new_level = level + 1\r\n            if neighbour not in visited_nodes:\r\n                self.dfs_utility(neighbour, visited_nodes, colors, level - 1, new_level)\r\n\r\n    def dfs(self, node):\r\n        Visited = set()\r\n        color = collections.defaultdict()\r\n        self.dfs_utility(node, Visited, color, 0, 0)\r\n        return color\r\n\r\n    def bfs(self, node, f_node):\r\n        count = float(\"inf\")\r\n        visited = set()\r\n        level = 0\r\n        if node not in visited:\r\n            queue.append([node, level])\r\n            visited.add(node)\r\n        flag = 0\r\n        while queue:\r\n            parent = queue.popleft()\r\n            if parent[0] == f_node:\r\n                flag = 1\r\n                count = min(count, parent[1])\r\n            level = parent[1] + 1\r\n            for item in self.graph[parent[0]]:\r\n                if item not in visited:\r\n                    queue.append([item, level])\r\n                    visited.add(item)\r\n        return count if flag else -1\r\n        return False\r\n\r\n\r\n################### Tree Implementaion ##############\r\nclass Tree:\r\n    def __init__(self, data):\r\n        self.data = data\r\n        self.left = None\r\n        self.right = None\r\n\r\n\r\ndef inorder(node, lis):\r\n    if node:\r\n        inorder(node.left, lis)\r\n        lis.append(node.data)\r\n        inorder(node.right, lis)\r\n    return lis\r\n\r\n\r\ndef leaf_node_sum(root):\r\n    if root is None:\r\n        return 0\r\n    if root.left is None and root.right is None:\r\n        return root.data\r\n    return leaf_node_sum(root.left) + leaf_node_sum(root.right)\r\n\r\n\r\ndef hight(root):\r\n    if root is None:\r\n        return -1\r\n    if root.left is None and root.right is None:\r\n        return 0\r\n    return max(hight(root.left), hight(root.right)) + 1\r\n\r\n\r\n################## Union Find #######################\r\nclass UnionFind():\r\n    parents = []\r\n    sizes = []\r\n    count = 0\r\n\r\n    def __init__(self, n):\r\n        self.count = n\r\n        self.parents = [i for i in range(n)]\r\n        self.sizes = [1 for i in range(n)]\r\n\r\n    def find(self, i):\r\n        if self.parents[i] == i:\r\n            return i\r\n        else:\r\n            self.parents[i] = self.find(self.parents[i])\r\n            return self.parents[i]\r\n\r\n    def unite(self, i, j):\r\n        root_i = self.find(i)\r\n        root_j = self.find(j)\r\n        if root_i == root_j:\r\n            return\r\n        elif root_i < root_j:\r\n            self.parents[root_j] = root_i\r\n            self.sizes[root_i] += self.sizes[root_j]\r\n        else:\r\n            self.parents[root_i] = root_j\r\n            self.sizes[root_j] += self.sizes[root_i]\r\n\r\n    def same(self, i, j):\r\n        return self.find(i) == self.find(j)\r\n\r\n    def size(self, i):\r\n        return self.sizes[self.find(i)]\r\n\r\n    def group_count(self):\r\n        return len(set(self.find(i) for i in range(self.count)))\r\n\r\n    def answer(self, extra, p, q):\r\n        dic = collections.Counter()\r\n        for q in range(n):\r\n            dic[self.find(q)] = self.size(q)\r\n        hq = list(dic.values())\r\n        heapq._heapify_max(hq)\r\n        ans = -1\r\n        for z in range(extra + 1):\r\n            if hq:\r\n                ans += heapq._heappop_max(hq)\r\n            else:\r\n                break\r\n        return ans\r\n\r\n\r\n#################################################\r\n\r\ndef rounding(n):\r\n    return int(decimal.Decimal(f'{n}').to_integral_value())\r\n\r\n\r\ndef factors(n):\r\n    return set(reduce(list.__add__,\r\n                      ([i, n // i] for i in range(1, int(n ** 0.5) + 1) if n % i == 0), [1]))\r\n\r\n\r\ndef p_sum(array):\r\n    return list(itertools.accumulate(array))\r\n\r\n\r\ndef base_change(nn, bb):\r\n    if nn == 0:\r\n        return [0]\r\n    digits = []\r\n    while nn:\r\n        digits.append(int(nn % bb))\r\n        nn //= bb\r\n    return digits[::-1]\r\n\r\n\r\ndef diophantine(a: int, b: int, c: int):\r\n    d, x, y = extended_gcd(a, b)\r\n    r = c // d\r\n    return r * x, r * y\r\n\r\n\r\n@bootstrap\r\ndef extended_gcd(a: int, b: int):\r\n    if b == 0:\r\n        d, x, y = a, 1, 0\r\n    else:\r\n        (d, p, q) = yield extended_gcd(b, a % b)\r\n        x = q\r\n        y = p - q * (a // b)\r\n\r\n    yield d, x, y\r\n\r\n\r\n######################################################################################\r\n\r\n'''\r\nKnowledge and awareness are vague, and perhaps better called illusions.\r\nEveryone lives within their own subjective interpretation.\r\n                                                            ~Uchiha Itachi\r\n'''\r\n\r\n################################ <fast I/O> ###########################################\r\nBUFSIZE = 8192\r\n\r\n\r\nclass FastIO(IOBase):\r\n    newlines = 0\r\n\r\n    def __init__(self, file):\r\n        self._fd = file.fileno()\r\n        self.buffer = BytesIO()\r\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\r\n        self.write = self.buffer.write if self.writable else None\r\n\r\n    def read(self):\r\n        while True:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            if not b:\r\n                break\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines = 0\r\n        return self.buffer.read()\r\n\r\n    def readline(self, **kwargs):\r\n        while self.newlines == 0:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            self.newlines = b.count(b\"\\n\") + (not b)\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines -= 1\r\n        return self.buffer.readline()\r\n\r\n    def flush(self):\r\n        if self.writable:\r\n            os.write(self._fd, self.buffer.getvalue())\r\n            self.buffer.truncate(0), self.buffer.seek(0)\r\n\r\n\r\nclass IOWrapper(IOBase):\r\n    def __init__(self, file):\r\n        self.buffer = FastIO(file)\r\n        self.flush = self.buffer.flush\r\n        self.writable = self.buffer.writable\r\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\r\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\r\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\r\n\r\n\r\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\r\n\r\n\r\n#############################################<I/O Region >##############################################\r\n\r\n\r\ndef inp():\r\n    return sys.stdin.readline().strip()\r\n\r\n\r\ndef map_inp(v_type):\r\n    return map(v_type, inp().split())\r\n\r\n\r\ndef list_inp(v_type):\r\n    return list(map_inp(v_type))\r\n\r\n\r\ndef interactive():\r\n    return sys.stdout.flush()\r\n\r\n\r\n######################################## Solution ####################################\r\n\r\n\r\ndef primes_sieve1(limit):\r\n    limitn = limit + 1\r\n    primes = dict()\r\n    for i in range(2, limitn): primes[i] = True\r\n\r\n    for i in primes:\r\n        factors = range(i, limitn, i)\r\n        for f in factors[1:]:\r\n            primes[f] = False\r\n    return [i for i in primes if primes[i] == True]\r\n\r\n\r\ndef c_sum(x):\r\n    return (x * (x + 1)) // 2\r\ndef ans(a):\r\n    print(a)\r\n    return\r\n\r\nfor _ in range(int(inp())):\r\n    n = int(inp())\r\n    if n <= 2:\r\n        ans(-1)\r\n        continue\r\n    if n % 2:\r\n        ans(2)\r\n        continue\r\n    if n % 3 == 0:\r\n        ans(3)\r\n        continue\r\n    if n % 4 == 2:\r\n        ans(4)\r\n        continue\r\n    m = n\r\n    while m % 2 == 0:\r\n        m //= 2\r\n    if m == 1:\r\n        ans(-1)\r\n        continue\r\n    for k in (m, n // m * 2):\r\n        a = n - k * (k + 1) // 2\r\n        if a >= 0 and a % k == 0:\r\n            ans(k)\r\n            break\r\n",
    "prob_desc_created_at": "1648132500",
    "tags": [
        "constructive algorithms",
        "math",
        "number theory"
    ],
    "hidden_unit_tests": ""
}
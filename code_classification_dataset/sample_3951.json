{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"3\\n2\\n1\"]",
    "src_uid": "878c2e57a396187ccef51d0f941386cf",
    "prob_desc_notes": "NoteIn the first test case the division may be as follows:  $$$[18, 6]$$$  $$$[2, 4]$$$  $$$[1]$$$ ",
    "prob_desc_description": "This is the easy version of the problem. The only difference is that in this version $$$k = 0$$$.There is an array $$$a_1, a_2, \\ldots, a_n$$$ of $$$n$$$ positive integers. You should divide it into a minimal number of continuous segments, such that in each segment there are no two numbers (on different positions), whose product is a perfect square.Moreover, it is allowed to do at most $$$k$$$ such operations before the division: choose a number in the array and change its value to any positive integer. But in this version $$$k = 0$$$, so it is not important.What is the minimum number of continuous segments you should use if you will make changes optimally?",
    "prob_desc_output_spec": "For each test case print a single integer  — the answer to the problem.",
    "prob_desc_input_spec": "The first line contains a single integer $$$t$$$ $$$(1 \\le t \\le 1000)$$$  — the number of test cases. The first line of each test case contains two integers $$$n$$$, $$$k$$$ ($$$1 \\le n \\le 2 \\cdot 10^5$$$, $$$k = 0$$$). The second line of each test case contains $$$n$$$ integers $$$a_1, a_2, \\ldots, a_n$$$ ($$$1 \\le a_i \\le 10^7$$$). It's guaranteed that the sum of $$$n$$$ over all test cases does not exceed $$$2 \\cdot 10^5$$$.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3-64",
    "lang_cluster": "Python",
    "difficulty": 1700,
    "file_name": "train_087.jsonl",
    "code_uid": "4ddb977bd01523266d7c7398aeb33a88",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"3\\n\\n5 0\\n\\n18 6 2 4 1\\n\\n5 0\\n\\n6 8 1 24 8\\n\\n1 0\\n\\n1\"]",
    "exec_outcome": "PASSED",
    "source_code": "import os\r\nimport sys\r\nfrom collections import defaultdict,deque\r\nfrom io import BytesIO, IOBase\r\n# MOD = 998244353\r\n# nmax = (2*(10**5))+2\r\n \r\n# fact = [1] * (nmax+1)\r\n# for i in range(2, nmax+1):\r\n#     fact[i] = fact[i-1] * i % MOD\r\n    \r\n# inv = [1] * (nmax+1)\r\n# for i in range(2, nmax+1):\r\n#     inv[i] = pow(fact[i], MOD-2, MOD)\r\n \r\n \r\n# def C(n, m):\r\n#     return fact[n] * inv[m] % MOD * inv[n-m] % MOD if 0 <= m <= n else 0\r\nfactor_dict = {1: 1}\r\nprimes = []\r\n \r\nfor p in range(2, 10**7):\r\n    if p*p > 10**7:\r\n        break\r\n    prime = True\r\n    for i in range(2, p):\r\n        if i*i > p:\r\n            break\r\n        if p % i==0:\r\n            prime = False\r\n            break\r\n    if prime:\r\n        primes.append(p)\r\n \r\ndef factor(n):\r\n    if n in factor_dict:\r\n        return factor_dict[n]\r\n    n2 = n\r\n    for p in primes:\r\n        if p*p > n:\r\n            break\r\n        while n % (p*p)==0:\r\n            n = n//(p*p)\r\n    factor_dict[n2] = n\r\n    return n\r\n \r\nfor i in range(2, 10**4):\r\n    factor(i)\r\n    \r\nfrom collections import Counter\r\nfrom functools import lru_cache\r\nfrom collections import deque\r\ndef main():\r\n    # import bisect,math\r\n \r\n    # class SortedList():\r\n    #     BUCKET_RATIO = 50\r\n    #     REBUILD_RATIO = 170\r\n    \r\n    #     def __init__(self,buckets):\r\n    #         buckets = list(buckets)\r\n    #         buckets = sorted(buckets)\r\n    #         self._build(buckets)\r\n    \r\n    #     def __iter__(self):\r\n    #         for i in self.buckets:\r\n    #             for j in i: yield j\r\n    \r\n    #     def __reversed__(self):\r\n    #         for i in reversed(self.buckets):\r\n    #             for j in reversed(i): yield j\r\n    \r\n    #     def __len__(self):\r\n    #         return self.size\r\n    \r\n    #     def __contains__(self,x):\r\n    #         if self.size == 0: return False\r\n    #         bucket = self._find_bucket(x)\r\n    #         i = bisect.bisect_left(bucket,x)\r\n    #         return i != len(bucket) and bucket[i] == x\r\n    \r\n    #     def __getitem__(self,x):\r\n    #         if x < 0: x += self.size\r\n    #         if x < 0: raise IndexError\r\n    #         for i in self.buckets:\r\n    #             if x < len(i): return i[x]\r\n    #             x -= len(i)\r\n    #         raise IndexError\r\n    \r\n    #     def _build(self,buckets=None):\r\n    #         if buckets is None: buckets = list(self)\r\n    #         self.size = len(buckets)\r\n    #         bucket_size = int(math.ceil(math.sqrt(self.size/self.BUCKET_RATIO)))\r\n    #         tmp = []\r\n    #         for i in range(bucket_size):\r\n    #             t = buckets[(self.size*i)//bucket_size:(self.size*(i+1))//bucket_size]\r\n    #             tmp.append(t)\r\n    #         self.buckets = tmp\r\n    \r\n    #     def _find_bucket(self,x):\r\n    #         for i in self.buckets:\r\n    #             if x <= i[-1]:\r\n    #                 return i\r\n    #         return i\r\n    \r\n    #     def add(self,x):\r\n    #         # O(√N)\r\n    #         if self.size == 0:\r\n    #             self.buckets = [[x]]\r\n    #             self.size = 1\r\n    #             return True\r\n    \r\n    #         bucket = self._find_bucket(x)\r\n    #         bisect.insort(bucket,x)\r\n    #         self.size += 1\r\n    #         if len(bucket) > len(self.buckets) * self.REBUILD_RATIO:\r\n    #             self._build()\r\n    #         return True\r\n    \r\n    #     def remove(self,x):\r\n    #         # O(√N)\r\n    #         if self.size == 0: return False\r\n    #         bucket = self._find_bucket(x)\r\n    #         i = bisect.bisect_left(bucket,x)\r\n    #         if i == len(bucket) or bucket[i] != x: return False\r\n    #         bucket.pop(i)\r\n    #         self.size -= 1\r\n    #         if len(bucket) == 0: self._build()\r\n    #         return True\r\n    \r\n    #     def lt(self,x):\r\n    #         # less than < x\r\n    #         for i in reversed(self.buckets):\r\n    #             if i[0] < x:\r\n    #                 return i[bisect.bisect_left(i,x) - 1]\r\n    \r\n    #     def le(self,x):\r\n    #         # less than or equal to <= x\r\n    #         for i in reversed(self.buckets):\r\n    #             if i[0] <= x:\r\n    #                 return i[bisect.bisect_right(i,x) - 1]\r\n    \r\n    #     def gt(self,x):\r\n    #         # greater than > x\r\n    #         for i in self.buckets:\r\n    #             if i[-1] > x:\r\n    #                 return i[bisect.bisect_right(i,x)]\r\n    \r\n    #     def ge(self,x):\r\n    #         # greater than or equal to >= x\r\n    #         for i in self.buckets:\r\n    #             if i[-1] >= x:\r\n    #                 return i[bisect.bisect_left(i,x)]\r\n    #     def index(self,x):\r\n    #         # the number of elements < x\r\n    #         ans = 0\r\n    #         for i in self.buckets:\r\n    #             if i[-1] >= x:\r\n    #                 return ans + bisect.bisect_left(i,x)\r\n    #             ans += len(i)\r\n    #         return ans\r\n    \r\n    #     def index_right(self,x):\r\n    #         # the number of elements < x\r\n    #         ans = 0\r\n    #         for i in self.buckets:\r\n    #             if i[-1] > x:\r\n    #                 return ans + bisect.bisect_right(i,x)\r\n    #             ans += len(i)\r\n    #         return ans\r\n    from math import sqrt\r\n    for _ in range(int(input())):\r\n        n,k=map(int,input().split())\r\n        arr=list(map(int,input().split()))\r\n        seen=set([])\r\n        ans=0\r\n        for el in arr:\r\n            if factor(el) in seen:\r\n                ans+=1\r\n                seen=set([])\r\n                seen.add(factor(el))\r\n            else :\r\n                seen.add(factor(el))\r\n        if seen!=set([]):\r\n            ans+=1\r\n        print(ans)\r\n                            \r\n \r\n#----------------------------------------------------------------------------------------\r\n \r\n \r\n# region fastio\r\n \r\nBUFSIZE = 8192\r\n \r\n \r\nclass FastIO(IOBase):\r\n    newlines = 0\r\n \r\n    def __init__(self, file):\r\n        self._fd = file.fileno()\r\n        self.buffer = BytesIO()\r\n        self.writable = 'x' in file.mode or 'r' not in file.mode\r\n        self.write = self.buffer.write if self.writable else None\r\n \r\n    def read(self):\r\n        while True:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            if not b:\r\n                break\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines = 0\r\n        return self.buffer.read()\r\n \r\n    def readline(self):\r\n        while self.newlines == 0:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            self.newlines = b.count(b'\\n') + (not b)\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines -= 1\r\n        return self.buffer.readline()\r\n \r\n    def flush(self):\r\n        if self.writable:\r\n            os.write(self._fd, self.buffer.getvalue())\r\n            self.buffer.truncate(0), self.buffer.seek(0)\r\n \r\n \r\nclass IOWrapper(IOBase):\r\n    def __init__(self, file):\r\n        self.buffer = FastIO(file)\r\n        self.flush = self.buffer.flush\r\n        self.writable = self.buffer.writable\r\n        self.write = lambda s: self.buffer.write(s.encode('ascii'))\r\n        self.read = lambda: self.buffer.read().decode('ascii')\r\n        self.readline = lambda: self.buffer.readline().decode('ascii')\r\n \r\n \r\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\r\ninput = lambda: sys.stdin.readline().rstrip('\\r\\n')\r\n \r\n \r\n# endregion\r\n \r\nif __name__ == '__main__':\r\n    main()",
    "prob_desc_created_at": "1615991700",
    "tags": [
        "data structures",
        "dp",
        "greedy",
        "math",
        "number theory",
        "two pointers"
    ],
    "hidden_unit_tests": ""
}
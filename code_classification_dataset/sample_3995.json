{
    "prob_desc_time_limit": "2 секунды",
    "prob_desc_sample_outputs": "[\"orange\\ngreen\\ngreen\\nindigo\\nviolet\\nblue\\nindigo\", \"red\\nblue\\nblue\\nblue\\nblue\\nblue\\nblue\\nyellow\\nblue\"]",
    "src_uid": "bac4b0c78bd147031ae99ddece6ca84e",
    "prob_desc_notes": null,
    "prob_desc_description": "Немногие знают, что сотрудники ВКонтакте могут менять цвет подсветки в куполе знаменитого Дома Зингера, где расположена штаб-квартира ВКонтакте. Для этого нужно всего лишь отправить сообщение с цветом в специальный чат «Зингер | color», а бот его распознает и сменит подсветку. При этом на время городских мероприятий смена цвета блокируется.Формально, бот обрабатывает три типа сообщений:   lock: заблокировать изменение цвета. Если оно и так заблокировано на данный момент, сообщение игнорируется.  unlock: разблокировать изменение цвета. Если оно и так разблокировано на данный момент, сообщение игнорируется.  red / orange / yellow / green / blue / indigo / violet: изменить цвет купола на заданный, если изменение цвета на данный момент не заблокировано. Вам дана история сообщений, полученных ботом, в хронологическом порядке. Считайте, что перед получением первого сообщения купол подсвечивается голубым (blue), а изменение цвета не заблокировано.В качестве эксперимента было решено поддержать в боте эффективную обработку редактирования сообщений. Вам дана последовательность пар вида $$$(i, msg)$$$, означающих, что $$$i$$$-е в хронологическом порядке сообщение было отредактировано и теперь имеет вид $$$msg$$$. Обратите внимание, что редактироваться может любое сообщение, и при редактировании сообщения бот должен обработать всю историю сообщений заново (в частности, перед обработкой первого сообщения цвет купола голубой, а изменение цвета не заблокировано).Определите, какой цвет будет у купола Дома Зингера до первой операции редактирования, а также после каждой операции редактирования.",
    "prob_desc_output_spec": "Выведите $$$t+1$$$ строку: цвет купола до первой операции редактирования, а также после каждой операции редактирования в хронологическом порядке.",
    "prob_desc_input_spec": "В первой строке задано одно целое число $$$n$$$ ($$$1 \\le n \\le 10^5$$$) — число сообщений, полученных ботом. В следующих $$$n$$$ строках заданы сообщения, полученные ботом, в хронологическом порядке, по одному сообщению в строке. Каждое сообщение — строка из следующего набора: lock, unlock, red, orange, yellow, green, blue, indigo, violet. Сообщения пронумерованы от $$$1$$$ до $$$n$$$. В следующей строке задано одно целое число $$$t$$$ ($$$1 \\le t \\le 10^5$$$) — число операций редактирования сообщений. В следующих $$$t$$$ строках заданы операции редактирования в хронологическом порядке, по одной в строке. Каждая операция — пара из номера сообщения $$$i$$$ ($$$1 \\le i \\le n$$$) и его нового содержимого $$$msg$$$, также принадлежащего набору lock, unlock, red, orange, yellow, green, blue, indigo, violet.",
    "prob_desc_output_to": "стандартный вывод",
    "prob_desc_input_from": "стандартный ввод",
    "lang": "PyPy 3-64",
    "lang_cluster": "Python",
    "difficulty": -1,
    "file_name": "train_088.jsonl",
    "code_uid": "597d8e91d6e52ed7791067a11bfea83e",
    "prob_desc_memory_limit": "512 мегабайт",
    "prob_desc_sample_inputs": "[\"7\\nred\\nviolet\\nunlock\\nred\\norange\\nlock\\nindigo\\n6\\n5 green\\n6 lock\\n6 yellow\\n4 lock\\n1 lock\\n5 unlock\", \"1\\nred\\n8\\n1 lock\\n1 unlock\\n1 blue\\n1 unlock\\n1 unlock\\n1 lock\\n1 yellow\\n1 lock\"]",
    "exec_outcome": "PASSED",
    "source_code": "from heapq import heapify, heappop, heappush\nfrom sys import stdin, stdout\nfrom typing import List, TextIO\n\n\nclass MinSegmentTree:\n    def __init__(self, vals: List[int], max_val: int):\n        n = len(vals)\n        self.bits = (n - 1).bit_length()\n        self.width = 2 ** self.bits\n        self.nodes = vals.copy()\n        self.nodes += [max_val] * (self.width - n)\n        layer_shift = 0\n        layer_width = self.width\n        for _ in range(self.bits):\n            self.nodes.extend(\n                min(\n                    self.nodes[layer_shift + i * 2], self.nodes[layer_shift + i * 2 + 1]\n                )\n                for i in range(layer_width >> 1)\n            )\n            layer_shift += layer_width\n            layer_width >>= 1\n\n    def __repr__(self) -> str:\n        return repr(self.nodes[: self.width])\n\n    def change(self, i: int, val: int):\n        self.nodes[i] = val\n        layer_shift = 0\n        layer_width = self.width\n        for _ in range(self.bits):\n            i >>= 1\n            self.nodes[layer_shift + layer_width + i] = min(\n                self.nodes[layer_shift + i * 2], self.nodes[layer_shift + i * 2 + 1]\n            )\n            layer_shift += layer_width\n            layer_width >>= 1\n\n    def min(self, a: int, b: int, default: int):\n        m = default\n        layer_shift = 0\n        layer_width = self.width\n        while a < b:\n            if a % 2:\n                m = min(self.nodes[layer_shift + a], m)\n            if b % 2:\n                m = min(self.nodes[layer_shift + b - 1], m)\n            a = (a + 1) >> 1\n            b >>= 1\n            layer_shift += layer_width\n            layer_width >>= 1\n        return m\n\n\nclass MaxSegmentTree:\n    def __init__(self, vals: List[int], min_val: int):\n        self.min_tree = MinSegmentTree([-v for v in vals], -min_val)\n\n    def __repr__(self) -> str:\n        return repr(self.min_tree)\n\n    def change(self, i: int, val: int):\n        self.min_tree.change(i, -val)\n\n    def max(self, a: int, b: int, default: int):\n        return -self.min_tree.min(a, b, default)\n\n\ndef get_color(\n    cmds: List[str], unlocks: List[int], locks: MinSegmentTree, colors: MaxSegmentTree\n):\n    n = len(cmds)\n    return cmds[colors.max(-unlocks[0] + 1, locks.min(-unlocks[0] + 2, n, n), 1)]\n\n\ndef solve(fin: TextIO, fout: TextIO):\n    n = int(fin.readline())\n    cmds = [\"unlock\", \"blue\"] + [fin.readline().rstrip() for _ in range(n)] + [\"lock\"]\n    n += 3\n    unlocks = [\n        -i\n        for i, (cmd, next_cmd) in enumerate(zip(cmds, cmds[1:]))\n        if cmd == \"unlock\" and next_cmd not in [\"lock\", \"unlock\"]\n    ]\n    heapify(unlocks)\n    locks = MinSegmentTree(\n        [i if cmd == \"lock\" else n - 1 for i, cmd in enumerate(cmds)], n - 1\n    )\n    colors = MaxSegmentTree(\n        [i if cmd not in [\"lock\", \"unlock\"] else 1 for i, cmd in enumerate(cmds)], 1\n    )\n    color = get_color(cmds, unlocks, locks, colors)\n    fout.write(f\"{color}\\n\")\n\n    fin.readline()\n    for chcmd in fin:\n        pos, cmd = chcmd.split()\n        i = int(pos) + 1\n        if cmds[i] != cmd:\n            if cmd == \"lock\":\n                locks.change(i, i)\n                if cmds[i] not in [\"lock\", \"unlock\"]:\n                    colors.change(i, 1)\n            elif cmd == \"unlock\":\n                if cmds[i] == \"lock\":\n                    locks.change(i, n - 1)\n                if cmds[i] not in [\"lock\", \"unlock\"]:\n                    colors.change(i, 1)\n                if cmds[i + 1] not in [\"lock\", \"unlock\"]:\n                    heappush(unlocks, -i)\n            else:\n                if cmds[i] == \"lock\":\n                    locks.change(i, n - 1)\n                if cmds[i] in [\"lock\", \"unlock\"]:\n                    colors.change(i, i)\n                if cmds[i - 1] == \"unlock\":\n                    heappush(unlocks, -(i - 1))\n            cmds[i] = cmd\n            last_unlock = -unlocks[0]\n            while cmds[last_unlock] != \"unlock\" or cmds[last_unlock + 1] in [\n                \"lock\",\n                \"unlock\",\n            ]:\n                heappop(unlocks)\n                last_unlock = -unlocks[0]\n            color = get_color(cmds, unlocks, locks, colors)\n        fout.write(f\"{color}\\n\")\n\n\nif __name__ == \"__main__\":\n    solve(stdin, stdout)\n",
    "prob_desc_created_at": "1621846800",
    "tags": [
        "*special",
        "*special"
    ],
    "hidden_unit_tests": ""
}
{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"3 4\\n1 1 1 1\", \"2 3\\n1 1 1\", \"2 2\\n1 1\", \"6 11\\n1 1 1 1 1 1 1 3 1\"]",
    "src_uid": "dc3848faf577c5a49273020a14b343e1",
    "prob_desc_notes": "NoteThis is the tree for the first test case:    In this case, if you assign a weight of $$$1$$$ to each vertex, then the good vertices (which are painted black) are $$$1$$$, $$$3$$$ and $$$4$$$. It impossible to assign weights so that all vertices are good vertices. The minimum sum of weights in this case is $$$1+1+1+1=4$$$, and it is impossible to have a lower sum because the weights have to be positive integers.This is the tree for the second test case:    In this case, if you assign a weight of $$$1$$$ to each vertex, then the good vertices (which are painted black) are $$$2$$$ and $$$3$$$. It can be proven that this is an optimal assignment.",
    "prob_desc_description": "You are given a tree of $$$n$$$ vertices numbered from $$$1$$$ to $$$n$$$. A tree is a connected undirected graph without cycles. For each $$$i=1,2, \\ldots, n$$$, let $$$w_i$$$ be the weight of the $$$i$$$-th vertex. A vertex is called good if its weight is equal to the sum of the weights of all its neighbors.Initially, the weights of all nodes are unassigned. Assign positive integer weights to each vertex of the tree, such that the number of good vertices in the tree is maximized. If there are multiple ways to do it, you have to find one that minimizes the sum of weights of all vertices in the tree.",
    "prob_desc_output_spec": "In the first line print two integers  — the maximum number of good vertices and the minimum possible sum of weights for that maximum. In the second line print $$$n$$$ integers $$$w_1, w_2, \\ldots, w_n$$$ ($$$1\\le w_i\\le 10^9$$$)  — the corresponding weight assigned to each vertex. It can be proven that there exists an optimal solution satisfying these constraints. If there are multiple optimal solutions, you may print any.",
    "prob_desc_input_spec": "The first line contains one integer $$$n$$$ ($$$2\\le n\\le 2\\cdot 10^5$$$) — the number of vertices in the tree. Then, $$$n−1$$$ lines follow. Each of them contains two integers $$$u$$$ and $$$v$$$ ($$$1\\le u,v\\le n$$$) denoting an edge between vertices $$$u$$$ and $$$v$$$. It is guaranteed that the edges form a tree.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3-64",
    "lang_cluster": "Python",
    "difficulty": 2000,
    "file_name": "train_110.jsonl",
    "code_uid": "2468b1e1f237837269e5f3138f497cb3",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"4\\n1 2\\n2 3\\n2 4\", \"3\\n1 2\\n1 3\", \"2\\n1 2\", \"9\\n3 4\\n7 6\\n2 1\\n8 3\\n5 6\\n1 8\\n8 6\\n9 6\"]",
    "exec_outcome": "PASSED",
    "source_code": "#!/usr/bin/env python3\nimport sys\n# import getpass  # not available on codechef\n# import math, random\n# import functools, itertools, collections, heapq, bisect\nfrom collections import defaultdict\ninput = sys.stdin.readline  # to read input quickly\n\n# available on Google, AtCoder Python3, not available on Codeforces\n# import numpy as np\n# import scipy\n\nMAXINT = sys.maxsize\n\n# if testing locally, print to terminal with a different color\n# OFFLINE_TEST = getpass.getuser() == \"htong\"\nOFFLINE_TEST = False  # codechef does not allow getpass\ndef log(*args):\n    if OFFLINE_TEST:\n        print('\\033[36m', *args, '\\033[0m', file=sys.stderr)\n\ndef read_matrix(rows):\n    return [list(map(int,input().split())) for _ in range(rows)]\n\ndef minus_one_matrix(mrr):\n    return [[x-1 for x in row] for row in mrr]\n\n# ---------------------------- template ends here ----------------------------\n\n\n# https://codeforces.com/blog/entry/80158?locale=en\nfrom types import GeneratorType\ndef bootstrap(f, stack=[]):\n    # usage - please remember to YIELD to call and return\n    '''\n    @bootstrap\n    def recurse(n):\n        if n <= 0:\n            yield 0\n        yield (yield recurse(n-1)) + 2\n\n    res = recurse(10**5)\n    '''\n    def wrappedfunc(*args):\n        if stack:\n            return f(*args)\n        else:\n            to = f(*args)\n            while True:\n                if type(to) is GeneratorType:\n                    stack.append(to)\n                    to = next(to)\n                else:\n                    if stack:\n                        stack.pop()\n                    if not stack:\n                        break\n                    to = stack[-1].send(to)\n            return to\n    return wrappedfunc\n\n\n\nif True:\n    total_vertices = int(input())\n\n    # read line as a string\n    # srr = input().strip()\n\n    # read one line and parse each word as a string\n    # arr = input().split()\n\n    # read one line and parse each word as an integer\n    # a,b,c = list(map(int,input().split()))\n    # arr = list(map(int,input().split()))\n    # arr = minus_one(arr)\n\n    # read multiple rows\n    # arr = read_strings(k)  # and return as a list of str\n    mrr = read_matrix(total_vertices-1)  # and return as a list of list of int\n    mrr = minus_one_matrix(mrr)\n    # if total_vertices == 2:\n    #     return 2,2,[1,1]\n    # your solution here\n\n    # https://courses.grainger.illinois.edu/cs473/sp2011/lectures/09_lec.pdf\n    \n    g = defaultdict(set)\n    for a,b in mrr:\n        g[a].add(b)\n        g[b].add(a)\n        # log(a, b)\n\n    degree = defaultdict(int)\n    for x in range(total_vertices):\n        degree[x] = len(g[x])\n\n    opt = [-1 for _ in range(total_vertices)]\n    opt1_store = [-1 for _ in range(total_vertices)]\n    opt2_store = [-1 for _ in range(total_vertices)]\n\n    start = allstart = 0\n\n    assignment = [0 for _ in range(total_vertices)]\n\n    def dfs(start, g, entry_operation, exit_operation):\n        entered = set([start])\n        exiting = set()\n        stack = [start]\n        prev = {}\n\n        null_pointer = \"NULL\"\n        prev[start] = null_pointer\n\n        while stack:\n            cur = stack[-1]\n\n            if cur not in exiting:\n                for nex in g[cur]:\n                    if nex in entered:\n                        continue\n\n                    entry_operation(prev[cur], cur, nex)\n\n                    entered.add(nex)\n                    stack.append(nex)\n                    prev[nex] = cur\n                exiting.add(cur)\n\n            else:\n                stack.pop()\n                exit_operation(prev[cur], cur)\n\n    def entry_operation(prev, cur, nex):\n        pass\n\n    def exit_operation(prev, cur):\n        opt1 = 1_000_000 - degree[cur] + 1\n        opt2 = 0\n\n        for nex in g[cur]:\n            if nex == prev:\n                continue\n            opt2 += opt[nex]\n            for nex_nex in g[nex]:\n                if nex_nex == cur:\n                    continue\n                opt1 += opt[nex_nex]\n        \n        opt1_store[cur] = opt1\n        opt2_store[cur] = opt2\n        opt[cur] = max(opt1, opt2)\n\n\n    dfs(0, g, entry_operation, exit_operation)\n\n    color = {}\n    color[0] = 1 - int(opt[0] == opt2_store[0])\n\n    def entry_operation(prev, cur, nex):\n        if color[cur] == 1 or opt[nex] == opt2_store[nex]:\n            color[nex] = 0\n        else:\n            color[nex] = 1\n\n    def exit_operation(prev, cur):\n        pass\n\n    dfs(0, g, entry_operation, exit_operation)\n\n    # assert -1 not in assignment\n    # assert -1 not in opt\n    # assert -1 not in opt1_store\n    # assert -1 not in opt2_store\n    log(opt)\n    # log(assignment)\n\n    assignment = [degree[i] if color[i] else 1 for i in range(total_vertices)]\n    a = sum(degree[i] == x for i,x in enumerate(assignment))\n    b = sum(assignment)\n\n\n    print(a,b)\n    print(\" \".join(str(x) for x in assignment))\n\n\n",
    "prob_desc_created_at": "1646408100",
    "tags": [
        "constructive algorithms",
        "dfs and similar",
        "dp",
        "implementation",
        "trees"
    ],
    "hidden_unit_tests": ""
}
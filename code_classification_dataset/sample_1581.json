{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"Yes\\n4 5 16 11 64 44\", \"Yes\\n100 9900\", \"No\"]",
    "src_uid": "d07730b7bbbfa5339ea24162df7a5cab",
    "prob_desc_notes": "NoteIn the first example   $$$x_1=4$$$  $$$x_1+x_2=9$$$  $$$x_1+x_2+x_3=25$$$  $$$x_1+x_2+x_3+x_4=36$$$  $$$x_1+x_2+x_3+x_4+x_5=100$$$  $$$x_1+x_2+x_3+x_4+x_5+x_6=144$$$  All these numbers are perfect squares.In the second example, $$$x_1=100$$$, $$$x_1+x_2=10000$$$. They are all perfect squares. There're other answers possible. For example, $$$x_1=22500$$$ is another answer.In the third example, it is possible to show, that no such sequence exists.",
    "prob_desc_description": "Chouti is working on a strange math problem.There was a sequence of $$$n$$$ positive integers $$$x_1, x_2, \\ldots, x_n$$$, where $$$n$$$ is even. The sequence was very special, namely for every integer $$$t$$$ from $$$1$$$ to $$$n$$$, $$$x_1+x_2+...+x_t$$$ is a square of some integer number (that is, a perfect square).Somehow, the numbers with odd indexes turned to be missing, so he is only aware of numbers on even positions, i.e. $$$x_2, x_4, x_6, \\ldots, x_n$$$. The task for him is to restore the original sequence. Again, it's your turn to help him.The problem setter might make mistakes, so there can be no possible sequence at all. If there are several possible sequences, you can output any.",
    "prob_desc_output_spec": "If there are no possible sequence, print \"No\". Otherwise, print \"Yes\" and then $$$n$$$ positive integers $$$x_1, x_2, \\ldots, x_n$$$ ($$$1 \\le x_i \\le 10^{13}$$$), where $$$x_2, x_4, \\ldots, x_n$$$ should be same as in input data. If there are multiple answers, print any. Note, that the limit for $$$x_i$$$ is larger than for input data. It can be proved that in case there is an answer, there must be a possible sequence satisfying $$$1 \\le x_i \\le 10^{13}$$$.",
    "prob_desc_input_spec": "The first line contains an even number $$$n$$$ ($$$2 \\le n \\le 10^5$$$). The second line contains $$$\\frac{n}{2}$$$ positive integers $$$x_2, x_4, \\ldots, x_n$$$ ($$$1 \\le x_i \\le 2 \\cdot 10^5$$$).",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "Python 3",
    "lang_cluster": "Python",
    "difficulty": 1900,
    "file_name": "train_010.jsonl",
    "code_uid": "295cae8f4b7e32124a2ccab0c71df4fc",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"6\\n5 11 44\", \"2\\n9900\", \"6\\n314 1592 6535\"]",
    "exec_outcome": "PASSED",
    "source_code": "#!/usr/bin/env python\n\"\"\"\nThis file is part of https://github.com/Cheran-Senthil/PyRival.\n\nCopyright 2018 Cheran Senthilkumar all rights reserved,\nCheran Senthilkumar <hello@cheran.io>\nPermission to use, modify, and distribute this software is given under the\nterms of the MIT License.\n\n\"\"\"\nfrom __future__ import division, print_function\n\nimport cmath\nimport itertools\nimport math\nimport operator as op\n# import random\nimport sys\nfrom atexit import register\nfrom bisect import bisect_left, bisect_right\n# from collections import Counter, MutableSequence, defaultdict, deque\n# from copy import deepcopy\n# from decimal import Decimal\n# from difflib import SequenceMatcher\n# from fractions import Fraction\n# from heapq import heappop, heappush\n\nif sys.version_info[0] < 3:\n    # from cPickle import dumps\n    from io import BytesIO as stream\n    # from Queue import PriorityQueue, Queue\nelse:\n    from functools import reduce\n    from io import StringIO as stream\n    from math import gcd\n    # from pickle import dumps\n    # from queue import PriorityQueue, Queue\n\n\nif sys.version_info[0] < 3:\n    class dict(dict):\n        \"\"\"dict() -> new empty dictionary\"\"\"\n        def items(self):\n            \"\"\"D.items() -> a set-like object providing a view on D's items\"\"\"\n            return dict.iteritems(self)\n\n        def keys(self):\n            \"\"\"D.keys() -> a set-like object providing a view on D's keys\"\"\"\n            return dict.iterkeys(self)\n\n        def values(self):\n            \"\"\"D.values() -> an object providing a view on D's values\"\"\"\n            return dict.itervalues(self)\n\n    def gcd(x, y):\n        \"\"\"gcd(x, y) -> int\n        greatest common divisor of x and y\n        \"\"\"\n        while y:\n            x, y = y, x % y\n        return x\n\n    input = raw_input\n    range = xrange\n\n    filter = itertools.ifilter\n    map = itertools.imap\n    zip = itertools.izip\n\n\ndef sync_with_stdio(sync=True):\n    \"\"\"Set whether the standard Python streams are allowed to buffer their I/O.\n\n    Args:\n        sync (bool, optional): The new synchronization setting.\n\n    \"\"\"\n    global input, flush\n\n    if sync:\n        flush = sys.stdout.flush\n    else:\n        sys.stdin = stream(sys.stdin.read())\n        input = lambda: sys.stdin.readline().rstrip('\\r\\n')\n\n        sys.stdout = stream()\n        register(lambda: sys.__stdout__.write(sys.stdout.getvalue()))\n\n\ndef memodict(f):\n    \"\"\" Memoization decorator for a function taking a single argument. \"\"\"\n    class memodict(dict):\n        def __missing__(self, key):\n            ret = self[key] = f(key)\n            return ret\n    return memodict().__getitem__\n\n\n@memodict\ndef all_factors(n):\n    return set(reduce(list.__add__,\n                      ([i, n//i] for i in range(1, int(n**0.5) + 1, 2 if n % 2 else 1) if n % i == 0)))\n\n\ndef main():\n    n = int(input())\n    x = list(map(int, input().split(' ')))\n\n    a, b = 0, 0\n\n    f = all_factors(x[0])\n    for fi in f:\n        if (fi + (x[0] // fi)) % 2 == 0:\n            na = (fi + (x[0] // fi)) // 2\n            nb = fi - na if fi > na else (x[0] // fi) - na\n            if (a == 0) or (b == 0):\n                a, b = na, nb\n            else:\n                if na < a:\n                    a, b = na, nb\n\n    if (a == 0) or (b == 0):\n        print('No')\n        return\n\n    res = [b*b, x[0]]\n    pref_sum = sum(res)\n\n    for i in range(1, n // 2):\n        a, b = 0, 0\n        pref_sum += x[i]\n\n        f = all_factors(x[i])\n        for fi in f:\n            if (fi + (x[i] // fi)) % 2 == 0:\n                na = (fi + (x[i] // fi)) // 2\n                nb = fi - na if fi > na else (x[i] // fi) - na\n                if na*na > pref_sum:\n                    if (a == 0) or (b == 0):\n                        a, b = na, nb\n                    else:\n                        if na < a:\n                            a, b = na, nb\n\n        if (a == 0) or (b == 0):\n            print('No')\n            return\n\n        res.append(a*a - pref_sum)\n        pref_sum += res[-1]\n        res.append(x[i])\n\n    print('Yes')\n    print(*res)\n\n\nif __name__ == '__main__':\n    sync_with_stdio()\n    main()\n",
    "prob_desc_created_at": "1544970900",
    "tags": [
        "greedy",
        "constructive algorithms",
        "number theory",
        "math",
        "binary search"
    ],
    "hidden_unit_tests": ""
}
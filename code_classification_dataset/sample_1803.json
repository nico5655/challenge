{
    "prob_desc_time_limit": "1 second",
    "prob_desc_sample_outputs": "[\"2\\n1\\n1\\n2\"]",
    "src_uid": "c9225c915669e183cbd8c20b848d96e5",
    "prob_desc_notes": "NoteIn the first match no one can make a turn, the only digit left is $$$2$$$, it's even, so Breach wins.In the second match the only digit left is $$$3$$$, it's odd, so Raze wins.In the third match Raze can mark the last digit, after that Breach can only mark $$$0$$$. $$$1$$$ will be the last digit left, it's odd, so Raze wins.In the fourth match no matter how Raze plays, Breach can mark $$$9$$$, and in the end there will be digit $$$0$$$. It's even, so Breach wins.",
    "prob_desc_description": "Everyone knows that agents in Valorant decide, who will play as attackers, and who will play as defenders. To do that Raze and Breach decided to play $$$t$$$ matches of a digit game...In each of $$$t$$$ matches of the digit game, a positive integer is generated. It consists of $$$n$$$ digits. The digits of this integer are numerated from $$$1$$$ to $$$n$$$ from the highest-order digit to the lowest-order digit. After this integer is announced, the match starts.Agents play in turns. Raze starts. In one turn an agent can choose any unmarked digit and mark it. Raze can choose digits on odd positions, but can not choose digits on even positions. Breach can choose digits on even positions, but can not choose digits on odd positions. The match ends, when there is only one unmarked digit left. If the single last digit is odd, then Raze wins, else Breach wins.It can be proved, that before the end of the match (for every initial integer with $$$n$$$ digits) each agent has an ability to make a turn, i.e. there is at least one unmarked digit, that stands on a position of required parity.For each of $$$t$$$ matches find out, which agent wins, if both of them want to win and play optimally.",
    "prob_desc_output_spec": "For each match print $$$1$$$, if Raze wins, and $$$2$$$, if Breach wins.",
    "prob_desc_input_spec": "First line of input contains an integer $$$t$$$ $$$(1 \\le t \\le 100)$$$  — the number of matches. The first line of each match description contains an integer $$$n$$$ $$$(1 \\le n \\le 10^3)$$$  — the number of digits of the generated number. The second line of each match description contains an $$$n$$$-digit positive integer without leading zeros.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "Python 3",
    "lang_cluster": "Python",
    "difficulty": 900,
    "file_name": "train_013.jsonl",
    "code_uid": "de3ac0c86e9608ca1fccd6decf91c5a6",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"4\\n1\\n2\\n1\\n3\\n3\\n102\\n4\\n2069\"]",
    "exec_outcome": "PASSED",
    "source_code": "'''\n# CodeForce Equalize Prices 900 points\n\n# a = old price / b = new price / k =value input\ndef Computer_Game():\n\n    for _ in range(int(input())):\n        k, n, a, b = map(int, input().split())  # init charge, num turns in game, a,b bat value\n        max_turns=0\n        for turns in range(n):\n\n            if k/b > n and (k-a)/b < n-1 and turns == 0:\n                max_turns=0\n                break\n            else:\n                if k > a:\n                    k -= a\n                    max_turns += 1\n                elif k > b:\n                    k -= b\n                    if k/b == n-turns:\n                        max_turns = 1\n                        break\n                else:\n                    max_turns = -1\n                    break\n\n\n        print(max_turns)\n\n\n    return\n\n\ndef bit_plus_plus():\n\n    summe = 0\n    for _ in range(int(input())):\n\n        statement = input()\n        if '+' in statement:\n            summe += 1\n        else:\n            summe -= 1\n    print(summe)\n    return\n\ndef petya_and_strings():\n\n    str_a, str_b = input().lower(), input().lower()\n    a=(str_a<str_b)\n    print((str_a>str_b)-(str_a<str_b))\n\n\n    return\n\n\n\n\ndef beautiful_matrix():\n\n    for idx in range(5):\n\n        row_input = list(map(int,input().split()))\n        if 1 in row_input:\n            row = idx+1\n            for idx1, elem in enumerate(row_input):\n                if elem == 1:\n                    column = idx1+1\n\n    output = abs(3 - row) + abs(3 - column)\n    print(output)\n        #for row_num in range(4):\n           # if 1 in row(row_num)\n\n    return\n\n\ndef helpful_maths():\n\n\n    string = sorted(list(input().split('+')))\n    print('+'.join(string))\n\n    return\n\n\ndef word_capitalization():\n\n    string = input()\n    string_new = string[0].upper()+string[1:]\n    print(string_new)\n\n    return\n\ndef Stones_on_the_Table():\n    _ = input()\n    string=list(input())\n    color_old = ''\n    color_old_old = ''\n    take = 0\n    for color in string:\n\n        if color == color_old:\n            take += 1\n        else:\n            color_old = color\n\n\n    print(take)\n\n    return\n\ndef Boy_or_girl():\n    print([{*input()}])\n    string = input()\n    new_string = ''\n    for _ in string:\n        if _ not in new_string:\n            new_string = new_string + _\n    if len(new_string) % 2 != 0:\n        print('IGNORE HIM!')\n    else:\n        print('CHAT WITH HER!')\n\n    return\n\n\ndef soldier_and_bananas():\n\n    k,n,w = map(int,input().split())\n    prize = 0\n    for num in range(w):\n        prize = prize + (num+1)*k\n\n    print(prize-n if prize-n > 0 else 0)\n    return\n\n\ndef bear_and_big_brother():\n\n    a,b = map(int, input().split())\n    years = 0\n    while a <= b:\n        a = a*3\n        b = b*2\n        years += 1\n\n    print(years)\n\n    return\n\n\ndef Tram():\n    passenger = []\n    cur_pass = 0\n    for _ in range(int(input())):\n\n        exit_passenger, enter_passenger = map(int,input().split())\n        cur_pass = cur_pass - exit_passenger + enter_passenger\n        passenger.append(cur_pass)\n\n    print(max(passenger))\n    return\n\n\n\ndef subtract_one(number):\n\n    if float(number)%10 == 0:\n        result = number / 10\n    else:\n        result = number - 1\n\n    return int(result)\n\ndef wrong_subtraction():\n\n    n, k = map(int, input().split())\n\n    for _ in range(k):\n        n = subtract_one(n)\n\n    print(n)\n    return\n\ndef wet_shark_and_odd_and_even():\n\n    odd = []\n    even = []\n    odd_cnt = 0\n    n = input()\n    numbers = list(map(int,input().split()))\n    for number in numbers:\n        if number%2 == 0:\n            even.append(number)\n        else:\n            odd.append(number)\n            odd_cnt += 1\n\n    odd.sort()\n    k = int(odd_cnt/2)*2\n    if k > 0:\n        summe = sum(even) + sum(odd[-k:])\n    else:\n        summe = sum(even)\n    print(summe)\n\n\n    return\n\n\n\n\n\ndef sorting(volumes):\n\n    sorting_steps = 0\n    idx = 0\n    cnt = 0\n    while(idx < len(volumes)-1):\n        a = volumes[idx]\n        b = volumes[idx+1]\n        # print(volumes)\n        if a > b:\n            volumes[idx] = b\n            volumes[idx+1] = a\n            sorting_steps += 1\n            if idx > 0:\n                idx -= 1\n\n            else:\n                cnt = cnt+1\n                idx = cnt\n\n        else:\n            idx += 1\n    return sorting_steps\n\ndef cubes_sorting():\n\n    for _ in range(int(input())):\n\n        n = int(input())\n        a = list(map(int,input().split()))\n\n        max_sort = n*(n-1)/2-1\n\n        sorting_steps = sorting(a)\n\n        if sorting_steps > max_sort:\n            print('NO')\n        else:\n            print('YES')\n\n\n    return\n\ndef elephant():\n\n    coord = int(input())\n    steps_taken = 0\n    for steps in range(5,0,-1):\n        if (coord / steps) >= 1:\n            steps_taken = int(coord / steps) + steps_taken\n            coord = int(coord % steps)\n    print(steps_taken)\n    return\n\ndef queue_at_the_school():\n    number, time = map(int,input().split())\n    queue=list(input())\n\n    i = 0\n\n    while i < time:\n        idx = 0\n        while idx < len(queue)-1:\n            if queue[idx] == 'B' and queue[idx+1] == 'G':\n                queue[idx] = 'G'\n                queue[idx+1] = 'B'\n                idx += 2\n            else:\n                idx += 1\n        i += 1\n\n    print(''.join(queue))\n    return\n\ndef nearly_lucky_number():\n    number = input()\n    l_number = 0\n    bla=[sum(i in '47' for i in number) in [4, 7]]\n    print('4' in number)\n    for elem in number:\n        if elem == '7' or elem == '4':\n            l_number += 1\n    print('YES' if l_number == 4 or l_number == 7 else 'NO')\n\n    return\n\ndef word():\n    string = input()\n    count = 0\n    for elem in string:\n        if elem.isupper():\n            count += 1\n\n    print(string.upper() if count > len(string)/2 else string.lower())\n\n    return\n'''\ndef translation():\n    word_1 = input()\n    word_2 = input()[::-1]\n    print([\"NO\", \"YES\"] [word_1 == word_2])\n\n\n    return\n\ndef anton_and_danik():\n\n    games = int(input())\n    wins=input()\n    anton_wins = sum(i == 'A' for i in wins)\n    if anton_wins*2 > len(wins):\n        print('Anton')\n    elif anton_wins*2 == len(wins):\n        print('Friendship')\n    else:\n        print('Danik')\n    return\n\ndef acoomodation():\n\n    cnt = 0\n    for _ in range(int(input())):\n        p, q = map(int, input().split())\n        if q - p >= 2:\n            cnt +=1\n\n    print(cnt)\n\n\n    return\n\ndef juicer():\n\n    n, b, d = map(int, input().split())\n\n    sum_orange = 0\n    cnt_empty = 0\n    for orange in list(map(int, input().split())):\n\n        if orange <= b:\n            sum_orange += orange\n            if sum_orange > d:\n                cnt_empty += 1\n                sum_orange = 0\n    print(cnt_empty)\n    return\n\n\ndef digit_game():\n\n    for game in range(int(input())):\n        breach_odd_cnt = 0\n        breach_even_cnt = 0\n        raze_odd_cnt = 0\n        raze_even_cnt = 0\n        n = int(input())\n        number = input()\n        breach_numbers = ''\n        raze_numbers = ''\n        len_number = len(number)\n\n        idx = 1\n        for digit in number:\n\n            if idx%2 == 0:\n                breach_numbers += digit\n                if digit in '13579':\n                    breach_odd_cnt += 1\n                else:\n                    breach_even_cnt += 1\n            else:\n                raze_numbers += digit\n                if digit in '13579':\n                    raze_odd_cnt += 1\n                else:\n                    raze_even_cnt += 1\n            idx += 1\n        if len_number == 1:\n            if int(number)%2 == 0:\n                print(2)\n            else:\n                print(1)\n        elif len_number%2 == 0:  # last pick from raze raze lässt eins übrig\n            if breach_even_cnt >= 1:\n                print(2)\n            else:\n                print(1)\n        else:  # last pick from breach breach lässt übrig\n            if raze_odd_cnt >= 1:\n                print(1)\n            else:\n                print(2)\n\n            # raze only odd breach only even 1 = odd 0 = even raze starts\n            # 1 raze wins\n            # 2 breach wins\n\n    return\n\n\nif __name__ == '__main__':\n\n    digit_game()\n\n'''\nif __name__ == '__main__':\n    num_queries = int(input())\n\n    for querie in range(num_queries):\n        num_products, value_products = map(int, input().split())\n        price_products = list(map(int, input().split()))\n        B_Max = min(price_products)+value_products\n        B_Min = max(price_products)-value_products\n        if B_Max >= B_Min:\n            print(B_Max)\n        else:\n            print(-1)\n'''\n\n\n\n\n\n\n",
    "prob_desc_created_at": "1600526100",
    "tags": [
        "implementation",
        "greedy",
        "games"
    ],
    "hidden_unit_tests": ""
}
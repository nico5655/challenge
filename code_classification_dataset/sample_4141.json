{
    "prob_desc_time_limit": "1 second",
    "prob_desc_sample_outputs": "[\"3\\n6\\n0\\n1\"]",
    "src_uid": "5b95da35a4c1251f5376cf3bacc1a549",
    "prob_desc_notes": "NoteIn the first test case, there is a single way to arrange people, because all sight levels are distinct. The first person will sit on the first seat, the second person will sit on the second place, the third person will sit on the third place. So inconvenience of the first person will be $$$0$$$, inconvenience of the second person will be $$$1$$$ and inconvenience of the third person will be $$$2$$$. The total inconvenience is $$$0 + 1 + 2 = 3$$$.In the second test case, people should sit as follows: $$$s_1 = 2$$$, $$$s_2 = 1$$$, $$$s_3 = 5$$$, $$$s_4 = 4$$$, $$$s_5 = 3$$$. The total inconvenience will be $$$6$$$.",
    "prob_desc_description": "It is the easy version of the problem. The only difference is that in this version $$$n = 1$$$.In the cinema seats can be represented as the table with $$$n$$$ rows and $$$m$$$ columns. The rows are numbered with integers from $$$1$$$ to $$$n$$$. The seats in each row are numbered with consecutive integers from left to right: in the $$$k$$$-th row from $$$m (k - 1) + 1$$$ to $$$m k$$$ for all rows $$$1 \\le k \\le n$$$. $$$1$$$$$$2$$$$$$\\cdots$$$$$$m - 1$$$$$$m$$$$$$m + 1$$$$$$m + 2$$$$$$\\cdots$$$$$$2 m - 1$$$$$$2 m$$$$$$2m + 1$$$$$$2m + 2$$$$$$\\cdots$$$$$$3 m - 1$$$$$$3 m$$$$$$\\vdots$$$$$$\\vdots$$$$$$\\ddots$$$$$$\\vdots$$$$$$\\vdots$$$$$$m (n - 1) + 1$$$$$$m (n - 1) + 2$$$$$$\\cdots$$$$$$n m - 1$$$$$$n m$$$ The table with seats indices There are $$$nm$$$ people who want to go to the cinema to watch a new film. They are numbered with integers from $$$1$$$ to $$$nm$$$. You should give exactly one seat to each person.It is known, that in this cinema as lower seat index you have as better you can see everything happening on the screen. $$$i$$$-th person has the level of sight $$$a_i$$$. Let's define $$$s_i$$$ as the seat index, that will be given to $$$i$$$-th person. You want to give better places for people with lower sight levels, so for any two people $$$i$$$, $$$j$$$ such that $$$a_i &lt; a_j$$$ it should be satisfied that $$$s_i &lt; s_j$$$.After you will give seats to all people they will start coming to their seats. In the order from $$$1$$$ to $$$nm$$$, each person will enter the hall and sit in their seat. To get to their place, the person will go to their seat's row and start moving from the first seat in this row to theirs from left to right. While moving some places will be free, some will be occupied with people already seated. The inconvenience of the person is equal to the number of occupied seats he or she will go through.Let's consider an example: $$$m = 5$$$, the person has the seat $$$4$$$ in the first row, the seats $$$1$$$, $$$3$$$, $$$5$$$ in the first row are already occupied, the seats $$$2$$$ and $$$4$$$ are free. The inconvenience of this person will be $$$2$$$, because he will go through occupied seats $$$1$$$ and $$$3$$$.Find the minimal total inconvenience (the sum of inconveniences of all people), that is possible to have by giving places for all people (all conditions should be satisfied).",
    "prob_desc_output_spec": "For each test case print a single integer — the minimal total inconvenience that can be achieved.",
    "prob_desc_input_spec": "The input consists of multiple test cases. The first line contains a single integer $$$t$$$ ($$$1 \\le t \\le 100$$$) — the number of test cases. Description of the test cases follows. The first line of each test case contains two integers $$$n$$$ and $$$m$$$ ($$$n = 1$$$, $$$1 \\le m \\le 300$$$) — the number of rows and places in each row respectively. The second line of each test case contains $$$n \\cdot m$$$ integers $$$a_1, a_2, \\ldots, a_{n \\cdot m}$$$ ($$$1 \\le a_i \\le 10^9$$$), where $$$a_i$$$ is the sight level of $$$i$$$-th person. It's guaranteed that the sum of $$$n \\cdot m$$$ over all test cases does not exceed $$$10^5$$$.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3-64",
    "lang_cluster": "Python",
    "difficulty": 1100,
    "file_name": "train_091.jsonl",
    "code_uid": "4dad8db1f8a81b2eba4b7a489bc5267d",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"4\\n1 3\\n1 2 3\\n1 5\\n2 1 5 3 3\\n1 2\\n2 1\\n1 6\\n2 3 2 1 1 1\"]",
    "exec_outcome": "PASSED",
    "source_code": "# cook your dish here\r\n#!/usr/bin/env python\r\nimport bisect\r\nfrom cmath import inf\r\nfrom heapq import heapify, heappop, heappush\r\nimport os\r\nfrom math import ceil, factorial, fmod,pi,sqrt,log,floor\r\nimport re\r\nimport sys\r\nfrom collections import Counter\r\nfrom io import BytesIO, IOBase, StringIO\r\n\r\ndef modFact(n, p):\r\n    if n >= p:\r\n        return 0   \r\n \r\n    result = 1\r\n    for i in range(1, n + 1):\r\n        result = (result * i) % p\r\n \r\n    return result\r\n \r\ndef calculate(p, q):\r\n     \r\n    mod = 998244353\r\n    expo = 0\r\n    expo = mod - 2\r\n \r\n    # Loop to find the value\r\n    # until the expo is not zero\r\n    while (expo):\r\n \r\n        # Multiply p with q\r\n        # if expo is odd\r\n        if (expo & 1):\r\n            p = (p * q) % mod\r\n        q = (q * q) % mod\r\n \r\n        # Reduce the value of\r\n        # expo by 2\r\n        expo >>= 1\r\n \r\n    return p\r\ndef compute_gcd(x, y):\r\n\r\n   while(y):\r\n       x, y = y, x % y\r\n   return x\r\n\r\n# This function computes LCM\r\ndef compute_lcm(x, y):\r\n   lcm = (x*y)//compute_gcd(x,y)\r\n   return lcm\r\n\r\ndef read_arr():\r\n    return [int(x) for x in input().split()]\r\n\r\n# def bin_search(num, arr):\r\n#     start = 0\r\n#     end = len(arr)-1\r\n#     while start <= end:\r\n#         mid=(start+end)//2\r\n#         if arr[mid] == num:\r\n#             return mid\r\n#         elif arr[mid] > num:\r\n#             end= mid-1\r\n#         else:\r\n#             start = mid + 1\r\n#     return -1\r\n\r\n\r\ndef factors(n) :\r\n     \r\n    # Note that this loop runs till square root\r\n    i = 1\r\n    ans=[]\r\n    while i <= sqrt(n):\r\n         \r\n        if (n % i == 0) :\r\n             \r\n            # If divisors are equal, print only one\r\n            if (n / i == i) :\r\n                ans.append(i)\r\n            else :\r\n                # Otherwise print both\r\n                \r\n                ans.append(i)\r\n                ans.append(int(n/i))\r\n        i = i + 1\r\n    return ans\r\n\r\ndef is_palindrome(n):\r\n    for j in range(len(n)//2):\r\n        if n[j]!=n[len(n)-j-1]:\r\n            return False\r\n    return True\r\n\r\ndef is_sorted(arr,n,m):\r\n    for j in range(n):\r\n        for k in range(m-1):\r\n            if arr[j][k] > arr[j][k+1]:\r\n                return False \r\n    return True\r\n\r\nMOD = 10**9 + 7    \r\n\r\ndef main():\r\n    for i in range(int(input())):\r\n        n, m = map(int, input().split())\r\n        arr = [int(x) for x in input().split()]\r\n        done = [False for j in range(m)]\r\n        cnt=0\r\n        tmp = arr.copy()\r\n        tmp.sort()\r\n        idx = {}\r\n        for j in range(m):\r\n            idx[tmp[j]] = j + 1\r\n        for j in range(m):\r\n            for k in range(idx[arr[j]]):\r\n                if done[k]:\r\n                    cnt += 1\r\n            done[idx[arr[j]]-1] = True \r\n            idx[arr[j]] -= 1\r\n        print(cnt)\r\n            \r\n\r\n        \r\n                \r\n\r\nBUFSIZE = 8192\r\n \r\n \r\nclass FastIO(IOBase):\r\n    newlines = 0\r\n \r\n    def __init__(self, file):\r\n        self._fd = file.fileno()\r\n        self.buffer = BytesIO()\r\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\r\n        self.write = self.buffer.write if self.writable else None\r\n \r\n    def read(self):\r\n        while True:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            if not b:\r\n                break\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines = 0\r\n        return self.buffer.read()\r\n \r\n    def readline(self):\r\n        while self.newlines == 0:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            self.newlines = b.count(b\"\\n\") + (not b)\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines -= 1\r\n        return self.buffer.readline()\r\n \r\n    def flush(self):\r\n        if self.writable:\r\n            os.write(self._fd, self.buffer.getvalue())\r\n            self.buffer.truncate(0), self.buffer.seek(0)\r\n \r\n \r\nclass IOWrapper(IOBase):\r\n    def __init__(self, file):\r\n        self.buffer = FastIO(file)\r\n        self.flush = self.buffer.flush\r\n        self.writable = self.buffer.writable\r\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\r\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\r\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\r\n \r\n \r\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\r\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\r\n \r\n# endregion\r\n \r\nif __name__ == \"__main__\":\r\n    main()",
    "prob_desc_created_at": "1631457300",
    "tags": [
        "data structures",
        "greedy",
        "sortings"
    ],
    "hidden_unit_tests": ""
}
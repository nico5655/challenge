{
    "prob_desc_time_limit": "1 second",
    "prob_desc_sample_outputs": "[\"15\", \"91\"]",
    "src_uid": "51aa12a683a43f520667cb2f2f421bd8",
    "prob_desc_notes": "NoteFor the first test, the optimal sizes of carrots are $$$\\{1,1,1,2,2,2\\}$$$. The time taken is $$$1^2+1^2+1^2+2^2+2^2+2^2=15$$$For the second test, the optimal sizes of carrots are $$$\\{4,5,5,5\\}$$$. The time taken is $$$4^2+5^2+5^2+5^2=91$$$.",
    "prob_desc_description": "There are some rabbits in Singapore Zoo. To feed them, Zookeeper bought $$$n$$$ carrots with lengths $$$a_1, a_2, a_3, \\ldots, a_n$$$. However, rabbits are very fertile and multiply very quickly. Zookeeper now has $$$k$$$ rabbits and does not have enough carrots to feed all of them. To solve this problem, Zookeeper decided to cut the carrots into $$$k$$$ pieces. For some reason, all resulting carrot lengths must be positive integers.Big carrots are very difficult for rabbits to handle and eat, so the time needed to eat a carrot of size $$$x$$$ is $$$x^2$$$.Help Zookeeper split his carrots while minimizing the sum of time taken for rabbits to eat the carrots.",
    "prob_desc_output_spec": "Output one integer: the minimum sum of time taken for rabbits to eat carrots.",
    "prob_desc_input_spec": "The first line contains two integers $$$n$$$ and $$$k$$$ $$$(1 \\leq n \\leq k \\leq 10^5)$$$: the initial number of carrots and the number of rabbits. The next line contains $$$n$$$ integers $$$a_1, a_2, \\ldots, a_n$$$ $$$(1 \\leq a_i \\leq 10^6)$$$: lengths of carrots. It is guaranteed that the sum of $$$a_i$$$ is at least $$$k$$$.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3",
    "lang_cluster": "Python",
    "difficulty": 2200,
    "file_name": "train_016.jsonl",
    "code_uid": "e5ed43ae25399781199169e264f86807",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"3 6\\n5 3 1\", \"1 4\\n19\"]",
    "exec_outcome": "PASSED",
    "source_code": "\"\"\"\n    Author - Satwik Tiwari .\n    17th Oct , 2020  - Saturday\n\"\"\"\n\n#===============================================================================================\n#importing some useful libraries.\n\n\nfrom __future__ import division, print_function\nfrom fractions import Fraction\nimport sys\nimport os\nfrom io import BytesIO, IOBase\n\n\n# from itertools import *\nfrom heapq import *\n# from math import gcd, factorial,floor,ceil\n\nfrom copy import deepcopy\nfrom collections import deque\n\n\n# from collections import Counter as counter  # Counter(list)  return a dict with {key: count}\n# from itertools import combinations as comb # if a = [1,2,3] then print(list(comb(a,2))) -----> [(1, 2), (1, 3), (2, 3)]\n# from itertools import permutations as permutate\n\n\nfrom bisect import bisect_left as bl\nfrom bisect import bisect_right as br\nfrom bisect import bisect\n\n#==============================================================================================\n#fast I/O region\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\ndef print(*args, **kwargs):\n    \"\"\"Prints the values to a stream, or to sys.stdout by default.\"\"\"\n    sep, file = kwargs.pop(\"sep\", \" \"), kwargs.pop(\"file\", sys.stdout)\n    at_start = True\n    for x in args:\n        if not at_start:\n            file.write(sep)\n        file.write(str(x))\n        at_start = False\n    file.write(kwargs.pop(\"end\", \"\\n\"))\n    if kwargs.pop(\"flush\", False):\n        file.flush()\n\n\nif sys.version_info[0] < 3:\n    sys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)\nelse:\n    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\n\n# inp = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n#===============================================================================================\n### START ITERATE RECURSION ###\n# from types import GeneratorType\ndef iterative(f, stack=[]):\n  def wrapped_func(*args, **kwargs):\n    if stack: return f(*args, **kwargs)\n    to = f(*args, **kwargs)\n    while True:\n      if type(to) is GeneratorType:\n        stack.append(to)\n        to = next(to)\n        continue\n      stack.pop()\n      if not stack: break\n      to = stack[-1].send(to)\n    return to\n  return wrapped_func\n#### END ITERATE RECURSION ####\n\n#===============================================================================================\n#some shortcuts\n\nmod = 10**9+7\ndef inp(): return sys.stdin.readline().rstrip(\"\\r\\n\") #for fast input\ndef out(var): sys.stdout.write(str(var))  #for fast output, always take string\ndef lis(): return list(map(int, inp().split()))\ndef stringlis(): return list(map(str, inp().split()))\ndef sep(): return map(int, inp().split())\ndef strsep(): return map(str, inp().split())\n# def graph(vertex): return [[] for i in range(0,vertex+1)]\ndef zerolist(n): return [0]*n\ndef nextline(): out(\"\\n\")  #as stdout.write always print sring.\ndef testcase(t):\n    for pp in range(t):\n        solve(pp)\ndef printlist(a) :\n    for p in range(0,len(a)):\n        out(str(a[p]) + ' ')\ndef google(p):\n    print('Case #'+str(p)+': ',end='')\ndef lcm(a,b): return (a*b)//gcd(a,b)\ndef power(x, y, p) :\n    res = 1     # Initialize result\n    x = x % p  # Update x if it is more , than or equal to p\n    if (x == 0) :\n        return 0\n    while (y > 0) :\n        if ((y & 1) == 1) : # If y is odd, multiply, x with result\n            res = (res * x) % p\n\n        y = y >> 1      # y = y/2\n        x = (x * x) % p\n    return res\ndef ncr(n,r): return factorial(n) // (factorial(r) * factorial(max(n - r, 1)))\ndef isPrime(n) :\n    if (n <= 1) : return False\n    if (n <= 3) : return True\n    if (n % 2 == 0 or n % 3 == 0) : return False\n    i = 5\n    while(i * i <= n) :\n        if (n % i == 0 or n % (i + 2) == 0) :\n            return False\n        i = i + 6\n    return True\n\n#===============================================================================================\n# code here ;))\ndef help(val,part):\n    temp = val//part\n    rem = val%part\n    return (temp*temp)*(part-rem) + ((temp+1)*(temp+1))*rem\n\ndef solve(case):\n    n,k = sep()\n    a = lis()\n\n    curr = 0\n    for i in range(n):\n        curr+=a[i]*a[i]\n\n    h = []\n    parts = [1]*n\n    for i in range(n):\n        heappush(h,(help(a[i],2) - help(a[i],1),i))\n    cnt = n\n\n    while(cnt<k):\n        temp = heappop(h)\n        # print(temp)\n        diff,ele = temp[0],temp[1]\n        curr+=diff\n        parts[ele]+=1\n        heappush(h,(help(a[ele],parts[ele]+1) - help(a[ele],parts[ele]),ele))\n        cnt+=1\n\n\n    print(curr)\n\n\n\n\n\n\n\n\ntestcase(1)\n# testcase(int(inp()))\n\n\n\n\n\n\n\n\n\n\n\n\n",
    "prob_desc_created_at": "1602939900",
    "tags": [
        "greedy",
        "math",
        "sortings",
        "data structures",
        "binary search"
    ],
    "hidden_unit_tests": ""
}
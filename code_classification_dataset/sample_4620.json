{
    "prob_desc_time_limit": "1 second",
    "prob_desc_sample_outputs": "[\"1\\n2\\n0\\n2\\n12\\n331032489\"]",
    "src_uid": "0f58ac08a26ce735bfe13fd089b7f746",
    "prob_desc_notes": "NoteIn the first test case, $$$a=[2,1,3]$$$. There are two possible ways to fill out the $$$-1$$$s in $$$b$$$ to make it a permutation: $$$[3,1,2]$$$ or $$$[3,2,1]$$$. We can make $$$a$$$ into $$$[3,1,2]$$$ with a strength of $$$1$$$ as follows: $$$$$$[2,1,3] \\xrightarrow[x=1,\\,y=1]{} [2,1,3] \\xrightarrow[x=2,\\,y=3]{} [3,1,2] \\xrightarrow[x=3,\\,y=3]{} [3,1,2].$$$$$$ It can be proven that it is impossible to make $$$[2,1,3]$$$ into $$$[3,2,1]$$$ with a strength of $$$1$$$. Thus only one permutation $$$b$$$ satisfies the constraints, so the answer is $$$1$$$.In the second test case, $$$a$$$ and $$$b$$$ the same as the previous test case, but we now have a strength of $$$2$$$. We can make $$$a$$$ into $$$[3,2,1]$$$ with a strength of $$$2$$$ as follows: $$$$$$[2,1,3] \\xrightarrow[x=1,\\,y=3]{} [2,3,1] \\xrightarrow[x=2,\\,y=3]{} [3,2,1] \\xrightarrow[x=3,\\,y=3]{} [3,2,1].$$$$$$ We can still make $$$a$$$ into $$$[3,1,2]$$$ using a strength of $$$1$$$ as shown in the previous test case, so the answer is $$$2$$$. In the third test case, there is only one permutation $$$b$$$. It can be shown that it is impossible to turn $$$a$$$ into $$$b$$$, so the answer is $$$0$$$.",
    "prob_desc_description": "You are given a permutation $$$a$$$ of length $$$n$$$. Recall that permutation is an array consisting of $$$n$$$ distinct integers from $$$1$$$ to $$$n$$$ in arbitrary order.You have a strength of $$$s$$$ and perform $$$n$$$ moves on the permutation $$$a$$$. The $$$i$$$-th move consists of the following:   Pick two integers $$$x$$$ and $$$y$$$ such that $$$i \\leq x \\leq y \\leq \\min(i+s,n)$$$, and swap the positions of the integers $$$x$$$ and $$$y$$$ in the permutation $$$a$$$. Note that you can select $$$x=y$$$ in the operation, in which case no swap will occur. You want to turn $$$a$$$ into another permutation $$$b$$$ after $$$n$$$ moves. However, some elements of $$$b$$$ are missing and are replaced with $$$-1$$$ instead. Count the number of ways to replace each $$$-1$$$ in $$$b$$$ with some integer from $$$1$$$ to $$$n$$$ so that $$$b$$$ is a permutation and it is possible to turn $$$a$$$ into $$$b$$$ with a strength of $$$s$$$. Since the answer can be large, output it modulo $$$998\\,244\\,353$$$.",
    "prob_desc_output_spec": "For each test case, output a single integer — the number of ways to fill up the permutation $$$b$$$ so that it is possible to turn $$$a$$$ into $$$b$$$ using a strength of $$$s$$$, modulo $$$998\\,244\\,353$$$.",
    "prob_desc_input_spec": "The input consists of multiple test cases. The first line contains an integer $$$t$$$ ($$$1 \\leq t \\leq 1000$$$) — the number of test cases. The description of the test cases follows. The first line of each test case contains two integers $$$n$$$ and $$$s$$$ ($$$1 \\leq n \\leq 2 \\cdot 10^5$$$; $$$1 \\leq s \\leq n$$$) — the size of the permutation and your strength, respectively. The second line of each test case contains $$$n$$$ integers $$$a_1, a_2, \\ldots, a_n$$$ ($$$1 \\le a_i \\le n$$$) — the elements of $$$a$$$. All elements of $$$a$$$ are distinct. The third line of each test case contains $$$n$$$ integers $$$b_1, b_2, \\ldots, b_n$$$ ($$$1 \\le b_i \\le n$$$ or $$$b_i = -1$$$) — the elements of $$$b$$$. All elements of $$$b$$$ that are not equal to $$$-1$$$ are distinct. It is guaranteed that the sum of $$$n$$$ over all test cases does not exceed $$$2 \\cdot 10^5$$$.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3-64",
    "lang_cluster": "Python",
    "difficulty": 2300,
    "file_name": "train_102.jsonl",
    "code_uid": "ad7ef552703769b81327420616bda135",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"6\\n\\n3 1\\n\\n2 1 3\\n\\n3 -1 -1\\n\\n3 2\\n\\n2 1 3\\n\\n3 -1 -1\\n\\n4 1\\n\\n1 4 3 2\\n\\n4 3 1 2\\n\\n6 4\\n\\n4 2 6 3 1 5\\n\\n6 1 5 -1 3 -1\\n\\n7 4\\n\\n1 3 6 2 7 4 5\\n\\n2 5 -1 -1 -1 4 -1\\n\\n14 14\\n\\n1 2 3 4 5 6 7 8 9 10 11 12 13 14\\n\\n-1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1\"]",
    "exec_outcome": "PASSED",
    "source_code": "from functools import reduce\r\nfrom sys import stdin, stdout\r\n\r\n\r\ndef read(): return stdin.readline().strip()\r\ndef write(x): stdout.write(str(x) + '\\n')\r\n\r\n\r\ndef get_index(a):\r\n    a_index = [-1] * len(a)\r\n    for i in range(len(a)):\r\n        if a[i] != -1:\r\n            a_index[a[i]] = i\r\n    return a_index\r\n\r\n\r\ndef solve():\r\n    n, s = map(int, read().split())\r\n\r\n    a_ = list(map(int, read().split()))\r\n    b_ = list(map(int, read().split()))\r\n\r\n    a = [i - 1 for i in a_]\r\n    b = [i - 1 if i != -1 else -1 for i in b_]\r\n\r\n    a_index = get_index(a)\r\n    b_index = get_index(b)\r\n\r\n    a = [a_index[i] for i in range(n)]\r\n    b = [b_index[i] if b_index[i] != -1 else -1 for i in range(n)]\r\n\r\n    a_index = get_index(a)\r\n    b_index = get_index(b)\r\n\r\n    # p = [a[i] for i in range(s)]\r\n    # p_in_b = [a[i] for i in range(s) if a[i] in b]\r\n    p_in_b = [a[i] for i in range(s) if b_index[a[i]] != -1]\r\n    # p_not_in_b = [a[i] for i in range(s) if a[i] not in b]\r\n    p_not_in_b = [a[i] for i in range(s) if b_index[a[i]] == -1]\r\n\r\n    p_in_b_index = [-1] * n\r\n    for i in range(len(p_in_b)):\r\n        p_in_b_index[p_in_b[i]] = i\r\n\r\n    c = [0] * n\r\n    for i in range(n):\r\n        j = i + s\r\n        if j < n:\r\n            # p.append(a[j])\r\n            # if a[j] in b:\r\n            if b_index[a[j]] != -1:\r\n                p_in_b.append(a[j])\r\n                p_in_b_index[a[j]] = len(p_in_b) - 1\r\n            else:\r\n                p_not_in_b.append(a[j])\r\n\r\n        if b[i] == -1:\r\n            # c[i] = len([i for i in p if i not in b])\r\n            c[i] = len(p_not_in_b)\r\n            # for i in p:\r\n            #     if i not in b:\r\n            #         p.remove(i)\r\n            #         break\r\n            # p_not_in_b.remove(p_not_in_b[0])\r\n            if p_not_in_b:\r\n                p_not_in_b.pop()\r\n        else:\r\n            # if b[i] in p_in_b:\r\n            if p_in_b_index[b[i]] != -1:\r\n                # if p_in_b_index[b[i]] != -1:\r\n                c[i] = 1\r\n                # p_in_b.remove(b[i])\r\n                p_in_b_index[b[i]] = -1\r\n            else:\r\n                c[i] = 0\r\n                break\r\n\r\n    # print(c)\r\n    write(reduce(lambda x, y: x * y % 998244353, c))\r\n\r\n\r\nT = 1\r\nT = int(read())\r\nfor _ in range(T):\r\n    solve()\r\n",
    "prob_desc_created_at": "1656426900",
    "tags": [
        "brute force",
        "combinatorics",
        "greedy",
        "sortings",
        "trees",
        "two pointers"
    ],
    "hidden_unit_tests": ""
}
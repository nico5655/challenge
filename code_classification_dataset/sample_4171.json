{
    "prob_desc_time_limit": "1 second",
    "prob_desc_sample_outputs": "[\"-3 5 1 2 2\\n1 1 1\"]",
    "src_uid": "fa24700412a8532b5b92c1e72d8a2e2d",
    "prob_desc_notes": "NoteIn the first case, when removing vertex $$$1$$$ all remaining connected components have sum $$$5$$$ and when removing vertex $$$3$$$ all remaining connected components have sum $$$2$$$. When removing other vertices, there is only one remaining connected component so all remaining connected components have the same sum.",
    "prob_desc_description": "You are given an undirected unrooted tree, i.e. a connected undirected graph without cycles.You must assign a nonzero integer weight to each vertex so that the following is satisfied: if any vertex of the tree is removed, then each of the remaining connected components has the same sum of weights in its vertices.",
    "prob_desc_output_spec": "For each test case, you must output one line with $$$n$$$ space separated integers $$$a_1, a_2, \\ldots, a_n$$$, where $$$a_i$$$ is the weight assigned to vertex $$$i$$$. The weights must satisfy $$$-10^5 \\leq a_i \\leq 10^5$$$ and $$$a_i \\neq 0$$$. It can be shown that there always exists a solution satisfying these constraints. If there are multiple possible solutions, output any of them.",
    "prob_desc_input_spec": "The input consists of multiple test cases. The first line contains a single integer $$$t$$$ ($$$1 \\leq t \\leq 10^4$$$) — the number of test cases. Description of the test cases follows. The first line of each test case contains an integer $$$n$$$ ($$$3 \\leq n \\leq 10^5$$$) — the number of vertices of the tree. The next $$$n-1$$$ lines of each case contain each two integers $$$u, v$$$ ($$$1 \\leq u,v \\leq n$$$) denoting that there is an edge between vertices $$$u$$$ and $$$v$$$. It is guaranteed that the given edges form a tree. The sum of $$$n$$$ for all test cases is at most $$$10^5$$$.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3-64",
    "lang_cluster": "Python",
    "difficulty": 2200,
    "file_name": "train_092.jsonl",
    "code_uid": "6853dc337b70dbcddcfb51dfd4903043",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"2\\n5\\n1 2\\n1 3\\n3 4\\n3 5\\n3\\n1 2\\n1 3\"]",
    "exec_outcome": "PASSED",
    "source_code": "\r\n    \r\nimport os,sys\r\nfrom io import BytesIO, IOBase\r\n\r\nfrom collections import deque, Counter,defaultdict as dft\r\nfrom heapq import heappop ,heappush\r\nfrom math import log,sqrt,factorial,cos,tan,sin,radians,log2,ceil,floor,gcd\r\nfrom bisect import bisect,bisect_left,bisect_right\r\nfrom decimal import *\r\nimport sys,threading\r\nfrom itertools import permutations, combinations\r\nfrom copy import deepcopy\r\ninput = sys.stdin.readline\r\n\r\ndef modI(a, m):\r\n\r\n    m0=m\r\n    y=0\r\n    x=1;\r\n    if(m==1): return 0;\r\n    while(a>1):\r\n    \r\n        q=a//m;\r\n        t=m;\r\n        m=a%m;\r\n        a=t;\r\n        t=y;\r\n        y=x-q*y;\r\n        x=t;\r\n    \r\n    if(x<0):x+=m0;\r\n    return x;\r\n\r\n\r\nii = lambda: int(input())\r\nsi = lambda: input().rstrip()\r\nmp = lambda: map(int, input().split())\r\nms=  lambda: map(str,input().strip().split(\" \"))\r\nml = lambda: list(mp())\r\nmf = lambda: map(float, input().split())\r\n\r\n\r\nalphs = \"abcdefghijklmnopqrstuvwxyz\"\r\n\r\n\r\n# stuff you should look for\r\n\t#  int overflow, array bounds\r\n\t#  special cases (n=1?)\r\n\t#  do smth instead of nothing and stay organized\r\n\t#  WRITE STUFF DOWN\r\n\t#  DON'T GET STUCK ON ONE APPROACH\r\n    #  DON'T use pow() multiple times use modI if possible.\r\n#\r\n\r\n\r\n    \r\n\r\n\r\ndef solve():\r\n    \r\n    \r\n    \r\n    \r\n    n=int(input())\r\n    dct=[[] for i in range(n+1)]\r\n    \r\n\r\n    for i in range(n-1):\r\n        a,b=map(int,input().split())\r\n        dct[a].append(b)\r\n        dct[b].append(a)\r\n    \r\n    \r\n    \r\n    w=[0]*(n+1)\r\n    vis=[0]*(n+1)\r\n    \r\n    \r\n    \r\n    #print(curr,pre)\r\n    st=deque([[1,1]])\r\n    while(st):\r\n        nd,c=st.popleft()\r\n        vis[nd]=1\r\n        w[nd]=len(dct[nd])*c\r\n        for lnk in dct[nd]:\r\n            if vis[lnk]:continue\r\n            st.append([lnk,-c])\r\n        \r\n    \r\n    print(*w[1:])\r\n            \r\n    \r\n    \r\n    \r\n\r\n \r\nBUFSIZE = 8192\r\n \r\n \r\nclass FastIO(IOBase):\r\n    newlines = 0\r\n \r\n    def __init__(self, file):\r\n        self._fd = file.fileno()\r\n        self.buffer = BytesIO()\r\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\r\n        self.write = self.buffer.write if self.writable else None\r\n \r\n    def read(self):\r\n        while True:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            if not b:\r\n                break\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines = 0\r\n        return self.buffer.read()\r\n \r\n    def readline(self):\r\n        while self.newlines == 0:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            self.newlines = b.count(b\"\\n\") + (not b)\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines -= 1\r\n        return self.buffer.readline()\r\n \r\n    def flush(self):\r\n        if self.writable:\r\n            os.write(self._fd, self.buffer.getvalue())\r\n            self.buffer.truncate(0), self.buffer.seek(0)\r\n \r\n \r\nclass IOWrapper(IOBase):\r\n    def __init__(self, file):\r\n        self.buffer = FastIO(file)\r\n        self.flush = self.buffer.flush\r\n        self.writable = self.buffer.writable\r\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\r\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\r\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\r\n \r\n \r\ndef print(*args, **kwargs):\r\n    \"\"\"Prints the values to a stream, or to sys.stdout by default.\"\"\"\r\n    sep, file = kwargs.pop(\"sep\", \" \"), kwargs.pop(\"file\", sys.stdout)\r\n    at_start = True\r\n    for x in args:\r\n        if not at_start:\r\n            file.write(sep)\r\n        file.write(str(x))\r\n        at_start = False\r\n    file.write(kwargs.pop(\"end\", \"\\n\"))\r\n    if kwargs.pop(\"flush\", False):\r\n        file.flush()\r\n\r\nif sys.version_info[0] < 3:\r\n    sys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)\r\nelse:\r\n    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\r\n \r\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\r\n \r\nclass SegmentTree:\r\n    def __init__(self, data, default=0, func=gcd):\r\n        \"\"\"initialize the segment tree with data\"\"\"\r\n        self._default = default\r\n        self._func = func\r\n        self._len = len(data)\r\n        self._size = _size = 1 << (self._len - 1).bit_length()\r\n \r\n        self.data = [default] * (2 * _size)\r\n        self.data[_size:_size + self._len] = data\r\n        for i in reversed(range(_size)):\r\n            self.data[i] = func(self.data[i + i], self.data[i + i + 1])\r\n \r\n    def __delitem__(self, idx):\r\n        self[idx] = self._default\r\n \r\n    def __getitem__(self, idx):\r\n        return self.data[idx + self._size]\r\n \r\n    def __setitem__(self, idx, value):\r\n        idx += self._size\r\n        self.data[idx] = value\r\n        idx >>= 1\r\n        while idx:\r\n            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])\r\n            idx >>= 1\r\n \r\n    def __len__(self):\r\n        return self._len\r\n \r\n    def query(self, start, stop):\r\n        \"\"\"func of data[start, stop)\"\"\"\r\n        start += self._size\r\n        stop += self._size\r\n \r\n        res_left = res_right = self._default\r\n        while start < stop:\r\n            if start & 1:\r\n                res_left = self._func(res_left, self.data[start])\r\n                start += 1\r\n            if stop & 1:\r\n                stop -= 1\r\n                res_right = self._func(self.data[stop], res_right)\r\n            start >>= 1\r\n            stop >>= 1\r\n \r\n        return self._func(res_left, res_right)\r\n \r\n    def __repr__(self):\r\n        return \"SegmentTree({0})\".format(self.data)\r\n\r\n# endregion\r\n\r\n \r\nif __name__ == \"__main__\":\r\n    tc=1\r\n    tc = ii()\r\n    for i in range(tc):\r\n    \tsolve()\r\n    \t",
    "prob_desc_created_at": "1648132500",
    "tags": [
        "constructive algorithms",
        "dfs and similar",
        "math",
        "trees"
    ],
    "hidden_unit_tests": ""
}
{
    "prob_desc_time_limit": "4 seconds",
    "prob_desc_sample_outputs": "[\"1\\n3\", \"1\\n5\\n1\"]",
    "src_uid": "67f5f685efaabdc8673649416fdfbf62",
    "prob_desc_notes": null,
    "prob_desc_description": "You are given an array a consisting of positive integers and q queries to this array. There are two types of queries:   1 l r x — for each index i such that l ≤ i ≤ r set ai = x.  2 l r — find the minimum among such ai that l ≤ i ≤ r. We decided that this problem is too easy. So the array a is given in a compressed form: there is an array b consisting of n elements and a number k in the input, and before all queries a is equal to the concatenation of k arrays b (so the size of a is n·k).",
    "prob_desc_output_spec": "For each query of type 2 print the answer to this query — the minimum on the corresponding segment.",
    "prob_desc_input_spec": "The first line contains two integers n and k (1 ≤ n ≤ 105, 1 ≤ k ≤ 104). The second line contains n integers — elements of the array b (1 ≤ bi ≤ 109). The third line contains one integer q (1 ≤ q ≤ 105). Then q lines follow, each representing a query. Each query is given either as 1 l r x — set all elements in the segment from l till r (including borders) to x (1 ≤ l ≤ r ≤ n·k, 1 ≤ x ≤ 109) or as 2 l r — find the minimum among all elements in the segment from l till r (1 ≤ l ≤ r ≤ n·k).",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 2",
    "lang_cluster": "Python",
    "difficulty": 2300,
    "file_name": "train_019.jsonl",
    "code_uid": "f687332b9d5e9d39bb8a6e0af4f51bab",
    "prob_desc_memory_limit": "512 megabytes",
    "prob_desc_sample_inputs": "[\"3 1\\n1 2 3\\n3\\n2 1 3\\n1 1 2 4\\n2 1 3\", \"3 2\\n1 2 3\\n5\\n2 4 4\\n1 4 4 5\\n2 4 4\\n1 1 6 1\\n2 6 6\"]",
    "exec_outcome": "PASSED",
    "source_code": "from sys import stdin, stdout\n\n\nn, k = map(int, stdin.readline().split())\nvalues = [0] + list(map(int, stdin.readline().split()))\nm = int(stdin.readline())\nquestions = []\nar = set()\n\nfor i in range(m):\n    questions.append(tuple(map(int, stdin.readline().strip().split())))\n    ar.add(int(questions[-1][1]))\n    ar.add(int(questions[-1][2]))\n    \n\ncompress = [0]\nar = sorted(list(ar))\n\npw = 1\nwhile (2 ** pw < n):\n    pw += 1\n\nsparse = [[float('inf') for j in range(len(values))] for i in range(pw)]\nsparse[0] = values\n\nfor i in range(1, pw):\n    for j in range(1, n - 2 ** i + 2):\n        sparse[i][j] = min(sparse[i - 1][j], sparse[i - 1][j + 2 ** (i - 1)])\n\n\nmn = min(values[1:])\n\n\ndef getmin(first, second):\n    if second - first + 1 >= n:\n        return mn\n    else:\n        second = second % n + n * (not(second % n))\n        first = first % n + n * (not(first % n))\n        \n        if second < first:\n            return min(getmin(1, second), getmin(first, n))\n        else:\n            length = second - first + 1\n            pw = 0\n    \n            while 2 ** pw <= length:\n                pw += 1\n            \n            pw -= 1\n            \n            return min(sparse[pw][first], sparse[pw][second - 2 ** pw + 1])\n\n\ncounting = {}\nd = {}\n\n\nfor i in range(len(ar)):\n    compress.append(ar[i])\n    d[ar[i]] = len(compress) - 1\n    \n    if i != len(ar) - 1 and ar[i + 1] - ar[i] > 1:\n        compress.append(ar[i] + 1)\n        counting[len(compress) - 1] = float('inf')\n        d[ar[i] + 1] = len(compress) - 1\n\nfor ind in counting:\n    counting[ind] = getmin(compress[ind - 1] + 1, compress[ind + 1] - 1)\n        \n    \n\ndef update(l, r, ind, lb, rb, value):\n        \n        \n    if updating[ind] and ind * 2 < len(tree):\n        \n        if (not updating[ind * 2] or (updating[ind * 2][1] < updating[ind][1])):\n            tree[ind * 2] = updating[ind][0]\n            updating[ind * 2] = updating[ind][::]\n            \n        if (not updating[ind * 2 + 1] or (updating[ind * 2 + 1][1] < updating[ind][1])):\n            tree[ind * 2 + 1] = updating[ind][0]\n            updating[ind * 2 + 1] = updating[ind][::]        \n        \n    updating[ind] = 0\n        \n        \n    if (l == lb and r == rb):\n        tree[ind] = value\n        \n        if (ind * 2 < len(tree)):\n            tree[ind * 2], tree[ind * 2 + 1] = value, value\n            updating[ind * 2], updating[ind * 2 + 1] = (value, time), (value, time)\n        \n        \n        while ind != 1:\n            ind //= 2\n            tree[ind] = min(tree[ind * 2], tree[ind * 2 + 1])\n        \n    else:\n        m = (lb + rb) // 2\n        \n        if (l <= m):\n            update(l, min(m, r), ind * 2, lb, m, value)\n        \n        if (r > m):\n            update(max(l, m + 1), r, ind * 2 + 1, m + 1, rb, value)\n        \n        \ndef get(l, r, ind, lb, rb):\n        \n        \n    if updating[ind] and ind * 2 < len(tree):\n        \n        if (not updating[ind * 2] or (updating[ind * 2][1] < updating[ind][1])):\n            tree[ind * 2] = updating[ind][0]\n            updating[ind * 2] = updating[ind][::]\n        \n        if (not updating[ind * 2 + 1] or (updating[ind * 2 + 1][1] < updating[ind][1])):\n            tree[ind * 2 + 1] = updating[ind][0]\n            updating[ind * 2 + 1] = updating[ind][::]\n        \n    updating[ind] = 0\n        \n        \n    if (l == lb and r == rb):\n        return tree[ind]\n    else:\n        m = (lb + rb) // 2\n        ans = float('inf')\n        \n        if (l <= m):\n            ans = get(l, min(m, r), ind * 2, lb, m)\n                    \n        if (r > m):\n            ans = min(ans, get(max(l, m + 1), r, ind * 2 + 1, m + 1, rb))\n        \n        \n        return ans\n\n\n\ndef getvalue(ind):\n    if (ind < len(compress)):\n        return (values[compress[ind] % n + n * (not(compress[ind] % n))])\n    else:\n        return 0\n    \n    \nsize = 1\nwhile (size < len(ar) * 2):\n    size *= 2\n\ntree = [float('inf') for i in range(2 * size)]\nupdating = [0 for i in range (2 * size)]\n\nfor i in range(size, 2 * size):\n    if i - size + 1 in counting:\n        tree[i] = counting[i - size + 1]\n    else:\n        tree[i] = getvalue(i - size + 1)\n\nfor i in range(size - 1, 0, -1):\n    tree[i] = min(tree[i * 2], tree[i * 2 + 1])\n    \n\nfor time in range(m):\n    if questions[time][0] == 1:\n        update(d[questions[time][1]], d[questions[time][2]], 1, 1, size, questions[time][-1])\n    else:\n        stdout.write(str(get(d[questions[time][1]], d[questions[time][2]], 1, 1, size)) + '\\n')\n        \n\n\n\n\n\n\n'''\n3 2\n1 2 3\n5\n2 4 4\n1 4 4 5\n2 4 4\n1 1 6 1\n2 6 6\n'''",
    "prob_desc_created_at": "1493391900",
    "tags": [
        "data structures"
    ],
    "hidden_unit_tests": ""
}
{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"1 2\\n1 2\\n2 2\\n1 3\\n4 4\\n5 5\\n1 1\\n2 2\\n3 11\"]",
    "src_uid": "321423f103e6d9c567079d2dde71b5bb",
    "prob_desc_notes": "NoteIn the first test, there should be only one subarray, which must be equal to the whole array. There are $$$2$$$ elements inside the range $$$[1, 2]$$$ and $$$0$$$ elements outside, if the chosen range is $$$[1, 1]$$$, there will be $$$1$$$ element inside ($$$a_1$$$) and $$$1$$$ element outside ($$$a_2$$$), and the answer will be invalid.In the second test, it is possible to choose the range $$$[2, 2]$$$, and split the array in subarrays $$$(1, 3)$$$ and $$$(4, 4)$$$, in subarray $$$(1, 3)$$$ there are $$$2$$$ elements inside the range ($$$a_2$$$ and $$$a_3$$$) and $$$1$$$ element outside ($$$a_1$$$), in subarray $$$(4, 4)$$$ there is only $$$1$$$ element ($$$a_4$$$), and it is inside the range.In the third test, it is possible to choose the range $$$[5, 5]$$$, and split the array in subarrays $$$(1, 4)$$$, $$$(5, 7)$$$ and $$$(8, 11)$$$, in the subarray $$$(1, 4)$$$ there are $$$3$$$ elements inside the range and $$$1$$$ element outside, in the subarray $$$(5, 7)$$$ there are $$$2$$$ elements inside and $$$1$$$ element outside and in the subarray $$$(8, 11)$$$ there are $$$3$$$ elements inside and $$$1$$$ element outside.",
    "prob_desc_description": "Given an array $$$a$$$ of $$$n$$$ integers, find a range of values $$$[x, y]$$$ ($$$x \\le y$$$), and split $$$a$$$ into exactly $$$k$$$ ($$$1 \\le k \\le n$$$) subarrays in such a way that:  Each subarray is formed by several continuous elements of $$$a$$$, that is, it is equal to $$$a_l, a_{l+1}, \\ldots, a_r$$$ for some $$$l$$$ and $$$r$$$ ($$$1 \\leq l \\leq r \\leq n$$$).  Each element from $$$a$$$ belongs to exactly one subarray.  In each subarray the number of elements inside the range $$$[x, y]$$$ (inclusive) is strictly greater than the number of elements outside the range. An element with index $$$i$$$ is inside the range $$$[x, y]$$$ if and only if $$$x \\le a_i \\le y$$$.  Print any solution that minimizes $$$y - x$$$.",
    "prob_desc_output_spec": "For each test case, print $$$k+1$$$ lines. In the first line, print $$$x$$$ and $$$y$$$ — the limits of the found range. Then print $$$k$$$ lines, the $$$i$$$-th should contain $$$l_i$$$ and $$$r_i$$$ ($$$1\\leq l_i \\leq r_i \\leq n$$$) — the limits of the $$$i$$$-th subarray. You can print the subarrays in any order.",
    "prob_desc_input_spec": "The input consists of multiple test cases. The first line contains a single integer $$$t$$$ ($$$1 \\leq t \\leq 3 \\cdot 10^4$$$) — the number of test cases. Description of the test cases follows. The first line of each test case contains two integers $$$n$$$ and $$$k$$$ ($$$1 \\le k \\le n \\le 2 \\cdot 10^5$$$) — the length of the array $$$a$$$ and the number of subarrays required in the partition. The second line of each test case contains $$$n$$$ integers $$$a_1, a_2, \\ldots, a_n$$$ ($$$1 \\le a_i \\le n$$$) where $$$a_i$$$ is the $$$i$$$-th element of the array. It is guaranteed that the sum of $$$n$$$ over all test cases does not exceed $$$2\\cdot10^5$$$.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3-64",
    "lang_cluster": "Python",
    "difficulty": 1800,
    "file_name": "train_088.jsonl",
    "code_uid": "e5de7bc0a6a1ccfc6e7d03029177be8d",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"3\\n2 1\\n1 2\\n4 2\\n1 2 2 2\\n11 3\\n5 5 5 1 5 5 1 5 5 5 1\"]",
    "exec_outcome": "PASSED",
    "source_code": "import sys\r\nimport os\r\nfrom io import BytesIO, IOBase\r\n\r\n# region fastio\r\nBUFSIZE = 8192\r\n \r\nclass FastIO(IOBase):\r\n    newlines = 0\r\n \r\n    def __init__(self, file):\r\n        self._fd = file.fileno()\r\n        self.buffer = BytesIO()\r\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\r\n        self.write = self.buffer.write if self.writable else None\r\n \r\n    def read(self):\r\n        while True:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            if not b:\r\n                break\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines = 0\r\n        return self.buffer.read()\r\n \r\n    def readline(self):\r\n        while self.newlines == 0:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            self.newlines = b.count(b\"\\n\") + (not b)\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines -= 1\r\n        return self.buffer.readline()\r\n \r\n    def flush(self):\r\n        if self.writable:\r\n            os.write(self._fd, self.buffer.getvalue())\r\n            self.buffer.truncate(0), self.buffer.seek(0)\r\n \r\nclass IOWrapper(IOBase):\r\n    def __init__(self, file):\r\n        self.buffer = FastIO(file)\r\n        self.flush = self.buffer.flush\r\n        self.writable = self.buffer.writable\r\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\r\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\r\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\r\n\r\nif sys.version_info[0] < 3:\r\n    sys.stdin = BytesIO(os.read(0, os.fstat(0).st_size))\r\nelse:\r\n    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\r\n\r\nf = sys.stdin\r\nif os.environ.get('USER') == \"loic\":\r\n    f = open(\"data.in\")\r\n    \r\nline = lambda: f.readline().split()\r\nui = lambda: int(line()[0])\r\nti = lambda: map(int,line())\r\nli = lambda: list(ti())\r\n\r\n#######################################################################\r\n\r\ndef bs_pred_r(predicate, start_l, start_r):\r\n    l = start_l\r\n    r = start_r\r\n    while l <= r:\r\n        mid = (l&r+1) + ((l^r+1)>>1)\r\n        if predicate(mid):\r\n            r = mid-1\r\n        else:\r\n            l = mid+1\r\n    return l\r\n\r\ndef build_ranges(x,y,k):\r\n    res = []\r\n    \r\n    c = 0\r\n    prev = 0\r\n    rem = k\r\n    for i,val in enumerate(A):\r\n        if x <= val <= y:\r\n            c += 1\r\n        if rem > 1:\r\n            sz = i - prev + 1\r\n            if c > sz//2:\r\n                c = 0\r\n                rem -= 1\r\n                res.append((prev,i))\r\n                prev = i+1\r\n    \r\n    res.append((prev,N-1))\r\n    \r\n    return res\r\n\r\ndef solve():\r\n    \r\n    c = [0] * (N+1)\r\n    for val in A:\r\n        c[val] += 1\r\n        \r\n    pref = [0] * (N+1)\r\n    for i in range(1,N+1):\r\n        pref[i] += pref[i-1] + c[i]\r\n    \r\n    x = -10**9\r\n    y = 10**9\r\n    for i,val in enumerate(pref):\r\n        q = K-1 + (N-K+1)//2 + 1\r\n        if val < q:\r\n            continue\r\n        d = val - q + 1\r\n        pred = lambda x: pref[x] >= d\r\n        l = bs_pred_r(pred, 0, N)\r\n        if i-l < y-x:\r\n            x = l\r\n            y = i\r\n    \r\n    res = build_ranges(x, y, K)\r\n    \r\n    return str(x) + \" \" + str(y) + \"\\n\" + \"\\n\".join(str(a+1) + \" \" + str(b+1) for a,b in res)\r\n\r\nfor test in range(1,ui()+1):\r\n    N,K = ti()\r\n    A = li()\r\n\r\n    print(solve())\r\n    \r\nf.close()",
    "prob_desc_created_at": "1643294100",
    "tags": [
        "binary search",
        "constructive algorithms",
        "greedy",
        "two pointers"
    ],
    "hidden_unit_tests": ""
}
{
    "prob_desc_time_limit": "3 seconds",
    "prob_desc_sample_outputs": "[\"? 1 6\\n\\n? 1 3\\n\\n? 4 6\\n\\n? 3 4\\n\\n! 1 2 2 3 3 4\"]",
    "src_uid": "9ce4b5ae7fafe68494aa4c0c560a467c",
    "prob_desc_notes": "NoteThe first query is $$$l=1$$$ and $$$r=6$$$. The mode is $$$2$$$, and $$$2$$$ appears $$$2$$$ times, so $$$x=2$$$ and $$$f=2$$$. Note that $$$3$$$ also appears two times, but $$$2$$$ is outputted because $$$2$$$ is smaller.The second query is $$$l=1$$$ and $$$r=3$$$. The mode is $$$2$$$ and $$$2$$$ appears twice in the subarray with indices $$$[1,3]$$$.The third query is $$$l=4$$$ and $$$r=6$$$. The mode is $$$3$$$ and $$$3$$$ appears twice in the subarray with indices $$$[4,6]$$$.The fourth query is $$$l=3$$$ and $$$r=4$$$. The mode is $$$2$$$, which appears once in the subarray with indices $$$[3,4]$$$. Note that $$$3$$$ also appears once in that range, but $$$2$$$ is smaller than $$$3$$$.",
    "prob_desc_description": "Ray lost his array and needs to find it by asking Omkar. Omkar is willing to disclose that the array has the following qualities:  The array has $$$n$$$ ($$$1 \\le n \\le 2 \\cdot 10^5$$$) elements.  Every element in the array $$$a_i$$$ is an integer in the range $$$1 \\le a_i \\le 10^9.$$$  The array is sorted in nondecreasing order. Ray is allowed to send Omkar a series of queries. A query consists of two integers, $$$l$$$ and $$$r$$$ such that $$$1 \\le l \\le r \\le n$$$. Omkar will respond with two integers, $$$x$$$ and $$$f$$$. $$$x$$$ is the mode of the subarray from index $$$l$$$ to index $$$r$$$ inclusive. The mode of an array is defined by the number that appears the most frequently. If there are multiple numbers that appear the most number of times, the smallest such number is considered to be the mode. $$$f$$$ is the amount of times that $$$x$$$ appears in the queried subarray.The array has $$$k$$$ ($$$1 \\le k \\le \\min(25000,n)$$$) distinct elements. However, due to Ray's sins, Omkar will not tell Ray what $$$k$$$ is. Ray is allowed to send at most $$$4k$$$ queries.Help Ray find his lost array.",
    "prob_desc_output_spec": null,
    "prob_desc_input_spec": "The only line of the input contains a single integer $$$n$$$ ($$$1 \\le n \\le 2 \\cdot 10^5$$$), which equals to the length of the array that you are trying to find.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 2",
    "lang_cluster": "Python",
    "difficulty": 2700,
    "file_name": "train_036.jsonl",
    "code_uid": "1a4d03be5eaef618ae65c1ec0b03ef83",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"6\\n\\n2 2\\n\\n2 2\\n\\n3 2\\n\\n2 1\"]",
    "exec_outcome": "PASSED",
    "source_code": "import os\nimport sys\nfrom __builtin__ import xrange as range\nfrom cStringIO import StringIO\nfrom future_builtins import ascii, filter, hex, map, oct, zip\nfrom io import IOBase\n \nimport __pypy__\n \n \ndef main():\n    rem = {}\n    def query(l,r):\n        if (l,r) not in rem:\n            print '?', l + 1, r\n            sys.stdout.flush()\n            x,f = [int(x) for x in input().split()]\n            rem[l,r] = x,f\n        return rem[l,r]\n \n    n = int(input())\n \n    A = [-1]*n\n    def solve(l,r):\n        if l == r:\n            return\n        mid = l + r >> 1\n \n        x0,f0 = query(l,r)\n        if r - l == f0:\n            for i in range(l,r):\n                A[i] = x0\n            return\n        x1,f1 = query(l,mid)\n        x2,f2 = query(mid,r)\n \n        if x0 == x1 and f0 > f1:\n            for i in range(mid - f1, mid - f1 + f0):\n                A[i] = x0\n            solve(l, mid - f1)\n            solve(mid - f1 + f0, r)\n        elif x0 == x2 and f0 > f2:\n            for i in range(mid + f2 - f0, mid + f2):\n                A[i] = x0\n            solve(l, mid + f2 - f0)\n            solve(mid + f2, r)\n        else:\n            solve(l,mid)\n            solve(mid,r)\n    solve(0,n)\n    print '!', ' '.join(str(a) for a in A)\n \n \n# region fastio\n \nBUFSIZE = 8192\n \n \nclass FastI(IOBase):\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self._buffer = StringIO()\n        self.newlines = 0\n \n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n \n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(\"\\n\") + (not b)\n            ptr = self._buffer.tell()\n            self._buffer.seek(0, 2), self._buffer.write(b), self._buffer.seek(ptr)\n        self.newlines -= 1\n        return self._buffer.readline()\n \n \nclass FastO(IOBase):\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self._buffer = __pypy__.builders.StringBuilder()\n        self.write = lambda s: self._buffer.append(s)\n \n    def flush(self):\n        os.write(self._fd, self._buffer.build())\n        self._buffer = __pypy__.builders.StringBuilder()\n \n \nsys.stdin, sys.stdout = FastI(sys.stdin), FastO(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n \n# endregion\n \nif __name__ == \"__main__\":\n    main()",
    "prob_desc_created_at": "1594479900",
    "tags": [
        "binary search",
        "divide and conquer",
        "interactive"
    ],
    "hidden_unit_tests": ""
}
{
    "prob_desc_time_limit": "1 second",
    "prob_desc_sample_outputs": "[\"YES\\nNO\\nYES\\nYES\\nNO\"]",
    "src_uid": "dd098a17343a02fa5dc0d2d6cea853c7",
    "prob_desc_notes": "NoteLet $$$f_t(c)$$$ represent the frequency of character $$$c$$$ in string $$$t$$$.For the first testcase we have $$$t$$$$$$f_t(a)$$$$$$f_t(b)$$$$$$a$$$$$$1$$$$$$0$$$$$$ab$$$$$$1$$$$$$1$$$$$$aba$$$$$$2$$$$$$1$$$$$$b$$$$$$0$$$$$$1$$$$$$ba$$$$$$1$$$$$$1$$$ It can be seen that for any substring $$$t$$$ of $$$s$$$, the difference between $$$f_t(a)$$$ and $$$f_t(b)$$$ is not more than $$$1$$$. Hence the string $$$s$$$ is perfectly balanced.For the second testcase we have $$$t$$$$$$f_t(a)$$$$$$f_t(b)$$$$$$a$$$$$$1$$$$$$0$$$$$$ab$$$$$$1$$$$$$1$$$$$$abb$$$$$$1$$$$$$2$$$$$$b$$$$$$0$$$$$$1$$$$$$bb$$$$$$0$$$$$$2$$$ It can be seen that for the substring $$$t=bb$$$, the difference between $$$f_t(a)$$$ and $$$f_t(b)$$$ is $$$2$$$ which is greater than $$$1$$$. Hence the string $$$s$$$ is not perfectly balanced.For the third testcase we have $$$t$$$$$$f_t(a)$$$$$$f_t(b)$$$$$$f_t(c)$$$$$$a$$$$$$1$$$$$$0$$$$$$0$$$$$$ab$$$$$$1$$$$$$1$$$$$$0$$$$$$abc$$$$$$1$$$$$$1$$$$$$1$$$$$$b$$$$$$0$$$$$$1$$$$$$0$$$$$$bc$$$$$$0$$$$$$1$$$$$$1$$$$$$c$$$$$$0$$$$$$0$$$$$$1$$$It can be seen that for any substring $$$t$$$ of $$$s$$$ and any two characters $$$u,v\\in\\{a,b,c\\}$$$, the difference between $$$f_t(u)$$$ and $$$f_t(v)$$$ is not more than $$$1$$$. Hence the string $$$s$$$ is perfectly balanced.",
    "prob_desc_description": "Let's call a string $$$s$$$ perfectly balanced if for all possible triplets $$$(t,u,v)$$$ such that $$$t$$$ is a non-empty substring of $$$s$$$ and $$$u$$$ and $$$v$$$ are characters present in $$$s$$$, the difference between the frequencies of $$$u$$$ and $$$v$$$ in $$$t$$$ is not more than $$$1$$$.For example, the strings \"aba\" and \"abc\" are perfectly balanced but \"abb\" is not because for the triplet (\"bb\",'a','b'), the condition is not satisfied.You are given a string $$$s$$$ consisting of lowercase English letters only. Your task is to determine whether $$$s$$$ is perfectly balanced or not.A string $$$b$$$ is called a substring of another string $$$a$$$ if $$$b$$$ can be obtained by deleting some characters (possibly $$$0$$$) from the start and some characters (possibly $$$0$$$) from the end of $$$a$$$.",
    "prob_desc_output_spec": "For each test case, print \"YES\" if $$$s$$$ is a perfectly balanced string, and \"NO\" otherwise. You may print each letter in any case (for example, \"YES\", \"Yes\", \"yes\", \"yEs\" will all be recognized as positive answer).",
    "prob_desc_input_spec": "The first line of input contains a single integer $$$t$$$ ($$$1\\leq t\\leq 2\\cdot 10^4$$$) denoting the number of testcases. Each of the next $$$t$$$ lines contain a single string $$$s$$$ ($$$1\\leq |s|\\leq 2\\cdot 10^5$$$), consisting of lowercase English letters. It is guaranteed that the sum of $$$|s|$$$ over all testcases does not exceed $$$2\\cdot 10^5$$$.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3-64",
    "lang_cluster": "Python",
    "difficulty": 1100,
    "file_name": "train_096.jsonl",
    "code_uid": "7201957b9c592357e6750fe48885049d",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"5\\naba\\nabb\\nabc\\naaaaa\\nabcba\"]",
    "exec_outcome": "PASSED",
    "source_code": "# cook your dish here\r\n#!/usr/bin/env python\r\nfrom bisect import bisect_left\r\nimport os\r\nfrom math import ceil, factorial, fmod,pi,sqrt\r\nfrom pickle import FALSE\r\nfrom re import T\r\nfrom select import select\r\nimport sys\r\nfrom collections import Counter\r\nfrom io import BytesIO, IOBase, StringIO\r\ndef modFact(n, p):\r\n    if n >= p:\r\n        return 0   \r\n \r\n    result = 1\r\n    for i in range(1, n + 1):\r\n        result = (result * i) % p\r\n \r\n    return result\r\n \r\ndef calculate(p, q):\r\n     \r\n    mod = 998244353\r\n    expo = 0\r\n    expo = mod - 2\r\n \r\n    # Loop to find the value\r\n    # until the expo is not zero\r\n    while (expo):\r\n \r\n        # Multiply p with q\r\n        # if expo is odd\r\n        if (expo & 1):\r\n            p = (p * q) % mod\r\n        q = (q * q) % mod\r\n \r\n        # Reduce the value of\r\n        # expo by 2\r\n        expo >>= 1\r\n \r\n    return p\r\ndef compute_gcd(x, y):\r\n\r\n   while(y):\r\n       x, y = y, x % y\r\n   return x\r\n\r\n# This function computes LCM\r\ndef compute_lcm(x, y):\r\n   lcm = (x*y)//compute_gcd(x,y)\r\n   return lcm\r\n\r\ndef read_arr():\r\n    return [int(x) for x in input().split()]\r\n\r\ndef bin_search(num, arr):\r\n    start = 0\r\n    end = len(arr)-1\r\n    while start <= end:\r\n        mid=(start+end)//2\r\n        if arr[mid] == num:\r\n            return mid\r\n        elif arr[mid] > num:\r\n            end= mid-1\r\n        else:\r\n            start = mid + 1\r\n    return -1\r\n\r\n\r\ndef factors(n) :\r\n     \r\n    # Note that this loop runs till square root\r\n    i = 1\r\n    ans=[]\r\n    while i <= sqrt(n):\r\n         \r\n        if (n % i == 0) :\r\n             \r\n            # If divisors are equal, print only one\r\n            if (n / i == i) :\r\n                ans.append(i)\r\n            else :\r\n                # Otherwise print both\r\n                \r\n                ans.append(i)\r\n                ans.append(int(n/i))\r\n        i = i + 1\r\n    return ans\r\n\r\ndef is_palindrome(n):\r\n    for j in range(len(n)//2):\r\n        if n[j]!=n[len(n)-j-1]:\r\n            return False\r\n    return True\r\ndef fine(arr):\r\n    pres = []\r\n    string = \"\"\r\n    for j in arr:\r\n        for k in j:\r\n            string += k \r\n    j = 0\r\n    while j < len(string):\r\n        if string[j] not in pres:\r\n            pres.append(string[j])\r\n            while string[j]==pres[-1]:\r\n                j += 1\r\n                if j == len(string):\r\n                    break \r\n        else:\r\n            return False \r\n    return True\r\n\r\n\r\ndef main():\r\n    for i in range(int(input())):\r\n        string = [x for x in input()]\r\n        sets =set(string)\r\n        ans=\"YES\"\r\n        for j in range(len(string)-len(sets)+1):\r\n            pres = set()\r\n            for k in range(j,j+len(sets)):\r\n                pres.add(string[k])\r\n            if pres!=sets:\r\n                ans=\"NO\"\r\n                break \r\n        print(ans)\r\n\r\n\r\n        \r\n# 1 0 0 0 1 1\r\n# zero -> 0 0 1 1 0 0\r\n# one -> 1 1 1 0 1 1\r\n# zero -> 0 0 0 0 0 0\r\n# one -> 1 1 1 1 1 0\r\n                                   \r\n \r\nBUFSIZE = 8192\r\n \r\n \r\nclass FastIO(IOBase):\r\n    newlines = 0\r\n \r\n    def __init__(self, file):\r\n        self._fd = file.fileno()\r\n        self.buffer = BytesIO()\r\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\r\n        self.write = self.buffer.write if self.writable else None\r\n \r\n    def read(self):\r\n        while True:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            if not b:\r\n                break\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines = 0\r\n        return self.buffer.read()\r\n \r\n    def readline(self):\r\n        while self.newlines == 0:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            self.newlines = b.count(b\"\\n\") + (not b)\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines -= 1\r\n        return self.buffer.readline()\r\n \r\n    def flush(self):\r\n        if self.writable:\r\n            os.write(self._fd, self.buffer.getvalue())\r\n            self.buffer.truncate(0), self.buffer.seek(0)\r\n \r\n \r\nclass IOWrapper(IOBase):\r\n    def __init__(self, file):\r\n        self.buffer = FastIO(file)\r\n        self.flush = self.buffer.flush\r\n        self.writable = self.buffer.writable\r\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\r\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\r\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\r\n \r\n \r\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\r\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\r\n \r\n# endregion\r\n \r\nif __name__ == \"__main__\":\r\n    main()",
    "prob_desc_created_at": "1651329300",
    "tags": [
        "brute force",
        "greedy",
        "strings"
    ],
    "hidden_unit_tests": ""
}
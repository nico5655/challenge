{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"2\\n1 0\", \"-1\", \"3\\n9 4 0\"]",
    "src_uid": "6f8de802d2b6b0f48f2be0531b3ac8d4",
    "prob_desc_notes": "NoteIn the first example, Gorf is on the bottom of the well and jump to the height $$$1$$$ meter below ground level. After that he slip down by meter and stays on height $$$2$$$ meters below ground level. Now, from here, he can reach ground level in one jump.In the second example, Gorf can jump to one meter below ground level, but will slip down back to the bottom of the well. That's why he can't reach ground level.In the third example, Gorf can reach ground level only from the height $$$5$$$ meters below the ground level. And Gorf can reach this height using a series of jumps $$$10 \\Rightarrow 9 \\dashrightarrow 9 \\Rightarrow 4 \\dashrightarrow 5$$$ where $$$\\Rightarrow$$$ is the jump and $$$\\dashrightarrow$$$ is slipping during breaks.",
    "prob_desc_description": "Frog Gorf is traveling through Swamp kingdom. Unfortunately, after a poor jump, he fell into a well of $$$n$$$ meters depth. Now Gorf is on the bottom of the well and has a long way up.The surface of the well's walls vary in quality: somewhere they are slippery, but somewhere have convenient ledges. In other words, if Gorf is on $$$x$$$ meters below ground level, then in one jump he can go up on any integer distance from $$$0$$$ to $$$a_x$$$ meters inclusive. (Note that Gorf can't jump down, only up).Unfortunately, Gorf has to take a break after each jump (including jump on $$$0$$$ meters). And after jumping up to position $$$x$$$ meters below ground level, he'll slip exactly $$$b_x$$$ meters down while resting.Calculate the minimum number of jumps Gorf needs to reach ground level.",
    "prob_desc_output_spec": "If Gorf can't reach ground level, print $$$-1$$$. Otherwise, firstly print integer $$$k$$$ — the minimum possible number of jumps. Then print the sequence $$$d_1,\\,d_2,\\,\\ldots,\\,d_k$$$ where $$$d_j$$$ is the depth Gorf'll reach after the $$$j$$$-th jump, but before he'll slip down during the break. Ground level is equal to $$$0$$$. If there are multiple answers, print any of them.",
    "prob_desc_input_spec": "The first line contains a single integer $$$n$$$ ($$$1 \\le n \\le 300\\,000$$$) — the depth of the well. The second line contains $$$n$$$ integers $$$a_1, a_2, \\ldots, a_n$$$ ($$$0 \\le a_i \\le i$$$), where $$$a_i$$$ is the maximum height Gorf can jump from $$$i$$$ meters below ground level. The third line contains $$$n$$$ integers $$$b_1, b_2, \\ldots, b_n$$$ ($$$0 \\le b_i \\le n - i$$$), where $$$b_i$$$ is the distance Gorf will slip down if he takes a break on $$$i$$$ meters below ground level.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3-64",
    "lang_cluster": "Python",
    "difficulty": 1900,
    "file_name": "train_092.jsonl",
    "code_uid": "fbae864d06746c3b0087d32e74821964",
    "prob_desc_memory_limit": "512 megabytes",
    "prob_desc_sample_inputs": "[\"3\\n0 2 2\\n1 1 0\", \"2\\n1 1\\n1 0\", \"10\\n0 1 2 3 5 5 6 7 8 5\\n9 8 7 1 5 4 3 2 0 0\"]",
    "exec_outcome": "PASSED",
    "source_code": "from sys import stdin, stdout\r\nimport sys\r\nimport heapq\r\nfrom collections import defaultdict\r\nimport math\r\nimport bisect\r\nimport io, os\r\n# from cffi import FFI\r\nimport copy\r\nimport itertools\r\n\r\n# for interactive problem\r\n# n = int(stdin.readline())\r\n# print(x, flush=True)\r\n\r\ninput = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline\r\n\r\ndef ncr(n, r, p):\r\n    # initialize numerator\r\n    # and denominator\r\n    num = den = 1\r\n    for i in range(r):\r\n        num = (num * (n - i)) % p\r\n        den = (den * (i + 1)) % p\r\n    return (num * pow(den,\r\n            p - 2, p)) % p\r\n\r\n#input = sys.stdin.buffer.readline\r\n\r\n# ffi = FFI()\r\n# ffi.cdef(\r\n#     \"\"\"\r\n#     typedef struct {\r\n#         long long suf;\r\n#         long long pre;\r\n#         long long maxi;\r\n#         bool is_plus;\r\n#         long long lowest;\r\n#         long long sum;\r\n#         int length;\r\n#     } node_t;\r\n#     \"\"\"\r\n# )\r\n#\r\n# MX = 2 << ((2 * 10 ** 5) - 1).bit_length()\r\n# data = ffi.new(\"node_t[]\", MX + 3)\r\n# data[MX] = (0, 0, 0, True, 0, 0, 0)\r\n# id_node = data[MX]\r\n# res_left = MX + 1\r\n# res_right = MX + 2\r\n#\r\n# def combine(a, b):\r\n#     if a.length == 0:\r\n#         return b\r\n#     if b.length == 0:\r\n#         return a\r\n#\r\n#     length = a.length + b.length\r\n#     if a.is_plus:\r\n#         pre = a.sum + b.pre\r\n#     else:\r\n#         pre = a.pre\r\n#     if b.is_plus:\r\n#         suf = a.suf + b.sum\r\n#     else:\r\n#         suf = b.suf\r\n#     is_plus = a.is_plus and b.is_plus\r\n#     sum = a.sum + b.sum\r\n#     maxi = max(a.maxi, b.maxi, a.suf + b.pre)\r\n#     lowest = min(a.lowest, a.sum + b.lowest)\r\n#     return (suf, pre, maxi, is_plus, lowest, sum, length)\r\n#\r\n# def mapValue(x):\r\n#     return (max(x, 0), max(x, 0), max(x, 0), (x >= 0), x, x, 1)\r\n#\r\n# class SegmentTree:\r\n#     def __init__(self, N, A):\r\n#         self._len = N\r\n#         self._size = _size = 1 << (self._len - 1).bit_length()\r\n#         for i in range(2 * _size):\r\n#             data[i] = id_node\r\n#         for i, x in enumerate(A):\r\n#             data[_size + i] = mapValue(x)\r\n#         for i in reversed(range(_size)):\r\n#             data[i] = combine(data[i + i], data[i + i + 1])\r\n#\r\n#     def __delitem__(self, idx):\r\n#         self[idx] = id_node\r\n#\r\n#     def __getitem__(self, idx):\r\n#         return data[idx + self._size]\r\n#\r\n#     def __setitem__(self, idx, value):\r\n#         idx += self._size\r\n#         data[idx] = value\r\n#         idx >>= 1\r\n#         while idx:\r\n#             data[idx] = combine(data[2 * idx], data[2 * idx + 1])\r\n#             idx >>= 1\r\n#\r\n#     def __len__(self):\r\n#         return self._len\r\n#\r\n#     def query(self, start, stop):\r\n#         \"\"\"func of data[start, stop)\"\"\"\r\n#         start += self._size\r\n#         stop += self._size\r\n#         data[res_left] = id_node\r\n#         data[res_right] = id_node\r\n#         while start < stop:\r\n#             if start & 1:\r\n#                 data[res_left] = combine(data[res_left], data[start])\r\n#                 start += 1\r\n#             if stop & 1:\r\n#                 stop -= 1\r\n#                 data[res_right] = combine(data[stop], data[res_right])\r\n#             start >>= 1\r\n#             stop >>= 1\r\n#         data[res_left] = combine(data[res_left], data[res_right])\r\n#         return data[res_left]\r\n\r\n# def main():\r\n#     n, q = map(int, stdin.readline().split())\r\n#     segtree = SegmentTree(n, map(int, stdin.readline().split()))\r\n#     ans = []\r\n#     for _ in range(q):\r\n#         t, l, r = map(int, stdin.readline().split())\r\n#         l -= 1\r\n#         if t == 1:\r\n#             segtree[l] = mapValue(r)\r\n#         else:\r\n#             ans.append(int(segtree.query(l, r).ans))\r\n#     print(\"\\n\".join(map(str, ans)))\r\n\r\ndef kbits(n, k):\r\n    result = []\r\n    for bits in itertools.combinations(range(n), k):\r\n        s = ['0'] * n\r\n        for bit in bits:\r\n            s[bit] = '1'\r\n        result.append(''.join(s))\r\n    return result\r\n\r\n\r\ndef main():\r\n    n = int(input())\r\n    a = list(map(int, input().split()))\r\n    b = list(map(int, input().split()))\r\n    dp = [math.inf] * n\r\n    dp[-1] = 0\r\n    prev = [math.inf] * n\r\n    prev_p = [math.inf] * n\r\n    ans = math.inf\r\n    prev_ans = -1\r\n    sched = n-1\r\n    stack = [n-1]\r\n    while stack:\r\n        temp = []\r\n        for i in stack:\r\n            x = max(i - a[i], 0)\r\n            if i - a[i] < 0:\r\n                if ans > dp[i]+1:\r\n                    ans = dp[i]+1\r\n                    prev_ans = i\r\n                ans = min(dp[i]+1, ans)\r\n            for j in range(x, sched):\r\n                pos = j + b[j]\r\n                if dp[pos] > dp[i] + 1:\r\n                    dp[pos] = dp[i] + 1\r\n                    prev[pos] = i\r\n                    prev_p[pos] = j\r\n                    temp.append(pos)\r\n            sched =min(x, sched)\r\n        stack =temp\r\n    if ans == math.inf:\r\n        ans = -1\r\n    stdout.write(str(ans)+\"\\n\")\r\n    if ans != -1:\r\n        arr = [-1]\r\n        while prev_ans != math.inf:\r\n            if prev_ans != -1:\r\n                arr.append(prev_p[prev_ans])\r\n            prev_ans = prev[prev_ans]\r\n        stdout.write(\" \".join([str(x+1) for x in reversed(arr[:-1])]) + \"\\n\")\r\n\r\n\r\nmain()",
    "prob_desc_created_at": "1635143700",
    "tags": [
        "data structures",
        "dp",
        "graphs",
        "greedy",
        "shortest paths"
    ],
    "hidden_unit_tests": ""
}
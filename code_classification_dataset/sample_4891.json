{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"2\\n1 2 3\\n3 4 5\\n-1\\n0\"]",
    "src_uid": "c3ee6419adfc85c80f35ecfdea6b0d43",
    "prob_desc_notes": "NoteIn the first example, the array becomes $$$[-6,-4,2,-1,2]$$$ after the first operation,$$$[-6,-4,-3,-1,2]$$$ after the second operation.In the second example, it is impossible to make the array sorted after any sequence of operations.In the third example, the array is already sorted, so we don't need to perform any operations.",
    "prob_desc_description": "You are given an array $$$a$$$ of $$$n$$$ elements. Your can perform the following operation no more than $$$n$$$ times: Select three indices $$$x,y,z$$$ $$$(1 \\leq x &lt; y &lt; z \\leq n)$$$ and replace $$$a_x$$$ with $$$a_y - a_z$$$. After the operation, $$$|a_x|$$$ need to be less than $$$10^{18}$$$.Your goal is to make the resulting array non-decreasing. If there are multiple solutions, you can output any. If it is impossible to achieve, you should report it as well.",
    "prob_desc_output_spec": "For each test case, print $$$-1$$$ in a single line if there is no solution. Otherwise in the first line you should print a single integer $$$m$$$ $$$(0 \\leq m \\leq n)$$$ — number of operations you performed. Then the $$$i$$$-th of the following $$$m$$$ lines should contain three integers $$$x,y,z$$$ $$$(1 \\leq x &lt; y &lt; z \\leq n)$$$— description of the $$$i$$$-th operation. If there are multiple solutions, you can output any. Note that you don't have to minimize the number of operations in this task.",
    "prob_desc_input_spec": "Each test contains multiple test cases. The first line will contain a single integer $$$t$$$ $$$(1 \\leq t \\leq 10000)$$$ — the number of test cases. Then $$$t$$$ test cases follow. The first line of each test case contains a single integer $$$n$$$ $$$(3 \\leq n \\leq 2 \\cdot 10^5)$$$ — the size of the array $$$a$$$. The second line of each test case contains $$$n$$$ integers $$$a_1, a_2, \\ldots ,a_n$$$ $$$(-10^9 \\leq a_i \\leq 10^9)$$$, the elements of $$$a$$$. It is guaranteed that the sum of $$$n$$$ over all test cases does not exceed $$$2 \\cdot 10^5$$$.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3",
    "lang_cluster": "Python",
    "difficulty": 1200,
    "file_name": "train_108.jsonl",
    "code_uid": "a930d12e897b28cbfe28c3d9dbe2f971",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"3\\n5\\n5 -4 2 -1 2\\n3\\n4 3 2\\n3\\n-3 -2 -1\"]",
    "exec_outcome": "PASSED",
    "source_code": "import array\r\nimport bisect\r\nimport heapq\r\nimport math\r\nimport collections\r\nimport sys\r\nimport copy\r\nfrom functools import reduce\r\nimport decimal\r\nfrom io import BytesIO, IOBase\r\nimport os\r\nimport itertools\r\nimport functools\r\nfrom types import GeneratorType\r\nimport fractions\r\n\r\n# sys.setrecursionlimit(10 ** 9)\r\ndecimal.getcontext().rounding = decimal.ROUND_HALF_UP\r\n\r\ngraphDict = collections.defaultdict\r\n\r\nqueue = collections.deque\r\n\r\n\r\n################## pypy deep recursion handling ##############\r\n# Author = @pajenegod\r\ndef bootstrap(f, stack=[]):\r\n    def wrappedfunc(*args, **kwargs):\r\n        to = f(*args, **kwargs)\r\n        if stack:\r\n            return to\r\n        else:\r\n            while True:\r\n                if type(to) is GeneratorType:\r\n                    stack.append(to)\r\n                    to = next(to)\r\n                else:\r\n                    stack.pop()\r\n                    if not stack:\r\n                        return to\r\n                    to = stack[-1].send(to)\r\n\r\n    return wrappedfunc\r\n\r\n\r\n################## Graphs ###################\r\nclass Graphs:\r\n    def __init__(self):\r\n        self.graph = graphDict(set)\r\n\r\n    def add_edge(self, u, v):\r\n        self.graph[u].add(v)\r\n        self.graph[v].add(u)\r\n\r\n    def dfs_utility(self, nodes, visited_nodes, colors, parity, level):\r\n        global count\r\n        if nodes == 1:\r\n            colors[nodes] = -1\r\n        else:\r\n            if len(self.graph[nodes]) == 1 and parity % 2 == 0:\r\n                if q == 1:\r\n                    colors[nodes] = 1\r\n                else:\r\n                    colors[nodes] = -1\r\n                    count += 1\r\n            else:\r\n                if parity % 2 == 0:\r\n                    colors[nodes] = -1\r\n                else:\r\n                    colors[nodes] = 1\r\n        visited_nodes.add(nodes)\r\n        for neighbour in self.graph[nodes]:\r\n            new_level = level + 1\r\n            if neighbour not in visited_nodes:\r\n                self.dfs_utility(neighbour, visited_nodes, colors, level - 1, new_level)\r\n\r\n    def dfs(self, node):\r\n        Visited = set()\r\n        color = collections.defaultdict()\r\n        self.dfs_utility(node, Visited, color, 0, 0)\r\n        return color\r\n\r\n    def bfs(self, node, f_node):\r\n        count = float(\"inf\")\r\n        visited = set()\r\n        level = 0\r\n        if node not in visited:\r\n            queue.append([node, level])\r\n            visited.add(node)\r\n        flag = 0\r\n        while queue:\r\n            parent = queue.popleft()\r\n            if parent[0] == f_node:\r\n                flag = 1\r\n                count = min(count, parent[1])\r\n            level = parent[1] + 1\r\n            for item in self.graph[parent[0]]:\r\n                if item not in visited:\r\n                    queue.append([item, level])\r\n                    visited.add(item)\r\n        return count if flag else -1\r\n        return False\r\n\r\n\r\n################### Tree Implementaion ##############\r\nclass Tree:\r\n    def __init__(self, data):\r\n        self.data = data\r\n        self.left = None\r\n        self.right = None\r\n\r\n\r\ndef inorder(node, lis):\r\n    if node:\r\n        inorder(node.left, lis)\r\n        lis.append(node.data)\r\n        inorder(node.right, lis)\r\n    return lis\r\n\r\n\r\ndef leaf_node_sum(root):\r\n    if root is None:\r\n        return 0\r\n    if root.left is None and root.right is None:\r\n        return root.data\r\n    return leaf_node_sum(root.left) + leaf_node_sum(root.right)\r\n\r\n\r\ndef hight(root):\r\n    if root is None:\r\n        return -1\r\n    if root.left is None and root.right is None:\r\n        return 0\r\n    return max(hight(root.left), hight(root.right)) + 1\r\n\r\n\r\n################## Union Find #######################\r\nclass UnionFind():\r\n    parents = []\r\n    sizes = []\r\n    count = 0\r\n\r\n    def __init__(self, n):\r\n        self.count = n\r\n        self.parents = [i for i in range(n)]\r\n        self.sizes = [1 for i in range(n)]\r\n\r\n    def find(self, i):\r\n        if self.parents[i] == i:\r\n            return i\r\n        else:\r\n            self.parents[i] = self.find(self.parents[i])\r\n            return self.parents[i]\r\n\r\n    def unite(self, i, j):\r\n        root_i = self.find(i)\r\n        root_j = self.find(j)\r\n        if root_i == root_j:\r\n            return\r\n        elif root_i < root_j:\r\n            self.parents[root_j] = root_i\r\n            self.sizes[root_i] += self.sizes[root_j]\r\n        else:\r\n            self.parents[root_i] = root_j\r\n            self.sizes[root_j] += self.sizes[root_i]\r\n\r\n    def same(self, i, j):\r\n        return self.find(i) == self.find(j)\r\n\r\n    def size(self, i):\r\n        return self.sizes[self.find(i)]\r\n\r\n    def group_count(self):\r\n        return len(set(self.find(i) for i in range(self.count)))\r\n\r\n    def answer(self, extra, p, q):\r\n        dic = collections.Counter()\r\n        for q in range(n):\r\n            dic[self.find(q)] = self.size(q)\r\n        hq = list(dic.values())\r\n        heapq._heapify_max(hq)\r\n        ans = -1\r\n        for z in range(extra + 1):\r\n            if hq:\r\n                ans += heapq._heappop_max(hq)\r\n            else:\r\n                break\r\n        return ans\r\n\r\n\r\n#################################################\r\n\r\ndef rounding(n):\r\n    return int(decimal.Decimal(f'{n}').to_integral_value())\r\n\r\n\r\ndef factors(n):\r\n    return set(reduce(list.__add__,\r\n                      ([i, n // i] for i in range(1, int(n ** 0.5) + 1) if n % i == 0), [1]))\r\n\r\n\r\ndef p_sum(array):\r\n    return list(itertools.accumulate(array))\r\n\r\n\r\ndef base_change(nn, bb):\r\n    if nn == 0:\r\n        return [0]\r\n    digits = []\r\n    while nn:\r\n        digits.append(int(nn % bb))\r\n        nn //= bb\r\n    return digits[::-1]\r\n\r\n\r\ndef diophantine(a: int, b: int, c: int):\r\n    d, x, y = extended_gcd(a, b)\r\n    r = c // d\r\n    return r * x, r * y\r\n\r\n\r\n@bootstrap\r\ndef extended_gcd(a: int, b: int):\r\n    if b == 0:\r\n        d, x, y = a, 1, 0\r\n    else:\r\n        (d, p, q) = yield extended_gcd(b, a % b)\r\n        x = q\r\n        y = p - q * (a // b)\r\n\r\n    yield d, x, y\r\n\r\n\r\n######################################################################################\r\n\r\n'''\r\nKnowledge and awareness are vague, and perhaps better called illusions.\r\nEveryone lives within their own subjective interpretation.\r\n                                                            ~Uchiha Itachi\r\n'''\r\n\r\n################################ <fast I/O> ###########################################\r\nBUFSIZE = 8192\r\n\r\n\r\nclass FastIO(IOBase):\r\n    newlines = 0\r\n\r\n    def __init__(self, file):\r\n        self._fd = file.fileno()\r\n        self.buffer = BytesIO()\r\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\r\n        self.write = self.buffer.write if self.writable else None\r\n\r\n    def read(self):\r\n        while True:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            if not b:\r\n                break\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines = 0\r\n        return self.buffer.read()\r\n\r\n    def readline(self, **kwargs):\r\n        while self.newlines == 0:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            self.newlines = b.count(b\"\\n\") + (not b)\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines -= 1\r\n        return self.buffer.readline()\r\n\r\n    def flush(self):\r\n        if self.writable:\r\n            os.write(self._fd, self.buffer.getvalue())\r\n            self.buffer.truncate(0), self.buffer.seek(0)\r\n\r\n\r\nclass IOWrapper(IOBase):\r\n    def __init__(self, file):\r\n        self.buffer = FastIO(file)\r\n        self.flush = self.buffer.flush\r\n        self.writable = self.buffer.writable\r\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\r\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\r\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\r\n\r\n\r\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\r\n\r\n\r\n#############################################<I/O Region >##############################################\r\n\r\n\r\ndef inp():\r\n    return sys.stdin.readline().strip()\r\n\r\n\r\ndef map_inp(v_type):\r\n    return map(v_type, inp().split())\r\n\r\n\r\ndef list_inp(v_type):\r\n    return list(map_inp(v_type))\r\n\r\n\r\ndef interactive():\r\n    return sys.stdout.flush()\r\n\r\n\r\n######################################## Solution ####################################\r\n\r\nfor _ in range(int(inp())):\r\n    n = int(inp())\r\n    arr = list_inp(int)\r\n    if arr[-1] < arr[-2]:\r\n        print(-1)\r\n    elif arr == list(sorted(arr)):\r\n        print(0)\r\n    else:\r\n        arr.reverse()\r\n        maxi = arr[0]\r\n        mini = arr[1]\r\n        max_ind = n\r\n        ans = []\r\n        count = 0\r\n        for i in range(2, n):\r\n            arr[i] = arr[1] - maxi\r\n            ans.append([n - i, n - 1, n])\r\n            count += 1\r\n        arr.reverse()\r\n        if arr == list(sorted(arr)):\r\n            print(count)\r\n            for item in ans:\r\n                print(*item)\r\n        else:\r\n            print(-1)\r\n",
    "prob_desc_created_at": "1645367700",
    "tags": [
        "constructive algorithms",
        "greedy"
    ],
    "hidden_unit_tests": ""
}
{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"5.000000000000000\\n3.000000000000000\\n0.000000000000000\\n1.500000000000000\\n2.000000000000000\"]",
    "src_uid": "2863d7304de4a07a8f6cd95bffaf590c",
    "prob_desc_notes": "Note  The 1-st point is always in the shade;  the 2-nd point is in the shade while light source is moving from $$$(3, -3)$$$ to $$$(6, -3)$$$;  the 3-rd point is in the shade while light source is at point $$$(6, -3)$$$.  the 4-th point is in the shade while light source is moving from $$$(1, -3)$$$ to $$$(2.5, -3)$$$ and at point $$$(6, -3)$$$;  the 5-th point is in the shade while light source is moving from $$$(1, -3)$$$ to $$$(2.5, -3)$$$ and from $$$(5.5, -3)$$$ to $$$(6, -3)$$$; ",
    "prob_desc_description": "There is a light source on the plane. This source is so small that it can be represented as point. The light source is moving from point $$$(a, s_y)$$$ to the $$$(b, s_y)$$$ $$$(s_y &lt; 0)$$$ with speed equal to $$$1$$$ unit per second. The trajectory of this light source is a straight segment connecting these two points. There is also a fence on $$$OX$$$ axis represented as $$$n$$$ segments $$$(l_i, r_i)$$$ (so the actual coordinates of endpoints of each segment are $$$(l_i, 0)$$$ and $$$(r_i, 0)$$$). The point $$$(x, y)$$$ is in the shade if segment connecting $$$(x,y)$$$ and the current position of the light source intersects or touches with any segment of the fence.  You are given $$$q$$$ points. For each point calculate total time of this point being in the shade, while the light source is moving from $$$(a, s_y)$$$ to the $$$(b, s_y)$$$.",
    "prob_desc_output_spec": "Print $$$q$$$ lines. The $$$i$$$-th line should contain one real number — total time of the $$$i$$$-th point being in the shade, while the light source is moving from $$$(a, s_y)$$$ to the $$$(b, s_y)$$$. The answer is considered as correct if its absolute of relative error doesn't exceed $$$10^{-6}$$$.",
    "prob_desc_input_spec": "First line contains three space separated integers $$$s_y$$$, $$$a$$$ and $$$b$$$ ($$$-10^9 \\le s_y &lt; 0$$$, $$$1 \\le a &lt; b \\le 10^9$$$) — corresponding coordinates of the light source. Second line contains single integer $$$n$$$ ($$$1 \\le n \\le 2 \\cdot 10^5$$$) — number of segments in the fence. Next $$$n$$$ lines contain two integers per line: $$$l_i$$$ and $$$r_i$$$ ($$$1 \\le l_i &lt; r_i \\le 10^9$$$, $$$r_{i - 1} &lt; l_i$$$) — segments in the fence in increasing order. Segments don't intersect or touch each other. Next line contains single integer $$$q$$$ ($$$1 \\le q \\le 2 \\cdot 10^5$$$) — number of points to check. Next $$$q$$$ lines contain two integers per line: $$$x_i$$$ and $$$y_i$$$ ($$$1 \\le x_i, y_i \\le 10^9$$$) — points to process.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 2",
    "lang_cluster": "Python",
    "difficulty": 2400,
    "file_name": "train_056.jsonl",
    "code_uid": "970ad33eb15b8e23250c2b5a384d1b58",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"-3 1 6\\n2\\n2 4\\n6 7\\n5\\n3 1\\n1 3\\n6 1\\n6 4\\n7 6\"]",
    "exec_outcome": "PASSED",
    "source_code": "from __future__ import division\nimport sys\nrange = xrange\ninput = sys.stdin.readline\n\nsy,a,b = [int(x) for x in input().split()]\n\nn = int(input())\n\ninp = [int(x) for line in sys.stdin for x in line.split()]\nii = 0\n\nL = []\nR = []\nfor _ in range(n):\n    l = inp[ii]\n    r = inp[ii+1]\n    ii+=2\n    L.append(l)\n    R.append(r)\n\nLsum = [0]\nfor l in L:\n    Lsum.append(Lsum[-1]+l)\nRsum = [0]\nfor r in R:\n    Rsum.append(Rsum[-1]+r)\n\nout = []\nq = inp[ii]\nii+=1\nfor _ in range(q):\n    px = inp[ii]\n    py = inp[ii+1]\n    ii+=2\n\n    shade = 0\n    \n\n    # L' = px + (l-px)/py*(py-sy)\n    # R' = px + (l-px)/py*(py-sy)\n    \n    A = 0\n    B = len(L)\n    while A<B:\n        M = (A+B)//2\n        l = L[M]\n        l = px + (l-px)/py*(py-sy)\n        if l<a:\n            A = M+1\n        else:\n            B = M\n    ind1 = A\n\n    if ind1==n:\n        lista = [ind1-1]\n    else:\n        A = ind1-1\n        B = len(R)-1\n        while A<B:\n            M = (A+B+1)//2\n            r = R[M]\n            r = px + (r-px)/py*(py-sy)\n            if b<r:\n                B = M-1\n            else:\n                A = M\n        ind2 = A\n\n        if ind2==ind1-1:\n            lista = [ind1-2,ind1-1,ind1,ind1+1]\n        else:\n            \n            l = Lsum[ind2+1]-Lsum[ind1]\n            r = Rsum[ind2+1]-Rsum[ind1]\n            \n            l = (l)/py*(py-sy)\n            r = (r)/py*(py-sy)\n\n            shade += r-l\n\n            lista = [ind1-1,ind2+1]\n\n    \n    for i in lista:\n        if i<0 or i>=n:\n            continue\n        l = L[i]\n        r = R[i]\n        l = px + (l-px)/py*(py-sy)\n        r = px + (r-px)/py*(py-sy)\n\n        if l<=a:\n            l = a\n        if b<=r:\n            r = b\n        shade += max(r-l,0)\n    out.append('%.10f'%(shade))\nprint '\\n'.join(out)\n",
    "prob_desc_created_at": "1533307500",
    "tags": [
        "binary search",
        "geometry"
    ],
    "hidden_unit_tests": ""
}
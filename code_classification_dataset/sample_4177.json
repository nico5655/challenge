{
    "prob_desc_time_limit": "2.5 seconds",
    "prob_desc_sample_outputs": "[\"15\", \"10\", \"-3\", \"96\"]",
    "src_uid": "c21b78e3a3950446541a2a067f1e4d60",
    "prob_desc_notes": "NoteIn the first example, Alice can achieve maximum beauty by taking five photos, each one containing one building. In the second example, Alice can achieve a maximum beauty of $$$10$$$ by taking four pictures: three just containing one building, on buildings $$$1$$$, $$$2$$$ and $$$5$$$, each photo with beauty $$$-3$$$, $$$4$$$ and $$$7$$$ respectively, and another photo containing building $$$3$$$ and $$$4$$$, with beauty $$$2$$$. In the third example, Alice will just take one picture of the whole city.In the fourth example, Alice can take the following pictures to achieve maximum beauty: photos with just one building on buildings $$$1$$$, $$$2$$$, $$$8$$$, $$$9$$$, and $$$10$$$, and a single photo of buildings $$$3$$$, $$$4$$$, $$$5$$$, $$$6$$$, and $$$7$$$. ",
    "prob_desc_description": "Alice is visiting New York City. To make the trip fun, Alice will take photos of the city skyline and give the set of photos as a present to Bob. However, she wants to find the set of photos with maximum beauty and she needs your help. There are $$$n$$$ buildings in the city, the $$$i$$$-th of them has positive height $$$h_i$$$. All $$$n$$$ building heights in the city are different. In addition, each building has a beauty value $$$b_i$$$. Note that beauty can be positive or negative, as there are ugly buildings in the city too. A set of photos consists of one or more photos of the buildings in the skyline. Each photo includes one or more buildings in the skyline that form a contiguous segment of indices. Each building needs to be in exactly one photo. This means that if a building does not appear in any photo, or if a building appears in more than one photo, the set of pictures is not valid. The beauty of a photo is equivalent to the beauty $$$b_i$$$ of the shortest building in it. The total beauty of a set of photos is the sum of the beauty of all photos in it. Help Alice to find the maximum beauty a valid set of photos can have. ",
    "prob_desc_output_spec": "Print one number representing the maximum beauty Alice can achieve for a valid set of photos of the skyline. ",
    "prob_desc_input_spec": "The first line contains an integer $$$n$$$ ($$$1 \\le n \\le 3 \\cdot 10^5$$$), the number of buildings on the skyline.  The second line contains $$$n$$$ distinct integers $$$h_1, h_2, \\ldots, h_n$$$ ($$$1 \\le h_i \\le n$$$). The $$$i$$$-th number represents the height of building $$$i$$$. The third line contains $$$n$$$ integers $$$b_1, b_2, \\ldots, b_n$$$ ($$$-10^9 \\le b_i \\le 10^9$$$). The $$$i$$$-th number represents the beauty of building $$$i$$$.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3-64",
    "lang_cluster": "Python",
    "difficulty": 2100,
    "file_name": "train_092.jsonl",
    "code_uid": "42f90f747de0f75c17ecaf7e1695753a",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"5\\n1 2 3 5 4\\n1 5 3 2 4\", \"5\\n1 4 3 2 5\\n-3 4 -10 2 7\", \"2\\n2 1\\n-2 -3\", \"10\\n4 7 3 2 5 1 9 10 6 8\\n-4 40 -46 -8 -16 4 -10 41 12 3\"]",
    "exec_outcome": "PASSED",
    "source_code": "import io,os\ninput = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline\nfrom collections import deque \n\n\nclass segment_tree(object):\n\n    # self.flag True means get minimum,  False means get maximum \n\n    def merge(self,num,curr):\n        if self.flag:\n            return min(curr,num)\n        else:\n            return max(curr,num)\n\n\n\n    def __init__(self,n,initial,flag):\n        self.flag = flag\n        self.n = n\n        self.arr = [0]*(2*n)\n        for i in range(2*n-1,0,-1):\n            if i>=n:  self.arr[i] = initial[i-n]\n            else:     self.arr[i] = self.merge(self.arr[2*i],self.arr[2*i+1])\n\n\n\n\n    def update(self,index,target):\n\n        self.arr[index] = target\n        if index & 1:\n            nexttarget = self.merge( self.arr[index], self.arr[index-1])\n        else:\n            nexttarget = self.merge( self.arr[index], self.arr[index+1])\n        if index>0:  self.update(index>>1,nexttarget )\n\n\n    def addnum(self,index,diff):\n        self.update(index+self.n, self.arr[index+self.n] + diff)\n\n\n    def query(self,left,right):\n        i,j = self.n+left,  self.n+right+1\n        if self.flag:\n            output = float('inf')  # initial output should be changed if you want to change the merge function\n        else:\n            output = -float('inf')\n\n        while i<j:\n            if i&1:\n                output = self.merge(self.arr[i],output)\n                i += 1\n            if j&1:\n                j -= 1\n                output = self.merge(self.arr[j],output)\n            i = i >> 1\n            j = j >> 1\n        return output\n\n\n\ndef getranking(arr):\n    temp = []\n    n = len(arr)\n    output = [0]*n\n    for i in range(len(arr)):\n        temp.append((arr[i],i))\n    temp.sort(key=lambda x:(x[0],x[1]))\n    for i in range(n):\n        output[temp[i][1]] = i\n    return output \n\n    \n\n\ndef main(t):\n\n    n = int(input())\n    height = list(map(int,input().split()))\n    ranking = getranking(height)\n    seg = segment_tree(n,ranking,True)\n    dic = {}\n    for i in range(n):  dic[ranking[i]] = i\n  \n    beauty = list(map(int,input().split()))\n    leftnode = [-1]*n\n    rightnode = [-1]*n\n\n\n    \n\n    parity = [-1]*n\n\n\n    # get the left and right son node\n  \n    queue = deque()\n\n    root = dic[0]\n    queue.append((0,n-1,root))    \n\n    childnum = [1]*n\n\n\n\n    seq = []\n    while queue:\n        left,right,index = queue.popleft()\n        seq.append(index)\n        if left <= index-1:\n            leftnode[index] = dic[seg.query(left,index-1)]\n            queue.append((left,index-1,leftnode[index])) \n            parity[leftnode[index]] = 0   # 0 for leftnode and 1 for rightnode\n\n        if index+1 <= right:\n            rightnode[index] = dic[seg.query(index+1,right)]\n            queue.append((index+1,right,rightnode[index])) \n            parity[rightnode[index]] = 1\n\n    seq = seq[::-1]\n\n\n#    print(leftnode,rightnode,dic,seq)\n    dp = [0]*n\n\n    for index in seq:\n        num1,num2,num3 = -float('inf'), beauty[index], -float('inf')\n        if leftnode[index] >= 0:  \n            num1 = dp[leftnode[index]]\n            childnum[index] += childnum[leftnode[index]]\n        if rightnode[index] >= 0: \n            num3 = dp[rightnode[index]]\n            childnum[index] += childnum[rightnode[index]]\n\n        dp[index] = num2 + max(num1,0) + max(num3,0)\n        leftnum,rightnum = 0,0\n        if leftnode[index] >= 0:  leftnum = childnum[leftnode[index]]\n        if rightnode[index] >= 0:  rightnum = childnum[rightnode[index]]\n        if index > leftnum and rightnode[index] >= 0:   dp[index] = max(dp[index], dp[rightnode[index]]) \n        if index + rightnum < n - 1 and leftnode[index] >= 0:   dp[index] = max(dp[index], dp[leftnode[index]])\n         \n      \n#    print(dp)\n            \n    print(dp[seq[-1]])\n            \n \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nT = 1 #int(input())\nt = 1\nwhile t<=T:\n    main(t)\n    t += 1\n\n",
    "prob_desc_created_at": "1616322000",
    "tags": [
        "data structures",
        "dp"
    ],
    "hidden_unit_tests": ""
}
{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"0\\n1\\n1\\n3\\n2\\n2\\n5\"]",
    "src_uid": "2b7f4168d1e5de655f40510bbee87686",
    "prob_desc_notes": "NoteIn the first test case, $$$S$$$ is already sorted.In the second test case, it's enough to apply the operation with $$$l = 1, r = 2$$$.In the third test case, it's enough to apply the operation with $$$l = 1, r = 2$$$.",
    "prob_desc_description": "You are given a binary string $$$S$$$ of length $$$n$$$ indexed from $$$1$$$ to $$$n$$$. You can perform the following operation any number of times (possibly zero):Choose two integers $$$l$$$ and $$$r$$$ ($$$1 \\le l \\le r \\le n$$$). Let $$$cnt_0$$$ be the number of times 0 occurs in $$$S[l \\ldots r]$$$ and $$$cnt_1$$$ be the number of times 1 occurs in $$$S[l \\ldots r]$$$. You can pay $$$|cnt_0 - cnt_1| + 1$$$ coins and sort the $$$S[l \\ldots r]$$$. (by $$$S[l \\ldots r]$$$ we mean the substring of $$$S$$$ starting at position $$$l$$$ and ending at position $$$r$$$)For example if $$$S = $$$ 11001, we can perform the operation on $$$S[2 \\ldots 4]$$$, paying $$$|2 - 1| + 1 = 2$$$ coins, and obtain $$$S = $$$ 10011 as a new string.Find the minimum total number of coins required to sort $$$S$$$ in increasing order.",
    "prob_desc_output_spec": "For each test case, output the minimum total number of coins required to sort $$$S$$$ in increasing order.",
    "prob_desc_input_spec": "The first line contains a single integer $$$t$$$ ($$$1 \\le t \\le 1000$$$) — the number of test cases. The description of test cases follows. The first line of each test case contains a single integer $$$n$$$ ($$$1 \\le n \\le 2 \\cdot 10^5$$$) — the size of $$$S$$$. The second line of each test case contains a binary string $$$S$$$ of $$$n$$$ characters $$$S_1S_2 \\ldots S_n$$$. ($$$S_i = $$$ 0 or $$$S_i = $$$ 1 for each $$$1 \\le i \\le n$$$) It is guaranteed that the sum of $$$n$$$ over all test cases doesn't exceed $$$2 \\cdot 10^5$$$.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3-64",
    "lang_cluster": "Python",
    "difficulty": 3400,
    "file_name": "train_109.jsonl",
    "code_uid": "dae4b37403858cde6d0d2c29981fa7cc",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"7\\n\\n1\\n\\n1\\n\\n2\\n\\n10\\n\\n3\\n\\n101\\n\\n4\\n\\n1000\\n\\n5\\n\\n11010\\n\\n6\\n\\n110000\\n\\n20\\n\\n01000010001010011000\"]",
    "exec_outcome": "PASSED",
    "source_code": "import sys\r\n\r\n# store inf in a variable called inf\r\ninf = float('inf')\r\n\r\n\r\n# change stdout buffer size\r\nbuffer = open(1, 'w', 10**6)\r\n\r\n\r\n# fast printing function\r\ndef print(*args, sep=' ', end='\\n'):\r\n    buffer.write(sep.join(str(arg) for arg in args) + end)\r\n\r\n\r\n# flush stdout\r\ndef flush():\r\n    buffer.flush()\r\n\r\n\r\n# read a list of integers from stdin\r\ndef read_ints(index=None):\r\n    return [int(x) for x in input().split()]\r\n\r\n\r\ndef read_ints_indexed(index):\r\n    return [(int(x), i + index) for i, x in enumerate(input().split())]\r\n\r\n\r\n# Find the previous greater element for every element in a list\r\ndef findPrevGreaterOrEqual(arr):\r\n    # base case\r\n    if not arr:\r\n        return []\r\n\r\n    # create an empty stack\r\n    s = list()\r\n    ans = []\r\n\r\n    # do for each element\r\n    for i in range(len(arr)):\r\n        # loop till stack is empty\r\n        while s:\r\n            # If the stack's top element is greater or equal than the current element,\r\n            # it is the previous greater or equal element\r\n            if arr[s[-1]] >= arr[i]:\r\n                ans.append(s[-1])\r\n                break\r\n            # remove the stack's top element is less if it is lower or equal\r\n            # to the current element\r\n            else:\r\n                s.pop()\r\n\r\n        # If the stack becomes empty, all elements to the left\r\n        # of the current element are lower\r\n        if not s:\r\n            ans.append(-1)\r\n\r\n        # push current element into the stack\r\n        s.append(i)\r\n\r\n    return ans\r\n\r\n\r\n# check if array is sorted\r\ndef is_sorted(arr):\r\n    for i in range(len(arr) - 1):\r\n        if arr[i] > arr[i + 1]:\r\n            return False\r\n    return True\r\n\r\n\r\ndef solve():\r\n    n = int(input())\r\n    s = [bool(int(x)) for x in input()]\r\n\r\n    # if the number of zeros is greater than the number of ones, we swap the problem\r\n    b = 0\r\n    for i in range(n):\r\n        if s[i]:\r\n            b += 1\r\n        else:\r\n            b -= 1\r\n\r\n    if b < 0:\r\n        s = [not x for x in s]\r\n        s.reverse()\r\n\r\n    # change 0's to -1's\r\n    cs = [1 if x else -1 for x in s]\r\n\r\n    # build the array of prefixes\r\n    pref = [0] * (n + 1)\r\n    for i in range(1, n + 1):\r\n        pref[i] = pref[i - 1] + cs[i - 1]\r\n\r\n    # find the previous greater or equal elem for every index in the array of prefixes\r\n    prev = findPrevGreaterOrEqual(pref)\r\n\r\n    # locate `i` where the first iteration should take place\r\n    i = n\r\n    while i > 0 and pref[i] > pref[i - 1]:\r\n        i -= 1\r\n\r\n    # find `j` for that `i`\r\n    j = i - 1\r\n    for k in range(i, -1, -1):\r\n        # this is the smallest index with value equal to pref[i] so we can break the loop\r\n        if pref[k] == pref[i] and prev[k] == -1:\r\n            j = k\r\n            break\r\n\r\n    ans = 0\r\n    # while pref[i] > 0 we cant sort in one operation of balance 0\r\n    while pref[i] > 0:\r\n        ans += 1\r\n\r\n        # sort [j,i] and fix pref\r\n        for k in range(j + 1, (i + j) // 2 + 1):\r\n            s[k - 1] = False\r\n            pref[k] = pref[j] - (k - j)\r\n\r\n        for k in range((i + j) // 2 + 1, i + 1):\r\n            s[k - 1] = True\r\n            pref[k] = pref[j] + (k - ((i + j) // 2))\r\n\r\n        # move i to its new position\r\n        i -= 1\r\n        while i > 0 and pref[i] > pref[i - 1]:\r\n            i -= 1\r\n\r\n        # move j to its new position as well\r\n        for k in range(j - 1, -1, -1):\r\n            if pref[k] == pref[i] and prev[k] == -1:\r\n                j = k\r\n                break\r\n\r\n    if is_sorted(s):\r\n        print(ans)\r\n    else:\r\n        print(ans + 1)\r\n\r\n\r\nif __name__ == '__main__':\r\n    test_cases = int(input())\r\n    for _ in range(test_cases):\r\n        solve()\r\n",
    "prob_desc_created_at": "1655390100",
    "tags": [
        "binary search",
        "greedy",
        "two pointers"
    ],
    "hidden_unit_tests": ""
}
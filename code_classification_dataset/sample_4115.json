{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"4\", \"7\", \"12\"]",
    "src_uid": "a569cd5f8bf8aaf011858f839e91848a",
    "prob_desc_notes": "NoteIn the first test case it's optimal to install two towers with efficiencies $$$2$$$ at vertices $$$1$$$ and $$$3$$$.In the second test case it's optimal to install a tower with efficiency $$$1$$$ at vertex $$$1$$$ and two towers with efficiencies $$$3$$$ at vertices $$$2$$$ and $$$5$$$.In the third test case it's optimal to install two towers with efficiencies $$$6$$$ at vertices $$$1$$$ and $$$2$$$.",
    "prob_desc_description": "You are given a tree with $$$n$$$ vertices numbered from $$$1$$$ to $$$n$$$. The height of the $$$i$$$-th vertex is $$$h_i$$$. You can place any number of towers into vertices, for each tower you can choose which vertex to put it in, as well as choose its efficiency. Setting up a tower with efficiency $$$e$$$ costs $$$e$$$ coins, where $$$e &gt; 0$$$.It is considered that a vertex $$$x$$$ gets a signal if for some pair of towers at the vertices $$$u$$$ and $$$v$$$ ($$$u \\neq v$$$, but it is allowed that $$$x = u$$$ or $$$x = v$$$) with efficiencies $$$e_u$$$ and $$$e_v$$$, respectively, it is satisfied that $$$\\min(e_u, e_v) \\geq h_x$$$ and $$$x$$$ lies on the path between $$$u$$$ and $$$v$$$.Find the minimum number of coins required to set up towers so that you can get a signal at all vertices.",
    "prob_desc_output_spec": "Print one integer — the minimum required number of coins.",
    "prob_desc_input_spec": "The first line contains an integer $$$n$$$ ($$$2 \\le n \\le 200\\,000$$$) — the number of vertices in the tree. The second line contains $$$n$$$ integers $$$h_i$$$ ($$$1 \\le h_i \\le 10^9$$$) — the heights of the vertices. Each of the next $$$n - 1$$$ lines contain a pair of numbers $$$v_i, u_i$$$ ($$$1 \\le v_i, u_i \\le n$$$) — an edge of the tree. It is guaranteed that the given edges form a tree.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3-64",
    "lang_cluster": "Python",
    "difficulty": 2500,
    "file_name": "train_090.jsonl",
    "code_uid": "786ea06f699169284910a078e5e27b97",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"3\\n1 2 1\\n1 2\\n2 3\", \"5\\n1 3 3 1 3\\n1 3\\n5 4\\n4 3\\n2 3\", \"2\\n6 1\\n1 2\"]",
    "exec_outcome": "PASSED",
    "source_code": "import os\r\nimport sys\r\nfrom io import BytesIO, IOBase\r\n\r\nBUFSIZE = 8192\r\n\r\nclass FastIO(IOBase):\r\n    newlines = 0\r\n\r\n    def __init__(self, file):\r\n        self._fd = file.fileno()\r\n        self.buffer = BytesIO()\r\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\r\n        self.write = self.buffer.write if self.writable else None\r\n\r\n    def read(self):\r\n        while True:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            if not b:\r\n                break\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines = 0\r\n        return self.buffer.read()\r\n\r\n    def readline(self):\r\n        while self.newlines == 0:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            self.newlines = b.count(b\"\\n\") + (not b)\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines -= 1\r\n        return self.buffer.readline()\r\n\r\n    def flush(self):\r\n        if self.writable:\r\n            os.write(self._fd, self.buffer.getvalue())\r\n            self.buffer.truncate(0), self.buffer.seek(0)\r\n\r\n\r\nclass IOWrapper(IOBase):\r\n    def __init__(self, file):\r\n        self.buffer = FastIO(file)\r\n        self.flush = self.buffer.flush\r\n        self.writable = self.buffer.writable\r\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\r\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\r\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\r\n\r\n\r\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\r\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\r\n\r\nfrom collections import defaultdict as dd\r\nfrom collections import deque\r\nimport bisect\r\nimport heapq\r\n\r\ndef ri():\r\n    return int(input())\r\n\r\ndef rl():\r\n    return list(map(int, input().split()))\r\n\r\n\r\ndef solve():\r\n    n = ri()\r\n    H = rl()\r\n    G = dd(list)\r\n    P = dd(lambda:-1)\r\n    for i in range(n - 1):\r\n        u, v = rl()\r\n        u -= 1\r\n        v -= 1\r\n        G[u].append(v)\r\n        G[v].append(u)\r\n    \r\n    root = 0\r\n    highest = 0\r\n    for i in range(n):\r\n        if H[i] > highest:\r\n            root = i\r\n            highest = H[i]\r\n\r\n    P[root] = root\r\n    curr = [root]\r\n    while curr:\r\n        node = curr.pop()\r\n        for nbr in G[node]:\r\n            if P[nbr] == -1:\r\n                P[nbr] = node\r\n                curr.append(nbr)\r\n    \r\n    maxbelow = [0] * n\r\n    # def dfs(u):\r\n        # for v in G[u]:\r\n            # if v != P[u]:\r\n                # dfs(v)\r\n                # maxbelow[u] = max(maxbelow[u], maxbelow[v], H[v])\r\n# \r\n        # \r\n    # dfs(root)\r\n\r\n    layers = [root]\r\n    curr = [root]\r\n    while curr:\r\n        nxt = []\r\n        for node in curr:\r\n            for nbr in G[node]:\r\n                if nbr != P[node]:\r\n                    nxt.append(nbr)\r\n        layers += nxt\r\n        curr = nxt\r\n    \r\n    for u in layers[::-1]:\r\n        for v in G[u]:\r\n            if v != P[u]:\r\n                maxbelow[u] = max(maxbelow[u], maxbelow[v], H[v])\r\n\r\n    ans = 0\r\n    for i in range(n):\r\n        if i == root: continue\r\n        ans += max(0, H[i] - maxbelow[i])\r\n    \r\n    paths = []\r\n    for v in G[root]:\r\n        paths.append(max(H[v], maxbelow[v]))\r\n    if len(paths) == 1:\r\n        ans += H[root] + H[root] - paths[0]\r\n    else:\r\n        paths.sort()\r\n        ans += 2 * H[root] - paths[-1] - paths[-2]\r\n    print (ans)\r\n     \r\n\r\n\r\nmode = 's'\r\n\r\nif mode == 'T':\r\n    t = ri()\r\n    for i in range(t):\r\n        solve()\r\nelse:\r\n    solve()\r\n",
    "prob_desc_created_at": "1644676500",
    "tags": [
        "constructive algorithms",
        "dfs and similar",
        "dp",
        "greedy",
        "trees"
    ],
    "hidden_unit_tests": ""
}
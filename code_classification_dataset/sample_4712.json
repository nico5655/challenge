{
    "prob_desc_time_limit": "4 seconds",
    "prob_desc_sample_outputs": "[\"4\", \"40\"]",
    "src_uid": "f24193d656bca889e5167d9b7bd2a379",
    "prob_desc_notes": null,
    "prob_desc_description": "Monocarp is playing a tower defense game. A level in the game can be represented as an OX axis, where each lattice point from $$$1$$$ to $$$n$$$ contains a tower in it.The tower in the $$$i$$$-th point has $$$c_i$$$ mana capacity and $$$r_i$$$ mana regeneration rate. In the beginning, before the $$$0$$$-th second, each tower has full mana. If, at the end of some second, the $$$i$$$-th tower has $$$x$$$ mana, then it becomes $$$\\mathit{min}(x + r_i, c_i)$$$ mana for the next second.There are $$$q$$$ monsters spawning on a level. The $$$j$$$-th monster spawns at point $$$1$$$ at the beginning of $$$t_j$$$-th second, and it has $$$h_j$$$ health. Every monster is moving $$$1$$$ point per second in the direction of increasing coordinate.When a monster passes the tower, the tower deals $$$\\mathit{min}(H, M)$$$ damage to it, where $$$H$$$ is the current health of the monster and $$$M$$$ is the current mana amount of the tower. This amount gets subtracted from both monster's health and tower's mana.Unfortunately, sometimes some monsters can pass all $$$n$$$ towers and remain alive. Monocarp wants to know what will be the total health of the monsters after they pass all towers.",
    "prob_desc_output_spec": "Print a single integer — the total health of all monsters after they pass all towers.",
    "prob_desc_input_spec": "The first line contains a single integer $$$n$$$ ($$$1 \\le n \\le 2 \\cdot 10^5$$$) — the number of towers. The $$$i$$$-th of the next $$$n$$$ lines contains two integers $$$c_i$$$ and $$$r_i$$$ ($$$1 \\le r_i \\le c_i \\le 10^9$$$) — the mana capacity and the mana regeneration rate of the $$$i$$$-th tower. The next line contains a single integer $$$q$$$ ($$$1 \\le q \\le 2 \\cdot 10^5$$$) — the number of monsters. The $$$j$$$-th of the next $$$q$$$ lines contains two integers $$$t_j$$$ and $$$h_j$$$ ($$$0 \\le t_j \\le 2 \\cdot 10^5$$$; $$$1 \\le h_j \\le 10^{12}$$$) — the time the $$$j$$$-th monster spawns and its health. The monsters are listed in the increasing order of their spawn time, so $$$t_j &lt; t_{j+1}$$$ for all $$$1 \\le j \\le q-1$$$.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3-64",
    "lang_cluster": "Python",
    "difficulty": 3000,
    "file_name": "train_104.jsonl",
    "code_uid": "3084f7df8e38dbccd03d1582e883ce52",
    "prob_desc_memory_limit": "512 megabytes",
    "prob_desc_sample_inputs": "[\"3\\n5 1\\n7 4\\n4 2\\n4\\n0 14\\n1 10\\n3 16\\n10 16\", \"5\\n2 1\\n4 1\\n5 4\\n7 5\\n8 3\\n9\\n1 21\\n2 18\\n3 14\\n4 24\\n5 8\\n6 25\\n7 19\\n8 24\\n9 24\"]",
    "exec_outcome": "PASSED",
    "source_code": "import sys, bisect\ninput = sys.stdin.readline\nn = int(input())\nms = 1 if n == 1 else (n-1).bit_length()\nc0, r0 = zip(*[map(int, input().split()) for i in range(n)])\nx, y = zip(*sorted([(c0[i]//r0[i], i) for i in range(n)]))\nd, sumr, sumc = [[0]*(n+1) for i in range(ms)], [], []\ndef genpre(s, d):\n    r = [0]\n    for i in d: r.append(r[-1]+s[i])\n    return r\nsumr0 = genpre(r0, range(n))\n\ndef build():\n    a = y\n    size=1<<ms\n    for d1 in d:\n        b = []\n        for j in range(0, n, size):\n            mid = j+(size>>1)\n            t = []\n            for k in range(j, min(n, j+size)):\n                if a[k] < mid: d1[k+1]=1 if k == j else d1[k]+1; b.append(a[k])\n                else: d1[k+1]=0 if k == j else d1[k]; t.append(a[k])\n            b.extend(t)\n        size>>=1\n        a = b\n        sumr.append(genpre(r0, a)); sumc.append(genpre(c0, a))\n\ndef query(point, th, h):\n    size, last = 1<<ms, 0\n    pos = bisect.bisect_left(x, point)\n    sc, sr = 0, 0\n    for idx, d1 in enumerate(d):\n        size>>=1\n        mid = last+size\n        if mid <= th:\n            pp = last + (d1[pos] if pos != last else 0)\n            cc, rr = sumc[idx][pp]-sumc[idx][last], sumr[idx][pp]-sumr[idx][last]\n            # print(mid, th, h, last, pos, sr, sc, cc, rr, cc+sc + point*(sumr0[mid]-sr-rr), d1)\n            if cc+sc + point*(sumr0[mid]-sr-rr) < h:\n                sc+=cc; sr+=rr\n                pos = mid + pos - pp \n                last = mid\n                continue\n        # print(last,pos,d1)\n        pos = last + (d1[pos] if pos != last else 0)\n    return sc+point*(sumr0[last]-sr), last\n\nbuild()\nM = 10**18\ns = [(0,n,-M, 0)]\nans = 0\n# print(c0,r0,x,y,d, sumr, sumc)\nfor t, h in [map(int, input().split()) for i in range(int(input()))]:\n    while s:\n        l, r, p, left = s.pop()\n        if (l != r): \n            tmp, _ = query(t-p, l, M)\n            h = h+tmp\n            tmp, pos = query(t-p, r, h)\n            h-=tmp\n            if pos < r: \n                if h: \n                    if pos+1 < r: s.append((pos+1, r, p, 0))\n                    s.append((pos, pos, t+pos, min(c0[pos], r0[pos]*(t-p))-h))\n                    h = 0\n                else: s.append((pos, r, p, 0))\n                if pos: s.append((0,pos,t,0))\n        else:\n            tmp = min(c0[l], left+(t+r-p)*r0[l])\n            if tmp >= h: \n                s.append((l, r, t+r, tmp-h))\n                if l: s.append((0,l,t,0))\n                h=0\n            else: h-=tmp\n        if h == 0: break\n    if h: s.append((0,n,t,0)); ans+=h\nprint(ans)\n",
    "prob_desc_created_at": "1646922900",
    "tags": [
        "binary search",
        "brute force",
        "data structures"
    ],
    "hidden_unit_tests": ""
}
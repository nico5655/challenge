{
    "prob_desc_time_limit": "1 second",
    "prob_desc_sample_outputs": "[\"3\\n1\\n4\"]",
    "src_uid": "ce3f65acc33d624ed977e1d8f3494597",
    "prob_desc_notes": "NoteIn the first example, any edge $$$x \\to y$$$ such that $$$x &gt; y$$$ is valid, because there already is a path $$$1 \\to 2 \\to 3$$$.In the second example only the edge $$$4 \\to 1$$$ is valid. There is a path $$$3 \\to 4 \\to 1 \\to 2$$$ if this edge is added.In the third example you can add edges $$$2 \\to 1$$$, $$$3 \\to 1$$$, $$$4 \\to 1$$$, $$$4 \\to 2$$$.",
    "prob_desc_description": "You are given a directed acyclic graph with $$$n$$$ vertices and $$$m$$$ edges. For all edges $$$a \\to b$$$ in the graph, $$$a &lt; b$$$ holds.You need to find the number of pairs of vertices $$$x$$$, $$$y$$$, such that $$$x &gt; y$$$ and after adding the edge $$$x \\to y$$$ to the graph, it has a Hamiltonian path. ",
    "prob_desc_output_spec": "For each test case, print one integer: the number of pairs of vertices $$$x$$$, $$$y$$$, $$$x &gt; y$$$, such that after adding the edge $$$x \\to y$$$ to the graph, it has a Hamiltonian path. ",
    "prob_desc_input_spec": "The first line of input contains one integer $$$t$$$ ($$$1 \\leq t \\leq 5$$$): the number of test cases. The next lines contains the descriptions of the test cases. In the first line you are given two integers $$$n$$$ and $$$m$$$ ($$$1 \\leq n \\leq 150\\,000$$$, $$$0 \\leq m \\leq \\min(150\\,000, \\frac{n(n-1)}{2})$$$): the number of vertices and edges in the graph.  Each of the next $$$m$$$ lines contains two integers $$$a$$$, $$$b$$$ ($$$1 \\leq a &lt; b \\leq n$$$), specifying an edge $$$a \\to b$$$ in the graph. No edge $$$a \\to b$$$ appears more than once.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3",
    "lang_cluster": "Python",
    "difficulty": 3500,
    "file_name": "train_101.jsonl",
    "code_uid": "4c32784f824e939589f7e424cf8220fb",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"3\\n3 2\\n1 2\\n2 3\\n4 3\\n1 2\\n3 4\\n1 4\\n4 4\\n1 3\\n1 4\\n2 3\\n3 4\"]",
    "exec_outcome": "PASSED",
    "source_code": "import io,os,sys\r\nread = io.BytesIO(os.read(0, os.fstat(0).st_size))\r\nI = lambda:map(int, read.readline().split())\r\nimport time\r\n#I = lambda:map(int, sys.stdin.readline().split())\r\n\r\nt, = I()\r\nfor _ in range(t):\r\n\tn, m = I()\r\n\t# if n > 100:\r\n\t# \tprint(time.time())\r\n\tto = [[] for i in range(n)]\r\n\tfro = [[] for i in range(n)]\r\n\tfor i in range(m):\r\n\t\ta, b = I()\r\n\t\ta -= 1\r\n\t\tb -= 1\r\n\t\tto[b].append(a)\r\n\t\tfro[a].append(b)\r\n\t# if n > 100:\r\n\t# \tprint(time.time())\r\n\tfor i in range(n):\r\n\t\tto[i].sort()\r\n\t\tfro[i].sort()\r\n\t# if n > 100:\r\n\t# \tprint(time.time())\r\n\tfirst = None\r\n\tlast = None\r\n\tfor i in range(n - 1):\r\n\t\tif len(fro[i]) == 0 or fro[i][0] != i + 1:\r\n\t\t\tif first is None:\r\n\t\t\t\tfirst = i\r\n\t\t\tlast = i\r\n\tif first is None:\r\n\t\tprint(n * (n - 1) // 2)\r\n\t\tcontinue\r\n\r\n\t# if n > 100:\r\n\t# \tprint(time.time())\r\n\ty = first\r\n\ti = first + 1\r\n\tblue = {y}\r\n\tred = set()\r\n\r\n\truse = []\r\n\tbuse = []\r\n\tif first == last:\r\n\t\tbuse.append(y)\r\n\r\n\twhile i < n - 1:\r\n\t\t#print(i, red, blue)\r\n\t\ti += 1\r\n\t\tif len(to[i]) == 0:\r\n\t\t\tblue = red = set()\r\n\t\t\tbreak\r\n\t\tif to[i][-1] != i - 1:\r\n\t\t\tnewr = set()\r\n\t\t\tnewb = set()\r\n\t\telse:\r\n\t\t\tnewr = red\r\n\t\t\tnewb = blue\r\n\t\tfor guy in to[i]:\r\n\t\t\tif guy < i - 1 and guy in blue:\r\n\t\t\t\tnewr.add(i - 1)\r\n\t\t\tif guy < i - 1 and guy in red:\r\n\t\t\t\tnewb.add(i - 1)\r\n\t\tblue = newb\r\n\t\tred = newr\r\n\r\n\t\tif i > last:\r\n\t\t\tif i - 1 in blue:\r\n\t\t\t\tbuse.append(i - 1)\r\n\t\t\tif i - 1 in red:\r\n\t\t\t\truse.append(i - 1)\r\n\tif len(blue) > 0:\r\n\t\truse.append(n - 1)\r\n\tif len(red) > 0:\r\n\t\tbuse.append(n - 1)\r\n\r\n\t# if n > 100:\r\n\t# \tprint(time.time())\r\n\t# print(i, red, blue)\r\n\t# print(ruse, buse)\r\n\ti = y\r\n\tblue = set()\r\n\tred = {y + 1}\r\n\r\n\truse1 = []\r\n\tbuse1 = []\r\n\truse1.append(y + 1)\r\n\twhile i > 0:\r\n\t\ti -= 1\r\n\t\tif len(fro[i]) == 0:\r\n\t\t\tblue = red = set()\r\n\t\t\tbreak\r\n\t\tif fro[i][0] != i + 1:\r\n\t\t\tnewr = set()\r\n\t\t\tnewb = set()\r\n\t\telse:\r\n\t\t\tnewr = red\r\n\t\t\tnewb = blue\r\n\t\tfor guy in fro[i]:\r\n\t\t\tif guy > y + 1:\r\n\t\t\t\tbreak\r\n\t\t\tif guy > i + 1 and guy in blue:\r\n\t\t\t\tnewr.add(i + 1)\r\n\t\t\tif guy > i + 1 and guy in red:\r\n\t\t\t\tnewb.add(i + 1)\r\n\t\tblue = newb\r\n\t\tred = newr\r\n\r\n\t\tif i + 1 in blue:\r\n\t\t\tbuse1.append(i + 1)\r\n\t\tif i + 1 in red:\r\n\t\t\truse1.append(i + 1)\r\n\tif len(blue) > 0:\r\n\t\truse1.append(0)\r\n\tif len(red) > 0:\r\n\t\tbuse1.append(0)\r\n\r\n\t# print(ruse1, buse1)\r\n\t# if n > 100:\r\n\t# \tprint(time.time())\r\n\truse = set(ruse)\r\n\tbuse = set(buse)\r\n\truse1 = set(ruse1)\r\n\tbuse1 = set(buse1)\r\n\r\n\tboth = ruse & buse\r\n\tboth1 = ruse1 & buse1\r\n\truse -= both\r\n\tbuse -= both\r\n\truse1 -= both1\r\n\tbuse1 -= both1\r\n\t# print(ruse, buse, both, ruse1, buse1, both1)\r\n\tx = len(ruse1) * (len(both) + len(buse)) + len(buse1) * (len(both) + len(ruse)) + len(both1) * (len(both) + len(ruse) + len(buse))\r\n\t# print(x)\r\n\tif first == last:\r\n\t\tx -= 1\r\n\tif y in ruse1 or y in both1:\r\n\t\tx -= 1\r\n\tif y + 1 in buse or y + 1 in both:\r\n\t\tx -= 1\r\n\tprint(x)\r\n\t# if n > 100:\r\n\t# \tprint(time.time())\r\n\t# \texit()",
    "prob_desc_created_at": "1640792100",
    "tags": [
        "dfs and similar",
        "dp",
        "graphs"
    ],
    "hidden_unit_tests": ""
}
{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"and 2 5\\n\\nor 5 6\\n\\nfinish 5\"]",
    "src_uid": "7fb8b73fa2948b360644d40b7035ce4a",
    "prob_desc_notes": "NoteIn the example, the hidden sequence is $$$[1, 6, 4, 2, 3, 5, 4]$$$.Below is the interaction in the example.Query (contestant's program)Response (interactor)Notesand 2 52$$$a_2=6$$$, $$$a_5=3$$$. Interactor returns bitwise AND of the given numbers.or 5 67$$$a_5=3$$$, $$$a_6=5$$$. Interactor returns bitwise OR of the given numbers.finish 5$$$5$$$ is the correct answer. Note that you must find the value and not the index of the kth smallest number. ",
    "prob_desc_description": "  This is an interactive taskWilliam has a certain sequence of integers $$$a_1, a_2, \\dots, a_n$$$ in his mind, but due to security concerns, he does not want to reveal it to you completely. William is ready to respond to no more than $$$2 \\cdot n$$$ of the following questions:  What is the result of a bitwise AND of two items with indices $$$i$$$ and $$$j$$$ ($$$i \\neq j$$$)  What is the result of a bitwise OR of two items with indices $$$i$$$ and $$$j$$$ ($$$i \\neq j$$$) You can ask William these questions and you need to find the $$$k$$$-th smallest number of the sequence.Formally the $$$k$$$-th smallest number is equal to the number at the $$$k$$$-th place in a 1-indexed array sorted in non-decreasing order. For example in array $$$[5, 3, 3, 10, 1]$$$ $$$4$$$th smallest number is equal to $$$5$$$, and $$$2$$$nd and $$$3$$$rd are $$$3$$$.",
    "prob_desc_output_spec": null,
    "prob_desc_input_spec": "It is guaranteed that for each element in a sequence the condition $$$0 \\le a_i \\le 10^9$$$ is satisfied.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3-64",
    "lang_cluster": "Python",
    "difficulty": 1800,
    "file_name": "train_107.jsonl",
    "code_uid": "75e5d3dda0079d906b06255f041ce7de",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"7 6\\n\\n2\\n\\n7\"]",
    "exec_outcome": "PASSED",
    "source_code": "import os\r\nimport sys\r\nfrom io import BytesIO, IOBase\r\n\r\n# region fastio\r\nBUFSIZE = 8192\r\n\r\n\r\nclass FastIO(IOBase):\r\n    newlines = 0\r\n\r\n    def __init__(self, file):\r\n        self._fd = file.fileno()\r\n        self.buffer = BytesIO()\r\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\r\n        self.write = self.buffer.write if self.writable else None\r\n\r\n    def read(self):\r\n        while True:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            if not b:\r\n                break\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines = 0\r\n        return self.buffer.read()\r\n\r\n    def readline(self):\r\n        while self.newlines == 0:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            self.newlines = b.count(b\"\\n\") + (not b)\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines -= 1\r\n        return self.buffer.readline()\r\n\r\n    def flush(self):\r\n        if self.writable:\r\n            os.write(self._fd, self.buffer.getvalue())\r\n            self.buffer.truncate(0), self.buffer.seek(0)\r\n\r\n\r\nclass IOWrapper(IOBase):\r\n    def __init__(self, file):\r\n        self.buffer = FastIO(file)\r\n        self.flush = self.buffer.flush\r\n        self.writable = self.buffer.writable\r\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\r\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\r\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\r\n\r\n\r\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\r\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\r\n\r\n############# Importing modules and stuffs we require  ######################################################\r\n\r\ntry:\r\n        import sys\r\n        from functools import lru_cache, cmp_to_key, reduce\r\n        from heapq import merge, heapify, heappop, heappush\r\n        # from math import *\r\n        from collections import defaultdict as dd, deque, Counter as Cntr\r\n        from itertools import combinations as comb, permutations as perm\r\n        from bisect import bisect_left as bl, bisect_right as br, bisect, insort\r\n        from time import perf_counter\r\n        from fractions import Fraction\r\n        import copy\r\n        from copy import deepcopy\r\n        import time\r\n        from decimal import *\r\n        starttime = time.time()\r\n        mod = int(pow(10, 9) + 7)\r\n        mod2 = 998244353\r\n\r\n        def data(): return sys.stdin.readline()\r\n        def out(*var, end=\"\\n\"): sys.stdout.write(' '.join(map(str, var))+end)\r\n        def L(): return list(sp())\r\n        def sl(): return list(ssp())\r\n        def sp(): return map(int, data().split())\r\n        def ssp(): return map(str, data().split())\r\n        def l1d(n, val=0): return [val for i in range(n)]\r\n        def l2d(n, m, val=0): return [l1d(n, val) for j in range(m)]\r\n        def A2(n,m): return [[0]*m for i in range(n)]\r\n        def A(n):return [0]*n\r\n\r\n        # from sys import stdin\r\n        # input = stdin.buffer.readline\r\n        # I = lambda : list(map(int,input().split()))\r\n        # import sys\r\n        # input=sys.stdin.readline\r\n        # import io, os\r\n        # input = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline\r\n        import random\r\n        sys.stdin = open(\"input.txt\", \"r\")\r\n        sys.stdout = open(\"output.txt\", \"w\")\r\n        # from sys import *\r\n        # setrecursionlimit(2*(10**6))\r\nexcept:\r\n        pass\r\nR = range\r\n\r\n############# Importing modules and stuffs we require  ######################################################\r\n\r\n\r\nn,k = L()\r\nA = []\r\nB = []\r\nfor i in range(n-1):\r\n        print(\"and\",1,i+2,flush=True)\r\n        x = L()[0]\r\n        if x==-1:\r\n                exit()\r\n        print(\"or\",1,i+2,flush=True)\r\n        y = L()[0]\r\n        if y==-1:\r\n                exit()\r\n        A.append(x)\r\n        B.append(y)\r\nz = 0\r\nfor ele in A:\r\n        for i in range(32):\r\n                if (ele>>i)&1:\r\n                        z|=(1<<i)\r\nprint(\"and\",2,3,flush=True)\r\nx = L()[0]\r\nprint(\"or\",2,3,flush=True)\r\ny = L()[0]\r\n\r\nfor i in range(32):\r\n        if ((z>>i)&1==0) and (((B[0]>>i)&1 and (x>>i)&1==0) or ((B[1]>>i)&1 and (x>>i)&1==0)) and (y>>i)&1==0:\r\n                z|=(1<<i)\r\n\r\nX = [z]\r\nfor i in range(n-1):\r\n        z = 0\r\n        for j in range(32):\r\n                if (B[i]>>j)&1 and (X[0]>>j)&1==0:\r\n                        z|=(1<<j)\r\n                elif (A[i]>>j)&1:\r\n                        z|=(1<<j)\r\n        X.append(z)\r\nprint(\"finish\",sorted(X)[k-1],flush=True)\r\n",
    "prob_desc_created_at": "1630247700",
    "tags": [
        "bitmasks",
        "constructive algorithms",
        "interactive",
        "math"
    ],
    "hidden_unit_tests": ""
}
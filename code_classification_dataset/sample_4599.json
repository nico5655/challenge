{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"1\\n9\\n6\\n35\\n112\"]",
    "src_uid": "eaab346f1dd620c8634a7991fa581bff",
    "prob_desc_notes": "NoteIn the first test case, there is the only substring \")\". Its cost is $$$1$$$ because we can insert '(' to the beginning of this substring and get a string \"()\", that is a balanced string.In the second test case, the cost of each substring of length one is $$$1$$$. The cost of a substring \")(\" is $$$1$$$ because we can cyclically shift it to right and get a string \"()\". The cost of strings \")()\" and \"()(\" is $$$1$$$ because its enough to insert one bracket to each of them. The cost of substring \")()(\" is $$$1$$$ because we can cyclically shift it to right and get a string \"()()\". So there are $$$4 + 2 + 2 + 1 = 9$$$ substring of cost $$$1$$$ and $$$1$$$ substring of cost $$$0$$$. So the sum of the costs is $$$9$$$.In the third test case,   \"(\", the cost is $$$1$$$;  \"()\", the cost is $$$0$$$;  \"())\", the cost is $$$1$$$;  \")\", the cost is $$$1$$$;  \"))\", the cost is $$$2$$$;  \")\", the cost is $$$1$$$. So the sum of the costs is $$$6$$$.",
    "prob_desc_description": "Daemon Targaryen decided to stop looking like a Metin2 character. He turned himself into the most beautiful thing, a bracket sequence.For a bracket sequence, we can do two kind of operations:  Select one of its substrings$$$^\\dagger$$$ and cyclic shift it to the right. For example, after a cyclic shift to the right, \"(())\" will become \")(()\";  Insert any bracket, opening '(' or closing ')', wherever you want in the sequence. We define the cost of a bracket sequence as the minimum number of such operations to make it balanced$$$^\\ddagger$$$.Given a bracket sequence $$$s$$$ of length $$$n$$$, find the sum of costs across all its $$$\\frac{n(n+1)}{2}$$$ non-empty substrings. Note that for each substring we calculate the cost independently.$$$^\\dagger$$$ A string $$$a$$$ is a substring of a string $$$b$$$ if $$$a$$$ can be obtained from $$$b$$$ by deletion of several (possibly, zero or all) characters from the beginning and several (possibly, zero or all) characters from the end.$$$^\\ddagger$$$ A sequence of brackets is called balanced if one can turn it into a valid math expression by adding characters $$$+$$$ and $$$1$$$. For example, sequences \"(())()\", \"()\", and \"(()(()))\" are balanced, while \")(\", \"(()\", and \"(()))(\" are not.",
    "prob_desc_output_spec": "For each test case, print a single integer — the sum of costs of all substrings of $$$s$$$.",
    "prob_desc_input_spec": "Each test consists of multiple test cases. The first line contains a single integer $$$t$$$ ($$$1 \\leq t \\leq 10^5$$$) — the number of test cases. The description of test cases follows. The first line of each test case contains a single integer $$$n$$$ ($$$1 \\le n \\le 2 \\cdot 10^5$$$) — the length of the bracket sequence. The second line of each test case contains a string $$$s$$$, consisting only of characters '(' and ')', of length $$$n$$$ — the bracket sequence. It is guaranteed that sum of $$$n$$$ across all test cases does not exceed $$$2 \\cdot 10^5$$$.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3-64",
    "lang_cluster": "Python",
    "difficulty": 2400,
    "file_name": "train_101.jsonl",
    "code_uid": "4abecb950b6e32430d8f119b093f8a8a",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"5\\n\\n1\\n\\n)\\n\\n4\\n\\n)()(\\n\\n3\\n\\n())\\n\\n5\\n\\n(((((\\n\\n10\\n\\n)(())))())\"]",
    "exec_outcome": "PASSED",
    "source_code": "import os,sys\r\nfrom random import randint, shuffle\r\nfrom io import BytesIO, IOBase\r\n\r\nfrom collections import defaultdict,deque,Counter\r\nfrom bisect import bisect_left,bisect_right\r\nfrom heapq import heappush,heappop\r\nfrom functools import lru_cache\r\nfrom itertools import accumulate, permutations\r\nimport math\r\n\r\n# Fast IO Region\r\nBUFSIZE = 8192\r\nclass FastIO(IOBase):\r\n    newlines = 0\r\n    def __init__(self, file):\r\n        self._fd = file.fileno()\r\n        self.buffer = BytesIO()\r\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\r\n        self.write = self.buffer.write if self.writable else None\r\n    def read(self):\r\n        while True:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            if not b:\r\n                break\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines = 0\r\n        return self.buffer.read()\r\n    def readline(self):\r\n        while self.newlines == 0:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            self.newlines = b.count(b\"\\n\") + (not b)\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines -= 1\r\n        return self.buffer.readline()\r\n    def flush(self):\r\n        if self.writable:\r\n            os.write(self._fd, self.buffer.getvalue())\r\n            self.buffer.truncate(0), self.buffer.seek(0)\r\nclass IOWrapper(IOBase):\r\n    def __init__(self, file):\r\n        self.buffer = FastIO(file)\r\n        self.flush = self.buffer.flush\r\n        self.writable = self.buffer.writable\r\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\r\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\r\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\r\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\r\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\r\n\r\n# for _ in range(int(input())):\r\n#     n = int(input())\r\n#     a = list(map(int, input().split()))\r\n\r\n# for _ in range(int(input())):\r\n#     n = int(input())\r\n#     a = list(map(int, input().split()))\r\n#     if a[0] == min(a):\r\n#         print('YES')\r\n#     else:\r\n#         print('NO')\r\n\r\n# for _ in range(int(input())):\r\n#     n = int(input())\r\n#     s = input()\r\n#     cnt = 0\r\n#     for i in range(n):\r\n#         if s[i] == '0':\r\n#             cnt += 1\r\n#     if cnt == 0 or cnt == n:\r\n#         ans = n * n\r\n#     else:\r\n#         ans = cnt * (n - cnt)\r\n#     a = s.split('0')\r\n#     mx = 0\r\n#     for i in a:\r\n#         mx = max(mx, len(i))\r\n#     b = s.split('1')\r\n#     for i in b:\r\n#         mx = max(mx, len(i))\r\n#     print(max(mx * mx, ans))\r\n\r\n# N = int(pow(10 ** 9, 0.5)) + 5\r\n# def get_prime_linear(n):\r\n#     global cnt\r\n#     for i in range(2, n + 1):\r\n#         if not st[i]:\r\n#             primes[cnt] = i\r\n#             cnt += 1\r\n#         for j in range(n):\r\n#             if primes[j] > n / i: break\r\n#             st[primes[j] * i] = True\r\n#             if i % primes[j] == 0: break \r\n# primes, cnt, st = [0] * (N + 5), 0, [False] * (N + 5)\r\n# get_prime_linear(N)\r\n# prime1e3 = primes[:cnt]\r\n# @lru_cache(None)\r\n# def get_factor(n):\r\n#     res = []\r\n#     for i in prime1e3:\r\n#         if i * i > n:\r\n#             break\r\n#         while n % i == 0:\r\n#             n //= i\r\n#             res.append(i)\r\n#     if n > 1:\r\n#         res.append(n)\r\n#     return sorted(set(res))\r\n\r\n# mod = 998244353\r\n# for _ in range(int(input())):\r\n#     n, m = list(map(int, input().split()))\r\n#     a = list(map(int, input().split()))\r\n#     ans = 1\r\n#     for i in range(1, n):\r\n#         if a[i - 1] % a[i]:\r\n#             ans = 0\r\n#             break\r\n#         k = a[i - 1] // a[i]\r\n#         mx = m // a[i]\r\n#         f = get_factor(k)\r\n#         res = 0\r\n#         N = len(f)\r\n#         for i in range(1 << N):\r\n#             cnt = 0\r\n#             cur = 1\r\n#             for j in range(N):\r\n#                 if i >> j & 1:\r\n#                     cnt += 1\r\n#                     cur *= f[j]\r\n#             if cnt % 2 == 0: res += mx // cur\r\n#             else: res -= mx // cur\r\n#         ans = ans * res % mod\r\n#     print(ans)\r\n\r\nfor _ in range(int(input())):\r\n    n = int(input())\r\n    s = input()\r\n    a = [0]\r\n    cur = 0\r\n    for i in range(n):\r\n        if s[i] == '(':\r\n            cur += 1\r\n        else:\r\n            cur -= 1\r\n        a.append(cur)\r\n    n = len(a)\r\n    stack = []\r\n    l = [-1] * (n)\r\n    for i in range(n):\r\n        while stack and stack[-1][0] >= a[i]:\r\n            stack.pop()\r\n        l[i] = stack[-1][1] if stack else -1\r\n        stack.append([a[i], i])\r\n    stack = []\r\n    r = [n] * (n)\r\n    for i in range(n)[::-1]:\r\n        while stack and stack[-1][0] > a[i]:\r\n            stack.pop()\r\n        r[i] = stack[-1][1] if stack else n\r\n        stack.append([a[i], i])\r\n    ans = 0\r\n    for i in range(n):\r\n        ans -= a[i] * (i - l[i]) * (r[i] - i)\r\n    a.sort()\r\n    for i in range(n):\r\n        ans += (i + 1) * a[i]\r\n    print(ans)\r\n\r\n\r\n\r\n\r\n\r\n",
    "prob_desc_created_at": "1667745300",
    "tags": [
        "binary search",
        "data structures",
        "divide and conquer",
        "dp",
        "greedy",
        "strings"
    ],
    "hidden_unit_tests": ""
}
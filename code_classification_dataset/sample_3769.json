{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"8\\n5\\n11880\\n351025663\"]",
    "src_uid": "5f44c5eed653c150476b7fc6fa5d373b",
    "prob_desc_notes": "NoteIn the first test case, the following $$$8$$$ arrays satisfy the conditions from the statement:   $$$[1,2,1]$$$;  $$$[1,2,2]$$$;  $$$[1,3,1]$$$;  $$$[1,3,2]$$$;  $$$[1,3,3]$$$;  $$$[2,3,1]$$$;  $$$[2,3,2]$$$;  $$$[2,3,3]$$$. In the second test case, the following $$$5$$$ arrays satisfy the conditions from the statement:   $$$[1,1,1,1]$$$;  $$$[2,1,1,1]$$$;  $$$[2,2,1,1]$$$;  $$$[2,2,2,1]$$$;  $$$[2,2,2,2]$$$. ",
    "prob_desc_description": "The position of the leftmost maximum on the segment $$$[l; r]$$$ of array $$$x = [x_1, x_2, \\ldots, x_n]$$$ is the smallest integer $$$i$$$ such that $$$l \\le i \\le r$$$ and $$$x_i = \\max(x_l, x_{l+1}, \\ldots, x_r)$$$.You are given an array $$$a = [a_1, a_2, \\ldots, a_n]$$$ of length $$$n$$$. Find the number of integer arrays $$$b = [b_1, b_2, \\ldots, b_n]$$$ of length $$$n$$$ that satisfy the following conditions:   $$$1 \\le b_i \\le m$$$ for all $$$1 \\le i \\le n$$$;  for all pairs of integers $$$1 \\le l \\le r \\le n$$$, the position of the leftmost maximum on the segment $$$[l; r]$$$ of the array $$$b$$$ is equal to the position of the leftmost maximum on the segment $$$[l; r]$$$ of the array $$$a$$$. Since the answer might be very large, print its remainder modulo $$$10^9+7$$$.",
    "prob_desc_output_spec": "For each test case print one integer — the number of arrays $$$b$$$ that satisfy the conditions from the statement, modulo $$$10^9+7$$$.",
    "prob_desc_input_spec": "Each test contains multiple test cases. The first line contains a single integer $$$t$$$ ($$$1 \\le t \\le 10^3$$$) — the number of test cases. The first line of each test case contains two integers $$$n$$$ and $$$m$$$ ($$$2 \\le n,m \\le 2 \\cdot 10^5$$$, $$$n \\cdot m \\le 10^6$$$). The second line of each test case contains $$$n$$$ integers $$$a_1,a_2,\\ldots,a_n$$$ ($$$1 \\le a_i \\le m$$$) — the array $$$a$$$. It is guaranteed that the sum of $$$n \\cdot m$$$ over all test cases doesn't exceed $$$10^6$$$.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3-64",
    "lang_cluster": "Python",
    "difficulty": 2300,
    "file_name": "train_083.jsonl",
    "code_uid": "df6622606291bb3cdc8dc4e9889fdf3a",
    "prob_desc_memory_limit": "512 megabytes",
    "prob_desc_sample_inputs": "[\"4\\n\\n3 3\\n\\n1 3 2\\n\\n4 2\\n\\n2 2 2 2\\n\\n6 9\\n\\n6 9 6 9 6 9\\n\\n9 100\\n\\n10 40 20 20 100 60 80 60 60\"]",
    "exec_outcome": "PASSED",
    "source_code": "import sys\r\n\r\n\r\ndef solve():\r\n    inp = sys.stdin.readline\r\n    n, m = map(int, inp().split())\r\n    g = [[] for i in range(n + 1)]\r\n    ginv = [[] for i in range(n + 1)]\r\n    idx = 0\r\n    st = []\r\n    for v in map(int, inp().split()):\r\n        while st:\r\n           pv, pidx = st[-1]\r\n           if pv < v:\r\n               st.pop()\r\n               g[idx].append(pidx)\r\n               ginv[pidx].append(idx)\r\n           else:\r\n               break\r\n        st.append((v, idx))\r\n        idx += 1\r\n    while st:\r\n        pv, pidx = st[-1]\r\n        st.pop()\r\n        g[n].append(pidx)\r\n        ginv[pidx].append(n)\r\n    degree = [0] * (n + 1)\r\n    st = []\r\n    for i in range(n + 1):\r\n        degree[i] = len(g[i])\r\n        if degree[i] == 0:\r\n            st.append(i)\r\n    dp = [None] * (n + 1)\r\n    MOD = int(1e9 + 7)\r\n    while st:\r\n        x = st[-1]\r\n        st.pop()\r\n        if g[x]:\r\n            vec = g[x]\r\n            d = dp[vec[0]]\r\n            for i in range(1, m + 2):\r\n                d[i] = (d[i] + d[i - 1]) % MOD\r\n            for j in range(1, len(vec)):\r\n                dd = dp[vec[j]]\r\n                nd = [0] * (m + 2)\r\n                for i in range(1, m + 2):\r\n                    nd[i] = (dd[i] * d[i] + nd[i - 1]) % MOD\r\n                d = nd\r\n            d.insert(0, 0)\r\n            d.pop()\r\n        else:\r\n            d = [1] * (m + 2)\r\n            d[0] = 0\r\n        dp[x] = d\r\n        for v in ginv[x]:\r\n            degree[v] -= 1\r\n            if degree[v] == 0:\r\n                st.append(v)\r\n    print(dp[n][m + 1])\r\n\r\ndef main():\r\n    for i in range(int(sys.stdin.readline())):\r\n        solve()\r\n\r\n\r\nif __name__ == '__main__':\r\n    main()\r\n",
    "prob_desc_created_at": "1668263700",
    "tags": [
        "binary search",
        "data structures",
        "divide and conquer",
        "dp",
        "flows",
        "math",
        "trees"
    ],
    "hidden_unit_tests": ""
}
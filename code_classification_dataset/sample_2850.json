{
    "prob_desc_time_limit": "3 seconds",
    "prob_desc_sample_outputs": "[\"2 1\", \"2 1 3\", \"-1\"]",
    "src_uid": "a2616b1681f30ce4b2a5fdc81cf52b50",
    "prob_desc_notes": null,
    "prob_desc_description": "The employees of the F company have lots of ways to entertain themselves. Today they invited a famous magician who shows a trick with plastic cups and a marble.The point is to trick the spectator's attention. Initially, the spectator stands in front of a line of n plastic cups. Then the magician places a small marble under one cup and shuffles the cups. Then the spectator should guess which cup hides the marble.But the head coder of the F company isn't easy to trick. When he saw the performance, he noticed several important facts:  each cup contains a mark — a number from 1 to n; all marks on the cups are distinct;  the magician shuffles the cups in m operations, each operation looks like that: take a cup marked xi, sitting at position yi in the row of cups (the positions are numbered from left to right, starting from 1) and shift it to the very beginning of the cup row (on the first position). When the head coder came home after work he wanted to re-do the trick. Unfortunately, he didn't remember the starting or the final position of the cups. He only remembered which operations the magician performed. Help the coder: given the operations in the order they were made find at least one initial permutation of the cups that can go through the described operations in the given order. Otherwise, state that such permutation doesn't exist.",
    "prob_desc_output_spec": "If the described permutation doesn't exist (the programmer remembered wrong operations), print -1. Otherwise, print n distinct integers, each from 1 to n: the i-th number should represent the mark on the cup that initially is in the row in position i. If there are multiple correct answers, you should print the lexicographically minimum one.",
    "prob_desc_input_spec": "The first line contains integers n and m (1 ≤ n, m ≤ 106). Each of the next m lines contains a couple of integers. The i-th line contains integers xi, yi (1 ≤ xi, yi ≤ n) — the description of the i-th operation of the magician. Note that the operations are given in the order in which the magician made them and the coder wants to make them in the same order.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3",
    "lang_cluster": "Python",
    "difficulty": 2200,
    "file_name": "train_033.jsonl",
    "code_uid": "73927b0047c033c29901e53181d6d788",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"2 1\\n2 1\", \"3 2\\n1 2\\n1 1\", \"3 3\\n1 3\\n2 3\\n1 3\"]",
    "exec_outcome": "PASSED",
    "source_code": "import io\nimport os\n\n# List with O(n^1/3) (for n=10**6) get/set/insert/delete based on: https://github.com/cheran-senthil/PyRival/blob/master/pyrival/data_structures/SortedList.py\n\n\nclass UnsortedList:\n    def __init__(self, iterable=[], _load=100):\n        \"\"\"Initialize sorted list instance.\"\"\"\n        values = sorted(iterable)\n        self._len = _len = len(values)\n        self._load = _load\n        self._lists = _lists = [values[i : i + _load] for i in range(0, _len, _load)]\n        self._list_lens = [len(_list) for _list in _lists]\n        # self._mins = [_list[0] for _list in _lists]\n        self._fen_tree = []\n        self._rebuild = True\n\n    def _fen_build(self):\n        \"\"\"Build a fenwick tree instance.\"\"\"\n        self._fen_tree[:] = self._list_lens\n        _fen_tree = self._fen_tree\n        for i in range(len(_fen_tree)):\n            if i | i + 1 < len(_fen_tree):\n                _fen_tree[i | i + 1] += _fen_tree[i]\n        self._rebuild = False\n\n    def _fen_update(self, index, value):\n        \"\"\"Update `fen_tree[index] += value`.\"\"\"\n        if not self._rebuild:\n            _fen_tree = self._fen_tree\n            while index < len(_fen_tree):\n                _fen_tree[index] += value\n                index |= index + 1\n\n    def _fen_query(self, end):\n        \"\"\"Return `sum(_fen_tree[:end])`.\"\"\"\n        if self._rebuild:\n            self._fen_build()\n\n        _fen_tree = self._fen_tree\n        x = 0\n        while end:\n            x += _fen_tree[end - 1]\n            end &= end - 1\n        return x\n\n    def _fen_findkth(self, k):\n        \"\"\"Return a pair of (the largest `idx` such that `sum(_fen_tree[:idx]) <= k`, `k - sum(_fen_tree[:idx])`).\"\"\"\n        _list_lens = self._list_lens\n        if k < _list_lens[0]:\n            return 0, k\n        if k >= self._len - _list_lens[-1]:\n            return len(_list_lens) - 1, k + _list_lens[-1] - self._len\n        if self._rebuild:\n            self._fen_build()\n\n        _fen_tree = self._fen_tree\n        idx = -1\n        for d in reversed(range(len(_fen_tree).bit_length())):\n            right_idx = idx + (1 << d)\n            if right_idx < len(_fen_tree) and k >= _fen_tree[right_idx]:\n                idx = right_idx\n                k -= _fen_tree[idx]\n        return idx + 1, k\n\n    def _delete(self, pos, idx):\n        \"\"\"Delete value at the given `(pos, idx)`.\"\"\"\n        _lists = self._lists\n        # _mins = self._mins\n        _list_lens = self._list_lens\n\n        self._len -= 1\n        self._fen_update(pos, -1)\n        del _lists[pos][idx]\n        _list_lens[pos] -= 1\n\n        if _list_lens[pos]:\n            # _mins[pos] = _lists[pos][0]\n            pass\n        else:\n            del _lists[pos]\n            del _list_lens[pos]\n            # del _mins[pos]\n            self._rebuild = True\n\n    def __len__(self):\n        \"\"\"Return the size of the sorted list.\"\"\"\n        return self._len\n\n    def __getitem__(self, index):\n        \"\"\"Lookup value at `index` in sorted list.\"\"\"\n        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)\n        return self._lists[pos][idx]\n\n    def __delitem__(self, index):\n        \"\"\"Remove value at `index` from sorted list.\"\"\"\n        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)\n        self._delete(pos, idx)\n\n    def __setitem__(self, index, value):\n        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)\n        self._lists[pos][idx] = value\n\n    def insert(self, index, value):\n        _load = self._load\n        _lists = self._lists\n        _list_lens = self._list_lens\n\n        if _lists:\n            pos, idx = self._fen_findkth(self._len + index if index < 0 else index)\n            self._fen_update(pos, 1)\n            _list = _lists[pos]\n            _list.insert(idx, value)\n            _list_lens[pos] += 1\n            if _load + _load < len(_list):\n                _lists.insert(pos + 1, _list[_load:])\n                _list_lens.insert(pos + 1, len(_list) - _load)\n                _list_lens[pos] = _load\n                del _list[_load:]\n                self._rebuild = True\n        else:\n            _lists.append([value])\n            _list_lens.append(1)\n            self._rebuild = True\n        self._len += 1\n\n    def __iter__(self):\n        \"\"\"Return an iterator over the sorted list.\"\"\"\n        return (value for _list in self._lists for value in _list)\n\n    def __reversed__(self):\n        \"\"\"Return a reverse iterator over the sorted list.\"\"\"\n        return (value for _list in reversed(self._lists) for value in reversed(_list))\n\n    def __repr__(self):\n        \"\"\"Return string representation of sorted list.\"\"\"\n        return \"SortedList({0})\".format(list(self))\n\n\ndef solve(N, M, queries):\n    idToMark = [-1 for i in range(N)]\n    cups = UnsortedList([i for i in range(N)])\n    for mark, pos in queries:\n        pos -= 1  # 0-indexed\n        cupId = cups[pos]\n        del cups[pos]\n        cups.insert(0, cupId)\n\n        if idToMark[cupId] == -1:\n            idToMark[cupId] = mark\n        elif idToMark[cupId] != mark:\n            return b\"-1\"\n\n    markToCounts = [0 for i in range(N + 1)]\n    for cupId, mark in enumerate(idToMark):\n        if mark != -1:\n            markToCounts[mark] += 1\n            if markToCounts[mark] > 1:\n                return b\"-1\"\n\n    j = 1\n    ans = []\n    for cupId, mark in enumerate(idToMark):\n        if mark != -1:\n            ans.append(mark)\n        else:\n            while markToCounts[j] > 0:\n                j += 1\n            ans.append(j)\n            j += 1\n    return b\" \".join(str(x).encode(\"ascii\") for x in ans)\n\n\nif False:\n    N, M = 10 ** 6, 10 ** 6\n    queries = [[N // 2 + (i % (N // 2)), N // 2] for i in range(M)]\n    ans = solve(N, M, queries)\n    # print(ans)\n    assert ans != b\"-1\"\n    exit()\n\nif __name__ == \"__main__\":\n    input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline\n\n    N, M = [int(x) for x in input().split()]\n    queries = ((int(x) for x in input().split()) for i in range(M))\n    ans = solve(N, M, queries)\n\n    os.write(1, ans)\n",
    "prob_desc_created_at": "1398169140",
    "tags": [
        "data structures"
    ],
    "hidden_unit_tests": ""
}
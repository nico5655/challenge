{
    "prob_desc_time_limit": "5 seconds",
    "prob_desc_sample_outputs": "[\"500000004\\n1\\n500000004\", \"625000011\\n13\\n62500020\\n375000027\\n62500027\"]",
    "src_uid": "cdf42ae9f76a36295c701b0606ea5bfc",
    "prob_desc_notes": "NoteIn first testcase, initially, there are four possible battalions   {} Strength = $$$0$$$  {$$$1$$$} Strength = $$$0$$$  {$$$2$$$} Strength = $$$0$$$  {$$$1,2$$$} Strength = $$$2$$$  So strength of army is $$$\\frac{0+0+0+2}{4}$$$ = $$$\\frac{1}{2}$$$After changing $$$p_{1}$$$ to $$$2$$$, strength of battallion {$$$1,2$$$} changes to $$$4$$$, so strength of army becomes $$$1$$$.After changing $$$p_{2}$$$ to $$$1$$$, strength of battalion {$$$1,2$$$} again becomes $$$2$$$, so strength of army becomes $$$\\frac{1}{2}$$$.",
    "prob_desc_description": "There are $$$n$$$ officers in the Army of Byteland. Each officer has some power associated with him. The power of the $$$i$$$-th officer is denoted by $$$p_{i}$$$. As the war is fast approaching, the General would like to know the strength of the army.The strength of an army is calculated in a strange way in Byteland. The General selects a random subset of officers from these $$$n$$$ officers and calls this subset a battalion.(All $$$2^n$$$ subsets of the $$$n$$$ officers can be chosen equally likely, including empty subset and the subset of all officers).The strength of a battalion is calculated in the following way:Let the powers of the chosen officers be $$$a_{1},a_{2},\\ldots,a_{k}$$$, where $$$a_1 \\le a_2 \\le \\dots \\le a_k$$$. The strength of this battalion is equal to $$$a_1a_2 + a_2a_3 + \\dots + a_{k-1}a_k$$$. (If the size of Battalion is $$$\\leq 1$$$, then the strength of this battalion is $$$0$$$).The strength of the army is equal to the expected value of the strength of the battalion.As the war is really long, the powers of officers may change. Precisely, there will be $$$q$$$ changes. Each one of the form $$$i$$$ $$$x$$$ indicating that $$$p_{i}$$$ is changed to $$$x$$$.You need to find the strength of the army initially and after each of these $$$q$$$ updates.Note that the changes are permanent.The strength should be found by modulo $$$10^{9}+7$$$. Formally, let $$$M=10^{9}+7$$$. It can be shown that the answer can be expressed as an irreducible fraction $$$p/q$$$, where $$$p$$$ and $$$q$$$ are integers and $$$q\\not\\equiv 0 \\bmod M$$$). Output the integer equal to $$$p\\cdot q^{-1} \\bmod M$$$. In other words, output such an integer $$$x$$$ that $$$0 \\leq x &lt; M$$$ and $$$x ⋅ q \\equiv p \\bmod M$$$).",
    "prob_desc_output_spec": "In the first line output the initial strength of the army. In $$$i$$$-th of the next $$$q$$$ lines, output the strength of the army after $$$i$$$-th update.",
    "prob_desc_input_spec": "The first line of the input contains a single integer $$$n$$$ ($$$1 \\leq n \\leq 3⋅10^{5}$$$)  — the number of officers in Byteland's Army. The second line contains $$$n$$$ integers $$$p_{1},p_{2},\\ldots,p_{n}$$$ ($$$1 \\leq p_{i} \\leq 10^{9}$$$). The third line contains a single integer $$$q$$$ ($$$1 \\leq q \\leq 3⋅10^{5}$$$)  — the number of updates. Each of the next $$$q$$$ lines contains two integers $$$i$$$ and $$$x$$$ ($$$1 \\leq i \\leq n$$$, $$$ 1 \\leq x \\leq 10^{9}$$$), indicating that $$$p_{i}$$$ is updated to $$$x$$$ .",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 2",
    "lang_cluster": "Python",
    "difficulty": 2800,
    "file_name": "train_070.jsonl",
    "code_uid": "9c11f8f3a484509b7dfcd0b39691ed80",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"2\\n1 2\\n2\\n1 2\\n2 1\", \"4\\n1 2 3 4\\n4\\n1 5\\n2 5\\n3 5\\n4 5\"]",
    "exec_outcome": "PASSED",
    "source_code": "import sys, os\nrange = xrange\ninput = raw_input\n \nimport __pypy__\nmulmod = __pypy__.intop.int_mulmod\nsub = __pypy__.intop.int_sub\nmul = __pypy__.intop.int_mul\nMOD = 10**9 + 7\nMODINV = 1.0/MOD\n \ndef mulmod(a,b):\n    x = sub(mul(a,b), mul(MOD, int(a * MODINV * b)))\n    return x + MOD if (x < 0) else (x if x < MOD else x - MOD)\n \n \n#precalc 2^-1 powers\ninvpow = pow(2, MOD - 2, MOD)\npow2 = [1]\nfor _ in range(3 * 10**5 + 10):\n    pow2.append(mulmod(pow2[-1], invpow))\n \n# returns order such that A[order[i]] <= A[order[i + 1]]\ndef sqrtsorted(A, maxval = 10**9):\n    asqrt = int((maxval)**0.5 + 2)\n    blocks1 = [[] for _ in range(asqrt)]\n    blocks2 = [[] for _ in range(asqrt)]\n    for i in range(len(A)):\n        blocks1[A[i] % asqrt].append(i)\n    for block in blocks1:\n        for i in block:\n            blocks2[A[i]//asqrt].append(i)\n    ret = []\n    for block in blocks2:\n        ret += block\n    return ret\n \n# Keeps track of expected power using the structure of the segment tree\nclass segtree:\n    def __init__(self, data, counter):\n        n = len(data)\n        m = 1\n        while m < n: m *= 2\n        \n        self.m = m\n        self.dataL = [0]*(m+m)\n        self.dataR = [0]*(m+m)\n        self.counter = [0]*(m+m)\n        self.power = 0\n \n        self.dataL[m:m+n] = data\n        self.dataR[m:m+n] = data\n        self.counter[m:m+n] = counter\n \n        for ind in reversed(range(1,m)):\n            self.counter[ind] = self.counter[ind << 1] + self.counter[(ind << 1) + 1]\n            \n            self.dataL[ind] = (mulmod(self.dataL[ind << 1], pow2[self.counter[(ind << 1) + 1]]) + self.dataL[(ind << 1) + 1] ) % MOD\n            self.dataR[ind] = (self.dataR[ind << 1] + mulmod(self.dataR[(ind << 1) + 1], pow2[self.counter[ind << 1]]) ) % MOD\n            self.power = (self.power + mulmod(self.dataL[ind << 1], self.dataR[(ind << 1) + 1]) ) % MOD\n            \n \n    \n    # Keeps track of expected power when the segment tree is modified\n    def add(self, ind, val, c = 1):\n        ind += self.m\n        while ind > 1:\n            self.counter[ind] += c\n            self.power = self.power - mulmod(self.dataL[ind & ~1], self.dataR[ind | 1])\n            \n            # If first time\n            if ind >= self.m:\n                self.dataL[ind] = val\n                self.dataR[ind] = val\n            else:\n                self.dataL[ind] = (mulmod(self.dataL[ind << 1], pow2[self.counter[(ind << 1) + 1]]) + self.dataL[(ind << 1) + 1] ) % MOD\n                self.dataR[ind] = (self.dataR[ind << 1] + mulmod(self.dataR[(ind << 1) + 1], pow2[self.counter[ind << 1]]) ) % MOD\n            \n            self.power = (self.power + mulmod(self.dataL[ind & ~1], self.dataR[ind | 1]) ) % MOD\n            \n            ind >>= 1\n    \n    def rem(self, ind):\n        self.add(ind, 0, -1)\n    \n    def get_power(self):\n        return mulmod(self.power, pow2[2])\n \n#############\n### READ INPUT\n \ninp = [int(x) for x in os.read(0, os.fstat(0).st_size).split()]; ii = 0\nn = inp[ii]; ii += 1\n \n# Order all involved powers\nvalues = inp[ii: ii + n] + inp[ii + n + 2:: 2]\norder = sqrtsorted(values)\n \ninvorder = [-1]*len(order)\nfor i in range(len(order)):\n    invorder[order[i]] = i\n \n# Initialize the seg tree containing powers\nP = inp[ii: ii + n]; ii += n\nwho = list(range(n))\n \n \n##############\n### POPULATE SEGTREE\n \npower = 0\n \ndata = [0]*len(order)\ncounter = [0]*len(order)\nfor i in range(n):\n    data[invorder[i]] = P[i]\n    counter[invorder[i]] = 1\n \nseg = segtree(data, counter)\n \n##############\n### SOLVE QUERIES\n \nimport __pypy__\nout = __pypy__.builders.StringBuilder()\n \nq = inp[ii]; ii += 1\nout.append(str(seg.get_power()))\nout.append('\\n')\nfor _ in range(q):\n    i = inp[ii] - 1; ii += 1\n    x = inp[ii]; ii += 1\n \n    # Remove power at who[i]\n    ind = invorder[who[i]]\n    seg.rem(ind)\n \n    # Add new power at i\n    ind = invorder[n + _]\n    who[i] = n + _\n    seg.add(ind, x)\n \n    out.append(str(seg.get_power()))\n    out.append('\\n')\n \nos.write(1, out.build())",
    "prob_desc_created_at": "1583332500",
    "tags": [
        "data structures",
        "divide and conquer",
        "probabilities"
    ],
    "hidden_unit_tests": ""
}
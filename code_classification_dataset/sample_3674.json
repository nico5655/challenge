{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"2\\n3\", \"2\"]",
    "src_uid": "dd0dc4390b4c8e58aeeb82b9a587e946",
    "prob_desc_notes": "NoteIn the first example on the first day if s = 1, f = 2, t = 3, Misha would go on the route 1  2, and Grisha would go on the route 3  1  2. He would see the text at the stations 1 and 2. On the second day, if s = 3, f = 2, t = 3, both boys would go on the route 3  1  2. Grisha would see the text at 3 stations.In the second examle if s = 1, f = 3, t = 2, Misha would go on the route 1  2  3, and Grisha would go on the route 2  3 and would see the text at both stations.",
    "prob_desc_description": "Misha and Grisha are funny boys, so they like to use new underground. The underground has n stations connected with n - 1 routes so that each route connects two stations, and it is possible to reach every station from any other.The boys decided to have fun and came up with a plan. Namely, in some day in the morning Misha will ride the underground from station s to station f by the shortest path, and will draw with aerosol an ugly text \"Misha was here\" on every station he will pass through (including s and f). After that on the same day at evening Grisha will ride from station t to station f by the shortest path and will count stations with Misha's text. After that at night the underground workers will wash the texts out, because the underground should be clean. The boys have already chosen three stations a, b and c for each of several following days, one of them should be station s on that day, another should be station f, and the remaining should be station t. They became interested how they should choose these stations s, f, t so that the number Grisha will count is as large as possible. They asked you for help.",
    "prob_desc_output_spec": "Print q lines. In the i-th of these lines print the maximum possible number Grisha can get counting when the stations s, t and f are chosen optimally from the three stations on the i-th day.",
    "prob_desc_input_spec": "The first line contains two integers n and q (2 ≤ n ≤ 105, 1 ≤ q ≤ 105) — the number of stations and the number of days. The second line contains n - 1 integers p2, p3, ..., pn (1 ≤ pi ≤ n). The integer pi means that there is a route between stations pi and i. It is guaranteed that it's possible to reach every station from any other. The next q lines contains three integers a, b and c each (1 ≤ a, b, c ≤ n) — the ids of stations chosen by boys for some day. Note that some of these ids could be same.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3",
    "lang_cluster": "Python",
    "difficulty": 1900,
    "file_name": "train_078.jsonl",
    "code_uid": "6e00e00e7bbce0508b17ceb6821f373b",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"3 2\\n1 1\\n1 2 3\\n2 3 3\", \"4 1\\n1 2 3\\n1 2 3\"]",
    "exec_outcome": "PASSED",
    "source_code": "import os\nimport sys\nfrom io import BytesIO, IOBase\nfrom types import GeneratorType\nfrom collections import defaultdict\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\nsys.setrecursionlimit(3*10**5)\n\n\ndef bootstrap(f, stack=[]):\n    def wrappedfunc(*args, **kwargs):\n        if stack:\n            return f(*args, **kwargs)\n        else:\n            to = f(*args, **kwargs)\n            while True:\n                if type(to) is GeneratorType:\n                    stack.append(to)\n                    to = next(to)\n                else:\n                    stack.pop()\n                    if not stack:\n                        break\n                    to = stack[-1].send(to)\n            return to\n    return wrappedfunc\n\n\n\n\n\n\nMA=10**5+1\nlevel=20\ntree=[[] for i in range(MA)]\ndepth=[0 for i in range(MA)]\nparent=[[0 for i in range(level)] for j in range(MA)]\n\n\n@bootstrap\ndef dfs(cur,prev):\n    depth[cur] = depth[prev] + 1\n    parent[cur][0] = prev\n    for i in range(len(tree[cur])):\n        if (tree[cur][i] != prev):\n            yield dfs(tree[cur][i], cur)\n\n    yield\n\ndef precomputeSparseMatrix(n):\n    for i in range(1,level):\n        for node in range(1,n+1):\n            if (parent[node][i-1] != -1):\n                parent[node][i] =parent[parent[node][i-1]][i-1]\n\n\ndef lca(u,v):\n    if (depth[v] < depth[u]):\n        u,v=v,u\n\n    diff = depth[v] - depth[u]\n\n\n    for i in range(level):\n        if ((diff >> i) & 1):\n            v = parent[v][i]\n\n\n    if (u == v):\n        return u\n\n    i=level-1\n    while(i>=0):\n\n        if (parent[u][i] != parent[v][i]):\n            u = parent[u][i]\n            v = parent[v][i]\n\n        i+=-1\n\n    return parent[u][0]\n\n\n\ndef add(a,b):\n    tree[a].append(b)\n    tree[b].append(a)\n\ndef res(s,t,f):\n    p=lca(t,f)\n    q=lca(s,f)\n    if p==q:\n        r=depth[lca(s,t)]-depth[p]\n        return min(depth[p] + depth[f] - 2 * depth[p] + 1+r, depth[q] + depth[f] - 2 * depth[q] + 1+r)\n\n\n    return min(depth[p]+depth[f]-2*depth[p]+1,depth[q]+depth[f]-2*depth[q]+1)\n\n\n\n\n\n\n\n\nn,q=map(int,input().split())\np=list(map(int,input().split()))\n\n\n\n\n\n\nfor j in range(n-1):\n    tree[p[j]].append(j+2)\n    tree[j+2].append(p[j])\n\ndfs(1,0)\nprecomputeSparseMatrix(n)\nfor j in range(q):\n    a,b,c=map(int,input().split())\n    print(max(res(a,b,c),res(a,c,b),res(b,c,a)))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
    "prob_desc_created_at": "1500906900",
    "tags": [
        "dfs and similar",
        "trees",
        "graphs"
    ],
    "hidden_unit_tests": ""
}
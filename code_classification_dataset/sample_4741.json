{
    "prob_desc_time_limit": "1 second",
    "prob_desc_sample_outputs": "[\"3 1 4 2 5 6\\n123 10 456 789\\n9 6\"]",
    "src_uid": "4296da660a39a6e98b41387929701c0a",
    "prob_desc_notes": "NoteIn the first testcase, array $$$[3, 1, 4, 2, 5, 6]$$$ works, as it's a permutation of $$$[1, 2, 3, 4, 5, 6]$$$, and $$$\\frac{3+4}{2}\\neq 1$$$, $$$\\frac{1+2}{2}\\neq 4$$$, $$$\\frac{4+5}{2}\\neq 2$$$, $$$\\frac{2+6}{2}\\neq 5$$$, $$$\\frac{5+3}{2}\\neq 6$$$, $$$\\frac{6+1}{2}\\neq 3$$$.",
    "prob_desc_description": "You are given an array $$$a$$$ of $$$2n$$$ distinct integers. You want to arrange the elements of the array in a circle such that no element is equal to the the arithmetic mean of its $$$2$$$ neighbours.More formally, find an array $$$b$$$, such that: $$$b$$$ is a permutation of $$$a$$$.For every $$$i$$$ from $$$1$$$ to $$$2n$$$, $$$b_i \\neq \\frac{b_{i-1}+b_{i+1}}{2}$$$, where $$$b_0 = b_{2n}$$$ and $$$b_{2n+1} = b_1$$$. It can be proved that under the constraints of this problem, such array $$$b$$$ always exists.",
    "prob_desc_output_spec": "For each testcase, you should output $$$2n$$$ integers, $$$b_1, b_2, \\ldots b_{2n}$$$, for which the conditions from the statement are satisfied.",
    "prob_desc_input_spec": "The first line of input contains a single integer $$$t$$$ $$$(1 \\leq t \\leq 1000)$$$ — the number of testcases. The description of testcases follows. The first line of each testcase contains a single integer $$$n$$$ $$$(1 \\leq n \\leq 25)$$$. The second line of each testcase contains $$$2n$$$ integers $$$a_1, a_2, \\ldots, a_{2n}$$$ $$$(1 \\leq a_i \\leq 10^9)$$$ — elements of the array. Note that there is no limit to the sum of $$$n$$$ over all testcases.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "Python 3",
    "lang_cluster": "Python",
    "difficulty": 800,
    "file_name": "train_105.jsonl",
    "code_uid": "7bcc48e34e7f5874e53cd39ebaaa9ae9",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"3\\n3\\n1 2 3 4 5 6\\n2\\n123 456 789 10\\n1\\n6 9\"]",
    "exec_outcome": "PASSED",
    "source_code": "import os\nimport sys\nimport math\nfrom io import BytesIO, IOBase\nfrom collections import deque,defaultdict,OrderedDict,Counter\nfrom heapq import heappush,heappop,heapify\nfrom bisect import bisect_right,insort,bisect_left\nfrom functools import lru_cache\nfrom itertools import permutations\n\nsys.setrecursionlimit(10**6)\n\ndef STRIN():return input()\ndef INTIN():return int(input())\ndef LINT():return list(map(int,input().split()))\ndef LSTR():return list(map(str,input().split()))\ndef MINT():return map(int,input().split())\ndef MSTR():return map(str,input().split())\n\n\n\ndef solve(s):\n\n    if s==s[::-1]:\n        return True\n    return False\n\n\ndef main():\n    for _ in range(int(input())):\n        n=INTIN()\n        l=LINT()\n\n        l.sort()\n        \n        ans=[0]*(2*n)\n\n        a=l[:(2*n)//2]\n        b=l[(2*n)//2:]\n        k=0\n\n        for i,j in zip(a,b):\n            ans[k]=j \n            ans[k+1]=i\n            k+=2\n        print(*ans)\n\n\n\n      \n        \n\n\n\n\n        \n\n\n\n\n\n\n\n        \n       \n\n\n\n\n    \n    \n\n            \n\n\n\n        \n\n\n\n\n\n\n\n\n    \n        \n\n\n\n\n\n    \n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# region fastio\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n# endregion\n\nif __name__ == \"__main__\":\n    main()\n\n",
    "prob_desc_created_at": "1622210700",
    "tags": [
        "constructive algorithms",
        "sortings"
    ],
    "hidden_unit_tests": ""
}
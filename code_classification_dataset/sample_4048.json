{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"YES\\nNO\\nYES\\nNO\\nYES\", \"YES\\nNO\\nYES\\nYES\"]",
    "src_uid": "e2db2e7470a24c17158772be94eef12c",
    "prob_desc_notes": null,
    "prob_desc_description": "This is an easy version of the problem. The only difference between an easy and a hard version is in the number of queries.Polycarp grew a tree from $$$n$$$ vertices. We remind you that a tree of $$$n$$$ vertices is an undirected connected graph of $$$n$$$ vertices and $$$n-1$$$ edges that does not contain cycles.He calls a set of vertices passable if there is such a path in the tree that passes through each vertex of this set without passing through any edge twice. The path can visit other vertices (not from this set).In other words, a set of vertices is called passable if there is a simple path that passes through all the vertices of this set (and possibly some other).For example, for a tree below sets $$$\\{3, 2, 5\\}$$$, $$$\\{1, 5, 4\\}$$$, $$$\\{1, 4\\}$$$ are passable, and $$$\\{1, 3, 5\\}$$$, $$$\\{1, 2, 3, 4, 5\\}$$$ are not.  Polycarp asks you to answer $$$q$$$ queries. Each query is a set of vertices. For each query, you need to determine whether the corresponding set of vertices is passable.",
    "prob_desc_output_spec": "Output $$$q$$$ lines, each of which contains the answer to the corresponding query. As an answer, output \"YES\" if the set is passable, and \"NO\" otherwise. You can output the answer in any case (for example, the strings \"yEs\", \"yes\", \"Yes\" and \"YES\" will be recognized as a positive answer).",
    "prob_desc_input_spec": "The first line of input contains a single integer $$$n$$$ ($$$1 \\le n \\le 2 \\cdot 10^5$$$) — number of vertices. Following $$$n - 1$$$ lines a description of the tree.. Each line contains two integers $$$u$$$ and $$$v$$$ ($$$1 \\le u, v \\le n$$$, $$$u \\ne v$$$) — indices of vertices connected by an edge. Following line contains single integer $$$q$$$ ($$$1 \\le q \\le 5$$$) — number of queries. The following $$$2 \\cdot q$$$ lines contain descriptions of sets. The first line of the description contains an integer $$$k$$$ ($$$1 \\le k \\le n$$$) — the size of the set. The second line of the description contains $$$k$$$ of distinct integers $$$p_1, p_2, \\dots, p_k$$$ ($$$1 \\le p_i \\le n$$$) — indices of the vertices of the set. It is guaranteed that the sum of $$$k$$$ values for all queries does not exceed $$$2 \\cdot 10^5$$$.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3-64",
    "lang_cluster": "Python",
    "difficulty": 1900,
    "file_name": "train_089.jsonl",
    "code_uid": "d15fdd310b6b0d01b4e2e7f7d4fdc839",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"5\\n1 2\\n2 3\\n2 4\\n4 5\\n5\\n3\\n3 2 5\\n5\\n1 2 3 4 5\\n2\\n1 4\\n3\\n1 3 5\\n3\\n1 5 4\", \"5\\n1 2\\n3 2\\n2 4\\n5 2\\n4\\n2\\n3 1\\n3\\n3 4 5\\n3\\n2 3 5\\n1\\n1\"]",
    "exec_outcome": "PASSED",
    "source_code": "import sys\r\nfrom typing import List\r\n\r\ninput = sys.stdin.readline\r\n\r\nclass LowestCommonAncestor:\r\n    def __init__(self, n, E):\r\n        assert n >= 1 and len(E) == n - 1\r\n        self.n = n\r\n        self.adj = [[] for _ in range(self.n)]\r\n\r\n        for e in E:\r\n            u, v = e\r\n            self.adj[u].append(v)\r\n            self.adj[v].append(u)\r\n\r\n        self.sz = 1\r\n        while 1 << self.sz < n:\r\n            self.sz += 1\r\n\r\n        self.root = None\r\n        self.depth = [-1 for _ in range(n)]\r\n        self.up = [[-1] * self.sz for _ in range(n)]\r\n\r\n    def dfs(self, root):\r\n        stack = [(root, root, 0)]\r\n        while len(stack):\r\n            u, prev, d = stack.pop()\r\n            self.depth[u] = d\r\n            self.up[u][0] = prev\r\n            for v in self.adj[u]:\r\n                if v == prev:\r\n                    continue\r\n                stack.append((v, u, d + 1))\r\n\r\n        for j in range(1, self.sz):\r\n            for i in range(1, self.n):\r\n                if self.up[i][j - 1] == -1:\r\n                    continue\r\n                self.up[i][j] = self.up[self.up[i][j - 1]][j - 1]\r\n\r\n    def lca(self, u, v):\r\n        if self.depth[u] > self.depth[v]:\r\n            u, v = v, u\r\n        diff = self.depth[v] - self.depth[u]\r\n        for i in reversed(range(self.sz)):\r\n            if diff >> i & 1:\r\n                v = self.up[v][i]\r\n\r\n        if u == v:\r\n            return u\r\n        for i in reversed(range(self.sz)):\r\n            pu, pv = self.up[u][i], self.up[v][i]\r\n            if pu != pv:\r\n                u, v = pu, pv\r\n        return self.up[u][0]\r\n\r\n\r\n\r\ndef query(LCA, p):\r\n    depth = LCA.depth\r\n    lca = LCA.lca\r\n    p.sort(key=lambda idx: -depth[idx])\r\n    left_chain_deepest = p[0]\r\n\r\n    right_chain_deepest = -1\r\n    turning_point = 0\r\n    for x in p:\r\n        if lca(x, left_chain_deepest) != x:\r\n            if right_chain_deepest == -1:\r\n                right_chain_deepest = x\r\n                turning_point = lca(left_chain_deepest, right_chain_deepest)\r\n            else:\r\n                if lca(x, right_chain_deepest) != x:\r\n                    # print(\"Third Chain!\")\r\n                    return False\r\n\r\n    if right_chain_deepest == -1:\r\n        return True\r\n\r\n    if depth[turning_point] > depth[p[-1]]:\r\n        # print(\"Turning point(%d), deeper than root(%d)\" % (turning_point + 1, p[-1] + 1))\r\n        return False\r\n    return True\r\n\r\n# initialize\r\nn = int(input())\r\nE = []\r\nfor i in range(n - 1):\r\n    u, v = map(lambda s: int(s)-1, input().split())\r\n    E.append((u, v))\r\nLCA = LowestCommonAncestor(n, E)\r\nLCA.dfs(1-1)\r\nq = int(input())\r\nfor qq in range(q):\r\n    k = int(input())\r\n    *p, = map(lambda s: int(s)-1, input().split())\r\n    print(\"YES\" if query(LCA, p) else \"NO\")\r\n\r\n\r\n\r\n# n = 5\r\n# E = [(1, 2), (2, 3), (2, 4), (4, 5)]\r\n# *E2, = map(lambda pair: (pair[0]-1, pair[1]-1), E)\r\n#\r\n# LCA = LowestCommonAncestor(n, E2)\r\n# root = 1\r\n# LCA.dfs(root - 1)\r\n# print(LCA.depth)\r\n#\r\n# q = 5\r\n# arr_k\r\n# for qq in range(q):\r\n#     k = arr_k[qq]\r\n",
    "prob_desc_created_at": "1657463700",
    "tags": [
        "dfs and similar",
        "trees"
    ],
    "hidden_unit_tests": ""
}
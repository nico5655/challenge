{
    "prob_desc_time_limit": "3 seconds",
    "prob_desc_sample_outputs": "[\"7\\n2\\n4\\n1\\n1\\n3\"]",
    "src_uid": "2c1ee398ea86209335c2248eaa723aca",
    "prob_desc_notes": null,
    "prob_desc_description": "The only difference between easy and hard versions is constraints.You are given a sequence $$$a$$$ consisting of $$$n$$$ positive integers.Let's define a three blocks palindrome as the sequence, consisting of at most two distinct elements (let these elements are $$$a$$$ and $$$b$$$, $$$a$$$ can be equal $$$b$$$) and is as follows: $$$[\\underbrace{a, a, \\dots, a}_{x}, \\underbrace{b, b, \\dots, b}_{y}, \\underbrace{a, a, \\dots, a}_{x}]$$$. There $$$x, y$$$ are integers greater than or equal to $$$0$$$. For example, sequences $$$[]$$$, $$$[2]$$$, $$$[1, 1]$$$, $$$[1, 2, 1]$$$, $$$[1, 2, 2, 1]$$$ and $$$[1, 1, 2, 1, 1]$$$ are three block palindromes but $$$[1, 2, 3, 2, 1]$$$, $$$[1, 2, 1, 2, 1]$$$ and $$$[1, 2]$$$ are not.Your task is to choose the maximum by length subsequence of $$$a$$$ that is a three blocks palindrome.You have to answer $$$t$$$ independent test cases.Recall that the sequence $$$t$$$ is a a subsequence of the sequence $$$s$$$ if $$$t$$$ can be derived from $$$s$$$ by removing zero or more elements without changing the order of the remaining elements. For example, if $$$s=[1, 2, 1, 3, 1, 2, 1]$$$, then possible subsequences are: $$$[1, 1, 1, 1]$$$, $$$[3]$$$ and $$$[1, 2, 1, 3, 1, 2, 1]$$$, but not $$$[3, 2, 3]$$$ and $$$[1, 1, 1, 1, 2]$$$.",
    "prob_desc_output_spec": "For each test case, print the answer — the maximum possible length of some subsequence of $$$a$$$ that is a three blocks palindrome.",
    "prob_desc_input_spec": "The first line of the input contains one integer $$$t$$$ ($$$1 \\le t \\le 2000$$$) — the number of test cases. Then $$$t$$$ test cases follow. The first line of the test case contains one integer $$$n$$$ ($$$1 \\le n \\le 2000$$$) — the length of $$$a$$$. The second line of the test case contains $$$n$$$ integers $$$a_1, a_2, \\dots, a_n$$$ ($$$1 \\le a_i \\le 26$$$), where $$$a_i$$$ is the $$$i$$$-th element of $$$a$$$. Note that the maximum value of $$$a_i$$$ can be up to $$$26$$$. It is guaranteed that the sum of $$$n$$$ over all test cases does not exceed $$$2000$$$ ($$$\\sum n \\le 2000$$$).",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3",
    "lang_cluster": "Python",
    "difficulty": 1800,
    "file_name": "train_010.jsonl",
    "code_uid": "758077f11bd31e5e8efbd259c142ef7a",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"6\\n8\\n1 1 2 2 3 2 1 1\\n3\\n1 3 3\\n4\\n1 10 10 1\\n1\\n26\\n2\\n2 1\\n3\\n1 1 1\"]",
    "exec_outcome": "PASSED",
    "source_code": "import os\nimport sys\nfrom io import BytesIO, IOBase\n# region fastio\n\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n# ------------------------------\n\nfrom math import factorial\nfrom collections import Counter, defaultdict\nfrom heapq import heapify, heappop, heappush\n\ndef RL(): return map(int, sys.stdin.readline().rstrip().split())\ndef N(): return int(input())\ndef comb(n, m): return factorial(n) / (factorial(m) * factorial(n - m)) if n >= m else 0\ndef perm(n, m): return factorial(n) // (factorial(n - m)) if n >= m else 0\ndef mdis(x1, y1, x2, y2): return abs(x1 - x2) + abs(y1 - y2)\nmod = 1000000007\nINF = float('inf')\n\n# ------------------------------\n\n\ndef main():\n    for _ in range(N()):\n        n = N()\n        arr = list(RL())\n        sm = [[0]*201]\n        res = 0\n\n        for i in arr:\n            now = sm[-1].copy()\n            now[i]+=1\n            sm.append(now)\n            res = max(now[i], res)\n\n\n        for i in range(201):\n            b, e, sc = 0, n-1, 0\n            while b<e:\n                while b<n and arr[b]!=i: b+=1\n                while e>-1 and arr[e]!=i: e-=1\n                if b>=e: continue\n                sc+=2\n                pre = 0\n                for j in range(201):\n                    pre = max(sm[e][j]-sm[b+1][j], pre)\n\n                res = max(pre+sc, res)\n\n                b+=1\n                e-=1\n        print(res)\n\n\nif __name__ == \"__main__\":\n    main()\n\n",
    "prob_desc_created_at": "1586788500",
    "tags": [
        "dp",
        "two pointers",
        "data structures",
        "brute force"
    ],
    "hidden_unit_tests": ""
}
{
    "prob_desc_time_limit": "2.5 seconds",
    "prob_desc_sample_outputs": "[\"2\", \"5\", \"6\"]",
    "src_uid": "072fe39ccec85497af67cf46551a5920",
    "prob_desc_notes": "NoteIn the first example Slastyona has only one box. She has to put all cakes in it, so that there are two types of cakes in the box, so the value is equal to 2.In the second example it is profitable to put the first two cakes in the first box, and all the rest in the second. There are two distinct types in the first box, and three in the second box then, so the total value is 5.",
    "prob_desc_description": "  Some time ago Slastyona the Sweetmaid decided to open her own bakery! She bought required ingredients and a wonder-oven which can bake several types of cakes, and opened the bakery.Soon the expenses started to overcome the income, so Slastyona decided to study the sweets market. She learned it's profitable to pack cakes in boxes, and that the more distinct cake types a box contains (let's denote this number as the value of the box), the higher price it has.She needs to change the production technology! The problem is that the oven chooses the cake types on its own and Slastyona can't affect it. However, she knows the types and order of n cakes the oven is going to bake today. Slastyona has to pack exactly k boxes with cakes today, and she has to put in each box several (at least one) cakes the oven produced one right after another (in other words, she has to put in a box a continuous segment of cakes).Slastyona wants to maximize the total value of all boxes with cakes. Help her determine this maximum possible total value.",
    "prob_desc_output_spec": "Print the only integer – the maximum total value of all boxes with cakes.",
    "prob_desc_input_spec": "The first line contains two integers n and k (1 ≤ n ≤ 35000, 1 ≤ k ≤ min(n, 50)) – the number of cakes and the number of boxes, respectively. The second line contains n integers a1, a2, ..., an (1 ≤ ai ≤ n) – the types of cakes in the order the oven bakes them.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 2",
    "lang_cluster": "Python",
    "difficulty": 2200,
    "file_name": "train_023.jsonl",
    "code_uid": "cda3b0c84902bdd48ed30f974c577959",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"4 1\\n1 2 2 1\", \"7 2\\n1 3 3 1 4 4 4\", \"8 3\\n7 7 8 7 7 8 1 7\"]",
    "exec_outcome": "PASSED",
    "source_code": "import sys\nfrom collections import defaultdict as di\nrange = range\ninput = raw_input\n\nclass LazySegmentTree:\n    def __init__(self, data, default=0, func=max):\n        \"\"\"initialize the lazy segment tree with data\"\"\"\n        self._default = default\n        self._func = func\n\n        self._len = len(data)\n        self._size = _size = 1 << (self._len - 1).bit_length()\n        self._lazy = [0] * (2 * _size)\n\n        self.data = [default] * (2 * _size)\n        self.data[_size:_size + self._len] = data\n        for i in reversed(range(_size)):\n            self.data[i] = func(self.data[i + i], self.data[i + i + 1])\n\n    def __len__(self):\n        return self._len\n\n    def _push(self, idx):\n        \"\"\"push query on idx to its children\"\"\"\n        # Let the children know of the queries\n        q, self._lazy[idx] = self._lazy[idx], 0\n\n        self._lazy[2 * idx] += q\n        self._lazy[2 * idx + 1] += q\n        self.data[2 * idx] += q\n        self.data[2 * idx + 1] += q\n\n    def _update(self, idx):\n        \"\"\"updates the node idx to know of all queries applied to it via its ancestors\"\"\"\n        for i in reversed(range(1, idx.bit_length())):\n            self._push(idx >> i)\n\n    def _build(self, idx):\n        \"\"\"make the changes to idx be known to its ancestors\"\"\"\n        idx >>= 1\n        while idx:\n            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1]) + self._lazy[idx]\n            idx >>= 1\n\n    def add(self, start, stop, value):\n        \"\"\"lazily add value to [start, stop)\"\"\"\n        start = start_copy = start + self._size\n        stop = stop_copy = stop + self._size\n        while start < stop:\n            if start & 1:\n                self._lazy[start] += value\n                self.data[start] += value\n                start += 1\n            if stop & 1:\n                stop -= 1\n                self._lazy[stop] += value\n                self.data[stop] += value\n            start >>= 1\n            stop >>= 1\n\n        # Tell all nodes above of the updated area of the updates\n        self._build(start_copy)\n        self._build(stop_copy - 1)\n\n    def query(self, start, stop, default=0):\n        \"\"\"func of data[start, stop)\"\"\"\n        start += self._size\n        stop += self._size\n\n        # Apply all the lazily stored queries\n        self._update(start)\n        self._update(stop - 1)\n\n        res = default\n        while start < stop:\n            if start & 1:\n                res = self._func(res, self.data[start])\n                start += 1\n            if stop & 1:\n                stop -= 1\n                res = self._func(res, self.data[stop])\n            start >>= 1\n            stop >>= 1\n        return res\n\n    def __repr__(self):\n        return \"LazySegmentTree({0})\".format(self.data)\n\n\n\nn, k = [int(x) for x in input().split()]\nA = [int(x) for x in input().split()]\n\nlast_occ = [-1]*(n + 1)\nupdate = []\nfor i in range(n):\n    a = A[i]\n    update.append(last_occ[a])\n    last_occ[a] = i\n\noldDP = [0]*(n+1)\nfor _ in range(k):\n    seg = LazySegmentTree(oldDP)\n    \n    DP = [0]\n    for i in range(1,n+1):\n        #for j in range(update[i - 1] + 1, i):\n        #    oldDP[j] += 1\n        seg.add(update[i - 1] + 1, i, 1)\n\n        #DP.append(max(oldDP[:i+1]))\n        DP.append(seg.query(0,i+1))\n    oldDP = DP\n\nprint max(oldDP)\n",
    "prob_desc_created_at": "1501425300",
    "tags": [
        "dp",
        "two pointers",
        "divide and conquer",
        "data structures",
        "binary search"
    ],
    "hidden_unit_tests": ""
}
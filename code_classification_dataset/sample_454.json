{
    "prob_desc_time_limit": "3 seconds",
    "prob_desc_sample_outputs": "[\"4\", \"-1\"]",
    "src_uid": "915b4776a6b1fa15886247eb1ad40b60",
    "prob_desc_notes": null,
    "prob_desc_description": "An accordion is a string (yes, in the real world accordions are musical instruments, but let's forget about it for a while) which can be represented as a concatenation of: an opening bracket (ASCII code $$$091$$$), a colon (ASCII code $$$058$$$), some (possibly zero) vertical line characters (ASCII code $$$124$$$), another colon, and a closing bracket (ASCII code $$$093$$$). The length of the accordion is the number of characters in it.For example, [::], [:||:] and [:|||:] are accordions having length $$$4$$$, $$$6$$$ and $$$7$$$. (:|:), {:||:}, [:], ]:||:[ are not accordions. You are given a string $$$s$$$. You want to transform it into an accordion by removing some (possibly zero) characters from it. Note that you may not insert new characters or reorder existing ones. Is it possible to obtain an accordion by removing characters from $$$s$$$, and if so, what is the maximum possible length of the result?",
    "prob_desc_output_spec": "If it is not possible to obtain an accordion by removing some characters from $$$s$$$, print $$$-1$$$. Otherwise print maximum possible length of the resulting accordion.",
    "prob_desc_input_spec": "The only line contains one string $$$s$$$ ($$$1 \\le |s| \\le 500000$$$). It consists of lowercase Latin letters and characters [, ], : and |.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 2",
    "lang_cluster": "Python",
    "difficulty": 1300,
    "file_name": "train_002.jsonl",
    "code_uid": "18bfe20d395d9b9f4705a68f74496d37",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"|[a:b:|]\", \"|]:[|:]\"]",
    "exec_outcome": "PASSED",
    "source_code": "from __future__ import division, print_function\n \nimport os,sys\nfrom io import BytesIO, IOBase\n \nif sys.version_info[0] < 3:\n    from __builtin__ import xrange as range\n    from future_builtins import ascii, filter, hex, map, oct, zip\n \n \ndef ii():  return int(input())\ndef si():  return input()\ndef mi():  return map(int,input().split(\" \"))\ndef msi(): return map(str,input().split(\" \"))\ndef li():  return list(mi())\n \ndef dmain():\n    sys.setrecursionlimit(1000000)\n    threading.stack_size(1024000)\n    thread = threading.Thread(target=main)\n    thread.start()\n    \n#from math import *\n\n \ndef gcd(x, y):\n    while y:\n        x, y = y, x % y\n    return x\n    \ndef checkPrime(n) : # Check Prime Number or not \n    if (n <= 1) : return False\n    if (n <= 3) : return True\n    if (n % 2 == 0 or n % 3 == 0) : return False\n    i = 5\n    while(i * i <= n) : \n        if (n % i == 0 or n % (i + 2) == 0) : \n            return False\n        i = i + 6\n    return True\n \ndef read():\n    sys.stdin = open('input.txt', 'r')  \n    sys.stdout = open('output.txt', 'w') \ndef accordian(s):\n    idx1=s.find(\"[\")\n    if idx1==-1:\n        return(\"-1\")\n    s=s[idx1+1:]\n    \n    idx2=s.find(\":\")\n    if idx2==-1:\n        return(\"-1\")\n    s=s[idx2+1:]\n    \n    s=s[::-1]\n    \n    idx3=s.find(\"]\")\n    if idx3==-1:\n        return(\"-1\")\n    s=s[idx3+1:]\n   \n    idx4=s.find(\":\")\n    if idx4==-1:\n        return(\"-1\")\n    s=s[idx4+1:]\n    \n    count=s.count(\"|\")\n    count+=4\n    return count\ndef main():\n    s=si()\n    res=accordian(s)\n    print(res)\n# region fastio\n# template taken from https://github.com/cheran-senthil/PyRival/blob/master/templates/template.py\n \nBUFSIZE = 8192\n \n \nclass FastIO(IOBase):\n    newlines = 0\n \n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n \n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n \n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n \n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n \n \nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n \n \ndef print(*args, **kwargs):\n    \"\"\"Prints the values to a stream, or to sys.stdout by default.\"\"\"\n    sep, file = kwargs.pop(\"sep\", \" \"), kwargs.pop(\"file\", sys.stdout)\n    at_start = True\n    for x in args:\n        if not at_start:\n            file.write(sep)\n        file.write(str(x))\n        at_start = False\n    file.write(kwargs.pop(\"end\", \"\\n\"))\n    if kwargs.pop(\"flush\", False):\n        file.flush()\n \n \nif sys.version_info[0] < 3:\n    sys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)\nelse:\n    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\n \ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n \n# endregion\n \n \nif __name__ == \"__main__\":\n    #read()\n    main()\n    #dmain()\n \n# Comment Read()",
    "prob_desc_created_at": "1547217300",
    "tags": [
        "implementation",
        "greedy"
    ],
    "hidden_unit_tests": ""
}
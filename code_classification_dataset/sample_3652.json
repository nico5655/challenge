{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"2 8\", \"8 2\", \"2 7\"]",
    "src_uid": "a43409fc4d4225df585bbeecf5d54680",
    "prob_desc_notes": null,
    "prob_desc_description": "The Old City is a rectangular city represented as an m × n grid of blocks. This city contains many buildings, straight two-way streets and junctions. Each junction and each building is exactly one block. All the streets have width of one block and are either vertical or horizontal. There is a junction on both sides of each street. We call two blocks adjacent if and only if they share a common side. No two blocks of different streets are adjacent and no two junctions are adjacent. There is an annual festival and as a part of it, The Old Peykan follows a special path in the city. This path starts from a block in a street, continues with many junctions and ends in a block of some street. For each street block, we know how much time it takes for the Old Peykan to go from this block to an adjacent block. Also the Old Peykan can go from each junction to its adjacent street blocks in one minute. Of course Old Peykan can't go to building blocks.We know the initial position of the Old Peykan and the sequence of junctions that it passes to reach its destination. After passing all the junctions and reaching the destination, it will stay there forever. Your task is to find out where will the Old Peykan be k minutes after it starts moving. Consider that The Old Peykan always follows the shortest path that passes through the given sequence of junctions and reaches the destination.Note that the Old Peykan may visit some blocks more than once.",
    "prob_desc_output_spec": "In a single line print two integers rf and cf — (rf, cf) being the position of the Old Peykan after exactly k minutes.",
    "prob_desc_input_spec": "The first line of input contains three integers m, n and k (3 ≤ m, n ≤ 100, 1 ≤ k ≤ 100000). Next m lines are representing the city's map. Each of them containts n characters, each character is a block:   Character \"#\" represents a building.  Digits \"1\", \"2\", ..., \"9\" represent a block of an street and this digit means the number of minutes it takes for the Old Peykan to pass this block.  Characters \"a\", \"b\", ..., \"z\" means that this block is a junction and this character is it's name. All the junction names are unique.  Consider that all blocks have the coordinates: the j-th in the i-th line have coordinates (i, j) (1 ≤ i ≤ m, 1 ≤ j ≤ n). The (m + 2)th line contains two integers rs and cs (1 ≤ rs ≤ m, 1 ≤ cs ≤ n), string s and another two integers re and ce (1 ≤ re ≤ m, 1 ≤ ce ≤ n). The path starts from block (rs, cs), continues through junctions in the order that is specified by s and will end in block (re, ce). Length of s is between 1 and 1000. It's guaranteed that string s denotes a correct path from the start position to the end position and string s doesn't contain two consecutive equal letters. Also start position (rs, cs) and the end position (re, ce) are street blocks.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "Python 2",
    "lang_cluster": "Python",
    "difficulty": 2300,
    "file_name": "train_076.jsonl",
    "code_uid": "b896a434e41af84169a4957e68ce74d5",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"3 10 12\\n##########\\n#z1a1111b#\\n##########\\n2 3 ab 2 8\", \"10 3 5\\n###\\n#w#\\n#1#\\n#a#\\n#1#\\n#1#\\n#1#\\n#1#\\n#b#\\n###\\n3 2 abababababababab 6 2\", \"3 10 6\\n##########\\n#z1a1311b#\\n##########\\n2 3 ab 2 8\"]",
    "exec_outcome": "PASSED",
    "source_code": "#t = input()\nt = 1\ndef xstep(p, q):\n    if p<q:\n        return p+1\n    elif p>q:\n        return p-1\n    else:\n        return p\ndef step(p, q):\n    return (xstep(p[0], q[0]), xstep(p[1], q[1]))\nfor _ in range(t):\n    n, m, k = tuple(int(x) for x in raw_input().split())\n    tbl = [list(raw_input()) for i in range(n)]\n    ind = {}\n    for r in range(len(tbl)):\n        for c in range(len(tbl[r])):\n            if ord(tbl[r][c])>=ord('a') and ord(tbl[r][c])<=ord('z'):\n                ind[tbl[r][c]]=(r,c)\n                tbl[r][c]='1'\n    l = {}\n    for r in range(len(tbl)):\n        for c in range(len(tbl[r])):\n            if ord(tbl[r][c])>=ord('1') and ord(tbl[r][c])<=ord('9'):\n                l[r, c] = int(tbl[r][c])\n    inp = raw_input().split()\n    path = []\n    path.append((int(inp[0])-1, int(inp[1])-1))\n    for c in inp[2]:\n        path.append(ind[c])\n    path.append((int(inp[3])-1, int(inp[4])-1))\n    (x, y) = path[0]\n    good = False\n    for dest in path:\n        while (x, y) != dest:\n            if k>=l[x, y]:\n                k-=l[x, y]\n                (x, y) = step((x, y), dest)\n            else:\n                print x+1, y+1\n                good = True\n                break\n        if good:\n            break\n    if not good:\n        print path[-1][0]+1, path[-1][1]+1\n",
    "prob_desc_created_at": "1351783800",
    "tags": [
        "implementation",
        "brute force"
    ],
    "hidden_unit_tests": ""
}
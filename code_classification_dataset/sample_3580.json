{
    "prob_desc_time_limit": "3 seconds",
    "prob_desc_sample_outputs": "[\"3.4142135624 -1.4142135624\\n2.0000000000 0.0000000000\\n0.5857864376 -1.4142135624\", \"1.0000000000 -1.0000000000\"]",
    "src_uid": "3d8aa764053d3cf14f34f11de61d1816",
    "prob_desc_notes": "NoteIn the first test note the initial and the final state of the wooden polygon.   Red Triangle is the initial state and the green one is the triangle after rotation around $$$(2,0)$$$.In the second sample note that the polygon rotates $$$180$$$ degrees counter-clockwise or clockwise direction (it does not matter), because Hag's father makes sure that the polygon is stable and his son does not trick him.",
    "prob_desc_description": "Hag is a very talented person. He has always had an artist inside him but his father forced him to study mechanical engineering.Yesterday he spent all of his time cutting a giant piece of wood trying to make it look like a goose. Anyway, his dad found out that he was doing arts rather than studying mechanics and other boring subjects. He confronted Hag with the fact that he is a spoiled son that does not care about his future, and if he continues to do arts he will cut his 25 Lira monthly allowance.Hag is trying to prove to his dad that the wooden piece is a project for mechanics subject. He also told his dad that the wooden piece is a strictly convex polygon with $$$n$$$ vertices.Hag brought two pins and pinned the polygon with them in the $$$1$$$-st and $$$2$$$-nd vertices to the wall. His dad has $$$q$$$ queries to Hag of two types.   $$$1$$$ $$$f$$$ $$$t$$$: pull a pin from the vertex $$$f$$$, wait for the wooden polygon to rotate under the gravity force (if it will rotate) and stabilize. And then put the pin in vertex $$$t$$$.  $$$2$$$ $$$v$$$: answer what are the coordinates of the vertex $$$v$$$. Please help Hag to answer his father's queries.You can assume that the wood that forms the polygon has uniform density and the polygon has a positive thickness, same in all points. After every query of the 1-st type Hag's dad tries to move the polygon a bit and watches it stabilize again.",
    "prob_desc_output_spec": "The output should contain the answer to each query of second type — two numbers in a separate line. Your answer is considered correct, if its absolute or relative error does not exceed $$$10^{-4}$$$. Formally, let your answer be $$$a$$$, and the jury's answer be $$$b$$$. Your answer is considered correct if $$$\\frac{|a - b|}{\\max{(1, |b|)}} \\le 10^{-4}$$$",
    "prob_desc_input_spec": "The first line contains two integers $$$n$$$ and $$$q$$$ ($$$3\\leq n \\leq 10\\,000$$$, $$$1 \\leq q \\leq 200000$$$) — the number of vertices in the polygon and the number of queries. The next $$$n$$$ lines describe the wooden polygon, the $$$i$$$-th line contains two integers $$$x_i$$$ and $$$y_i$$$ ($$$|x_i|, |y_i|\\leq 10^8$$$) — the coordinates of the $$$i$$$-th vertex of the polygon. It is guaranteed that polygon is strictly convex and the vertices are given in the counter-clockwise order and all vertices are distinct. The next $$$q$$$ lines describe the queries, one per line. Each query starts with its type $$$1$$$ or $$$2$$$. Each query of the first type continues with two integers $$$f$$$ and $$$t$$$ ($$$1 \\le f, t \\le n$$$) — the vertex the pin is taken from, and the vertex the pin is put to and the polygon finishes rotating. It is guaranteed that the vertex $$$f$$$ contains a pin. Each query of the second type continues with a single integer $$$v$$$ ($$$1 \\le v \\le n$$$) — the vertex the coordinates of which Hag should tell his father. It is guaranteed that there is at least one query of the second type.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "Python 3",
    "lang_cluster": "Python",
    "difficulty": 2600,
    "file_name": "train_070.jsonl",
    "code_uid": "121272df9e79adc0a8835b8b1cb2b6d3",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"3 4\\n0 0\\n2 0\\n2 2\\n1 1 2\\n2 1\\n2 2\\n2 3\", \"3 2\\n-1 1\\n0 0\\n1 1\\n1 1 2\\n2 1\"]",
    "exec_outcome": "PASSED",
    "source_code": "import math;\n#Вычисление координаты точки по координатам центра, углу, и начальным относительно центра\ndef getCoordinate(gx, gy, alpha, x, y):\n    x1=gx+x*math.cos(alpha)-y*math.sin(alpha);\n    y1=gy+x*math.sin(alpha)+y*math.cos(alpha);\n    return x1, y1\n#Вычисление угла, на который надо повернуть точку с координатами x, y,\n#чтобы она оказалась прямо над gx, gy\ndef getAngle(gx, gy, x, y):\n    x=x-gx;\n    y=y-gy;\n    cos=x/math.sqrt(x**2+y**2);\n    alpha=math.acos(cos);\n    if y<0:\n        alpha=-alpha;\n    return math.pi/2-alpha;\nn, q = map(int, input().split(' '));\nx=[0]*n;\ny=[0]*n;\nfor i in range(n):\n    x[i], y[i]=map(int, input().split(' '));\nr=[0]*q;\nf=[0]*q;\nt=[0]*q;\nv=[0]*q;\nfor i in range(q):\n    l=list(map(int, input().split(' ')));\n    r[i]=l[0];\n    if r[i]==1:\n        f[i]=l[1]-1;\n        t[i]=l[2]-1;\n    else:\n        v[i]=l[1]-1;\ngx=0;\ngy=0;\ns=0;\nfor i in range(n):\n    ip=i+1;\n    if ip==n:\n        ip=0;\n    ds=x[i]*y[ip]-x[ip]*y[i];\n    s+=ds;\n    gx+=(x[i]+x[ip])*ds;\n    gy+=(y[i]+y[ip])*ds;\ns/=2;\ngx/=6*s;\ngy/=6*s;\nangles=[0]*n;\nfor i in range(n):\n    angles[i]=getAngle(gx, gy, x[i], y[i]);\nfor i in range(n):\n    x[i]-=gx;\n    y[i]-=gy;\nalpha=0;\n#print('pos',gx, gy, alpha);\n#Восстанавливать положение точек будем по центру масс и углу\n#Угол - поворот против часовой вокруг центра масс\nfix={0, 1}\nfor i in range(q):\n    if r[i]==2:\n        currX, currY = getCoordinate(gx, gy, alpha, x[v[i]], y[v[i]]);\n        print(\"%.6f %.6f\"%(currX, currY))\n    else:\n        if len(fix)==2:\n            fix.remove(f[i]);\n        #print('remove',f[i])\n        #j - единственный элемент в множестве\n        for j in fix:\n            #print(j);\n            currX, currY = getCoordinate(gx, gy, alpha, x[j], y[j]);\n            #print('fix:', currX, currY)\n            #dalpha=getAngle(gx, gy, currX, currY);\n            #alpha+=dalpha;\n            alpha=angles[j];\n            #Чтобы вычислить новые координаты g, нуно повернуть ее на угол\n            #dalpha относительно currX, currY\n            gx, gy=currX, currY-math.sqrt(x[j]**2+y[j]**2);\n            \n            #print('pos',gx, gy, alpha/math.pi)\n        fix.add(t[i]);\n        \n",
    "prob_desc_created_at": "1525183500",
    "tags": [
        "geometry"
    ],
    "hidden_unit_tests": ""
}
{
    "prob_desc_time_limit": "5 seconds",
    "prob_desc_sample_outputs": "[\"162\", \"102\"]",
    "src_uid": "ee32db0f67954ed0eccae1429819f4d7",
    "prob_desc_notes": null,
    "prob_desc_description": "You are given $$$n$$$ segments on the coordinate axis. The $$$i$$$-th segment is $$$[l_i, r_i]$$$. Let's denote the set of all integer points belonging to the $$$i$$$-th segment as $$$S_i$$$.Let $$$A \\cup B$$$ be the union of two sets $$$A$$$ and $$$B$$$, $$$A \\cap B$$$ be the intersection of two sets $$$A$$$ and $$$B$$$, and $$$A \\oplus B$$$ be the symmetric difference of $$$A$$$ and $$$B$$$ (a set which contains all elements of $$$A$$$ and all elements of $$$B$$$, except for the ones that belong to both sets).Let $$$[\\mathbin{op}_1, \\mathbin{op}_2, \\dots, \\mathbin{op}_{n-1}]$$$ be an array where each element is either $$$\\cup$$$, $$$\\oplus$$$, or $$$\\cap$$$. Over all $$$3^{n-1}$$$ ways to choose this array, calculate the sum of the following values:$$$$$$|(((S_1\\ \\mathbin{op}_1\\ S_2)\\ \\mathbin{op}_2\\ S_3)\\ \\mathbin{op}_3\\ S_4)\\ \\dots\\ \\mathbin{op}_{n-1}\\ S_n|$$$$$$In this expression, $$$|S|$$$ denotes the size of the set $$$S$$$.",
    "prob_desc_output_spec": "Print one integer â€” the sum of $$$|(((S_1\\ \\mathbin{op}_1\\ S_2)\\ \\mathbin{op}_2\\ S_3)\\ \\mathbin{op}_3\\ S_4)\\ \\dots\\ \\mathbin{op}_{n-1}\\ S_n|$$$ over all possible ways to choose $$$[\\mathbin{op}_1, \\mathbin{op}_2, \\dots, \\mathbin{op}_{n-1}]$$$. Since the answer can be huge, print it modulo $$$998244353$$$.",
    "prob_desc_input_spec": "The first line contains one integer $$$n$$$ ($$$2 \\le n \\le 3 \\cdot 10^5$$$). Then, $$$n$$$ lines follow. The $$$i$$$-th of them contains two integers $$$l_i$$$ and $$$r_i$$$ ($$$0 \\le l_i \\le r_i \\le 3 \\cdot 10^5$$$).",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3-64",
    "lang_cluster": "Python",
    "difficulty": 2300,
    "file_name": "train_089.jsonl",
    "code_uid": "3b8e9b7f182f5f2df6f60cabd91f646e",
    "prob_desc_memory_limit": "512 megabytes",
    "prob_desc_sample_inputs": "[\"4\\n3 5\\n4 8\\n2 2\\n1 9\", \"4\\n1 9\\n3 5\\n4 8\\n2 2\"]",
    "exec_outcome": "PASSED",
    "source_code": "import cProfile\r\nimport sys\r\nimport io\r\nimport os\r\nimport traceback\r\nfrom collections import deque\r\nfrom itertools import accumulate\r\n\r\n# region IO\r\nBUFSIZE = 8192\r\n\r\n\r\nclass FastIO(io.IOBase):\r\n    newlines = 0\r\n\r\n    def __init__(self, file):\r\n        self._file = file\r\n        self._fd = file.fileno()\r\n        self.buffer = io.BytesIO()\r\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\r\n        self.write = self.buffer.write if self.writable else None\r\n\r\n    def read(self):\r\n        while True:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            if not b:\r\n                break\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines = 0\r\n        return self.buffer.read()\r\n\r\n    def readline(self):\r\n        while self.newlines == 0:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            self.newlines = b.count(b\"\\n\") + (not b)\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines -= 1\r\n        return self.buffer.readline()\r\n\r\n    def flush(self):\r\n        if self.writable:\r\n            os.write(self._fd, self.buffer.getvalue())\r\n            self.buffer.truncate(0), self.buffer.seek(0)\r\n\r\n\r\nclass IOWrapper(io.IOBase):\r\n    def __init__(self, file):\r\n        self.buffer = FastIO(file)\r\n        self.flush = self.buffer.flush\r\n        self.writable = self.buffer.writable\r\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\r\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\r\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\r\n\r\n\r\ndef print(*args, **kwargs):\r\n    \"\"\"Prints the values to a stream, or to sys.stdout by default.\"\"\"\r\n    sep, file = kwargs.pop(\"sep\", \" \"), kwargs.pop(\"file\", sys.stdout)\r\n    at_start = True\r\n    for x in args:\r\n        if not at_start:\r\n            file.write(sep)\r\n        file.write(str(x))\r\n        at_start = False\r\n    file.write(kwargs.pop(\"end\", \"\\n\"))\r\n    if kwargs.pop(\"flush\", False):\r\n        file.flush()\r\n\r\n\r\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\r\n\r\n\r\ndef input(): return sys.stdin.readline().rstrip('\\r\\n')\r\n\r\n\r\ndef read_int_list():\r\n    return list(map(int, input().split()))\r\n\r\n\r\ndef read_int_tuple():\r\n    return tuple(map(int, input().split()))\r\n\r\n\r\ndef read_int():\r\n    return int(input())\r\n\r\n\r\n# endregion\r\n\r\n# region local test\r\nif 'AW' in os.environ.get('COMPUTERNAME', ''):\r\n    test_no = 1\r\n    # f = open(os.path.dirname(__file__) + f'\\\\in{test_no}.txt', 'r')\r\n    f = open('inputs')\r\n    def input():\r\n        return f.readline().rstrip(\"\\r\\n\")\r\n# endregion\r\n\r\nclass SegmentTree():\r\n    __slots__ = ['n', 'oper', 'e', 'log', 'size', 'data']\r\n\r\n    def __init__(self, n, oper, e):\r\n        self.n = n\r\n        self.oper = oper\r\n        self.log = (n - 1).bit_length()\r\n        self.size = 1 << self.log\r\n        self.data = [list(e) for _ in range(2 * self.size)]\r\n\r\n    # def _update(self, k):\r\n    #     self.oper(self.data[k], self.data[2 * k], self.data[2 * k + 1])\r\n\r\n    def build(self, arr):\r\n        # assert len(arr) <= self.n\r\n        for i in range(self.n):\r\n            t = self.data[self.size + i]\r\n            t[0], t[1], t[2], t[3] = arr[i]\r\n        for i in range(self.size - 1, 0, -1):\r\n            # self._update(i)\r\n            self.oper(self.data[i], self.data[2 * i], self.data[2 * i + 1])\r\n\r\n    def set(self, p, x):\r\n        # assert 0 <= p < self.n\r\n        p += self.size\r\n        # self.data[p] = x\r\n        t = self.data[p]\r\n        t[0], t[1], t[2], t[3] = x\r\n        for i in range(self.log):\r\n            p >>= 1\r\n            # self._update(p)\r\n            self.oper(self.data[p], self.data[2 * p], self.data[2 * p + 1])\r\n\r\nMOD = 998244353  # 1000000007\r\nN = 300000 + 32\r\npos = [[] for _ in range(N)]\r\n\r\nZERO = (3, 0, 1, 2)       # [3, 0], [1, 2]\r\nONE =  (1, 2, 1, 2)     # [1, 2], [1, 2]\r\nE =    (1, 0, 0, 1)                  # [1, 0], [0, 1]\r\n\r\ndef OPER(tn, fn, gn):\r\n    tn[0] = (fn[0] * gn[0] % MOD + fn[1] * gn[2] % MOD) % MOD\r\n    tn[1] = (fn[0] * gn[1] % MOD + fn[1] * gn[3] % MOD) % MOD\r\n    tn[2] = (fn[2] * gn[0] % MOD + fn[3] * gn[2] % MOD) % MOD\r\n    tn[3] = (fn[2] * gn[1] % MOD + fn[3] * gn[3] % MOD) % MOD\r\n\r\nn = read_int()\r\ndef main():\r\n    st = SegmentTree(n - 1, OPER, E)\r\n    st.build([ZERO for _ in range(n)])\r\n\r\n    book = [[] for _ in range(N)]\r\n    m = 0\r\n    for i in range(n):\r\n        l, r = read_int_tuple()\r\n        book[l].append((1, i))\r\n        book[r + 1].append((0, i))\r\n        if m < r + 1: m = r + 1\r\n\r\n    cur = res = 0\r\n    for i in range(m):\r\n        for c, j in book[i]:\r\n            if j == 0: cur = c\r\n            else: st.set(j - 1, ONE if c else ZERO)\r\n        res += st.data[1][cur * 2 + 1]\r\n        res %= MOD\r\n    print(res)\r\n\r\nmain()\r\n\r\n# cProfile.run(\"main()\")\r\n\r\n\r\n\r\n# n = read_int()\r\n#\r\n# def main():\r\n#     def matmul(k, i, j):\r\n#         u1, u2, u3, u4 = tree1[i], tree2[i], tree3[i], tree4[i]\r\n#         v1, v2, v3, v4 = tree1[j], tree2[j], tree3[j], tree4[j]\r\n#         tree1[k] = (u1 * v1 % mod + u2 * v3 % mod) % mod\r\n#         tree2[k] = (u1 * v2 % mod + u2 * v4 % mod) % mod\r\n#         tree3[k] = (u3 * v1 % mod + u4 * v3 % mod) % mod\r\n#         tree4[k] = (u3 * v2 % mod + u4 * v4 % mod) % mod\r\n#         return\r\n#\r\n#     def update(i, x):\r\n#         i += l1\r\n#         if x:\r\n#             tree1[i], tree2[i] = 2, 2\r\n#             tree3[i], tree4[i] = 1, 1\r\n#         else:\r\n#             tree1[i], tree2[i] = 2, 0\r\n#             tree3[i], tree4[i] = 1, 3\r\n#         i //= 2\r\n#         while i:\r\n#             matmul(i, 2 * i, 2 * i + 1)\r\n#             i //= 2\r\n#         return\r\n#\r\n#     mod = 998244353\r\n#     m = 3 * pow(10, 5) + 5\r\n#     l1 = pow(2, n.bit_length())\r\n#     l2 = 2 * l1\r\n#     tree1, tree2 = [1] * l2, [0] * l2\r\n#     tree3, tree4 = [0] * l2, [1] * l2\r\n#     for i in range(l1, l1 + n - 1):\r\n#         tree1[i], tree2[i] = 2, 0\r\n#         tree3[i], tree4[i] = 1, 3\r\n#     for i in range(l1 - 1, 0, -1):\r\n#         matmul(i, 2 * i, 2 * i + 1)\r\n#     x = [[] for _ in range(m + 1)]\r\n#     for i in range(n):\r\n#         l, r = read_int_tuple()\r\n#         x[l].append(n - i - 1)\r\n#         x[r + 1].append(n - i - 1)\r\n#     now = [0] * n\r\n#     ans = 0\r\n#     for i in range(m + 1):\r\n#         for j in x[i]:\r\n#             now[j] ^= 1\r\n#             if j < n - 1:\r\n#                 update(j, now[j])\r\n#         u1, u2 = tree1[1], tree2[1]\r\n#         if now[-1]:\r\n#             v1, v2 = 1, 0\r\n#         else:\r\n#             v1, v2 = 0, 1\r\n#         ans += u1 * v1 % mod + u2 * v2 % mod\r\n#         ans %= mod\r\n#     ans %= mod\r\n#     print(ans)\r\n#\r\n# cProfile.run(\"main()\")\r\n",
    "prob_desc_created_at": "1666017300",
    "tags": [
        "data structures",
        "dp",
        "matrices",
        "probabilities"
    ],
    "hidden_unit_tests": ""
}
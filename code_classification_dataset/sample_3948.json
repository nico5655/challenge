{
    "prob_desc_time_limit": "4.5 seconds",
    "prob_desc_sample_outputs": "[\"55\\n56\\n60\\n64\\n64\"]",
    "src_uid": "43188c8c24eee697bff59b210aa9e3de",
    "prob_desc_notes": null,
    "prob_desc_description": "Monocarp plays a computer game (yet again!). This game has a unique trading mechanics.To trade with a character, Monocarp has to choose one of the items he possesses and trade it for some item the other character possesses. Each item has an integer price. If Monocarp's chosen item has price $$$x$$$, then he can trade it for any item (exactly one item) with price not greater than $$$x+k$$$.Monocarp initially has $$$n$$$ items, the price of the $$$i$$$-th item he has is $$$a_i$$$. The character Monocarp is trading with has $$$m$$$ items, the price of the $$$i$$$-th item they have is $$$b_i$$$. Monocarp can trade with this character as many times as he wants (possibly even zero times), each time exchanging one of his items with one of the other character's items according to the aforementioned constraints. Note that if Monocarp gets some item during an exchange, he can trade it for another item (since now the item belongs to him), and vice versa: if Monocarp trades one of his items for another item, he can get his item back by trading something for it.You have to answer $$$q$$$ queries. Each query consists of one integer, which is the value of $$$k$$$, and asks you to calculate the maximum possible total cost of items Monocarp can have after some sequence of trades, assuming that he can trade an item of cost $$$x$$$ for an item of cost not greater than $$$x+k$$$ during each trade. Note that the queries are independent: the trades do not actually occur, Monocarp only wants to calculate the maximum total cost he can get.",
    "prob_desc_output_spec": "For each query, print one integer — the maximum possible total cost of items Monocarp can have after some sequence of trades, given the value of $$$k$$$ from the query.",
    "prob_desc_input_spec": "The first line contains three integers $$$n$$$, $$$m$$$ and $$$q$$$ ($$$1 \\le n, m, q \\le 2 \\cdot 10^5$$$). The second line contains $$$n$$$ integers $$$a_1, a_2, \\dots, a_n$$$ ($$$1 \\le a_i \\le 10^9$$$) — the prices of the items Monocarp has. The third line contains $$$m$$$ integers $$$b_1, b_2, \\dots, b_m$$$ ($$$1 \\le b_i \\le 10^9$$$) — the prices of the items the other character has. The fourth line contains $$$q$$$ integers, where the $$$i$$$-th integer is the value of $$$k$$$ for the $$$i$$$-th query ($$$0 \\le k \\le 10^9$$$).",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3-64",
    "lang_cluster": "Python",
    "difficulty": 2200,
    "file_name": "train_087.jsonl",
    "code_uid": "e7c6d9a513e5e450814cefa65c76deb4",
    "prob_desc_memory_limit": "512 megabytes",
    "prob_desc_sample_inputs": "[\"3 4 5\\n10 30 15\\n12 31 14 18\\n0 1 2 3 4\"]",
    "exec_outcome": "PASSED",
    "source_code": "\r\nimport os\r\nimport sys\r\nfrom io import BytesIO, IOBase\r\n \r\n# region fastio\r\n \r\nBUFSIZE = 8192\r\n \r\n \r\nclass FastIO(IOBase):\r\n    newlines = 0\r\n \r\n    def __init__(self, file):\r\n        self._fd = file.fileno()\r\n        self.buffer = BytesIO()\r\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\r\n        self.write = self.buffer.write if self.writable else None\r\n \r\n    def read(self):\r\n        while True:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            if not b:\r\n                break\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines = 0\r\n        return self.buffer.read()\r\n \r\n    def readline(self):\r\n        while self.newlines == 0:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            self.newlines = b.count(b\"\\n\") + (not b)\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines -= 1\r\n        return self.buffer.readline()\r\n \r\n    def flush(self):\r\n        if self.writable:\r\n            os.write(self._fd, self.buffer.getvalue())\r\n            self.buffer.truncate(0), self.buffer.seek(0)\r\n \r\n \r\nclass IOWrapper(IOBase):\r\n    def __init__(self, file):\r\n        self.buffer = FastIO(file)\r\n        self.flush = self.buffer.flush\r\n        self.writable = self.buffer.writable\r\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\r\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\r\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\r\n \r\n \r\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\r\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\r\n\r\nn,m,_ = map(int,input().split())\r\n\r\na = list(map(int,input().split()))\r\nb = list(map(int,input().split()))\r\nq = list(map(int,input().split()))\r\n\r\nitems = [(x,1) for x in a] + [(x,0) for x in b]\r\nitems.sort()\r\n\r\npref1 = [x for x,_ in items]\r\nctr = [x for _,x in items]\r\n\r\nfor i in range(1, len(items)):\r\n    pref1[i] += pref1[i - 1]\r\n\r\n\r\nevents = [(items[i + 1][0] - items[i][0], i) for i in range(n+m-1)]\r\nevents.sort(reverse=True)\r\n\r\nI = list(range(len(q)))\r\nI.sort(key = lambda i:q[i])\r\n\r\ncur = sum(a)\r\nans = [-1]*len(q)\r\n\r\nUF = [x for x in range(n+m)]\r\nsz = [0]*(n+m)\r\nhi = [x for x in range(n+m)]\r\n\r\ndef s(i, j):\r\n    return pref1[j] - (pref1[i-1] if i>=1 else 0)\r\n\r\ndef f(pi):\r\n    # number of items in a\r\n    cnt = ctr[pi]\r\n    if cnt == 0:\r\n        return 0\r\n\r\n    return s(hi[pi] - cnt + 1, hi[pi])\r\n\r\ndef find(x):\r\n    if UF[x] != x:\r\n        UF[x] = find(UF[x])\r\n    return UF[x]\r\n\r\ndef union(x,y):\r\n    global cur\r\n\r\n    px = find(x)\r\n    py = find(y)\r\n    if px == py:\r\n        return False\r\n\r\n    if sz[py] > sz[px]:\r\n        px,py = py,px\r\n\r\n    old = f(px) + f(py)\r\n\r\n    ctr[px] += ctr[py]\r\n    hi[px] = max(hi[px], hi[py])\r\n\r\n    new = f(px)\r\n    cur += new - old\r\n\r\n    UF[py] = px\r\n    sz[px] += 1\r\n    return True\r\n\r\nfor i in I:\r\n    k = q[i]\r\n\r\n    while events and events[-1][0] <= k:\r\n        _, i0 = events.pop()\r\n        union(i0, i0+1)\r\n\r\n    ans[i] = cur\r\n\r\nprint(\"\\n\".join(str(int(x)) for x in ans))\r\n\r\n",
    "prob_desc_created_at": "1639492500",
    "tags": [
        "data structures",
        "dsu",
        "greedy",
        "sortings"
    ],
    "hidden_unit_tests": ""
}
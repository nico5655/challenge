{
    "prob_desc_time_limit": "3 seconds",
    "prob_desc_sample_outputs": "[\"20\\n10\\n20\\n10\\n20\\n10\", \"2\\n3\\n2\\n3\\n2\\n3\\n1\\n1\\n3\"]",
    "src_uid": "082eec813f870357dbe3c5abec6a2b52",
    "prob_desc_notes": "NoteIn the first example, for $$$a=[10,20,10]$$$ the optimal subsequences are:   for $$$k=1$$$: $$$[20]$$$,  for $$$k=2$$$: $$$[10,20]$$$,  for $$$k=3$$$: $$$[10,20,10]$$$. ",
    "prob_desc_description": "This is the harder version of the problem. In this version, $$$1 \\le n, m \\le 2\\cdot10^5$$$. You can hack this problem if you locked it. But you can hack the previous problem only if you locked both problems.You are given a sequence of integers $$$a=[a_1,a_2,\\dots,a_n]$$$ of length $$$n$$$. Its subsequence is obtained by removing zero or more elements from the sequence $$$a$$$ (they do not necessarily go consecutively). For example, for the sequence $$$a=[11,20,11,33,11,20,11]$$$:  $$$[11,20,11,33,11,20,11]$$$, $$$[11,20,11,33,11,20]$$$, $$$[11,11,11,11]$$$, $$$[20]$$$, $$$[33,20]$$$ are subsequences (these are just some of the long list);  $$$[40]$$$, $$$[33,33]$$$, $$$[33,20,20]$$$, $$$[20,20,11,11]$$$ are not subsequences. Suppose that an additional non-negative integer $$$k$$$ ($$$1 \\le k \\le n$$$) is given, then the subsequence is called optimal if:  it has a length of $$$k$$$ and the sum of its elements is the maximum possible among all subsequences of length $$$k$$$;  and among all subsequences of length $$$k$$$ that satisfy the previous item, it is lexicographically minimal. Recall that the sequence $$$b=[b_1, b_2, \\dots, b_k]$$$ is lexicographically smaller than the sequence $$$c=[c_1, c_2, \\dots, c_k]$$$ if the first element (from the left) in which they differ less in the sequence $$$b$$$ than in $$$c$$$. Formally: there exists $$$t$$$ ($$$1 \\le t \\le k$$$) such that $$$b_1=c_1$$$, $$$b_2=c_2$$$, ..., $$$b_{t-1}=c_{t-1}$$$ and at the same time $$$b_t&lt;c_t$$$. For example:  $$$[10, 20, 20]$$$ lexicographically less than $$$[10, 21, 1]$$$,  $$$[7, 99, 99]$$$ is lexicographically less than $$$[10, 21, 1]$$$,  $$$[10, 21, 0]$$$ is lexicographically less than $$$[10, 21, 1]$$$. You are given a sequence of $$$a=[a_1,a_2,\\dots,a_n]$$$ and $$$m$$$ requests, each consisting of two numbers $$$k_j$$$ and $$$pos_j$$$ ($$$1 \\le k \\le n$$$, $$$1 \\le pos_j \\le k_j$$$). For each query, print the value that is in the index $$$pos_j$$$ of the optimal subsequence of the given sequence $$$a$$$ for $$$k=k_j$$$.For example, if $$$n=4$$$, $$$a=[10,20,30,20]$$$, $$$k_j=2$$$, then the optimal subsequence is $$$[20,30]$$$ — it is the minimum lexicographically among all subsequences of length $$$2$$$ with the maximum total sum of items. Thus, the answer to the request $$$k_j=2$$$, $$$pos_j=1$$$ is the number $$$20$$$, and the answer to the request $$$k_j=2$$$, $$$pos_j=2$$$ is the number $$$30$$$.",
    "prob_desc_output_spec": "Print $$$m$$$ integers $$$r_1, r_2, \\dots, r_m$$$ ($$$1 \\le r_j \\le 10^9$$$) one per line: answers to the requests in the order they appear in the input. The value of $$$r_j$$$ should be equal to the value contained in the position $$$pos_j$$$ of the optimal subsequence for $$$k=k_j$$$.",
    "prob_desc_input_spec": "The first line contains an integer $$$n$$$ ($$$1 \\le n \\le 2\\cdot10^5$$$) — the length of the sequence $$$a$$$. The second line contains elements of the sequence $$$a$$$: integer numbers $$$a_1, a_2, \\dots, a_n$$$ ($$$1 \\le a_i \\le 10^9$$$). The third line contains an integer $$$m$$$ ($$$1 \\le m \\le 2\\cdot10^5$$$) — the number of requests. The following $$$m$$$ lines contain pairs of integers $$$k_j$$$ and $$$pos_j$$$ ($$$1 \\le k \\le n$$$, $$$1 \\le pos_j \\le k_j$$$) — the requests.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3",
    "lang_cluster": "Python",
    "difficulty": 1800,
    "file_name": "train_004.jsonl",
    "code_uid": "8b3c1b0271d3c161cfce4be19c726cbc",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"3\\n10 20 10\\n6\\n1 1\\n2 1\\n2 2\\n3 1\\n3 2\\n3 3\", \"7\\n1 2 1 3 1 2 1\\n9\\n2 1\\n2 2\\n3 1\\n3 2\\n3 3\\n1 1\\n7 1\\n7 7\\n7 4\"]",
    "exec_outcome": "PASSED",
    "source_code": "# Binary Indexed Tree (Fenwick Tree)\nclass BIT():\n    \"\"\"一点加算、区間取得クエリをそれぞれO(logN)で答える\n    add: i番目にvalを加える\n    get_sum: 区間[l, r)の和を求める\n    i, l, rは0-indexed\n    \"\"\"\n    def __init__(self, n):\n        self.n = n\n        self.bit = [0] * (n + 1)\n\n    def _sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.bit[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, val):\n        \"\"\"i番目にvalを加える\"\"\"\n        i = i + 1\n        while i <= self.n:\n            self.bit[i] += val\n            i += i & -i\n\n    def get_sum(self, l, r):\n        \"\"\"区間[l, r)の和を求める\"\"\"\n        return self._sum(r) - self._sum(l)\n\n    def bisect_left(self, val):\n        \"\"\"[0, r)の和がval以下になるときの最小のrを求める\"\"\"\n        sum_ = 0\n        pos = 0\n        bit_length = (n+1).bit_length()\n        for i in range(bit_length, -1, -1):\n            k = pos + (1 << i)\n            if k < self.n + 1 and sum_ + self.bit[k] < val:\n                sum_ += self.bit[k]\n                pos += 1 << i\n        return pos + 1\n\n\nfrom operator import itemgetter\n\n\nn = int(input())\na = list(map(int, input().split()))\nm = int(input())\ninfo = [list(map(int, input().split())) + [i] for i in range(m)]\n\nb = list(zip(a, range(len(a))))\nb = sorted(b, key = itemgetter(0), reverse = True)\n\ninfo = sorted(info, key = itemgetter(0))\nbit = BIT(n)\n\nans = [0]*m\ncnt = 0\nfor i in range(m):\n    k, pos, ind = info[i]\n    while cnt < k:\n        bit.add(b[cnt][1], 1)\n        cnt += 1\n    ans[ind] = a[bit.bisect_left(pos)-1]\nfor i in ans:\n    print(i)",
    "prob_desc_created_at": "1574582700",
    "tags": [
        "greedy",
        "constructive algorithms",
        "sortings",
        "data structures",
        "binary search"
    ],
    "hidden_unit_tests": ""
}
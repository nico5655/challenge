{
    "prob_desc_time_limit": "1 second",
    "prob_desc_sample_outputs": "[\"2 2\", \"1 4\", \"2 4\", \"0 1\"]",
    "src_uid": "63eb7dc9077b88df505e52fa4bba5851",
    "prob_desc_notes": "NoteIn the first example, FJ can line up the cows as follows to achieve $$$2$$$ sleeping cows:   Cow $$$1$$$ is lined up on the left side and cow $$$2$$$ is lined up on the right side.  Cow $$$2$$$ is lined up on the left side and cow $$$1$$$ is lined up on the right side. In the second example, FJ can line up the cows as follows to achieve $$$1$$$ sleeping cow:   Cow $$$1$$$ is lined up on the left side.  Cow $$$2$$$ is lined up on the left side.  Cow $$$1$$$ is lined up on the right side.  Cow $$$2$$$ is lined up on the right side. In the third example, FJ can line up the cows as follows to achieve $$$2$$$ sleeping cows:   Cow $$$1$$$ and $$$2$$$ are lined up on the left side.  Cow $$$1$$$ and $$$2$$$ are lined up on the right side.  Cow $$$1$$$ is lined up on the left side and cow $$$2$$$ is lined up on the right side.  Cow $$$1$$$ is lined up on the right side and cow $$$2$$$ is lined up on the left side. In the fourth example, FJ cannot end up with any sleeping cows, so there will be no cows lined up on either side.",
    "prob_desc_description": "After a successful year of milk production, Farmer John is rewarding his cows with their favorite treat: tasty grass!On the field, there is a row of $$$n$$$ units of grass, each with a sweetness $$$s_i$$$. Farmer John has $$$m$$$ cows, each with a favorite sweetness $$$f_i$$$ and a hunger value $$$h_i$$$. He would like to pick two disjoint subsets of cows to line up on the left and right side of the grass row. There is no restriction on how many cows must be on either side. The cows will be treated in the following manner:   The cows from the left and right side will take turns feeding in an order decided by Farmer John.  When a cow feeds, it walks towards the other end without changing direction and eats grass of its favorite sweetness until it eats $$$h_i$$$ units.  The moment a cow eats $$$h_i$$$ units, it will fall asleep there, preventing further cows from passing it from both directions.  If it encounters another sleeping cow or reaches the end of the grass row, it will get upset. Farmer John absolutely does not want any cows to get upset. Note that grass does not grow back. Also, to prevent cows from getting upset, not every cow has to feed since FJ can choose a subset of them. Surprisingly, FJ has determined that sleeping cows are the most satisfied. If FJ orders optimally, what is the maximum number of sleeping cows that can result, and how many ways can FJ choose the subset of cows on the left and right side to achieve that maximum number of sleeping cows (modulo $$$10^9+7$$$)? The order in which FJ sends the cows does not matter as long as no cows get upset. ",
    "prob_desc_output_spec": "Output two integers  — the maximum number of sleeping cows that can result and the number of ways modulo $$$10^9+7$$$. ",
    "prob_desc_input_spec": "The first line contains two integers $$$n$$$ and $$$m$$$ ($$$1 \\le n \\le 5000$$$, $$$1 \\le m \\le 5000$$$)  — the number of units of grass and the number of cows.  The second line contains $$$n$$$ integers $$$s_1, s_2, \\ldots, s_n$$$ ($$$1 \\le s_i \\le n$$$)  — the sweetness values of the grass. The $$$i$$$-th of the following $$$m$$$ lines contains two integers $$$f_i$$$ and $$$h_i$$$ ($$$1 \\le f_i, h_i \\le n$$$)  — the favorite sweetness and hunger value of the $$$i$$$-th cow. No two cows have the same hunger and favorite sweetness simultaneously.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "PyPy 3",
    "lang_cluster": "Python",
    "difficulty": 2500,
    "file_name": "train_077.jsonl",
    "code_uid": "4accc91231dfe9fe0ff7551f1ee6d62b",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"5 2\\n1 1 1 1 1\\n1 2\\n1 3\", \"5 2\\n1 1 1 1 1\\n1 2\\n1 4\", \"3 2\\n2 3 2\\n3 1\\n2 1\", \"5 1\\n1 1 1 1 1\\n2 5\"]",
    "exec_outcome": "PASSED",
    "source_code": "from sys import stdin, stdout\nimport bisect\nat_dist = []\nmx = []\ncow = []\nsums = []\nm = []\nres_p = 0\nres_r = 1\n\ndef modInverse(a, m) : \n    return power(a, m - 2, m)\n      \n# To compute x^y under modulo m \ndef power(x, y, m) : \n      \n    if (y == 0) : \n        return 1\n          \n    p = power(x, y // 2, m) % m \n    p = (p * p) % m \n  \n    if(y % 2 == 0) : \n        return p  \n    else :  \n        return ((x * p) % m) \n  \n# Function to return gcd of a and b \ndef gcd(a, b) : \n    if (a == 0) : \n        return b \n          \n    return gcd(b % a, a) \n\ndef update(p, r):\n    global res_p\n    global res_r\n    if p > res_p:\n        res_p = p\n        res_r = r\n    elif p == res_p:\n        res_r += r\n        res_r = int(res_r % 1000000007)\n\ndef set_way(f):\n    right = bisect.bisect_right(cow[f],at_dist[f])\n    left = bisect.bisect_right(cow[f], mx[f] - at_dist[f])\n    mn = min(left, right)\n    mul = right*left - mn\n    plus = left + right\n    if mul > 0:\n        sums[f] = 2\n        m[f] = mul\n    elif plus > 0:\n        sums[f] = 1\n        m[f] = plus\n    else:\n        sums[f] = 0\n        m[f] = 1\n\ndef do_up(f):\n    right = at_dist[f]\n    b = bisect.bisect_right(cow[f],at_dist[f])\n    left = mx[f] - at_dist[f]\n    if right >= left:\n        b-=1\n    if b > 0:\n        sums[f] = 2\n        m[f] = b\n    else:\n        sums[f] = 1\n        m[f] = 1\n\ndef main():\n    global res_p\n    global res_r\n    global mx\n    n,M = list(map(int, stdin.readline().split()))\n    grass = list(map(int, stdin.readline().split()))\n    for i in range(n+1):\n        at_dist.append(0)\n        sums.append(0)\n        m.append(0)\n        cow.append([])\n    for i,x in enumerate(grass):\n        at_dist[x] += 1\n    mx = list(at_dist)\n    for _ in range(M):\n        f,h = list(map(int, stdin.readline().split()))\n        cow[f].append(h)\n    \n    for i in range(1,n+1):\n        cow[i].sort()\n        set_way(i)\n        res_p += sums[i]\n        res_r *= m[i]\n    t_p = res_p\n    t_r = res_r\n    for i in range(n):\n        f = grass[i]\n        t_p -= sums[f]\n        t_r = int(t_r* modInverse(m[f], 1000000007) % 1000000007)\n        at_dist[f] -=1\n        left = mx[f] - at_dist[f]\n        ii = bisect.bisect_left(cow[f], left)\n        if ii < len(cow[f]) and cow[f][ii] == left:\n            do_up(f)\n            temp_p = t_p + sums[f]\n            temp_r = t_r * m[f]\n            update(temp_p, temp_r)\n        set_way(f)\n        t_p += sums[grass[i]]\n        t_r = (t_r * m[grass[i]]) % 1000000007\n    stdout.write(str(res_p) + \" \" + str(int(res_r % 1000000007)))\n    \nmain()\n            ",
    "prob_desc_created_at": "1581953700",
    "tags": [
        "dp",
        "greedy",
        "combinatorics",
        "math",
        "implementation",
        "binary search"
    ],
    "hidden_unit_tests": ""
}
{
    "prob_desc_time_limit": "2 seconds",
    "prob_desc_sample_outputs": "[\"NO\", \"YES\\n3 5 4 1\\n3 5 3 1\\n3 5 2 1\"]",
    "src_uid": "d2cc50595767485707338a40a6dd9a78",
    "prob_desc_notes": null,
    "prob_desc_description": "You are organizing a cycling race on the streets of the city. The city contains n junctions, some pairs of them are connected by roads; on each road you can move in any direction. No two roads connect the same pair of intersections, and no road connects the intersection with itself.You want the race to be open to both professional athletes and beginner cyclists, and that's why you will organize the race in three nominations: easy, moderate and difficult; each participant will choose the more suitable nomination. For each nomination you must choose the route — the chain of junctions, consecutively connected by roads. Routes must meet the following conditions: all three routes should start at the same intersection, and finish at the same intersection (place of start and finish can't be the same); to avoid collisions, no two routes can have common junctions (except for the common start and finish), and can not go along the same road (irrespective of the driving direction on the road for those two routes); no route must pass twice through the same intersection or visit the same road twice (irrespective of the driving direction on the road for the first and second time of visit).Preparing for the competition is about to begin, and you need to determine the routes of the race as quickly as possible. The length of the routes is not important, it is only important that all the given requirements were met.",
    "prob_desc_output_spec": "If it is possible to create the routes, in the first line print \"YES\". In the next three lines print the descriptions of each of the three routes in the format \"l p1 ... pl\", where l is the number of intersections in the route, and p1, ..., pl are their numbers in the order they follow. The routes must meet all the requirements specified in the statement. If it is impossible to make the routes in accordance with the requirements, print NO.",
    "prob_desc_input_spec": "The first line contains two integers n and m (1 ≤ n, m ≤ 2·105) — the number of intersections and roads, respectively. The following m lines contain two integers — the numbers of the intersections connected by a road (the intersections are numbered starting with 1). It is guaranteed that each pair of intersections is connected by no more than one road, and no road connects the intersection to itself. Please note that it is not guaranteed that you can get from any junction to any other one by using the roads.",
    "prob_desc_output_to": "standard output",
    "prob_desc_input_from": "standard input",
    "lang": "Python 3",
    "lang_cluster": "Python",
    "difficulty": 3100,
    "file_name": "train_003.jsonl",
    "code_uid": "ad966cbdab6b8b1b396fdd957d32e934",
    "prob_desc_memory_limit": "256 megabytes",
    "prob_desc_sample_inputs": "[\"4 4\\n1 2\\n2 3\\n3 4\\n4 1\", \"5 6\\n1 2\\n1 3\\n1 4\\n2 5\\n3 5\\n4 5\"]",
    "exec_outcome": "PASSED",
    "source_code": "from typing import List\nimport sys\n\nn, m = [int(a) for a in input().split(' ')]\n\nadj: List[List[int]] = [[]] + [[] for _ in range(n)]\n\nvisited: List[bool] = [False] * (n + 1)\nparent: List[int] = [0] * (n + 1)\ndepth: List[int] = [0] * (n + 1)\nlow: List[int] = [0] * (n + 1)\ncx: List[int] = [0] * (n + 1)\ncy: List[int] = [0] * (n + 1)\nqi: List[int] = [0] * (n + 1)\n\nfor i in range(m):\n    u, v = [int(a) for a in input().split(' ')]\n    adj[u].append(v)\n    adj[v].append(u)\n\n\ndef solve():\n\n    for i in range(1, n + 1):\n        if not visited[i]:\n            # dfs(i)\n            dfs2(i)\n    print('NO')\n\n\ndef lca(a, b):\n    while depth[a] > depth[b]:\n        a = parent[a]\n    while depth[b] > depth[a]:\n        b = parent[b]\n    while a != b:\n        a = parent[a]\n        b = parent[b]\n    return a\n\n\ndef parent_path(a, b):\n    p = []\n    while a != b:\n        p.append(str(a))\n        a = parent[a]\n    p.append(str(b))\n    return p\n\n\ndef gett(a, b, u, v):\n    if depth[b] > depth[v]:\n        a, b, u, v = u, v, a, b\n    e = lca(a, u)\n    print('YES')\n    c1 = parent_path(e, v)\n    print(' '.join([str(len(c1))] + c1))\n    c2 = list(reversed(parent_path(a, e))) + list(reversed(parent_path(v, b)))\n    print(' '.join([str(len(c2))] + c2))\n    c3 = list(reversed(parent_path(u, e))) + [str(v)]\n    print(' '.join([str(len(c3))] + c3))\n    exit(0)\n\n\ndef dfs(i):\n    visited[i] = True\n    depth[i] = depth[parent[i]] + 1\n    for ni in adj[i]:\n        if parent[i] != ni:\n            if not visited[ni]:\n                parent[ni] = i\n                dfs(ni)\n            elif depth[ni] < depth[i]:\n                x = i\n                while x != ni:\n                    if cx[x] and cy[x]:\n                        gett(cx[x], cy[x], i, ni)\n                    else:\n                        cx[x] = i\n                        cy[x] = ni\n                    x = parent[x]\n\n\ndef dfs2(i):\n    visited[i] = True\n    q: List[int] = []\n    q.append(i)\n    while len(q) > 0:\n        u = q[-1]\n        if qi[u] >= len(adj[u]):\n            q.pop()\n            continue\n        v = adj[u][qi[u]]\n        qi[u] += 1\n        if parent[u] != v:\n            if not visited[v]:\n                parent[v] = u\n                depth[v] = depth[u] + 1\n                visited[v] = True\n                q.append(v)\n            elif depth[v] < depth[u]:\n                x = u\n                while x != v:\n                    if cx[x] and cy[x]:\n                        gett(cx[x], cy[x], u, v)\n                    else:\n                        cx[x] = u\n                        cy[x] = v\n                    x = parent[x]\n\nsolve()",
    "prob_desc_created_at": "1425279600",
    "tags": [
        "dfs and similar",
        "graphs"
    ],
    "hidden_unit_tests": ""
}